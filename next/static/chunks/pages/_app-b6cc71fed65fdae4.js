(self.webpackChunk_N_E = self.webpackChunk_N_E || []).push([
    [2888], {
        242: function(l, c, p) {
            var v = {
                "./en": [3197, 3197],
                "./en/": [3197, 3197],
                "./en/about": [9740, 9740],
                "./en/about.json": [9740, 9740],
                "./en/airdrop": [7927, 7927],
                "./en/airdrop.json": [7927, 7927],
                "./en/bridge": [3196, 3196],
                "./en/bridge.json": [3196, 3196],
                "./en/common": [464, 464],
                "./en/common.json": [464, 464],
                "./en/devs": [9442, 9442],
                "./en/devs.json": [9442, 9442],
                "./en/early-access": [3028, 3028],
                "./en/early-access.json": [3028, 3028],
                "./en/game": [3337, 3337],
                "./en/game.json": [3337, 3337],
                "./en/index": [3197, 3197],
                "./en/index.json": [3197, 3197],
                "./en/invite-code-form": [9301, 9301],
                "./en/invite-code-form.json": [9301, 9301],
                "./en/leaderboard": [8635, 8635],
                "./en/leaderboard.json": [8635, 8635],
                "./ja": [4298, 4298],
                "./ja/": [4298, 4298],
                "./ja/about": [2154, 2154],
                "./ja/about.json": [2154, 2154],
                "./ja/airdrop": [3576, 3576],
                "./ja/airdrop.json": [3576, 3576],
                "./ja/bridge": [3538, 3538],
                "./ja/bridge.json": [3538, 3538],
                "./ja/common": [459, 459],
                "./ja/common.json": [459, 459],
                "./ja/devs": [6612, 6612],
                "./ja/devs.json": [6612, 6612],
                "./ja/early-access": [274, 274],
                "./ja/early-access.json": [274, 274],
                "./ja/game": [9383, 9383],
                "./ja/game.json": [9383, 9383],
                "./ja/index": [4298, 4298],
                "./ja/index.json": [4298, 4298],
                "./ja/invite-code-form": [2398, 2398],
                "./ja/invite-code-form.json": [2398, 2398],
                "./ja/leaderboard": [6296, 4661],
                "./ja/leaderboard.json": [6296, 4661],
                "./ko": [9069, 9069],
                "./ko/": [9069, 9069],
                "./ko/about": [6805, 6805],
                "./ko/about.json": [6805, 6805],
                "./ko/airdrop": [3604, 3604],
                "./ko/airdrop.json": [3604, 3604],
                "./ko/bridge": [2249, 2249],
                "./ko/bridge.json": [2249, 2249],
                "./ko/common": [5271, 5271],
                "./ko/common.json": [5271, 5271],
                "./ko/devs": [1924, 1924],
                "./ko/devs.json": [1924, 1924],
                "./ko/early-access": [5354, 5354],
                "./ko/early-access.json": [5354, 5354],
                "./ko/game": [2289, 2289],
                "./ko/game.json": [2289, 2289],
                "./ko/index": [9069, 9069],
                "./ko/index.json": [9069, 9069],
                "./ko/invite-code-form": [5122, 5122],
                "./ko/invite-code-form.json": [5122, 5122],
                "./ko/leaderboard": [6330, 6330],
                "./ko/leaderboard.json": [6330, 6330],
                "./ru": [3264, 3264],
                "./ru/": [3264, 3264],
                "./ru/about": [6217, 6217],
                "./ru/about.json": [6217, 6217],
                "./ru/airdrop": [4467, 4467],
                "./ru/airdrop.json": [4467, 4467],
                "./ru/bridge": [7379, 7379],
                "./ru/bridge.json": [7379, 7379],
                "./ru/common": [7247, 7247],
                "./ru/common.json": [7247, 7247],
                "./ru/devs": [3455, 3455],
                "./ru/devs.json": [3455, 3455],
                "./ru/early-access": [8960, 8960],
                "./ru/early-access.json": [8960, 8960],
                "./ru/game": [2702, 2702],
                "./ru/game.json": [2702, 2702],
                "./ru/index": [3264, 3264],
                "./ru/index.json": [3264, 3264],
                "./ru/invite-code-form": [396, 396],
                "./ru/invite-code-form.json": [396, 396],
                "./ru/leaderboard": [8471, 8471],
                "./ru/leaderboard.json": [8471, 8471],
                "./tr": [1882, 1882],
                "./tr/": [1882, 1882],
                "./tr/about": [4602, 4602],
                "./tr/about.json": [4602, 4602],
                "./tr/airdrop": [474, 474],
                "./tr/airdrop.json": [474, 474],
                "./tr/bridge": [7281, 7281],
                "./tr/bridge.json": [7281, 7281],
                "./tr/common": [2973, 2973],
                "./tr/common.json": [2973, 2973],
                "./tr/devs": [2133, 2133],
                "./tr/devs.json": [2133, 2133],
                "./tr/early-access": [5645, 5645],
                "./tr/early-access.json": [5645, 5645],
                "./tr/game": [1047, 1047],
                "./tr/game.json": [1047, 1047],
                "./tr/index": [1882, 1882],
                "./tr/index.json": [1882, 1882],
                "./tr/invite-code-form": [4768, 429],
                "./tr/invite-code-form.json": [4768, 429],
                "./tr/leaderboard": [675, 675],
                "./tr/leaderboard.json": [675, 675],
                "./vi": [6422, 6422],
                "./vi/": [6422, 6422],
                "./vi/about": [5248, 5248],
                "./vi/about.json": [5248, 5248],
                "./vi/airdrop": [9076, 9076],
                "./vi/airdrop.json": [9076, 9076],
                "./vi/bridge": [30, 30],
                "./vi/bridge.json": [30, 30],
                "./vi/common": [9789, 9789],
                "./vi/common.json": [9789, 9789],
                "./vi/devs": [4896, 4896],
                "./vi/devs.json": [4896, 4896],
                "./vi/early-access": [3689, 3689],
                "./vi/early-access.json": [3689, 3689],
                "./vi/game": [8828, 8828],
                "./vi/game.json": [8828, 8828],
                "./vi/index": [6422, 6422],
                "./vi/index.json": [6422, 6422],
                "./vi/invite-code-form": [3541, 3541],
                "./vi/invite-code-form.json": [3541, 3541],
                "./vi/leaderboard": [7472, 7472],
                "./vi/leaderboard.json": [7472, 7472],
                "./zh-CN": [9182, 9182],
                "./zh-CN/": [9182, 9182],
                "./zh-CN/about": [7182, 7182],
                "./zh-CN/about.json": [7182, 7182],
                "./zh-CN/airdrop": [3993, 3993],
                "./zh-CN/airdrop.json": [3993, 3993],
                "./zh-CN/bridge": [5239, 5239],
                "./zh-CN/bridge.json": [5239, 5239],
                "./zh-CN/common": [5807, 5807],
                "./zh-CN/common.json": [5807, 5807],
                "./zh-CN/devs": [6062, 6062],
                "./zh-CN/devs.json": [6062, 6062],
                "./zh-CN/early-access": [7990, 7990],
                "./zh-CN/early-access.json": [7990, 7990],
                "./zh-CN/game": [3114, 3114],
                "./zh-CN/game.json": [3114, 3114],
                "./zh-CN/index": [9182, 9182],
                "./zh-CN/index.json": [9182, 9182],
                "./zh-CN/invite-code-form": [7839, 7839],
                "./zh-CN/invite-code-form.json": [7839, 7839],
                "./zh-CN/leaderboard": [4301, 4301],
                "./zh-CN/leaderboard.json": [4301, 4301]
            };

            function webpackAsyncContext(l) {
                if (!p.o(v, l)) return Promise.resolve().then(function() {
                    var c = Error("Cannot find module '" + l + "'");
                    throw c.code = "MODULE_NOT_FOUND", c
                });
                var c = v[l],
                    _ = c[0];
                return p.e(c[1]).then(function() {
                    return p.t(_, 19)
                })
            }
            webpackAsyncContext.keys = function() {
                return Object.keys(v)
            }, webpackAsyncContext.id = 242, l.exports = webpackAsyncContext
        },
        1539: function(l, c, p) {
            var v = {
                "./en/about.json": [9740, 9740],
                "./en/airdrop.json": [7927, 7927],
                "./en/bridge.json": [3196, 3196],
                "./en/common.json": [464, 464],
                "./en/devs.json": [9442, 9442],
                "./en/early-access.json": [3028, 3028],
                "./en/game.json": [3337, 3337],
                "./en/index.json": [3197, 3197],
                "./en/invite-code-form.json": [9301, 9301],
                "./en/leaderboard.json": [8635, 8635],
                "./ja/about.json": [2154, 2154],
                "./ja/airdrop.json": [3576, 3576],
                "./ja/bridge.json": [3538, 3538],
                "./ja/common.json": [459, 459],
                "./ja/devs.json": [6612, 6612],
                "./ja/early-access.json": [274, 274],
                "./ja/game.json": [9383, 9383],
                "./ja/index.json": [4298, 4298],
                "./ja/invite-code-form.json": [2398, 2398],
                "./ja/leaderboard.json": [6296, 4661],
                "./ko/about.json": [6805, 6805],
                "./ko/airdrop.json": [3604, 3604],
                "./ko/bridge.json": [2249, 2249],
                "./ko/common.json": [5271, 5271],
                "./ko/devs.json": [1924, 1924],
                "./ko/early-access.json": [5354, 5354],
                "./ko/game.json": [2289, 2289],
                "./ko/index.json": [9069, 9069],
                "./ko/invite-code-form.json": [5122, 5122],
                "./ko/leaderboard.json": [6330, 6330],
                "./ru/about.json": [6217, 6217],
                "./ru/airdrop.json": [4467, 4467],
                "./ru/bridge.json": [7379, 7379],
                "./ru/common.json": [7247, 7247],
                "./ru/devs.json": [3455, 3455],
                "./ru/early-access.json": [8960, 8960],
                "./ru/game.json": [2702, 2702],
                "./ru/index.json": [3264, 3264],
                "./ru/invite-code-form.json": [396, 396],
                "./ru/leaderboard.json": [8471, 8471],
                "./tr/about.json": [4602, 4602],
                "./tr/airdrop.json": [474, 474],
                "./tr/bridge.json": [7281, 7281],
                "./tr/common.json": [2973, 2973],
                "./tr/devs.json": [2133, 2133],
                "./tr/early-access.json": [5645, 5645],
                "./tr/game.json": [1047, 1047],
                "./tr/index.json": [1882, 1882],
                "./tr/invite-code-form.json": [4768, 429],
                "./tr/leaderboard.json": [675, 675],
                "./vi/about.json": [5248, 5248],
                "./vi/airdrop.json": [9076, 9076],
                "./vi/bridge.json": [30, 30],
                "./vi/common.json": [9789, 9789],
                "./vi/devs.json": [4896, 4896],
                "./vi/early-access.json": [3689, 3689],
                "./vi/game.json": [8828, 8828],
                "./vi/index.json": [6422, 6422],
                "./vi/invite-code-form.json": [3541, 3541],
                "./vi/leaderboard.json": [7472, 7472],
                "./zh-CN/about.json": [7182, 7182],
                "./zh-CN/airdrop.json": [3993, 3993],
                "./zh-CN/bridge.json": [5239, 5239],
                "./zh-CN/common.json": [5807, 5807],
                "./zh-CN/devs.json": [6062, 6062],
                "./zh-CN/early-access.json": [7990, 7990],
                "./zh-CN/game.json": [3114, 3114],
                "./zh-CN/index.json": [9182, 9182],
                "./zh-CN/invite-code-form.json": [7839, 7839],
                "./zh-CN/leaderboard.json": [4301, 4301]
            };

            function webpackAsyncContext(l) {
                if (!p.o(v, l)) return Promise.resolve().then(function() {
                    var c = Error("Cannot find module '" + l + "'");
                    throw c.code = "MODULE_NOT_FOUND", c
                });
                var c = v[l],
                    _ = c[0];
                return p.e(c[1]).then(function() {
                    return p.t(_, 19)
                })
            }
            webpackAsyncContext.keys = function() {
                return Object.keys(v)
            }, webpackAsyncContext.id = 1539, l.exports = webpackAsyncContext
        },
        8258: function(l, c, p) {
            "use strict";
            Object.defineProperty(c, "__esModule", {
                value: !0
            });
            var v = p(6581);

            function writeUint16BE(l, c, p) {
                return void 0 === c && (c = new Uint8Array(2)), void 0 === p && (p = 0), c[p + 0] = l >>> 8, c[p + 1] = l >>> 0, c
            }

            function writeUint16LE(l, c, p) {
                return void 0 === c && (c = new Uint8Array(2)), void 0 === p && (p = 0), c[p + 0] = l >>> 0, c[p + 1] = l >>> 8, c
            }

            function readInt32BE(l, c) {
                return void 0 === c && (c = 0), l[c] << 24 | l[c + 1] << 16 | l[c + 2] << 8 | l[c + 3]
            }

            function readUint32BE(l, c) {
                return void 0 === c && (c = 0), (l[c] << 24 | l[c + 1] << 16 | l[c + 2] << 8 | l[c + 3]) >>> 0
            }

            function readInt32LE(l, c) {
                return void 0 === c && (c = 0), l[c + 3] << 24 | l[c + 2] << 16 | l[c + 1] << 8 | l[c]
            }

            function readUint32LE(l, c) {
                return void 0 === c && (c = 0), (l[c + 3] << 24 | l[c + 2] << 16 | l[c + 1] << 8 | l[c]) >>> 0
            }

            function writeUint32BE(l, c, p) {
                return void 0 === c && (c = new Uint8Array(4)), void 0 === p && (p = 0), c[p + 0] = l >>> 24, c[p + 1] = l >>> 16, c[p + 2] = l >>> 8, c[p + 3] = l >>> 0, c
            }

            function writeUint32LE(l, c, p) {
                return void 0 === c && (c = new Uint8Array(4)), void 0 === p && (p = 0), c[p + 0] = l >>> 0, c[p + 1] = l >>> 8, c[p + 2] = l >>> 16, c[p + 3] = l >>> 24, c
            }

            function writeUint64BE(l, c, p) {
                return void 0 === c && (c = new Uint8Array(8)), void 0 === p && (p = 0), writeUint32BE(l / 4294967296 >>> 0, c, p), writeUint32BE(l >>> 0, c, p + 4), c
            }

            function writeUint64LE(l, c, p) {
                return void 0 === c && (c = new Uint8Array(8)), void 0 === p && (p = 0), writeUint32LE(l >>> 0, c, p), writeUint32LE(l / 4294967296 >>> 0, c, p + 4), c
            }
            c.readInt16BE = function(l, c) {
                return void 0 === c && (c = 0), (l[c + 0] << 8 | l[c + 1]) << 16 >> 16
            }, c.readUint16BE = function(l, c) {
                return void 0 === c && (c = 0), (l[c + 0] << 8 | l[c + 1]) >>> 0
            }, c.readInt16LE = function(l, c) {
                return void 0 === c && (c = 0), (l[c + 1] << 8 | l[c]) << 16 >> 16
            }, c.readUint16LE = function(l, c) {
                return void 0 === c && (c = 0), (l[c + 1] << 8 | l[c]) >>> 0
            }, c.writeUint16BE = writeUint16BE, c.writeInt16BE = writeUint16BE, c.writeUint16LE = writeUint16LE, c.writeInt16LE = writeUint16LE, c.readInt32BE = readInt32BE, c.readUint32BE = readUint32BE, c.readInt32LE = readInt32LE, c.readUint32LE = readUint32LE, c.writeUint32BE = writeUint32BE, c.writeInt32BE = writeUint32BE, c.writeUint32LE = writeUint32LE, c.writeInt32LE = writeUint32LE, c.readInt64BE = function(l, c) {
                void 0 === c && (c = 0);
                var p = readInt32BE(l, c),
                    v = readInt32BE(l, c + 4);
                return 4294967296 * p + v - (v >> 31) * 4294967296
            }, c.readUint64BE = function(l, c) {
                return void 0 === c && (c = 0), 4294967296 * readUint32BE(l, c) + readUint32BE(l, c + 4)
            }, c.readInt64LE = function(l, c) {
                void 0 === c && (c = 0);
                var p = readInt32LE(l, c);
                return 4294967296 * readInt32LE(l, c + 4) + p - (p >> 31) * 4294967296
            }, c.readUint64LE = function(l, c) {
                void 0 === c && (c = 0);
                var p = readUint32LE(l, c);
                return 4294967296 * readUint32LE(l, c + 4) + p
            }, c.writeUint64BE = writeUint64BE, c.writeInt64BE = writeUint64BE, c.writeUint64LE = writeUint64LE, c.writeInt64LE = writeUint64LE, c.readUintBE = function(l, c, p) {
                if (void 0 === p && (p = 0), l % 8 != 0) throw Error("readUintBE supports only bitLengths divisible by 8");
                if (l / 8 > c.length - p) throw Error("readUintBE: array is too short for the given bitLength");
                for (var v = 0, _ = 1, C = l / 8 + p - 1; C >= p; C--) v += c[C] * _, _ *= 256;
                return v
            }, c.readUintLE = function(l, c, p) {
                if (void 0 === p && (p = 0), l % 8 != 0) throw Error("readUintLE supports only bitLengths divisible by 8");
                if (l / 8 > c.length - p) throw Error("readUintLE: array is too short for the given bitLength");
                for (var v = 0, _ = 1, C = p; C < p + l / 8; C++) v += c[C] * _, _ *= 256;
                return v
            }, c.writeUintBE = function(l, c, p, _) {
                if (void 0 === p && (p = new Uint8Array(l / 8)), void 0 === _ && (_ = 0), l % 8 != 0) throw Error("writeUintBE supports only bitLengths divisible by 8");
                if (!v.isSafeInteger(c)) throw Error("writeUintBE value must be an integer");
                for (var C = 1, P = l / 8 + _ - 1; P >= _; P--) p[P] = c / C & 255, C *= 256;
                return p
            }, c.writeUintLE = function(l, c, p, _) {
                if (void 0 === p && (p = new Uint8Array(l / 8)), void 0 === _ && (_ = 0), l % 8 != 0) throw Error("writeUintLE supports only bitLengths divisible by 8");
                if (!v.isSafeInteger(c)) throw Error("writeUintLE value must be an integer");
                for (var C = 1, P = _; P < _ + l / 8; P++) p[P] = c / C & 255, C *= 256;
                return p
            }, c.readFloat32BE = function(l, c) {
                return void 0 === c && (c = 0), new DataView(l.buffer, l.byteOffset, l.byteLength).getFloat32(c)
            }, c.readFloat32LE = function(l, c) {
                return void 0 === c && (c = 0), new DataView(l.buffer, l.byteOffset, l.byteLength).getFloat32(c, !0)
            }, c.readFloat64BE = function(l, c) {
                return void 0 === c && (c = 0), new DataView(l.buffer, l.byteOffset, l.byteLength).getFloat64(c)
            }, c.readFloat64LE = function(l, c) {
                return void 0 === c && (c = 0), new DataView(l.buffer, l.byteOffset, l.byteLength).getFloat64(c, !0)
            }, c.writeFloat32BE = function(l, c, p) {
                return void 0 === c && (c = new Uint8Array(4)), void 0 === p && (p = 0), new DataView(c.buffer, c.byteOffset, c.byteLength).setFloat32(p, l), c
            }, c.writeFloat32LE = function(l, c, p) {
                return void 0 === c && (c = new Uint8Array(4)), void 0 === p && (p = 0), new DataView(c.buffer, c.byteOffset, c.byteLength).setFloat32(p, l, !0), c
            }, c.writeFloat64BE = function(l, c, p) {
                return void 0 === c && (c = new Uint8Array(8)), void 0 === p && (p = 0), new DataView(c.buffer, c.byteOffset, c.byteLength).setFloat64(p, l), c
            }, c.writeFloat64LE = function(l, c, p) {
                return void 0 === c && (c = new Uint8Array(8)), void 0 === p && (p = 0), new DataView(c.buffer, c.byteOffset, c.byteLength).setFloat64(p, l, !0), c
            }
        },
        7656: function(l, c, p) {
            "use strict";
            Object.defineProperty(c, "__esModule", {
                value: !0
            });
            var v = p(8258),
                _ = p(4460);

            function streamXOR(l, c, p, C, P) {
                if (void 0 === P && (P = 0), 32 !== l.length) throw Error("ChaCha: key size must be 32 bytes");
                if (C.length < p.length) throw Error("ChaCha: destination is shorter than source");
                if (0 === P) {
                    if (8 !== c.length && 12 !== c.length) throw Error("ChaCha nonce must be 8 or 12 bytes");
                    M = (T = new Uint8Array(16)).length - c.length, T.set(c, M)
                } else {
                    if (16 !== c.length) throw Error("ChaCha nonce with counter must be 16 bytes");
                    T = c, M = P
                }
                for (var T, M, z = new Uint8Array(64), J = 0; J < p.length; J += 64) {
                    ! function(l, c, p) {
                        for (var _ = p[3] << 24 | p[2] << 16 | p[1] << 8 | p[0], C = p[7] << 24 | p[6] << 16 | p[5] << 8 | p[4], P = p[11] << 24 | p[10] << 16 | p[9] << 8 | p[8], T = p[15] << 24 | p[14] << 16 | p[13] << 8 | p[12], M = p[19] << 24 | p[18] << 16 | p[17] << 8 | p[16], z = p[23] << 24 | p[22] << 16 | p[21] << 8 | p[20], J = p[27] << 24 | p[26] << 16 | p[25] << 8 | p[24], Q = p[31] << 24 | p[30] << 16 | p[29] << 8 | p[28], X = c[3] << 24 | c[2] << 16 | c[1] << 8 | c[0], es = c[7] << 24 | c[6] << 16 | c[5] << 8 | c[4], eo = c[11] << 24 | c[10] << 16 | c[9] << 8 | c[8], el = c[15] << 24 | c[14] << 16 | c[13] << 8 | c[12], ec = 1634760805, eh = 857760878, ed = 2036477234, ef = 1797285236, ep = _, eg = C, em = P, ey = T, eb = M, ew = z, ex = J, e_ = Q, eE = X, eA = es, eC = eo, eS = el, eN = 0; eN < 20; eN += 2) eE ^= ec = ec + ep | 0, ep ^= eb = eb + (eE = eE >>> 16 | eE << 16) | 0, ep = ep >>> 20 | ep << 12, eA ^= eh = eh + eg | 0, eg ^= ew = ew + (eA = eA >>> 16 | eA << 16) | 0, eg = eg >>> 20 | eg << 12, eC ^= ed = ed + em | 0, em ^= ex = ex + (eC = eC >>> 16 | eC << 16) | 0, em = em >>> 20 | em << 12, eS ^= ef = ef + ey | 0, ey ^= e_ = e_ + (eS = eS >>> 16 | eS << 16) | 0, ey = ey >>> 20 | ey << 12, eC ^= ed = ed + em | 0, em ^= ex = ex + (eC = eC >>> 24 | eC << 8) | 0, em = em >>> 25 | em << 7, eS ^= ef = ef + ey | 0, ey ^= e_ = e_ + (eS = eS >>> 24 | eS << 8) | 0, ey = ey >>> 25 | ey << 7, eA ^= eh = eh + eg | 0, eg ^= ew = ew + (eA = eA >>> 24 | eA << 8) | 0, eg = eg >>> 25 | eg << 7, eE ^= ec = ec + ep | 0, ep ^= eb = eb + (eE = eE >>> 24 | eE << 8) | 0, ep = ep >>> 25 | ep << 7, eS ^= ec = ec + eg | 0, eg ^= ex = ex + (eS = eS >>> 16 | eS << 16) | 0, eg = eg >>> 20 | eg << 12, eE ^= eh = eh + em | 0, em ^= e_ = e_ + (eE = eE >>> 16 | eE << 16) | 0, em = em >>> 20 | em << 12, eA ^= ed = ed + ey | 0, ey ^= eb = eb + (eA = eA >>> 16 | eA << 16) | 0, ey = ey >>> 20 | ey << 12, eC ^= ef = ef + ep | 0, ep ^= ew = ew + (eC = eC >>> 16 | eC << 16) | 0, ep = ep >>> 20 | ep << 12, eA ^= ed = ed + ey | 0, ey ^= eb = eb + (eA = eA >>> 24 | eA << 8) | 0, ey = ey >>> 25 | ey << 7, eC ^= ef = ef + ep | 0, ep ^= ew = ew + (eC = eC >>> 24 | eC << 8) | 0, ep = ep >>> 25 | ep << 7, eE ^= eh = eh + em | 0, em ^= e_ = e_ + (eE = eE >>> 24 | eE << 8) | 0, em = em >>> 25 | em << 7, eS ^= ec = ec + eg | 0, eg ^= ex = ex + (eS = eS >>> 24 | eS << 8) | 0, eg = eg >>> 25 | eg << 7;
                        v.writeUint32LE(ec + 1634760805 | 0, l, 0), v.writeUint32LE(eh + 857760878 | 0, l, 4), v.writeUint32LE(ed + 2036477234 | 0, l, 8), v.writeUint32LE(ef + 1797285236 | 0, l, 12), v.writeUint32LE(ep + _ | 0, l, 16), v.writeUint32LE(eg + C | 0, l, 20), v.writeUint32LE(em + P | 0, l, 24), v.writeUint32LE(ey + T | 0, l, 28), v.writeUint32LE(eb + M | 0, l, 32), v.writeUint32LE(ew + z | 0, l, 36), v.writeUint32LE(ex + J | 0, l, 40), v.writeUint32LE(e_ + Q | 0, l, 44), v.writeUint32LE(eE + X | 0, l, 48), v.writeUint32LE(eA + es | 0, l, 52), v.writeUint32LE(eC + eo | 0, l, 56), v.writeUint32LE(eS + el | 0, l, 60)
                    }(z, T, l);
                    for (var Q = J; Q < J + 64 && Q < p.length; Q++) C[Q] = p[Q] ^ z[Q - J];
                    ! function(l, c, p) {
                        for (var v = 1; p--;) v = v + (255 & l[c]) | 0, l[c] = 255 & v, v >>>= 8, c++;
                        if (v > 0) throw Error("ChaCha: counter overflow")
                    }(T, 0, M)
                }
                return _.wipe(z), 0 === P && _.wipe(T), C
            }
            c.streamXOR = streamXOR, c.stream = function(l, c, p, v) {
                return void 0 === v && (v = 0), _.wipe(p), streamXOR(l, c, p, p, v)
            }
        },
        3001: function(l, c, p) {
            "use strict";
            var v = p(7656),
                _ = p(4418),
                C = p(4460),
                P = p(8258),
                T = p(7829);
            c.Cv = 32, c.WH = 12, c.pg = 16;
            var M = new Uint8Array(16),
                z = function() {
                    function ChaCha20Poly1305(l) {
                        if (this.nonceLength = c.WH, this.tagLength = c.pg, l.length !== c.Cv) throw Error("ChaCha20Poly1305 needs 32-byte key");
                        this._key = new Uint8Array(l)
                    }
                    return ChaCha20Poly1305.prototype.seal = function(l, c, p, _) {
                        if (l.length > 16) throw Error("ChaCha20Poly1305: incorrect nonce length");
                        var P, T = new Uint8Array(16);
                        T.set(l, T.length - l.length);
                        var M = new Uint8Array(32);
                        v.stream(this._key, T, M, 4);
                        var z = c.length + this.tagLength;
                        if (_) {
                            if (_.length !== z) throw Error("ChaCha20Poly1305: incorrect destination length");
                            P = _
                        } else P = new Uint8Array(z);
                        return v.streamXOR(this._key, T, c, P, 4), this._authenticate(P.subarray(P.length - this.tagLength, P.length), M, P.subarray(0, P.length - this.tagLength), p), C.wipe(T), P
                    }, ChaCha20Poly1305.prototype.open = function(l, c, p, _) {
                        if (l.length > 16) throw Error("ChaCha20Poly1305: incorrect nonce length");
                        if (c.length < this.tagLength) return null;
                        var P, M = new Uint8Array(16);
                        M.set(l, M.length - l.length);
                        var z = new Uint8Array(32);
                        v.stream(this._key, M, z, 4);
                        var J = new Uint8Array(this.tagLength);
                        if (this._authenticate(J, z, c.subarray(0, c.length - this.tagLength), p), !T.equal(J, c.subarray(c.length - this.tagLength, c.length))) return null;
                        var Q = c.length - this.tagLength;
                        if (_) {
                            if (_.length !== Q) throw Error("ChaCha20Poly1305: incorrect destination length");
                            P = _
                        } else P = new Uint8Array(Q);
                        return v.streamXOR(this._key, M, c.subarray(0, c.length - this.tagLength), P, 4), C.wipe(M), P
                    }, ChaCha20Poly1305.prototype.clean = function() {
                        return C.wipe(this._key), this
                    }, ChaCha20Poly1305.prototype._authenticate = function(l, c, p, v) {
                        var T = new _.Poly1305(c);
                        v && (T.update(v), v.length % 16 > 0 && T.update(M.subarray(v.length % 16))), T.update(p), p.length % 16 > 0 && T.update(M.subarray(p.length % 16));
                        var z = new Uint8Array(8);
                        v && P.writeUint64LE(v.length, z), T.update(z), P.writeUint64LE(p.length, z), T.update(z);
                        for (var J = T.digest(), Q = 0; Q < J.length; Q++) l[Q] = J[Q];
                        T.clean(), C.wipe(J), C.wipe(z)
                    }, ChaCha20Poly1305
                }();
            c.OK = z
        },
        7829: function(l, c) {
            "use strict";

            function compare(l, c) {
                if (l.length !== c.length) return 0;
                for (var p = 0, v = 0; v < l.length; v++) p |= l[v] ^ c[v];
                return 1 & p - 1 >>> 8
            }
            Object.defineProperty(c, "__esModule", {
                value: !0
            }), c.select = function(l, c, p) {
                return ~(l - 1) & c | l - 1 & p
            }, c.lessOrEqual = function(l, c) {
                return (0 | l) - (0 | c) - 1 >>> 31 & 1
            }, c.compare = compare, c.equal = function(l, c) {
                return 0 !== l.length && 0 !== c.length && 0 !== compare(l, c)
            }
        },
        7425: function(l, c, p) {
            "use strict";
            c.Xx = c._w = c.aP = c.KS = c.jQ = void 0, p(4510);
            let v = p(1152);

            function gf(l) {
                let c = new Float64Array(16);
                if (l)
                    for (let p = 0; p < l.length; p++) c[p] = l[p];
                return c
            }
            p(4460), c.jQ = 64, c.KS = 64, c.aP = 32;
            let _ = new Uint8Array(32);
            _[0] = 9;
            let C = gf(),
                P = gf([1]),
                T = (gf([30883, 4953, 19914, 30187, 55467, 16705, 2637, 112, 59544, 30585, 16505, 36039, 65139, 11119, 27886, 20995]), gf([61785, 9906, 39828, 60374, 45398, 33411, 5274, 224, 53552, 61171, 33010, 6542, 64743, 22239, 55772, 9222])),
                M = gf([54554, 36645, 11616, 51542, 42930, 38181, 51040, 26924, 56412, 64982, 57905, 49316, 21502, 52590, 14035, 8553]),
                z = gf([26200, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214]);

            function set25519(l, c) {
                for (let p = 0; p < 16; p++) l[p] = 0 | c[p]
            }

            function car25519(l) {
                let c = 1;
                for (let p = 0; p < 16; p++) {
                    let v = l[p] + c + 65535;
                    c = Math.floor(v / 65536), l[p] = v - 65536 * c
                }
                l[0] += c - 1 + 37 * (c - 1)
            }

            function sel25519(l, c, p) {
                let v = ~(p - 1);
                for (let p = 0; p < 16; p++) {
                    let _ = v & (l[p] ^ c[p]);
                    l[p] ^= _, c[p] ^= _
                }
            }

            function pack25519(l, c) {
                let p = gf(),
                    v = gf();
                for (let l = 0; l < 16; l++) v[l] = c[l];
                car25519(v), car25519(v), car25519(v);
                for (let l = 0; l < 2; l++) {
                    p[0] = v[0] - 65517;
                    for (let l = 1; l < 15; l++) p[l] = v[l] - 65535 - (p[l - 1] >> 16 & 1), p[l - 1] &= 65535;
                    p[15] = v[15] - 32767 - (p[14] >> 16 & 1);
                    let l = p[15] >> 16 & 1;
                    p[14] &= 65535, sel25519(v, p, 1 - l)
                }
                for (let c = 0; c < 16; c++) l[2 * c] = 255 & v[c], l[2 * c + 1] = v[c] >> 8
            }
            gf([41136, 18958, 6951, 50414, 58488, 44335, 6150, 12099, 55207, 15867, 153, 11085, 57099, 20417, 9344, 11139]);

            function add(l, c, p) {
                for (let v = 0; v < 16; v++) l[v] = c[v] + p[v]
            }

            function sub(l, c, p) {
                for (let v = 0; v < 16; v++) l[v] = c[v] - p[v]
            }

            function mul(l, c, p) {
                let v, _, C = 0,
                    P = 0,
                    T = 0,
                    M = 0,
                    z = 0,
                    J = 0,
                    Q = 0,
                    X = 0,
                    es = 0,
                    eo = 0,
                    el = 0,
                    ec = 0,
                    eh = 0,
                    ed = 0,
                    ef = 0,
                    ep = 0,
                    eg = 0,
                    em = 0,
                    ey = 0,
                    eb = 0,
                    ew = 0,
                    ex = 0,
                    e_ = 0,
                    eE = 0,
                    eA = 0,
                    eC = 0,
                    eS = 0,
                    eN = 0,
                    eP = 0,
                    eD = 0,
                    ek = 0,
                    eI = p[0],
                    eO = p[1],
                    ej = p[2],
                    eT = p[3],
                    eR = p[4],
                    eL = p[5],
                    eM = p[6],
                    eU = p[7],
                    eB = p[8],
                    eF = p[9],
                    eH = p[10],
                    eV = p[11],
                    ez = p[12],
                    eW = p[13],
                    eG = p[14],
                    eK = p[15];
                C += (v = c[0]) * eI, P += v * eO, T += v * ej, M += v * eT, z += v * eR, J += v * eL, Q += v * eM, X += v * eU, es += v * eB, eo += v * eF, el += v * eH, ec += v * eV, eh += v * ez, ed += v * eW, ef += v * eG, ep += v * eK, P += (v = c[1]) * eI, T += v * eO, M += v * ej, z += v * eT, J += v * eR, Q += v * eL, X += v * eM, es += v * eU, eo += v * eB, el += v * eF, ec += v * eH, eh += v * eV, ed += v * ez, ef += v * eW, ep += v * eG, eg += v * eK, T += (v = c[2]) * eI, M += v * eO, z += v * ej, J += v * eT, Q += v * eR, X += v * eL, es += v * eM, eo += v * eU, el += v * eB, ec += v * eF, eh += v * eH, ed += v * eV, ef += v * ez, ep += v * eW, eg += v * eG, em += v * eK, M += (v = c[3]) * eI, z += v * eO, J += v * ej, Q += v * eT, X += v * eR, es += v * eL, eo += v * eM, el += v * eU, ec += v * eB, eh += v * eF, ed += v * eH, ef += v * eV, ep += v * ez, eg += v * eW, em += v * eG, ey += v * eK, z += (v = c[4]) * eI, J += v * eO, Q += v * ej, X += v * eT, es += v * eR, eo += v * eL, el += v * eM, ec += v * eU, eh += v * eB, ed += v * eF, ef += v * eH, ep += v * eV, eg += v * ez, em += v * eW, ey += v * eG, eb += v * eK, J += (v = c[5]) * eI, Q += v * eO, X += v * ej, es += v * eT, eo += v * eR, el += v * eL, ec += v * eM, eh += v * eU, ed += v * eB, ef += v * eF, ep += v * eH, eg += v * eV, em += v * ez, ey += v * eW, eb += v * eG, ew += v * eK, Q += (v = c[6]) * eI, X += v * eO, es += v * ej, eo += v * eT, el += v * eR, ec += v * eL, eh += v * eM, ed += v * eU, ef += v * eB, ep += v * eF, eg += v * eH, em += v * eV, ey += v * ez, eb += v * eW, ew += v * eG, ex += v * eK, X += (v = c[7]) * eI, es += v * eO, eo += v * ej, el += v * eT, ec += v * eR, eh += v * eL, ed += v * eM, ef += v * eU, ep += v * eB, eg += v * eF, em += v * eH, ey += v * eV, eb += v * ez, ew += v * eW, ex += v * eG, e_ += v * eK, es += (v = c[8]) * eI, eo += v * eO, el += v * ej, ec += v * eT, eh += v * eR, ed += v * eL, ef += v * eM, ep += v * eU, eg += v * eB, em += v * eF, ey += v * eH, eb += v * eV, ew += v * ez, ex += v * eW, e_ += v * eG, eE += v * eK, eo += (v = c[9]) * eI, el += v * eO, ec += v * ej, eh += v * eT, ed += v * eR, ef += v * eL, ep += v * eM, eg += v * eU, em += v * eB, ey += v * eF, eb += v * eH, ew += v * eV, ex += v * ez, e_ += v * eW, eE += v * eG, eA += v * eK, el += (v = c[10]) * eI, ec += v * eO, eh += v * ej, ed += v * eT, ef += v * eR, ep += v * eL, eg += v * eM, em += v * eU, ey += v * eB, eb += v * eF, ew += v * eH, ex += v * eV, e_ += v * ez, eE += v * eW, eA += v * eG, eC += v * eK, ec += (v = c[11]) * eI, eh += v * eO, ed += v * ej, ef += v * eT, ep += v * eR, eg += v * eL, em += v * eM, ey += v * eU, eb += v * eB, ew += v * eF, ex += v * eH, e_ += v * eV, eE += v * ez, eA += v * eW, eC += v * eG, eS += v * eK, eh += (v = c[12]) * eI, ed += v * eO, ef += v * ej, ep += v * eT, eg += v * eR, em += v * eL, ey += v * eM, eb += v * eU, ew += v * eB, ex += v * eF, e_ += v * eH, eE += v * eV, eA += v * ez, eC += v * eW, eS += v * eG, eN += v * eK, ed += (v = c[13]) * eI, ef += v * eO, ep += v * ej, eg += v * eT, em += v * eR, ey += v * eL, eb += v * eM, ew += v * eU, ex += v * eB, e_ += v * eF, eE += v * eH, eA += v * eV, eC += v * ez, eS += v * eW, eN += v * eG, eP += v * eK, ef += (v = c[14]) * eI, ep += v * eO, eg += v * ej, em += v * eT, ey += v * eR, eb += v * eL, ew += v * eM, ex += v * eU, e_ += v * eB, eE += v * eF, eA += v * eH, eC += v * eV, eS += v * ez, eN += v * eW, eP += v * eG, eD += v * eK, ep += (v = c[15]) * eI, eg += v * eO, em += v * ej, ey += v * eT, eb += v * eR, ew += v * eL, ex += v * eM, e_ += v * eU, eE += v * eB, eA += v * eF, eC += v * eH, eS += v * eV, eN += v * ez, eP += v * eW, eD += v * eG, ek += v * eK, C += 38 * eg, P += 38 * em, T += 38 * ey, M += 38 * eb, z += 38 * ew, J += 38 * ex, Q += 38 * e_, X += 38 * eE, es += 38 * eA, eo += 38 * eC, el += 38 * eS, ec += 38 * eN, eh += 38 * eP, ed += 38 * eD, ef += 38 * ek, _ = Math.floor((v = C + (_ = 1) + 65535) / 65536), C = v - 65536 * _, _ = Math.floor((v = P + _ + 65535) / 65536), P = v - 65536 * _, _ = Math.floor((v = T + _ + 65535) / 65536), T = v - 65536 * _, _ = Math.floor((v = M + _ + 65535) / 65536), M = v - 65536 * _, _ = Math.floor((v = z + _ + 65535) / 65536), z = v - 65536 * _, _ = Math.floor((v = J + _ + 65535) / 65536), J = v - 65536 * _, _ = Math.floor((v = Q + _ + 65535) / 65536), Q = v - 65536 * _, _ = Math.floor((v = X + _ + 65535) / 65536), X = v - 65536 * _, _ = Math.floor((v = es + _ + 65535) / 65536), es = v - 65536 * _, _ = Math.floor((v = eo + _ + 65535) / 65536), eo = v - 65536 * _, _ = Math.floor((v = el + _ + 65535) / 65536), el = v - 65536 * _, _ = Math.floor((v = ec + _ + 65535) / 65536), ec = v - 65536 * _, _ = Math.floor((v = eh + _ + 65535) / 65536), eh = v - 65536 * _, _ = Math.floor((v = ed + _ + 65535) / 65536), ed = v - 65536 * _, _ = Math.floor((v = ef + _ + 65535) / 65536), ef = v - 65536 * _, _ = Math.floor((v = ep + _ + 65535) / 65536), ep = v - 65536 * _, C += _ - 1 + 37 * (_ - 1), _ = Math.floor((v = C + (_ = 1) + 65535) / 65536), C = v - 65536 * _, _ = Math.floor((v = P + _ + 65535) / 65536), P = v - 65536 * _, _ = Math.floor((v = T + _ + 65535) / 65536), T = v - 65536 * _, _ = Math.floor((v = M + _ + 65535) / 65536), M = v - 65536 * _, _ = Math.floor((v = z + _ + 65535) / 65536), z = v - 65536 * _, _ = Math.floor((v = J + _ + 65535) / 65536), J = v - 65536 * _, _ = Math.floor((v = Q + _ + 65535) / 65536), Q = v - 65536 * _, _ = Math.floor((v = X + _ + 65535) / 65536), X = v - 65536 * _, _ = Math.floor((v = es + _ + 65535) / 65536), es = v - 65536 * _, _ = Math.floor((v = eo + _ + 65535) / 65536), eo = v - 65536 * _, _ = Math.floor((v = el + _ + 65535) / 65536), el = v - 65536 * _, _ = Math.floor((v = ec + _ + 65535) / 65536), ec = v - 65536 * _, _ = Math.floor((v = eh + _ + 65535) / 65536), eh = v - 65536 * _, _ = Math.floor((v = ed + _ + 65535) / 65536), ed = v - 65536 * _, _ = Math.floor((v = ef + _ + 65535) / 65536), ef = v - 65536 * _, _ = Math.floor((v = ep + _ + 65535) / 65536), ep = v - 65536 * _, C += _ - 1 + 37 * (_ - 1), l[0] = C, l[1] = P, l[2] = T, l[3] = M, l[4] = z, l[5] = J, l[6] = Q, l[7] = X, l[8] = es, l[9] = eo, l[10] = el, l[11] = ec, l[12] = eh, l[13] = ed, l[14] = ef, l[15] = ep
            }

            function edadd(l, c) {
                let p = gf(),
                    v = gf(),
                    _ = gf(),
                    C = gf(),
                    P = gf(),
                    M = gf(),
                    z = gf(),
                    J = gf(),
                    Q = gf();
                sub(p, l[1], l[0]), sub(Q, c[1], c[0]), mul(p, p, Q), add(v, l[0], l[1]), add(Q, c[0], c[1]), mul(v, v, Q), mul(_, l[3], c[3]), mul(_, _, T), mul(C, l[2], c[2]), add(C, C, C), sub(P, v, p), sub(M, C, _), add(z, C, _), add(J, v, p), mul(l[0], P, M), mul(l[1], J, z), mul(l[2], z, M), mul(l[3], P, J)
            }

            function cswap(l, c, p) {
                for (let v = 0; v < 4; v++) sel25519(l[v], c[v], p)
            }

            function pack(l, c) {
                let p = gf(),
                    v = gf(),
                    _ = gf();
                (function(l, c) {
                    let p;
                    let v = gf();
                    for (p = 0; p < 16; p++) v[p] = c[p];
                    for (p = 253; p >= 0; p--) mul(v, v, v), 2 !== p && 4 !== p && mul(v, v, c);
                    for (p = 0; p < 16; p++) l[p] = v[p]
                })(_, c[2]), mul(p, c[0], _), mul(v, c[1], _), pack25519(l, v), l[31] ^= function(l) {
                    let c = new Uint8Array(32);
                    return pack25519(c, l), 1 & c[0]
                }(p) << 7
            }

            function scalarbase(l, c) {
                let p = [gf(), gf(), gf(), gf()];
                set25519(p[0], M), set25519(p[1], z), set25519(p[2], P), mul(p[3], M, z),
                    function(l, c, p) {
                        set25519(l[0], C), set25519(l[1], P), set25519(l[2], P), set25519(l[3], C);
                        for (let v = 255; v >= 0; --v) {
                            let _ = p[v / 8 | 0] >> (7 & v) & 1;
                            cswap(l, c, _), edadd(c, l), edadd(l, l), cswap(l, c, _)
                        }
                    }(l, p, c)
            }
            c._w = function(l) {
                if (l.length !== c.aP) throw Error(`ed25519: seed must be ${c.aP} bytes`);
                let p = (0, v.hash)(l);
                p[0] &= 248, p[31] &= 127, p[31] |= 64;
                let _ = new Uint8Array(32),
                    C = [gf(), gf(), gf(), gf()];
                scalarbase(C, p), pack(_, C);
                let P = new Uint8Array(64);
                return P.set(l), P.set(_, 32), {
                    publicKey: _,
                    secretKey: P
                }
            };
            let J = new Float64Array([237, 211, 245, 92, 26, 99, 18, 88, 214, 156, 247, 162, 222, 249, 222, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16]);

            function modL(l, c) {
                let p, v, _, C;
                for (v = 63; v >= 32; --v) {
                    for (p = 0, _ = v - 32, C = v - 12; _ < C; ++_) c[_] += p - 16 * c[v] * J[_ - (v - 32)], p = Math.floor((c[_] + 128) / 256), c[_] -= 256 * p;
                    c[_] += p, c[v] = 0
                }
                for (_ = 0, p = 0; _ < 32; _++) c[_] += p - (c[31] >> 4) * J[_], p = c[_] >> 8, c[_] &= 255;
                for (_ = 0; _ < 32; _++) c[_] -= p * J[_];
                for (v = 0; v < 32; v++) c[v + 1] += c[v] >> 8, l[v] = 255 & c[v]
            }

            function reduce(l) {
                let c = new Float64Array(64);
                for (let p = 0; p < 64; p++) c[p] = l[p];
                for (let c = 0; c < 64; c++) l[c] = 0;
                modL(l, c)
            }
            c.Xx = function(l, c) {
                let p = new Float64Array(64),
                    _ = [gf(), gf(), gf(), gf()],
                    C = (0, v.hash)(l.subarray(0, 32));
                C[0] &= 248, C[31] &= 127, C[31] |= 64;
                let P = new Uint8Array(64);
                P.set(C.subarray(32), 32);
                let T = new v.SHA512;
                T.update(P.subarray(32)), T.update(c);
                let M = T.digest();
                T.clean(), reduce(M), scalarbase(_, M), pack(P, _), T.reset(), T.update(P.subarray(0, 32)), T.update(l.subarray(32)), T.update(c);
                let z = T.digest();
                reduce(z);
                for (let l = 0; l < 32; l++) p[l] = M[l];
                for (let l = 0; l < 32; l++)
                    for (let c = 0; c < 32; c++) p[l + c] += z[l] * C[c];
                return modL(P.subarray(32), p), P
            }
        },
        4069: function(l, c) {
            "use strict";
            Object.defineProperty(c, "__esModule", {
                value: !0
            }), c.isSerializableHash = function(l) {
                return void 0 !== l.saveState && void 0 !== l.restoreState && void 0 !== l.cleanSavedState
            }
        },
        221: function(l, c, p) {
            "use strict";
            var v = p(7478),
                _ = p(4460),
                C = function() {
                    function HKDF(l, c, p, _) {
                        void 0 === p && (p = new Uint8Array(0)), this._counter = new Uint8Array(1), this._hash = l, this._info = _;
                        var C = v.hmac(this._hash, p, c);
                        this._hmac = new v.HMAC(l, C), this._buffer = new Uint8Array(this._hmac.digestLength), this._bufpos = this._buffer.length
                    }
                    return HKDF.prototype._fillBuffer = function() {
                        this._counter[0]++;
                        var l = this._counter[0];
                        if (0 === l) throw Error("hkdf: cannot expand more");
                        this._hmac.reset(), l > 1 && this._hmac.update(this._buffer), this._info && this._hmac.update(this._info), this._hmac.update(this._counter), this._hmac.finish(this._buffer), this._bufpos = 0
                    }, HKDF.prototype.expand = function(l) {
                        for (var c = new Uint8Array(l), p = 0; p < c.length; p++) this._bufpos === this._buffer.length && this._fillBuffer(), c[p] = this._buffer[this._bufpos++];
                        return c
                    }, HKDF.prototype.clean = function() {
                        this._hmac.clean(), _.wipe(this._buffer), _.wipe(this._counter), this._bufpos = 0
                    }, HKDF
                }();
            c.t = C
        },
        7478: function(l, c, p) {
            "use strict";
            Object.defineProperty(c, "__esModule", {
                value: !0
            });
            var v = p(4069),
                _ = p(7829),
                C = p(4460),
                P = function() {
                    function HMAC(l, c) {
                        this._finished = !1, this._inner = new l, this._outer = new l, this.blockSize = this._outer.blockSize, this.digestLength = this._outer.digestLength;
                        var p = new Uint8Array(this.blockSize);
                        c.length > this.blockSize ? this._inner.update(c).finish(p).clean() : p.set(c);
                        for (var _ = 0; _ < p.length; _++) p[_] ^= 54;
                        this._inner.update(p);
                        for (var _ = 0; _ < p.length; _++) p[_] ^= 106;
                        this._outer.update(p), v.isSerializableHash(this._inner) && v.isSerializableHash(this._outer) && (this._innerKeyedState = this._inner.saveState(), this._outerKeyedState = this._outer.saveState()), C.wipe(p)
                    }
                    return HMAC.prototype.reset = function() {
                        if (!v.isSerializableHash(this._inner) || !v.isSerializableHash(this._outer)) throw Error("hmac: can't reset() because hash doesn't implement restoreState()");
                        return this._inner.restoreState(this._innerKeyedState), this._outer.restoreState(this._outerKeyedState), this._finished = !1, this
                    }, HMAC.prototype.clean = function() {
                        v.isSerializableHash(this._inner) && this._inner.cleanSavedState(this._innerKeyedState), v.isSerializableHash(this._outer) && this._outer.cleanSavedState(this._outerKeyedState), this._inner.clean(), this._outer.clean()
                    }, HMAC.prototype.update = function(l) {
                        return this._inner.update(l), this
                    }, HMAC.prototype.finish = function(l) {
                        return this._finished ? this._outer.finish(l) : (this._inner.finish(l), this._outer.update(l.subarray(0, this.digestLength)).finish(l), this._finished = !0), this
                    }, HMAC.prototype.digest = function() {
                        var l = new Uint8Array(this.digestLength);
                        return this.finish(l), l
                    }, HMAC.prototype.saveState = function() {
                        if (!v.isSerializableHash(this._inner)) throw Error("hmac: can't saveState() because hash doesn't implement it");
                        return this._inner.saveState()
                    }, HMAC.prototype.restoreState = function(l) {
                        if (!v.isSerializableHash(this._inner) || !v.isSerializableHash(this._outer)) throw Error("hmac: can't restoreState() because hash doesn't implement it");
                        return this._inner.restoreState(l), this._outer.restoreState(this._outerKeyedState), this._finished = !1, this
                    }, HMAC.prototype.cleanSavedState = function(l) {
                        if (!v.isSerializableHash(this._inner)) throw Error("hmac: can't cleanSavedState() because hash doesn't implement it");
                        this._inner.cleanSavedState(l)
                    }, HMAC
                }();
            c.HMAC = P, c.hmac = function(l, c, p) {
                var v = new P(l, c);
                v.update(p);
                var _ = v.digest();
                return v.clean(), _
            }, c.equal = _.equal
        },
        6581: function(l, c) {
            "use strict";
            Object.defineProperty(c, "__esModule", {
                value: !0
            }), c.mul = Math.imul || function(l, c) {
                var p = 65535 & l,
                    v = 65535 & c;
                return p * v + ((l >>> 16 & 65535) * v + p * (c >>> 16 & 65535) << 16 >>> 0) | 0
            }, c.add = function(l, c) {
                return l + c | 0
            }, c.sub = function(l, c) {
                return l - c | 0
            }, c.rotl = function(l, c) {
                return l << c | l >>> 32 - c
            }, c.rotr = function(l, c) {
                return l << 32 - c | l >>> c
            }, c.isInteger = Number.isInteger || function(l) {
                return "number" == typeof l && isFinite(l) && Math.floor(l) === l
            }, c.MAX_SAFE_INTEGER = 9007199254740991, c.isSafeInteger = function(l) {
                return c.isInteger(l) && l >= -c.MAX_SAFE_INTEGER && l <= c.MAX_SAFE_INTEGER
            }
        },
        4418: function(l, c, p) {
            "use strict";
            Object.defineProperty(c, "__esModule", {
                value: !0
            });
            var v = p(7829),
                _ = p(4460);
            c.DIGEST_LENGTH = 16;
            var C = function() {
                function Poly1305(l) {
                    this.digestLength = c.DIGEST_LENGTH, this._buffer = new Uint8Array(16), this._r = new Uint16Array(10), this._h = new Uint16Array(10), this._pad = new Uint16Array(8), this._leftover = 0, this._fin = 0, this._finished = !1;
                    var p = l[0] | l[1] << 8;
                    this._r[0] = 8191 & p;
                    var v = l[2] | l[3] << 8;
                    this._r[1] = (p >>> 13 | v << 3) & 8191;
                    var _ = l[4] | l[5] << 8;
                    this._r[2] = (v >>> 10 | _ << 6) & 7939;
                    var C = l[6] | l[7] << 8;
                    this._r[3] = (_ >>> 7 | C << 9) & 8191;
                    var P = l[8] | l[9] << 8;
                    this._r[4] = (C >>> 4 | P << 12) & 255, this._r[5] = P >>> 1 & 8190;
                    var T = l[10] | l[11] << 8;
                    this._r[6] = (P >>> 14 | T << 2) & 8191;
                    var M = l[12] | l[13] << 8;
                    this._r[7] = (T >>> 11 | M << 5) & 8065;
                    var z = l[14] | l[15] << 8;
                    this._r[8] = (M >>> 8 | z << 8) & 8191, this._r[9] = z >>> 5 & 127, this._pad[0] = l[16] | l[17] << 8, this._pad[1] = l[18] | l[19] << 8, this._pad[2] = l[20] | l[21] << 8, this._pad[3] = l[22] | l[23] << 8, this._pad[4] = l[24] | l[25] << 8, this._pad[5] = l[26] | l[27] << 8, this._pad[6] = l[28] | l[29] << 8, this._pad[7] = l[30] | l[31] << 8
                }
                return Poly1305.prototype._blocks = function(l, c, p) {
                    for (var v = this._fin ? 0 : 2048, _ = this._h[0], C = this._h[1], P = this._h[2], T = this._h[3], M = this._h[4], z = this._h[5], J = this._h[6], Q = this._h[7], X = this._h[8], es = this._h[9], eo = this._r[0], el = this._r[1], ec = this._r[2], eh = this._r[3], ed = this._r[4], ef = this._r[5], ep = this._r[6], eg = this._r[7], em = this._r[8], ey = this._r[9]; p >= 16;) {
                        var eb, ew = l[c + 0] | l[c + 1] << 8;
                        _ += 8191 & ew;
                        var ex = l[c + 2] | l[c + 3] << 8;
                        C += (ew >>> 13 | ex << 3) & 8191;
                        var e_ = l[c + 4] | l[c + 5] << 8;
                        P += (ex >>> 10 | e_ << 6) & 8191;
                        var eE = l[c + 6] | l[c + 7] << 8;
                        T += (e_ >>> 7 | eE << 9) & 8191;
                        var eA = l[c + 8] | l[c + 9] << 8;
                        M += (eE >>> 4 | eA << 12) & 8191, z += eA >>> 1 & 8191;
                        var eC = l[c + 10] | l[c + 11] << 8;
                        J += (eA >>> 14 | eC << 2) & 8191;
                        var eS = l[c + 12] | l[c + 13] << 8;
                        Q += (eC >>> 11 | eS << 5) & 8191;
                        var eN = l[c + 14] | l[c + 15] << 8;
                        X += (eS >>> 8 | eN << 8) & 8191, es += eN >>> 5 | v;
                        var eP = 0;
                        eP = (eb = 0 + _ * eo + C * (5 * ey) + P * (5 * em) + T * (5 * eg) + M * (5 * ep)) >>> 13, eb &= 8191, eb += z * (5 * ef) + J * (5 * ed) + Q * (5 * eh) + X * (5 * ec) + es * (5 * el), eP += eb >>> 13, eb &= 8191;
                        var eD = eP;
                        eD += _ * el + C * eo + P * (5 * ey) + T * (5 * em) + M * (5 * eg), eP = eD >>> 13, eD &= 8191, eD += z * (5 * ep) + J * (5 * ef) + Q * (5 * ed) + X * (5 * eh) + es * (5 * ec), eP += eD >>> 13, eD &= 8191;
                        var ek = eP;
                        ek += _ * ec + C * el + P * eo + T * (5 * ey) + M * (5 * em), eP = ek >>> 13, ek &= 8191, ek += z * (5 * eg) + J * (5 * ep) + Q * (5 * ef) + X * (5 * ed) + es * (5 * eh), eP += ek >>> 13, ek &= 8191;
                        var eI = eP;
                        eI += _ * eh + C * ec + P * el + T * eo + M * (5 * ey), eP = eI >>> 13, eI &= 8191, eI += z * (5 * em) + J * (5 * eg) + Q * (5 * ep) + X * (5 * ef) + es * (5 * ed), eP += eI >>> 13, eI &= 8191;
                        var eO = eP;
                        eO += _ * ed + C * eh + P * ec + T * el + M * eo, eP = eO >>> 13, eO &= 8191, eO += z * (5 * ey) + J * (5 * em) + Q * (5 * eg) + X * (5 * ep) + es * (5 * ef), eP += eO >>> 13, eO &= 8191;
                        var ej = eP;
                        ej += _ * ef + C * ed + P * eh + T * ec + M * el, eP = ej >>> 13, ej &= 8191, ej += z * eo + J * (5 * ey) + Q * (5 * em) + X * (5 * eg) + es * (5 * ep), eP += ej >>> 13, ej &= 8191;
                        var eT = eP;
                        eT += _ * ep + C * ef + P * ed + T * eh + M * ec, eP = eT >>> 13, eT &= 8191, eT += z * el + J * eo + Q * (5 * ey) + X * (5 * em) + es * (5 * eg), eP += eT >>> 13, eT &= 8191;
                        var eR = eP;
                        eR += _ * eg + C * ep + P * ef + T * ed + M * eh, eP = eR >>> 13, eR &= 8191, eR += z * ec + J * el + Q * eo + X * (5 * ey) + es * (5 * em), eP += eR >>> 13, eR &= 8191;
                        var eL = eP;
                        eL += _ * em + C * eg + P * ep + T * ef + M * ed, eP = eL >>> 13, eL &= 8191, eL += z * eh + J * ec + Q * el + X * eo + es * (5 * ey), eP += eL >>> 13, eL &= 8191;
                        var eM = eP;
                        eM += _ * ey + C * em + P * eg + T * ep + M * ef, eP = eM >>> 13, eM &= 8191, eM += z * ed + J * eh + Q * ec + X * el + es * eo, eP += eM >>> 13, eM &= 8191, eb = 8191 & (eP = (eP = (eP << 2) + eP | 0) + eb | 0), eP >>>= 13, eD += eP, _ = eb, C = eD, P = ek, T = eI, M = eO, z = ej, J = eT, Q = eR, X = eL, es = eM, c += 16, p -= 16
                    }
                    this._h[0] = _, this._h[1] = C, this._h[2] = P, this._h[3] = T, this._h[4] = M, this._h[5] = z, this._h[6] = J, this._h[7] = Q, this._h[8] = X, this._h[9] = es
                }, Poly1305.prototype.finish = function(l, c) {
                    void 0 === c && (c = 0);
                    var p, v, _, C, P = new Uint16Array(10);
                    if (this._leftover) {
                        for (C = this._leftover, this._buffer[C++] = 1; C < 16; C++) this._buffer[C] = 0;
                        this._fin = 1, this._blocks(this._buffer, 0, 16)
                    }
                    for (p = this._h[1] >>> 13, this._h[1] &= 8191, C = 2; C < 10; C++) this._h[C] += p, p = this._h[C] >>> 13, this._h[C] &= 8191;
                    for (this._h[0] += 5 * p, p = this._h[0] >>> 13, this._h[0] &= 8191, this._h[1] += p, p = this._h[1] >>> 13, this._h[1] &= 8191, this._h[2] += p, P[0] = this._h[0] + 5, p = P[0] >>> 13, P[0] &= 8191, C = 1; C < 10; C++) P[C] = this._h[C] + p, p = P[C] >>> 13, P[C] &= 8191;
                    for (P[9] -= 8192, v = (1 ^ p) - 1, C = 0; C < 10; C++) P[C] &= v;
                    for (C = 0, v = ~v; C < 10; C++) this._h[C] = this._h[C] & v | P[C];
                    for (C = 1, this._h[0] = (this._h[0] | this._h[1] << 13) & 65535, this._h[1] = (this._h[1] >>> 3 | this._h[2] << 10) & 65535, this._h[2] = (this._h[2] >>> 6 | this._h[3] << 7) & 65535, this._h[3] = (this._h[3] >>> 9 | this._h[4] << 4) & 65535, this._h[4] = (this._h[4] >>> 12 | this._h[5] << 1 | this._h[6] << 14) & 65535, this._h[5] = (this._h[6] >>> 2 | this._h[7] << 11) & 65535, this._h[6] = (this._h[7] >>> 5 | this._h[8] << 8) & 65535, this._h[7] = (this._h[8] >>> 8 | this._h[9] << 5) & 65535, _ = this._h[0] + this._pad[0], this._h[0] = 65535 & _; C < 8; C++) _ = (this._h[C] + this._pad[C] | 0) + (_ >>> 16) | 0, this._h[C] = 65535 & _;
                    return l[c + 0] = this._h[0] >>> 0, l[c + 1] = this._h[0] >>> 8, l[c + 2] = this._h[1] >>> 0, l[c + 3] = this._h[1] >>> 8, l[c + 4] = this._h[2] >>> 0, l[c + 5] = this._h[2] >>> 8, l[c + 6] = this._h[3] >>> 0, l[c + 7] = this._h[3] >>> 8, l[c + 8] = this._h[4] >>> 0, l[c + 9] = this._h[4] >>> 8, l[c + 10] = this._h[5] >>> 0, l[c + 11] = this._h[5] >>> 8, l[c + 12] = this._h[6] >>> 0, l[c + 13] = this._h[6] >>> 8, l[c + 14] = this._h[7] >>> 0, l[c + 15] = this._h[7] >>> 8, this._finished = !0, this
                }, Poly1305.prototype.update = function(l) {
                    var c, p = 0,
                        v = l.length;
                    if (this._leftover) {
                        (c = 16 - this._leftover) > v && (c = v);
                        for (var _ = 0; _ < c; _++) this._buffer[this._leftover + _] = l[p + _];
                        if (v -= c, p += c, this._leftover += c, this._leftover < 16) return this;
                        this._blocks(this._buffer, 0, 16), this._leftover = 0
                    }
                    if (v >= 16 && (c = v - v % 16, this._blocks(l, p, c), p += c, v -= c), v) {
                        for (var _ = 0; _ < v; _++) this._buffer[this._leftover + _] = l[p + _];
                        this._leftover += v
                    }
                    return this
                }, Poly1305.prototype.digest = function() {
                    if (this._finished) throw Error("Poly1305 was finished");
                    var l = new Uint8Array(16);
                    return this.finish(l), l
                }, Poly1305.prototype.clean = function() {
                    return _.wipe(this._buffer), _.wipe(this._r), _.wipe(this._h), _.wipe(this._pad), this._leftover = 0, this._fin = 0, this._finished = !0, this
                }, Poly1305
            }();
            c.Poly1305 = C, c.oneTimeAuth = function(l, c) {
                var p = new C(l);
                p.update(c);
                var v = p.digest();
                return p.clean(), v
            }, c.equal = function(l, p) {
                return l.length === c.DIGEST_LENGTH && p.length === c.DIGEST_LENGTH && v.equal(l, p)
            }
        },
        4510: function(l, c, p) {
            "use strict";
            Object.defineProperty(c, "__esModule", {
                value: !0
            }), c.randomStringForEntropy = c.randomString = c.randomUint32 = c.randomBytes = c.defaultRandomSource = void 0;
            let v = p(1818),
                _ = p(8258),
                C = p(4460);

            function randomBytes(l, p = c.defaultRandomSource) {
                return p.randomBytes(l)
            }
            c.defaultRandomSource = new v.SystemRandomSource, c.randomBytes = randomBytes, c.randomUint32 = function(l = c.defaultRandomSource) {
                let p = randomBytes(4, l),
                    v = (0, _.readUint32LE)(p);
                return (0, C.wipe)(p), v
            };
            let P = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";

            function randomString(l, p = P, v = c.defaultRandomSource) {
                if (p.length < 2) throw Error("randomString charset is too short");
                if (p.length > 256) throw Error("randomString charset is too long");
                let _ = "",
                    T = p.length,
                    M = 256 - 256 % T;
                for (; l > 0;) {
                    let c = randomBytes(Math.ceil(256 * l / M), v);
                    for (let v = 0; v < c.length && l > 0; v++) {
                        let C = c[v];
                        C < M && (_ += p.charAt(C % T), l--)
                    }(0, C.wipe)(c)
                }
                return _
            }
            c.randomString = randomString, c.randomStringForEntropy = function(l, p = P, v = c.defaultRandomSource) {
                let _ = Math.ceil(l / (Math.log(p.length) / Math.LN2));
                return randomString(_, p, v)
            }
        },
        930: function(l, c) {
            "use strict";
            Object.defineProperty(c, "__esModule", {
                value: !0
            }), c.BrowserRandomSource = void 0, c.BrowserRandomSource = class {
                constructor() {
                    this.isAvailable = !1, this.isInstantiated = !1;
                    let l = "undefined" != typeof self ? self.crypto || self.msCrypto : null;
                    l && void 0 !== l.getRandomValues && (this._crypto = l, this.isAvailable = !0, this.isInstantiated = !0)
                }
                randomBytes(l) {
                    if (!this.isAvailable || !this._crypto) throw Error("Browser random byte generator is not available.");
                    let c = new Uint8Array(l);
                    for (let l = 0; l < c.length; l += 65536) this._crypto.getRandomValues(c.subarray(l, l + Math.min(c.length - l, 65536)));
                    return c
                }
            }
        },
        9714: function(l, c, p) {
            "use strict";
            Object.defineProperty(c, "__esModule", {
                value: !0
            }), c.NodeRandomSource = void 0;
            let v = p(4460);
            c.NodeRandomSource = class {
                constructor() {
                    this.isAvailable = !1, this.isInstantiated = !1; {
                        let l = p(5883);
                        l && l.randomBytes && (this._crypto = l, this.isAvailable = !0, this.isInstantiated = !0)
                    }
                }
                randomBytes(l) {
                    if (!this.isAvailable || !this._crypto) throw Error("Node.js random byte generator is not available.");
                    let c = this._crypto.randomBytes(l);
                    if (c.length !== l) throw Error("NodeRandomSource: got fewer bytes than requested");
                    let p = new Uint8Array(l);
                    for (let l = 0; l < p.length; l++) p[l] = c[l];
                    return (0, v.wipe)(c), p
                }
            }
        },
        1818: function(l, c, p) {
            "use strict";
            Object.defineProperty(c, "__esModule", {
                value: !0
            }), c.SystemRandomSource = void 0;
            let v = p(930),
                _ = p(9714);
            c.SystemRandomSource = class {
                constructor() {
                    if (this.isAvailable = !1, this.name = "", this._source = new v.BrowserRandomSource, this._source.isAvailable) {
                        this.isAvailable = !0, this.name = "Browser";
                        return
                    }
                    if (this._source = new _.NodeRandomSource, this._source.isAvailable) {
                        this.isAvailable = !0, this.name = "Node";
                        return
                    }
                }
                randomBytes(l) {
                    if (!this.isAvailable) throw Error("System random byte generator is not available.");
                    return this._source.randomBytes(l)
                }
            }
        },
        5419: function(l, c, p) {
            "use strict";
            var v = p(8258),
                _ = p(4460);
            c.k = 32, c.cn = 64;
            var C = function() {
                function SHA256() {
                    this.digestLength = c.k, this.blockSize = c.cn, this._state = new Int32Array(8), this._temp = new Int32Array(64), this._buffer = new Uint8Array(128), this._bufferLength = 0, this._bytesHashed = 0, this._finished = !1, this.reset()
                }
                return SHA256.prototype._initState = function() {
                    this._state[0] = 1779033703, this._state[1] = 3144134277, this._state[2] = 1013904242, this._state[3] = 2773480762, this._state[4] = 1359893119, this._state[5] = 2600822924, this._state[6] = 528734635, this._state[7] = 1541459225
                }, SHA256.prototype.reset = function() {
                    return this._initState(), this._bufferLength = 0, this._bytesHashed = 0, this._finished = !1, this
                }, SHA256.prototype.clean = function() {
                    _.wipe(this._buffer), _.wipe(this._temp), this.reset()
                }, SHA256.prototype.update = function(l, c) {
                    if (void 0 === c && (c = l.length), this._finished) throw Error("SHA256: can't update because hash was finished.");
                    var p = 0;
                    if (this._bytesHashed += c, this._bufferLength > 0) {
                        for (; this._bufferLength < this.blockSize && c > 0;) this._buffer[this._bufferLength++] = l[p++], c--;
                        this._bufferLength === this.blockSize && (hashBlocks(this._temp, this._state, this._buffer, 0, this.blockSize), this._bufferLength = 0)
                    }
                    for (c >= this.blockSize && (p = hashBlocks(this._temp, this._state, l, p, c), c %= this.blockSize); c > 0;) this._buffer[this._bufferLength++] = l[p++], c--;
                    return this
                }, SHA256.prototype.finish = function(l) {
                    if (!this._finished) {
                        var c = this._bytesHashed,
                            p = this._bufferLength,
                            _ = c % 64 < 56 ? 64 : 128;
                        this._buffer[p] = 128;
                        for (var C = p + 1; C < _ - 8; C++) this._buffer[C] = 0;
                        v.writeUint32BE(c / 536870912 | 0, this._buffer, _ - 8), v.writeUint32BE(c << 3, this._buffer, _ - 4), hashBlocks(this._temp, this._state, this._buffer, 0, _), this._finished = !0
                    }
                    for (var C = 0; C < this.digestLength / 4; C++) v.writeUint32BE(this._state[C], l, 4 * C);
                    return this
                }, SHA256.prototype.digest = function() {
                    var l = new Uint8Array(this.digestLength);
                    return this.finish(l), l
                }, SHA256.prototype.saveState = function() {
                    if (this._finished) throw Error("SHA256: cannot save finished state");
                    return {
                        state: new Int32Array(this._state),
                        buffer: this._bufferLength > 0 ? new Uint8Array(this._buffer) : void 0,
                        bufferLength: this._bufferLength,
                        bytesHashed: this._bytesHashed
                    }
                }, SHA256.prototype.restoreState = function(l) {
                    return this._state.set(l.state), this._bufferLength = l.bufferLength, l.buffer && this._buffer.set(l.buffer), this._bytesHashed = l.bytesHashed, this._finished = !1, this
                }, SHA256.prototype.cleanSavedState = function(l) {
                    _.wipe(l.state), l.buffer && _.wipe(l.buffer), l.bufferLength = 0, l.bytesHashed = 0
                }, SHA256
            }();
            c.mE = C;
            var P = new Int32Array([1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298]);

            function hashBlocks(l, c, p, _, C) {
                for (; C >= 64;) {
                    for (var T = c[0], M = c[1], z = c[2], J = c[3], Q = c[4], X = c[5], es = c[6], eo = c[7], el = 0; el < 16; el++) {
                        var ec = _ + 4 * el;
                        l[el] = v.readUint32BE(p, ec)
                    }
                    for (var el = 16; el < 64; el++) {
                        var eh = l[el - 2],
                            ed = (eh >>> 17 | eh << 15) ^ (eh >>> 19 | eh << 13) ^ eh >>> 10,
                            ef = ((eh = l[el - 15]) >>> 7 | eh << 25) ^ (eh >>> 18 | eh << 14) ^ eh >>> 3;
                        l[el] = (ed + l[el - 7] | 0) + (ef + l[el - 16] | 0)
                    }
                    for (var el = 0; el < 64; el++) {
                        var ed = (((Q >>> 6 | Q << 26) ^ (Q >>> 11 | Q << 21) ^ (Q >>> 25 | Q << 7)) + (Q & X ^ ~Q & es) | 0) + (eo + (P[el] + l[el] | 0) | 0) | 0,
                            ef = ((T >>> 2 | T << 30) ^ (T >>> 13 | T << 19) ^ (T >>> 22 | T << 10)) + (T & M ^ T & z ^ M & z) | 0;
                        eo = es, es = X, X = Q, Q = J + ed | 0, J = z, z = M, M = T, T = ed + ef | 0
                    }
                    c[0] += T, c[1] += M, c[2] += z, c[3] += J, c[4] += Q, c[5] += X, c[6] += es, c[7] += eo, _ += 64, C -= 64
                }
                return _
            }
            c.vp = function(l) {
                var c = new C;
                c.update(l);
                var p = c.digest();
                return c.clean(), p
            }
        },
        1152: function(l, c, p) {
            "use strict";
            Object.defineProperty(c, "__esModule", {
                value: !0
            });
            var v = p(8258),
                _ = p(4460);
            c.DIGEST_LENGTH = 64, c.BLOCK_SIZE = 128;
            var C = function() {
                function SHA512() {
                    this.digestLength = c.DIGEST_LENGTH, this.blockSize = c.BLOCK_SIZE, this._stateHi = new Int32Array(8), this._stateLo = new Int32Array(8), this._tempHi = new Int32Array(16), this._tempLo = new Int32Array(16), this._buffer = new Uint8Array(256), this._bufferLength = 0, this._bytesHashed = 0, this._finished = !1, this.reset()
                }
                return SHA512.prototype._initState = function() {
                    this._stateHi[0] = 1779033703, this._stateHi[1] = 3144134277, this._stateHi[2] = 1013904242, this._stateHi[3] = 2773480762, this._stateHi[4] = 1359893119, this._stateHi[5] = 2600822924, this._stateHi[6] = 528734635, this._stateHi[7] = 1541459225, this._stateLo[0] = 4089235720, this._stateLo[1] = 2227873595, this._stateLo[2] = 4271175723, this._stateLo[3] = 1595750129, this._stateLo[4] = 2917565137, this._stateLo[5] = 725511199, this._stateLo[6] = 4215389547, this._stateLo[7] = 327033209
                }, SHA512.prototype.reset = function() {
                    return this._initState(), this._bufferLength = 0, this._bytesHashed = 0, this._finished = !1, this
                }, SHA512.prototype.clean = function() {
                    _.wipe(this._buffer), _.wipe(this._tempHi), _.wipe(this._tempLo), this.reset()
                }, SHA512.prototype.update = function(l, p) {
                    if (void 0 === p && (p = l.length), this._finished) throw Error("SHA512: can't update because hash was finished.");
                    var v = 0;
                    if (this._bytesHashed += p, this._bufferLength > 0) {
                        for (; this._bufferLength < c.BLOCK_SIZE && p > 0;) this._buffer[this._bufferLength++] = l[v++], p--;
                        this._bufferLength === this.blockSize && (hashBlocks(this._tempHi, this._tempLo, this._stateHi, this._stateLo, this._buffer, 0, this.blockSize), this._bufferLength = 0)
                    }
                    for (p >= this.blockSize && (v = hashBlocks(this._tempHi, this._tempLo, this._stateHi, this._stateLo, l, v, p), p %= this.blockSize); p > 0;) this._buffer[this._bufferLength++] = l[v++], p--;
                    return this
                }, SHA512.prototype.finish = function(l) {
                    if (!this._finished) {
                        var c = this._bytesHashed,
                            p = this._bufferLength,
                            _ = c % 128 < 112 ? 128 : 256;
                        this._buffer[p] = 128;
                        for (var C = p + 1; C < _ - 8; C++) this._buffer[C] = 0;
                        v.writeUint32BE(c / 536870912 | 0, this._buffer, _ - 8), v.writeUint32BE(c << 3, this._buffer, _ - 4), hashBlocks(this._tempHi, this._tempLo, this._stateHi, this._stateLo, this._buffer, 0, _), this._finished = !0
                    }
                    for (var C = 0; C < this.digestLength / 8; C++) v.writeUint32BE(this._stateHi[C], l, 8 * C), v.writeUint32BE(this._stateLo[C], l, 8 * C + 4);
                    return this
                }, SHA512.prototype.digest = function() {
                    var l = new Uint8Array(this.digestLength);
                    return this.finish(l), l
                }, SHA512.prototype.saveState = function() {
                    if (this._finished) throw Error("SHA256: cannot save finished state");
                    return {
                        stateHi: new Int32Array(this._stateHi),
                        stateLo: new Int32Array(this._stateLo),
                        buffer: this._bufferLength > 0 ? new Uint8Array(this._buffer) : void 0,
                        bufferLength: this._bufferLength,
                        bytesHashed: this._bytesHashed
                    }
                }, SHA512.prototype.restoreState = function(l) {
                    return this._stateHi.set(l.stateHi), this._stateLo.set(l.stateLo), this._bufferLength = l.bufferLength, l.buffer && this._buffer.set(l.buffer), this._bytesHashed = l.bytesHashed, this._finished = !1, this
                }, SHA512.prototype.cleanSavedState = function(l) {
                    _.wipe(l.stateHi), _.wipe(l.stateLo), l.buffer && _.wipe(l.buffer), l.bufferLength = 0, l.bytesHashed = 0
                }, SHA512
            }();
            c.SHA512 = C;
            var P = new Int32Array([1116352408, 3609767458, 1899447441, 602891725, 3049323471, 3964484399, 3921009573, 2173295548, 961987163, 4081628472, 1508970993, 3053834265, 2453635748, 2937671579, 2870763221, 3664609560, 3624381080, 2734883394, 310598401, 1164996542, 607225278, 1323610764, 1426881987, 3590304994, 1925078388, 4068182383, 2162078206, 991336113, 2614888103, 633803317, 3248222580, 3479774868, 3835390401, 2666613458, 4022224774, 944711139, 264347078, 2341262773, 604807628, 2007800933, 770255983, 1495990901, 1249150122, 1856431235, 1555081692, 3175218132, 1996064986, 2198950837, 2554220882, 3999719339, 2821834349, 766784016, 2952996808, 2566594879, 3210313671, 3203337956, 3336571891, 1034457026, 3584528711, 2466948901, 113926993, 3758326383, 338241895, 168717936, 666307205, 1188179964, 773529912, 1546045734, 1294757372, 1522805485, 1396182291, 2643833823, 1695183700, 2343527390, 1986661051, 1014477480, 2177026350, 1206759142, 2456956037, 344077627, 2730485921, 1290863460, 2820302411, 3158454273, 3259730800, 3505952657, 3345764771, 106217008, 3516065817, 3606008344, 3600352804, 1432725776, 4094571909, 1467031594, 275423344, 851169720, 430227734, 3100823752, 506948616, 1363258195, 659060556, 3750685593, 883997877, 3785050280, 958139571, 3318307427, 1322822218, 3812723403, 1537002063, 2003034995, 1747873779, 3602036899, 1955562222, 1575990012, 2024104815, 1125592928, 2227730452, 2716904306, 2361852424, 442776044, 2428436474, 593698344, 2756734187, 3733110249, 3204031479, 2999351573, 3329325298, 3815920427, 3391569614, 3928383900, 3515267271, 566280711, 3940187606, 3454069534, 4118630271, 4000239992, 116418474, 1914138554, 174292421, 2731055270, 289380356, 3203993006, 460393269, 320620315, 685471733, 587496836, 852142971, 1086792851, 1017036298, 365543100, 1126000580, 2618297676, 1288033470, 3409855158, 1501505948, 4234509866, 1607167915, 987167468, 1816402316, 1246189591]);

            function hashBlocks(l, c, p, _, C, T, M) {
                for (var z, J, Q, X, es, eo, el, ec, eh = p[0], ed = p[1], ef = p[2], ep = p[3], eg = p[4], em = p[5], ey = p[6], eb = p[7], ew = _[0], ex = _[1], e_ = _[2], eE = _[3], eA = _[4], eC = _[5], eS = _[6], eN = _[7]; M >= 128;) {
                    for (var eP = 0; eP < 16; eP++) {
                        var eD = 8 * eP + T;
                        l[eP] = v.readUint32BE(C, eD), c[eP] = v.readUint32BE(C, eD + 4)
                    }
                    for (var eP = 0; eP < 80; eP++) {
                        var ek = eh,
                            eI = ed,
                            eO = ef,
                            ej = ep,
                            eT = eg,
                            eR = em,
                            eL = ey,
                            eM = eb,
                            eU = ew,
                            eB = ex,
                            eF = e_,
                            eH = eE,
                            eV = eA,
                            ez = eC,
                            eW = eS,
                            eG = eN;
                        if (z = eb, es = 65535 & (J = eN), eo = J >>> 16, el = 65535 & z, ec = z >>> 16, z = (eg >>> 14 | eA << 18) ^ (eg >>> 18 | eA << 14) ^ (eA >>> 9 | eg << 23), es += 65535 & (J = (eA >>> 14 | eg << 18) ^ (eA >>> 18 | eg << 14) ^ (eg >>> 9 | eA << 23)), eo += J >>> 16, el += 65535 & z, ec += z >>> 16, z = eg & em ^ ~eg & ey, es += 65535 & (J = eA & eC ^ ~eA & eS), eo += J >>> 16, el += 65535 & z, ec += z >>> 16, z = P[2 * eP], es += 65535 & (J = P[2 * eP + 1]), eo += J >>> 16, el += 65535 & z, ec += z >>> 16, z = l[eP % 16], es += 65535 & (J = c[eP % 16]), eo += J >>> 16, el += 65535 & z, ec += z >>> 16, eo += es >>> 16, el += eo >>> 16, ec += el >>> 16, Q = 65535 & el | ec << 16, X = 65535 & es | eo << 16, z = Q, es = 65535 & (J = X), eo = J >>> 16, el = 65535 & z, ec = z >>> 16, z = (eh >>> 28 | ew << 4) ^ (ew >>> 2 | eh << 30) ^ (ew >>> 7 | eh << 25), es += 65535 & (J = (ew >>> 28 | eh << 4) ^ (eh >>> 2 | ew << 30) ^ (eh >>> 7 | ew << 25)), eo += J >>> 16, el += 65535 & z, ec += z >>> 16, z = eh & ed ^ eh & ef ^ ed & ef, es += 65535 & (J = ew & ex ^ ew & e_ ^ ex & e_), eo += J >>> 16, el += 65535 & z, ec += z >>> 16, eo += es >>> 16, el += eo >>> 16, ec += el >>> 16, eM = 65535 & el | ec << 16, eG = 65535 & es | eo << 16, z = ej, es = 65535 & (J = eH), eo = J >>> 16, el = 65535 & z, ec = z >>> 16, z = Q, es += 65535 & (J = X), eo += J >>> 16, el += 65535 & z, ec += z >>> 16, eo += es >>> 16, el += eo >>> 16, ec += el >>> 16, ej = 65535 & el | ec << 16, eH = 65535 & es | eo << 16, ed = ek, ef = eI, ep = eO, eg = ej, em = eT, ey = eR, eb = eL, eh = eM, ex = eU, e_ = eB, eE = eF, eA = eH, eC = eV, eS = ez, eN = eW, ew = eG, eP % 16 == 15)
                            for (var eD = 0; eD < 16; eD++) z = l[eD], es = 65535 & (J = c[eD]), eo = J >>> 16, el = 65535 & z, ec = z >>> 16, z = l[(eD + 9) % 16], es += 65535 & (J = c[(eD + 9) % 16]), eo += J >>> 16, el += 65535 & z, ec += z >>> 16, z = ((Q = l[(eD + 1) % 16]) >>> 1 | (X = c[(eD + 1) % 16]) << 31) ^ (Q >>> 8 | X << 24) ^ Q >>> 7, es += 65535 & (J = (X >>> 1 | Q << 31) ^ (X >>> 8 | Q << 24) ^ (X >>> 7 | Q << 25)), eo += J >>> 16, el += 65535 & z, ec += z >>> 16, z = ((Q = l[(eD + 14) % 16]) >>> 19 | (X = c[(eD + 14) % 16]) << 13) ^ (X >>> 29 | Q << 3) ^ Q >>> 6, es += 65535 & (J = (X >>> 19 | Q << 13) ^ (Q >>> 29 | X << 3) ^ (X >>> 6 | Q << 26)), eo += J >>> 16, el += 65535 & z, ec += z >>> 16, eo += es >>> 16, el += eo >>> 16, ec += el >>> 16, l[eD] = 65535 & el | ec << 16, c[eD] = 65535 & es | eo << 16
                    }
                    z = eh, es = 65535 & (J = ew), eo = J >>> 16, el = 65535 & z, ec = z >>> 16, z = p[0], es += 65535 & (J = _[0]), eo += J >>> 16, el += 65535 & z, ec += z >>> 16, eo += es >>> 16, el += eo >>> 16, ec += el >>> 16, p[0] = eh = 65535 & el | ec << 16, _[0] = ew = 65535 & es | eo << 16, z = ed, es = 65535 & (J = ex), eo = J >>> 16, el = 65535 & z, ec = z >>> 16, z = p[1], es += 65535 & (J = _[1]), eo += J >>> 16, el += 65535 & z, ec += z >>> 16, eo += es >>> 16, el += eo >>> 16, ec += el >>> 16, p[1] = ed = 65535 & el | ec << 16, _[1] = ex = 65535 & es | eo << 16, z = ef, es = 65535 & (J = e_), eo = J >>> 16, el = 65535 & z, ec = z >>> 16, z = p[2], es += 65535 & (J = _[2]), eo += J >>> 16, el += 65535 & z, ec += z >>> 16, eo += es >>> 16, el += eo >>> 16, ec += el >>> 16, p[2] = ef = 65535 & el | ec << 16, _[2] = e_ = 65535 & es | eo << 16, z = ep, es = 65535 & (J = eE), eo = J >>> 16, el = 65535 & z, ec = z >>> 16, z = p[3], es += 65535 & (J = _[3]), eo += J >>> 16, el += 65535 & z, ec += z >>> 16, eo += es >>> 16, el += eo >>> 16, ec += el >>> 16, p[3] = ep = 65535 & el | ec << 16, _[3] = eE = 65535 & es | eo << 16, z = eg, es = 65535 & (J = eA), eo = J >>> 16, el = 65535 & z, ec = z >>> 16, z = p[4], es += 65535 & (J = _[4]), eo += J >>> 16, el += 65535 & z, ec += z >>> 16, eo += es >>> 16, el += eo >>> 16, ec += el >>> 16, p[4] = eg = 65535 & el | ec << 16, _[4] = eA = 65535 & es | eo << 16, z = em, es = 65535 & (J = eC), eo = J >>> 16, el = 65535 & z, ec = z >>> 16, z = p[5], es += 65535 & (J = _[5]), eo += J >>> 16, el += 65535 & z, ec += z >>> 16, eo += es >>> 16, el += eo >>> 16, ec += el >>> 16, p[5] = em = 65535 & el | ec << 16, _[5] = eC = 65535 & es | eo << 16, z = ey, es = 65535 & (J = eS), eo = J >>> 16, el = 65535 & z, ec = z >>> 16, z = p[6], es += 65535 & (J = _[6]), eo += J >>> 16, el += 65535 & z, ec += z >>> 16, eo += es >>> 16, el += eo >>> 16, ec += el >>> 16, p[6] = ey = 65535 & el | ec << 16, _[6] = eS = 65535 & es | eo << 16, z = eb, es = 65535 & (J = eN), eo = J >>> 16, el = 65535 & z, ec = z >>> 16, z = p[7], es += 65535 & (J = _[7]), eo += J >>> 16, el += 65535 & z, ec += z >>> 16, eo += es >>> 16, el += eo >>> 16, ec += el >>> 16, p[7] = eb = 65535 & el | ec << 16, _[7] = eN = 65535 & es | eo << 16, T += 128, M -= 128
                }
                return T
            }
            c.hash = function(l) {
                var c = new C;
                c.update(l);
                var p = c.digest();
                return c.clean(), p
            }
        },
        4460: function(l, c) {
            "use strict";
            Object.defineProperty(c, "__esModule", {
                value: !0
            }), c.wipe = function(l) {
                for (var c = 0; c < l.length; c++) l[c] = 0;
                return l
            }
        },
        4066: function(l, c, p) {
            "use strict";
            c.gi = c.Au = c.KS = c.kz = void 0;
            let v = p(4510),
                _ = p(4460);

            function gf(l) {
                let c = new Float64Array(16);
                if (l)
                    for (let p = 0; p < l.length; p++) c[p] = l[p];
                return c
            }
            c.kz = 32, c.KS = 32;
            let C = new Uint8Array(32);
            C[0] = 9;
            let P = gf([56129, 1]);

            function car25519(l) {
                let c = 1;
                for (let p = 0; p < 16; p++) {
                    let v = l[p] + c + 65535;
                    c = Math.floor(v / 65536), l[p] = v - 65536 * c
                }
                l[0] += c - 1 + 37 * (c - 1)
            }

            function sel25519(l, c, p) {
                let v = ~(p - 1);
                for (let p = 0; p < 16; p++) {
                    let _ = v & (l[p] ^ c[p]);
                    l[p] ^= _, c[p] ^= _
                }
            }

            function add(l, c, p) {
                for (let v = 0; v < 16; v++) l[v] = c[v] + p[v]
            }

            function sub(l, c, p) {
                for (let v = 0; v < 16; v++) l[v] = c[v] - p[v]
            }

            function mul(l, c, p) {
                let v, _, C = 0,
                    P = 0,
                    T = 0,
                    M = 0,
                    z = 0,
                    J = 0,
                    Q = 0,
                    X = 0,
                    es = 0,
                    eo = 0,
                    el = 0,
                    ec = 0,
                    eh = 0,
                    ed = 0,
                    ef = 0,
                    ep = 0,
                    eg = 0,
                    em = 0,
                    ey = 0,
                    eb = 0,
                    ew = 0,
                    ex = 0,
                    e_ = 0,
                    eE = 0,
                    eA = 0,
                    eC = 0,
                    eS = 0,
                    eN = 0,
                    eP = 0,
                    eD = 0,
                    ek = 0,
                    eI = p[0],
                    eO = p[1],
                    ej = p[2],
                    eT = p[3],
                    eR = p[4],
                    eL = p[5],
                    eM = p[6],
                    eU = p[7],
                    eB = p[8],
                    eF = p[9],
                    eH = p[10],
                    eV = p[11],
                    ez = p[12],
                    eW = p[13],
                    eG = p[14],
                    eK = p[15];
                C += (v = c[0]) * eI, P += v * eO, T += v * ej, M += v * eT, z += v * eR, J += v * eL, Q += v * eM, X += v * eU, es += v * eB, eo += v * eF, el += v * eH, ec += v * eV, eh += v * ez, ed += v * eW, ef += v * eG, ep += v * eK, P += (v = c[1]) * eI, T += v * eO, M += v * ej, z += v * eT, J += v * eR, Q += v * eL, X += v * eM, es += v * eU, eo += v * eB, el += v * eF, ec += v * eH, eh += v * eV, ed += v * ez, ef += v * eW, ep += v * eG, eg += v * eK, T += (v = c[2]) * eI, M += v * eO, z += v * ej, J += v * eT, Q += v * eR, X += v * eL, es += v * eM, eo += v * eU, el += v * eB, ec += v * eF, eh += v * eH, ed += v * eV, ef += v * ez, ep += v * eW, eg += v * eG, em += v * eK, M += (v = c[3]) * eI, z += v * eO, J += v * ej, Q += v * eT, X += v * eR, es += v * eL, eo += v * eM, el += v * eU, ec += v * eB, eh += v * eF, ed += v * eH, ef += v * eV, ep += v * ez, eg += v * eW, em += v * eG, ey += v * eK, z += (v = c[4]) * eI, J += v * eO, Q += v * ej, X += v * eT, es += v * eR, eo += v * eL, el += v * eM, ec += v * eU, eh += v * eB, ed += v * eF, ef += v * eH, ep += v * eV, eg += v * ez, em += v * eW, ey += v * eG, eb += v * eK, J += (v = c[5]) * eI, Q += v * eO, X += v * ej, es += v * eT, eo += v * eR, el += v * eL, ec += v * eM, eh += v * eU, ed += v * eB, ef += v * eF, ep += v * eH, eg += v * eV, em += v * ez, ey += v * eW, eb += v * eG, ew += v * eK, Q += (v = c[6]) * eI, X += v * eO, es += v * ej, eo += v * eT, el += v * eR, ec += v * eL, eh += v * eM, ed += v * eU, ef += v * eB, ep += v * eF, eg += v * eH, em += v * eV, ey += v * ez, eb += v * eW, ew += v * eG, ex += v * eK, X += (v = c[7]) * eI, es += v * eO, eo += v * ej, el += v * eT, ec += v * eR, eh += v * eL, ed += v * eM, ef += v * eU, ep += v * eB, eg += v * eF, em += v * eH, ey += v * eV, eb += v * ez, ew += v * eW, ex += v * eG, e_ += v * eK, es += (v = c[8]) * eI, eo += v * eO, el += v * ej, ec += v * eT, eh += v * eR, ed += v * eL, ef += v * eM, ep += v * eU, eg += v * eB, em += v * eF, ey += v * eH, eb += v * eV, ew += v * ez, ex += v * eW, e_ += v * eG, eE += v * eK, eo += (v = c[9]) * eI, el += v * eO, ec += v * ej, eh += v * eT, ed += v * eR, ef += v * eL, ep += v * eM, eg += v * eU, em += v * eB, ey += v * eF, eb += v * eH, ew += v * eV, ex += v * ez, e_ += v * eW, eE += v * eG, eA += v * eK, el += (v = c[10]) * eI, ec += v * eO, eh += v * ej, ed += v * eT, ef += v * eR, ep += v * eL, eg += v * eM, em += v * eU, ey += v * eB, eb += v * eF, ew += v * eH, ex += v * eV, e_ += v * ez, eE += v * eW, eA += v * eG, eC += v * eK, ec += (v = c[11]) * eI, eh += v * eO, ed += v * ej, ef += v * eT, ep += v * eR, eg += v * eL, em += v * eM, ey += v * eU, eb += v * eB, ew += v * eF, ex += v * eH, e_ += v * eV, eE += v * ez, eA += v * eW, eC += v * eG, eS += v * eK, eh += (v = c[12]) * eI, ed += v * eO, ef += v * ej, ep += v * eT, eg += v * eR, em += v * eL, ey += v * eM, eb += v * eU, ew += v * eB, ex += v * eF, e_ += v * eH, eE += v * eV, eA += v * ez, eC += v * eW, eS += v * eG, eN += v * eK, ed += (v = c[13]) * eI, ef += v * eO, ep += v * ej, eg += v * eT, em += v * eR, ey += v * eL, eb += v * eM, ew += v * eU, ex += v * eB, e_ += v * eF, eE += v * eH, eA += v * eV, eC += v * ez, eS += v * eW, eN += v * eG, eP += v * eK, ef += (v = c[14]) * eI, ep += v * eO, eg += v * ej, em += v * eT, ey += v * eR, eb += v * eL, ew += v * eM, ex += v * eU, e_ += v * eB, eE += v * eF, eA += v * eH, eC += v * eV, eS += v * ez, eN += v * eW, eP += v * eG, eD += v * eK, ep += (v = c[15]) * eI, eg += v * eO, em += v * ej, ey += v * eT, eb += v * eR, ew += v * eL, ex += v * eM, e_ += v * eU, eE += v * eB, eA += v * eF, eC += v * eH, eS += v * eV, eN += v * ez, eP += v * eW, eD += v * eG, ek += v * eK, C += 38 * eg, P += 38 * em, T += 38 * ey, M += 38 * eb, z += 38 * ew, J += 38 * ex, Q += 38 * e_, X += 38 * eE, es += 38 * eA, eo += 38 * eC, el += 38 * eS, ec += 38 * eN, eh += 38 * eP, ed += 38 * eD, ef += 38 * ek, _ = Math.floor((v = C + (_ = 1) + 65535) / 65536), C = v - 65536 * _, _ = Math.floor((v = P + _ + 65535) / 65536), P = v - 65536 * _, _ = Math.floor((v = T + _ + 65535) / 65536), T = v - 65536 * _, _ = Math.floor((v = M + _ + 65535) / 65536), M = v - 65536 * _, _ = Math.floor((v = z + _ + 65535) / 65536), z = v - 65536 * _, _ = Math.floor((v = J + _ + 65535) / 65536), J = v - 65536 * _, _ = Math.floor((v = Q + _ + 65535) / 65536), Q = v - 65536 * _, _ = Math.floor((v = X + _ + 65535) / 65536), X = v - 65536 * _, _ = Math.floor((v = es + _ + 65535) / 65536), es = v - 65536 * _, _ = Math.floor((v = eo + _ + 65535) / 65536), eo = v - 65536 * _, _ = Math.floor((v = el + _ + 65535) / 65536), el = v - 65536 * _, _ = Math.floor((v = ec + _ + 65535) / 65536), ec = v - 65536 * _, _ = Math.floor((v = eh + _ + 65535) / 65536), eh = v - 65536 * _, _ = Math.floor((v = ed + _ + 65535) / 65536), ed = v - 65536 * _, _ = Math.floor((v = ef + _ + 65535) / 65536), ef = v - 65536 * _, _ = Math.floor((v = ep + _ + 65535) / 65536), ep = v - 65536 * _, C += _ - 1 + 37 * (_ - 1), _ = Math.floor((v = C + (_ = 1) + 65535) / 65536), C = v - 65536 * _, _ = Math.floor((v = P + _ + 65535) / 65536), P = v - 65536 * _, _ = Math.floor((v = T + _ + 65535) / 65536), T = v - 65536 * _, _ = Math.floor((v = M + _ + 65535) / 65536), M = v - 65536 * _, _ = Math.floor((v = z + _ + 65535) / 65536), z = v - 65536 * _, _ = Math.floor((v = J + _ + 65535) / 65536), J = v - 65536 * _, _ = Math.floor((v = Q + _ + 65535) / 65536), Q = v - 65536 * _, _ = Math.floor((v = X + _ + 65535) / 65536), X = v - 65536 * _, _ = Math.floor((v = es + _ + 65535) / 65536), es = v - 65536 * _, _ = Math.floor((v = eo + _ + 65535) / 65536), eo = v - 65536 * _, _ = Math.floor((v = el + _ + 65535) / 65536), el = v - 65536 * _, _ = Math.floor((v = ec + _ + 65535) / 65536), ec = v - 65536 * _, _ = Math.floor((v = eh + _ + 65535) / 65536), eh = v - 65536 * _, _ = Math.floor((v = ed + _ + 65535) / 65536), ed = v - 65536 * _, _ = Math.floor((v = ef + _ + 65535) / 65536), ef = v - 65536 * _, _ = Math.floor((v = ep + _ + 65535) / 65536), ep = v - 65536 * _, C += _ - 1 + 37 * (_ - 1), l[0] = C, l[1] = P, l[2] = T, l[3] = M, l[4] = z, l[5] = J, l[6] = Q, l[7] = X, l[8] = es, l[9] = eo, l[10] = el, l[11] = ec, l[12] = eh, l[13] = ed, l[14] = ef, l[15] = ep
            }

            function scalarMult(l, c) {
                let p = new Uint8Array(32),
                    v = new Float64Array(80),
                    _ = gf(),
                    C = gf(),
                    T = gf(),
                    M = gf(),
                    z = gf(),
                    J = gf();
                for (let c = 0; c < 31; c++) p[c] = l[c];
                p[31] = 127 & l[31] | 64, p[0] &= 248,
                    function(l, c) {
                        for (let p = 0; p < 16; p++) l[p] = c[2 * p] + (c[2 * p + 1] << 8);
                        l[15] &= 32767
                    }(v, c);
                for (let l = 0; l < 16; l++) C[l] = v[l];
                _[0] = M[0] = 1;
                for (let l = 254; l >= 0; --l) {
                    let c = p[l >>> 3] >>> (7 & l) & 1;
                    sel25519(_, C, c), sel25519(T, M, c), add(z, _, T), sub(_, _, T), add(T, C, M), sub(C, C, M), mul(M, z, z), mul(J, _, _), mul(_, T, _), mul(T, C, z), add(z, _, T), sub(_, _, T), mul(C, _, _), sub(T, M, J), mul(_, T, P), add(_, _, M), mul(T, T, _), mul(_, M, J), mul(M, C, v), mul(C, z, z), sel25519(_, C, c), sel25519(T, M, c)
                }
                for (let l = 0; l < 16; l++) v[l + 16] = _[l], v[l + 32] = T[l], v[l + 48] = C[l], v[l + 64] = M[l];
                let Q = v.subarray(32),
                    X = v.subarray(16);
                ! function(l, c) {
                    let p = gf();
                    for (let l = 0; l < 16; l++) p[l] = c[l];
                    for (let l = 253; l >= 0; l--) mul(p, p, p), 2 !== l && 4 !== l && mul(p, p, c);
                    for (let c = 0; c < 16; c++) l[c] = p[c]
                }(Q, Q), mul(X, X, Q);
                let es = new Uint8Array(32);
                return ! function(l, c) {
                    let p = gf(),
                        v = gf();
                    for (let l = 0; l < 16; l++) v[l] = c[l];
                    car25519(v), car25519(v), car25519(v);
                    for (let l = 0; l < 2; l++) {
                        p[0] = v[0] - 65517;
                        for (let l = 1; l < 15; l++) p[l] = v[l] - 65535 - (p[l - 1] >> 16 & 1), p[l - 1] &= 65535;
                        p[15] = v[15] - 32767 - (p[14] >> 16 & 1);
                        let l = p[15] >> 16 & 1;
                        p[14] &= 65535, sel25519(v, p, 1 - l)
                    }
                    for (let c = 0; c < 16; c++) l[2 * c] = 255 & v[c], l[2 * c + 1] = v[c] >> 8
                }(es, X), es
            }
            c.Au = function(l) {
                let p = (0, v.randomBytes)(32, l),
                    P = function(l) {
                        if (l.length !== c.KS) throw Error(`x25519: seed must be ${c.KS} bytes`);
                        let p = new Uint8Array(l),
                            v = scalarMult(p, C);
                        return {
                            publicKey: v,
                            secretKey: p
                        }
                    }(p);
                return (0, _.wipe)(p), P
            }, c.gi = function(l, p, v = !1) {
                if (l.length !== c.kz) throw Error("X25519: incorrect secret key length");
                if (p.length !== c.kz) throw Error("X25519: incorrect public key length");
                let _ = scalarMult(l, p);
                if (v) {
                    let l = 0;
                    for (let c = 0; c < _.length; c++) l |= _[c];
                    if (0 === l) throw Error("X25519: invalid shared key")
                }
                return _
            }
        },
        8323: function(l, c, p) {
            "use strict";

            function getBrowerCrypto() {
                return (null === p.g || void 0 === p.g ? void 0 : p.g.crypto) || (null === p.g || void 0 === p.g ? void 0 : p.g.msCrypto) || {}
            }

            function getSubtleCrypto() {
                let l = getBrowerCrypto();
                return l.subtle || l.webkitSubtle
            }
            Object.defineProperty(c, "__esModule", {
                value: !0
            }), c.isBrowserCryptoAvailable = c.getSubtleCrypto = c.getBrowerCrypto = void 0, c.getBrowerCrypto = getBrowerCrypto, c.getSubtleCrypto = getSubtleCrypto, c.isBrowserCryptoAvailable = function() {
                return !!getBrowerCrypto() && !!getSubtleCrypto()
            }
        },
        4174: function(l, c, p) {
            "use strict";
            var v = p(1390);

            function isReactNative() {
                return "undefined" == typeof document && "undefined" != typeof navigator && "ReactNative" === navigator.product
            }

            function isNode() {
                return void 0 !== v && void 0 !== v.versions && void 0 !== v.versions.node
            }
            Object.defineProperty(c, "__esModule", {
                value: !0
            }), c.isBrowser = c.isNode = c.isReactNative = void 0, c.isReactNative = isReactNative, c.isNode = isNode, c.isBrowser = function() {
                return !isReactNative() && !isNode()
            }
        },
        315: function(l, c, p) {
            "use strict";
            Object.defineProperty(c, "__esModule", {
                value: !0
            });
            let v = p(9243);
            v.__exportStar(p(8323), c), v.__exportStar(p(4174), c)
        },
        6920: function(l, c, p) {
            "use strict";
            p.d(c, {
                q: function() {
                    return IEvents
                }
            });
            let IEvents = class IEvents {}
        },
        7780: function(l, c, p) {
            "use strict";
            p.r(c), p.d(c, {
                IEvents: function() {
                    return v.q
                }
            });
            var v = p(6920)
        },
        5057: function(l, c, p) {
            "use strict";
            Object.defineProperty(c, "__esModule", {
                value: !0
            }), c.HEARTBEAT_EVENTS = c.HEARTBEAT_INTERVAL = void 0;
            let v = p(9044);
            c.HEARTBEAT_INTERVAL = v.FIVE_SECONDS, c.HEARTBEAT_EVENTS = {
                pulse: "heartbeat_pulse"
            }
        },
        429: function(l, c, p) {
            "use strict";
            Object.defineProperty(c, "__esModule", {
                value: !0
            });
            let v = p(9243);
            v.__exportStar(p(5057), c)
        },
        702: function(l, c, p) {
            "use strict";
            Object.defineProperty(c, "__esModule", {
                value: !0
            }), c.HeartBeat = void 0;
            let v = p(9243),
                _ = p(9944),
                C = p(9044),
                P = p(7773),
                T = p(429);
            let HeartBeat = class HeartBeat extends P.IHeartBeat {
                constructor(l) {
                    super(l), this.events = new _.EventEmitter, this.interval = T.HEARTBEAT_INTERVAL, this.interval = (null == l ? void 0 : l.interval) || T.HEARTBEAT_INTERVAL
                }
                static init(l) {
                    return v.__awaiter(this, void 0, void 0, function*() {
                        let c = new HeartBeat(l);
                        return yield c.init(), c
                    })
                }
                init() {
                    return v.__awaiter(this, void 0, void 0, function*() {
                        yield this.initialize()
                    })
                }
                stop() {
                    clearInterval(this.intervalRef)
                }
                on(l, c) {
                    this.events.on(l, c)
                }
                once(l, c) {
                    this.events.once(l, c)
                }
                off(l, c) {
                    this.events.off(l, c)
                }
                removeListener(l, c) {
                    this.events.removeListener(l, c)
                }
                initialize() {
                    return v.__awaiter(this, void 0, void 0, function*() {
                        this.intervalRef = setInterval(() => this.pulse(), C.toMiliseconds(this.interval))
                    })
                }
                pulse() {
                    this.events.emit(T.HEARTBEAT_EVENTS.pulse)
                }
            };
            c.HeartBeat = HeartBeat
        },
        8889: function(l, c, p) {
            "use strict";
            Object.defineProperty(c, "__esModule", {
                value: !0
            });
            let v = p(9243);
            v.__exportStar(p(702), c), v.__exportStar(p(7773), c), v.__exportStar(p(429), c)
        },
        541: function(l, c, p) {
            "use strict";
            Object.defineProperty(c, "__esModule", {
                value: !0
            }), c.IHeartBeat = void 0;
            let v = p(7780);
            let IHeartBeat = class IHeartBeat extends v.IEvents {
                constructor(l) {
                    super()
                }
            };
            c.IHeartBeat = IHeartBeat
        },
        7773: function(l, c, p) {
            "use strict";
            Object.defineProperty(c, "__esModule", {
                value: !0
            });
            let v = p(9243);
            v.__exportStar(p(541), c)
        },
        5315: function(l) {
            "use strict";
            l.exports = function() {
                throw Error("ws does not work in the browser. Browser clients must use the native WebSocket object")
            }
        },
        7251: function(l, c, p) {
            "use strict";
            let v = p(9243),
                _ = p(427),
                C = v.__importDefault(p(1201)),
                P = p(6580);
            c.ZP = class {
                constructor() {
                    this.localStorage = C.default
                }
                getKeys() {
                    return v.__awaiter(this, void 0, void 0, function*() {
                        return Object.keys(this.localStorage)
                    })
                }
                getEntries() {
                    return v.__awaiter(this, void 0, void 0, function*() {
                        return Object.entries(this.localStorage).map(P.parseEntry)
                    })
                }
                getItem(l) {
                    return v.__awaiter(this, void 0, void 0, function*() {
                        let c = this.localStorage.getItem(l);
                        if (null !== c) return _.safeJsonParse(c)
                    })
                }
                setItem(l, c) {
                    return v.__awaiter(this, void 0, void 0, function*() {
                        this.localStorage.setItem(l, _.safeJsonStringify(c))
                    })
                }
                removeItem(l) {
                    return v.__awaiter(this, void 0, void 0, function*() {
                        this.localStorage.removeItem(l)
                    })
                }
            }
        },
        1201: function(l, c, p) {
            "use strict";
            ! function() {
                function LocalStorage() {}
                LocalStorage.prototype.getItem = function(l) {
                    return this.hasOwnProperty(l) ? String(this[l]) : null
                }, LocalStorage.prototype.setItem = function(l, c) {
                    this[l] = String(c)
                }, LocalStorage.prototype.removeItem = function(l) {
                    delete this[l]
                }, LocalStorage.prototype.clear = function() {
                    let l = this;
                    Object.keys(l).forEach(function(c) {
                        l[c] = void 0, delete l[c]
                    })
                }, LocalStorage.prototype.key = function(l) {
                    return l = l || 0, Object.keys(this)[l]
                }, LocalStorage.prototype.__defineGetter__("length", function() {
                    return Object.keys(this).length
                }), void 0 !== p.g && p.g.localStorage ? l.exports = p.g.localStorage : "undefined" != typeof window && window.localStorage ? l.exports = window.localStorage : l.exports = new LocalStorage
            }()
        },
        6580: function(l, c, p) {
            "use strict";
            Object.defineProperty(c, "__esModule", {
                value: !0
            });
            let v = p(9243);
            v.__exportStar(p(1508), c), v.__exportStar(p(205), c)
        },
        1508: function(l, c) {
            "use strict";
            Object.defineProperty(c, "__esModule", {
                value: !0
            }), c.IKeyValueStorage = void 0, c.IKeyValueStorage = class {}
        },
        205: function(l, c, p) {
            "use strict";
            Object.defineProperty(c, "__esModule", {
                value: !0
            }), c.parseEntry = void 0;
            let v = p(427);
            c.parseEntry = function(l) {
                var c;
                return [l[0], v.safeJsonParse(null !== (c = l[1]) && void 0 !== c ? c : "")]
            }
        },
        7291: function(l, c) {
            "use strict";
            Object.defineProperty(c, "__esModule", {
                value: !0
            }), c.PINO_CUSTOM_CONTEXT_KEY = c.PINO_LOGGER_DEFAULTS = void 0, c.PINO_LOGGER_DEFAULTS = {
                level: "info"
            }, c.PINO_CUSTOM_CONTEXT_KEY = "custom_context"
        },
        3387: function(l, c, p) {
            "use strict";
            Object.defineProperty(c, "__esModule", {
                value: !0
            }), c.pino = void 0;
            let v = p(9243),
                _ = v.__importDefault(p(3856));
            Object.defineProperty(c, "pino", {
                enumerable: !0,
                get: function() {
                    return _.default
                }
            }), v.__exportStar(p(7291), c), v.__exportStar(p(4555), c)
        },
        4555: function(l, c, p) {
            "use strict";
            Object.defineProperty(c, "__esModule", {
                value: !0
            }), c.generateChildLogger = c.formatChildLoggerContext = c.getLoggerContext = c.setBrowserLoggerContext = c.getBrowserLoggerContext = c.getDefaultLoggerOptions = void 0;
            let v = p(7291);

            function getBrowserLoggerContext(l, c = v.PINO_CUSTOM_CONTEXT_KEY) {
                return l[c] || ""
            }

            function setBrowserLoggerContext(l, c, p = v.PINO_CUSTOM_CONTEXT_KEY) {
                return l[p] = c, l
            }

            function getLoggerContext(l, c = v.PINO_CUSTOM_CONTEXT_KEY) {
                return void 0 === l.bindings ? getBrowserLoggerContext(l, c) : l.bindings().context || ""
            }

            function formatChildLoggerContext(l, c, p = v.PINO_CUSTOM_CONTEXT_KEY) {
                let _ = getLoggerContext(l, p),
                    C = _.trim() ? `${_}/${c}` : c;
                return C
            }
            c.getDefaultLoggerOptions = function(l) {
                return Object.assign(Object.assign({}, l), {
                    level: (null == l ? void 0 : l.level) || v.PINO_LOGGER_DEFAULTS.level
                })
            }, c.getBrowserLoggerContext = getBrowserLoggerContext, c.setBrowserLoggerContext = setBrowserLoggerContext, c.getLoggerContext = getLoggerContext, c.formatChildLoggerContext = formatChildLoggerContext, c.generateChildLogger = function(l, c, p = v.PINO_CUSTOM_CONTEXT_KEY) {
                let _ = formatChildLoggerContext(l, c, p),
                    C = l.child({
                        context: _
                    });
                return setBrowserLoggerContext(C, _, p)
            }
        },
        6375: function() {},
        6380: function() {},
        498: function(l, c, p) {
            "use strict";
            Object.defineProperty(c, "__esModule", {
                value: !0
            });
            let v = p(9243);
            v.__exportStar(p(2610), c), v.__exportStar(p(712), c)
        },
        2610: function(l, c) {
            "use strict";
            Object.defineProperty(c, "__esModule", {
                value: !0
            }), c.ONE_THOUSAND = c.ONE_HUNDRED = void 0, c.ONE_HUNDRED = 100, c.ONE_THOUSAND = 1e3
        },
        712: function(l, c) {
            "use strict";
            Object.defineProperty(c, "__esModule", {
                value: !0
            }), c.ONE_YEAR = c.FOUR_WEEKS = c.THREE_WEEKS = c.TWO_WEEKS = c.ONE_WEEK = c.THIRTY_DAYS = c.SEVEN_DAYS = c.FIVE_DAYS = c.THREE_DAYS = c.ONE_DAY = c.TWENTY_FOUR_HOURS = c.TWELVE_HOURS = c.SIX_HOURS = c.THREE_HOURS = c.ONE_HOUR = c.SIXTY_MINUTES = c.THIRTY_MINUTES = c.TEN_MINUTES = c.FIVE_MINUTES = c.ONE_MINUTE = c.SIXTY_SECONDS = c.THIRTY_SECONDS = c.TEN_SECONDS = c.FIVE_SECONDS = c.ONE_SECOND = void 0, c.ONE_SECOND = 1, c.FIVE_SECONDS = 5, c.TEN_SECONDS = 10, c.THIRTY_SECONDS = 30, c.SIXTY_SECONDS = 60, c.ONE_MINUTE = c.SIXTY_SECONDS, c.FIVE_MINUTES = 5 * c.ONE_MINUTE, c.TEN_MINUTES = 10 * c.ONE_MINUTE, c.THIRTY_MINUTES = 30 * c.ONE_MINUTE, c.SIXTY_MINUTES = 60 * c.ONE_MINUTE, c.ONE_HOUR = c.SIXTY_MINUTES, c.THREE_HOURS = 3 * c.ONE_HOUR, c.SIX_HOURS = 6 * c.ONE_HOUR, c.TWELVE_HOURS = 12 * c.ONE_HOUR, c.TWENTY_FOUR_HOURS = 24 * c.ONE_HOUR, c.ONE_DAY = c.TWENTY_FOUR_HOURS, c.THREE_DAYS = 3 * c.ONE_DAY, c.FIVE_DAYS = 5 * c.ONE_DAY, c.SEVEN_DAYS = 7 * c.ONE_DAY, c.THIRTY_DAYS = 30 * c.ONE_DAY, c.ONE_WEEK = c.SEVEN_DAYS, c.TWO_WEEKS = 2 * c.ONE_WEEK, c.THREE_WEEKS = 3 * c.ONE_WEEK, c.FOUR_WEEKS = 4 * c.ONE_WEEK, c.ONE_YEAR = 365 * c.ONE_DAY
        },
        9044: function(l, c, p) {
            "use strict";
            Object.defineProperty(c, "__esModule", {
                value: !0
            });
            let v = p(9243);
            v.__exportStar(p(626), c), v.__exportStar(p(5659), c), v.__exportStar(p(231), c), v.__exportStar(p(498), c)
        },
        231: function(l, c, p) {
            "use strict";
            Object.defineProperty(c, "__esModule", {
                value: !0
            });
            let v = p(9243);
            v.__exportStar(p(3149), c)
        },
        3149: function(l, c) {
            "use strict";
            Object.defineProperty(c, "__esModule", {
                value: !0
            }), c.IWatch = void 0, c.IWatch = class {}
        },
        1902: function(l, c, p) {
            "use strict";
            Object.defineProperty(c, "__esModule", {
                value: !0
            }), c.fromMiliseconds = c.toMiliseconds = void 0;
            let v = p(498);
            c.toMiliseconds = function(l) {
                return l * v.ONE_THOUSAND
            }, c.fromMiliseconds = function(l) {
                return Math.floor(l / v.ONE_THOUSAND)
            }
        },
        1964: function(l, c) {
            "use strict";
            Object.defineProperty(c, "__esModule", {
                value: !0
            }), c.delay = void 0, c.delay = function(l) {
                return new Promise(c => {
                    setTimeout(() => {
                        c(!0)
                    }, l)
                })
            }
        },
        626: function(l, c, p) {
            "use strict";
            Object.defineProperty(c, "__esModule", {
                value: !0
            });
            let v = p(9243);
            v.__exportStar(p(1964), c), v.__exportStar(p(1902), c)
        },
        5659: function(l, c) {
            "use strict";
            Object.defineProperty(c, "__esModule", {
                value: !0
            }), c.Watch = void 0;
            let Watch = class Watch {
                constructor() {
                    this.timestamps = new Map
                }
                start(l) {
                    if (this.timestamps.has(l)) throw Error(`Watch already started for label: ${l}`);
                    this.timestamps.set(l, {
                        started: Date.now()
                    })
                }
                stop(l) {
                    let c = this.get(l);
                    if (void 0 !== c.elapsed) throw Error(`Watch already stopped for label: ${l}`);
                    let p = Date.now() - c.started;
                    this.timestamps.set(l, {
                        started: c.started,
                        elapsed: p
                    })
                }
                get(l) {
                    let c = this.timestamps.get(l);
                    if (void 0 === c) throw Error(`No timestamp found for label: ${l}`);
                    return c
                }
                elapsed(l) {
                    let c = this.get(l),
                        p = c.elapsed || Date.now() - c.started;
                    return p
                }
            };
            c.Watch = Watch, c.default = Watch
        },
        6525: function(l, c) {
            "use strict";

            function getFromWindow(l) {
                let c;
                return "undefined" != typeof window && void 0 !== window[l] && (c = window[l]), c
            }

            function getFromWindowOrThrow(l) {
                let c = getFromWindow(l);
                if (!c) throw Error(`${l} is not defined in Window`);
                return c
            }
            Object.defineProperty(c, "__esModule", {
                value: !0
            }), c.getLocalStorage = c.getLocalStorageOrThrow = c.getCrypto = c.getCryptoOrThrow = c.getLocation = c.getLocationOrThrow = c.getNavigator = c.getNavigatorOrThrow = c.getDocument = c.getDocumentOrThrow = c.getFromWindowOrThrow = c.getFromWindow = void 0, c.getFromWindow = getFromWindow, c.getFromWindowOrThrow = getFromWindowOrThrow, c.getDocumentOrThrow = function() {
                return getFromWindowOrThrow("document")
            }, c.getDocument = function() {
                return getFromWindow("document")
            }, c.getNavigatorOrThrow = function() {
                return getFromWindowOrThrow("navigator")
            }, c.getNavigator = function() {
                return getFromWindow("navigator")
            }, c.getLocationOrThrow = function() {
                return getFromWindowOrThrow("location")
            }, c.getLocation = function() {
                return getFromWindow("location")
            }, c.getCryptoOrThrow = function() {
                return getFromWindowOrThrow("crypto")
            }, c.getCrypto = function() {
                return getFromWindow("crypto")
            }, c.getLocalStorageOrThrow = function() {
                return getFromWindowOrThrow("localStorage")
            }, c.getLocalStorage = function() {
                return getFromWindow("localStorage")
            }
        },
        1976: function(l, c, p) {
            "use strict";
            c.D = void 0;
            let v = p(6525);
            c.D = function() {
                let l, c, p;
                try {
                    l = v.getDocumentOrThrow(), c = v.getLocationOrThrow()
                } catch (l) {
                    return null
                }

                function getWindowMetadataOfAny(...c) {
                    let p = l.getElementsByTagName("meta");
                    for (let l = 0; l < p.length; l++) {
                        let v = p[l],
                            _ = ["itemprop", "property", "name"].map(l => v.getAttribute(l)).filter(l => !!l && c.includes(l));
                        if (_.length && _) {
                            let l = v.getAttribute("content");
                            if (l) return l
                        }
                    }
                    return ""
                }
                let _ = ((p = getWindowMetadataOfAny("name", "og:site_name", "og:title", "twitter:title")) || (p = l.title), p),
                    C = function() {
                        let l = getWindowMetadataOfAny("description", "og:description", "twitter:description", "keywords");
                        return l
                    }(),
                    P = c.origin,
                    T = function() {
                        let p = l.getElementsByTagName("link"),
                            v = [];
                        for (let l = 0; l < p.length; l++) {
                            let _ = p[l],
                                C = _.getAttribute("rel");
                            if (C && C.toLowerCase().indexOf("icon") > -1) {
                                let l = _.getAttribute("href");
                                if (l) {
                                    if (-1 === l.toLowerCase().indexOf("https:") && -1 === l.toLowerCase().indexOf("http:") && 0 !== l.indexOf("//")) {
                                        let p = c.protocol + "//" + c.host;
                                        if (0 === l.indexOf("/")) p += l;
                                        else {
                                            let v = c.pathname.split("/");
                                            v.pop();
                                            let _ = v.join("/");
                                            p += _ + "/" + l
                                        }
                                        v.push(p)
                                    } else if (0 === l.indexOf("//")) {
                                        let p = c.protocol + l;
                                        v.push(p)
                                    } else v.push(l)
                                }
                            }
                        }
                        return v
                    }();
                return {
                    description: C,
                    url: P,
                    icons: T,
                    name: _
                }
            }
        },
        8213: function(l, c, p) {
            "use strict";
            p.r(c), p.d(c, {
                CountUp: function() {
                    return v
                }
            });
            var t = function() {
                    return (t = Object.assign || function(l) {
                        for (var c, p = 1, v = arguments.length; p < v; p++)
                            for (var _ in c = arguments[p]) Object.prototype.hasOwnProperty.call(c, _) && (l[_] = c[_]);
                        return l
                    }).apply(this, arguments)
                },
                v = function() {
                    function i(l, c, p) {
                        var v = this;
                        this.endVal = c, this.options = p, this.version = "2.8.0", this.defaults = {
                            startVal: 0,
                            decimalPlaces: 0,
                            duration: 2,
                            useEasing: !0,
                            useGrouping: !0,
                            useIndianSeparators: !1,
                            smartEasingThreshold: 999,
                            smartEasingAmount: 333,
                            separator: ",",
                            decimal: ".",
                            prefix: "",
                            suffix: "",
                            enableScrollSpy: !1,
                            scrollSpyDelay: 200,
                            scrollSpyOnce: !1
                        }, this.finalEndVal = null, this.useEasing = !0, this.countDown = !1, this.error = "", this.startVal = 0, this.paused = !0, this.once = !1, this.count = function(l) {
                            v.startTime || (v.startTime = l);
                            var c = l - v.startTime;
                            v.remaining = v.duration - c, v.useEasing ? v.countDown ? v.frameVal = v.startVal - v.easingFn(c, 0, v.startVal - v.endVal, v.duration) : v.frameVal = v.easingFn(c, v.startVal, v.endVal - v.startVal, v.duration) : v.frameVal = v.startVal + (v.endVal - v.startVal) * (c / v.duration);
                            var p = v.countDown ? v.frameVal < v.endVal : v.frameVal > v.endVal;
                            v.frameVal = p ? v.endVal : v.frameVal, v.frameVal = Number(v.frameVal.toFixed(v.options.decimalPlaces)), v.printValue(v.frameVal), c < v.duration ? v.rAF = requestAnimationFrame(v.count) : null !== v.finalEndVal ? v.update(v.finalEndVal) : v.options.onCompleteCallback && v.options.onCompleteCallback()
                        }, this.formatNumber = function(l) {
                            var c, p, _, C = (Math.abs(l).toFixed(v.options.decimalPlaces) + "").split(".");
                            if (c = C[0], p = C.length > 1 ? v.options.decimal + C[1] : "", v.options.useGrouping) {
                                _ = "";
                                for (var P = 3, T = 0, M = 0, z = c.length; M < z; ++M) v.options.useIndianSeparators && 4 === M && (P = 2, T = 1), 0 !== M && T % P == 0 && (_ = v.options.separator + _), T++, _ = c[z - M - 1] + _;
                                c = _
                            }
                            return v.options.numerals && v.options.numerals.length && (c = c.replace(/[0-9]/g, function(l) {
                                return v.options.numerals[+l]
                            }), p = p.replace(/[0-9]/g, function(l) {
                                return v.options.numerals[+l]
                            })), (l < 0 ? "-" : "") + v.options.prefix + c + p + v.options.suffix
                        }, this.easeOutExpo = function(l, c, p, v) {
                            return p * (1 - Math.pow(2, -10 * l / v)) * 1024 / 1023 + c
                        }, this.options = t(t({}, this.defaults), p), this.formattingFn = this.options.formattingFn ? this.options.formattingFn : this.formatNumber, this.easingFn = this.options.easingFn ? this.options.easingFn : this.easeOutExpo, this.startVal = this.validateValue(this.options.startVal), this.frameVal = this.startVal, this.endVal = this.validateValue(c), this.options.decimalPlaces = Math.max(this.options.decimalPlaces), this.resetDuration(), this.options.separator = String(this.options.separator), this.useEasing = this.options.useEasing, "" === this.options.separator && (this.options.useGrouping = !1), this.el = "string" == typeof l ? document.getElementById(l) : l, this.el ? this.printValue(this.startVal) : this.error = "[CountUp] target is null or undefined", "undefined" != typeof window && this.options.enableScrollSpy && (this.error ? console.error(this.error, l) : (window.onScrollFns = window.onScrollFns || [], window.onScrollFns.push(function() {
                            return v.handleScroll(v)
                        }), window.onscroll = function() {
                            window.onScrollFns.forEach(function(l) {
                                return l()
                            })
                        }, this.handleScroll(this)))
                    }
                    return i.prototype.handleScroll = function(l) {
                        if (l && window && !l.once) {
                            var c = window.innerHeight + window.scrollY,
                                p = l.el.getBoundingClientRect(),
                                v = p.top + window.pageYOffset,
                                _ = p.top + p.height + window.pageYOffset;
                            _ < c && _ > window.scrollY && l.paused ? (l.paused = !1, setTimeout(function() {
                                return l.start()
                            }, l.options.scrollSpyDelay), l.options.scrollSpyOnce && (l.once = !0)) : (window.scrollY > _ || v > c) && !l.paused && l.reset()
                        }
                    }, i.prototype.determineDirectionAndSmartEasing = function() {
                        var l = this.finalEndVal ? this.finalEndVal : this.endVal;
                        if (this.countDown = this.startVal > l, Math.abs(l - this.startVal) > this.options.smartEasingThreshold && this.options.useEasing) {
                            this.finalEndVal = l;
                            var c = this.countDown ? 1 : -1;
                            this.endVal = l + c * this.options.smartEasingAmount, this.duration = this.duration / 2
                        } else this.endVal = l, this.finalEndVal = null;
                        null !== this.finalEndVal ? this.useEasing = !1 : this.useEasing = this.options.useEasing
                    }, i.prototype.start = function(l) {
                        this.error || (this.options.onStartCallback && this.options.onStartCallback(), l && (this.options.onCompleteCallback = l), this.duration > 0 ? (this.determineDirectionAndSmartEasing(), this.paused = !1, this.rAF = requestAnimationFrame(this.count)) : this.printValue(this.endVal))
                    }, i.prototype.pauseResume = function() {
                        this.paused ? (this.startTime = null, this.duration = this.remaining, this.startVal = this.frameVal, this.determineDirectionAndSmartEasing(), this.rAF = requestAnimationFrame(this.count)) : cancelAnimationFrame(this.rAF), this.paused = !this.paused
                    }, i.prototype.reset = function() {
                        cancelAnimationFrame(this.rAF), this.paused = !0, this.resetDuration(), this.startVal = this.validateValue(this.options.startVal), this.frameVal = this.startVal, this.printValue(this.startVal)
                    }, i.prototype.update = function(l) {
                        cancelAnimationFrame(this.rAF), this.startTime = null, this.endVal = this.validateValue(l), this.endVal !== this.frameVal && (this.startVal = this.frameVal, null == this.finalEndVal && this.resetDuration(), this.finalEndVal = null, this.determineDirectionAndSmartEasing(), this.rAF = requestAnimationFrame(this.count))
                    }, i.prototype.printValue = function(l) {
                        var c;
                        if (this.el) {
                            var p = this.formattingFn(l);
                            (null === (c = this.options.plugin) || void 0 === c ? void 0 : c.render) ? this.options.plugin.render(this.el, p): "INPUT" === this.el.tagName ? this.el.value = p : "text" === this.el.tagName || "tspan" === this.el.tagName ? this.el.textContent = p : this.el.innerHTML = p
                        }
                    }, i.prototype.ensureNumber = function(l) {
                        return "number" == typeof l && !isNaN(l)
                    }, i.prototype.validateValue = function(l) {
                        var c = Number(l);
                        return this.ensureNumber(c) ? c : (this.error = "[CountUp] invalid start or end value: ".concat(l), null)
                    }, i.prototype.resetDuration = function() {
                        this.startTime = null, this.duration = 1e3 * Number(this.options.duration), this.remaining = this.duration
                    }, i
                }()
        },
        6862: function(l, c) {
            var p = "undefined" != typeof self ? self : this,
                v = function() {
                    function F() {
                        this.fetch = !1, this.DOMException = p.DOMException
                    }
                    return F.prototype = p, new F
                }();
            (function(l) {
                var c = {
                    searchParams: "URLSearchParams" in v,
                    iterable: "Symbol" in v && "iterator" in Symbol,
                    blob: "FileReader" in v && "Blob" in v && function() {
                        try {
                            return new Blob, !0
                        } catch (l) {
                            return !1
                        }
                    }(),
                    formData: "FormData" in v,
                    arrayBuffer: "ArrayBuffer" in v
                };
                if (c.arrayBuffer) var p = ["[object Int8Array]", "[object Uint8Array]", "[object Uint8ClampedArray]", "[object Int16Array]", "[object Uint16Array]", "[object Int32Array]", "[object Uint32Array]", "[object Float32Array]", "[object Float64Array]"],
                    _ = ArrayBuffer.isView || function(l) {
                        return l && p.indexOf(Object.prototype.toString.call(l)) > -1
                    };

                function normalizeName(l) {
                    if ("string" != typeof l && (l = String(l)), /[^a-z0-9\-#$%&'*+.^_`|~]/i.test(l)) throw TypeError("Invalid character in header field name");
                    return l.toLowerCase()
                }

                function normalizeValue(l) {
                    return "string" != typeof l && (l = String(l)), l
                }

                function iteratorFor(l) {
                    var p = {
                        next: function() {
                            var c = l.shift();
                            return {
                                done: void 0 === c,
                                value: c
                            }
                        }
                    };
                    return c.iterable && (p[Symbol.iterator] = function() {
                        return p
                    }), p
                }

                function Headers(l) {
                    this.map = {}, l instanceof Headers ? l.forEach(function(l, c) {
                        this.append(c, l)
                    }, this) : Array.isArray(l) ? l.forEach(function(l) {
                        this.append(l[0], l[1])
                    }, this) : l && Object.getOwnPropertyNames(l).forEach(function(c) {
                        this.append(c, l[c])
                    }, this)
                }

                function consumed(l) {
                    if (l.bodyUsed) return Promise.reject(TypeError("Already read"));
                    l.bodyUsed = !0
                }

                function fileReaderReady(l) {
                    return new Promise(function(c, p) {
                        l.onload = function() {
                            c(l.result)
                        }, l.onerror = function() {
                            p(l.error)
                        }
                    })
                }

                function readBlobAsArrayBuffer(l) {
                    var c = new FileReader,
                        p = fileReaderReady(c);
                    return c.readAsArrayBuffer(l), p
                }

                function bufferClone(l) {
                    if (l.slice) return l.slice(0);
                    var c = new Uint8Array(l.byteLength);
                    return c.set(new Uint8Array(l)), c.buffer
                }

                function Body() {
                    return this.bodyUsed = !1, this._initBody = function(l) {
                        if (this._bodyInit = l, l) {
                            if ("string" == typeof l) this._bodyText = l;
                            else if (c.blob && Blob.prototype.isPrototypeOf(l)) this._bodyBlob = l;
                            else if (c.formData && FormData.prototype.isPrototypeOf(l)) this._bodyFormData = l;
                            else if (c.searchParams && URLSearchParams.prototype.isPrototypeOf(l)) this._bodyText = l.toString();
                            else {
                                var p;
                                c.arrayBuffer && c.blob && (p = l) && DataView.prototype.isPrototypeOf(p) ? (this._bodyArrayBuffer = bufferClone(l.buffer), this._bodyInit = new Blob([this._bodyArrayBuffer])) : c.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(l) || _(l)) ? this._bodyArrayBuffer = bufferClone(l) : this._bodyText = l = Object.prototype.toString.call(l)
                            }
                        } else this._bodyText = "";
                        !this.headers.get("content-type") && ("string" == typeof l ? this.headers.set("content-type", "text/plain;charset=UTF-8") : this._bodyBlob && this._bodyBlob.type ? this.headers.set("content-type", this._bodyBlob.type) : c.searchParams && URLSearchParams.prototype.isPrototypeOf(l) && this.headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8"))
                    }, c.blob && (this.blob = function() {
                        var l = consumed(this);
                        if (l) return l;
                        if (this._bodyBlob) return Promise.resolve(this._bodyBlob);
                        if (this._bodyArrayBuffer) return Promise.resolve(new Blob([this._bodyArrayBuffer]));
                        if (!this._bodyFormData) return Promise.resolve(new Blob([this._bodyText]));
                        throw Error("could not read FormData body as blob")
                    }, this.arrayBuffer = function() {
                        return this._bodyArrayBuffer ? consumed(this) || Promise.resolve(this._bodyArrayBuffer) : this.blob().then(readBlobAsArrayBuffer)
                    }), this.text = function() {
                        var l, c, p, v = consumed(this);
                        if (v) return v;
                        if (this._bodyBlob) return l = this._bodyBlob, p = fileReaderReady(c = new FileReader), c.readAsText(l), p;
                        if (this._bodyArrayBuffer) return Promise.resolve(function(l) {
                            for (var c = new Uint8Array(l), p = Array(c.length), v = 0; v < c.length; v++) p[v] = String.fromCharCode(c[v]);
                            return p.join("")
                        }(this._bodyArrayBuffer));
                        if (!this._bodyFormData) return Promise.resolve(this._bodyText);
                        throw Error("could not read FormData body as text")
                    }, c.formData && (this.formData = function() {
                        return this.text().then(decode)
                    }), this.json = function() {
                        return this.text().then(JSON.parse)
                    }, this
                }
                Headers.prototype.append = function(l, c) {
                    l = normalizeName(l), c = normalizeValue(c);
                    var p = this.map[l];
                    this.map[l] = p ? p + ", " + c : c
                }, Headers.prototype.delete = function(l) {
                    delete this.map[normalizeName(l)]
                }, Headers.prototype.get = function(l) {
                    return l = normalizeName(l), this.has(l) ? this.map[l] : null
                }, Headers.prototype.has = function(l) {
                    return this.map.hasOwnProperty(normalizeName(l))
                }, Headers.prototype.set = function(l, c) {
                    this.map[normalizeName(l)] = normalizeValue(c)
                }, Headers.prototype.forEach = function(l, c) {
                    for (var p in this.map) this.map.hasOwnProperty(p) && l.call(c, this.map[p], p, this)
                }, Headers.prototype.keys = function() {
                    var l = [];
                    return this.forEach(function(c, p) {
                        l.push(p)
                    }), iteratorFor(l)
                }, Headers.prototype.values = function() {
                    var l = [];
                    return this.forEach(function(c) {
                        l.push(c)
                    }), iteratorFor(l)
                }, Headers.prototype.entries = function() {
                    var l = [];
                    return this.forEach(function(c, p) {
                        l.push([p, c])
                    }), iteratorFor(l)
                }, c.iterable && (Headers.prototype[Symbol.iterator] = Headers.prototype.entries);
                var C = ["DELETE", "GET", "HEAD", "OPTIONS", "POST", "PUT"];

                function Request(l, c) {
                    var p, v, _ = (c = c || {}).body;
                    if (l instanceof Request) {
                        if (l.bodyUsed) throw TypeError("Already read");
                        this.url = l.url, this.credentials = l.credentials, c.headers || (this.headers = new Headers(l.headers)), this.method = l.method, this.mode = l.mode, this.signal = l.signal, _ || null == l._bodyInit || (_ = l._bodyInit, l.bodyUsed = !0)
                    } else this.url = String(l);
                    if (this.credentials = c.credentials || this.credentials || "same-origin", (c.headers || !this.headers) && (this.headers = new Headers(c.headers)), this.method = (v = (p = c.method || this.method || "GET").toUpperCase(), C.indexOf(v) > -1 ? v : p), this.mode = c.mode || this.mode || null, this.signal = c.signal || this.signal, this.referrer = null, ("GET" === this.method || "HEAD" === this.method) && _) throw TypeError("Body not allowed for GET or HEAD requests");
                    this._initBody(_)
                }

                function decode(l) {
                    var c = new FormData;
                    return l.trim().split("&").forEach(function(l) {
                        if (l) {
                            var p = l.split("="),
                                v = p.shift().replace(/\+/g, " "),
                                _ = p.join("=").replace(/\+/g, " ");
                            c.append(decodeURIComponent(v), decodeURIComponent(_))
                        }
                    }), c
                }

                function Response(l, c) {
                    c || (c = {}), this.type = "default", this.status = void 0 === c.status ? 200 : c.status, this.ok = this.status >= 200 && this.status < 300, this.statusText = "statusText" in c ? c.statusText : "OK", this.headers = new Headers(c.headers), this.url = c.url || "", this._initBody(l)
                }
                Request.prototype.clone = function() {
                    return new Request(this, {
                        body: this._bodyInit
                    })
                }, Body.call(Request.prototype), Body.call(Response.prototype), Response.prototype.clone = function() {
                    return new Response(this._bodyInit, {
                        status: this.status,
                        statusText: this.statusText,
                        headers: new Headers(this.headers),
                        url: this.url
                    })
                }, Response.error = function() {
                    var l = new Response(null, {
                        status: 0,
                        statusText: ""
                    });
                    return l.type = "error", l
                };
                var P = [301, 302, 303, 307, 308];
                Response.redirect = function(l, c) {
                    if (-1 === P.indexOf(c)) throw RangeError("Invalid status code");
                    return new Response(null, {
                        status: c,
                        headers: {
                            location: l
                        }
                    })
                }, l.DOMException = v.DOMException;
                try {
                    new l.DOMException
                } catch (c) {
                    l.DOMException = function(l, c) {
                        this.message = l, this.name = c;
                        var p = Error(l);
                        this.stack = p.stack
                    }, l.DOMException.prototype = Object.create(Error.prototype), l.DOMException.prototype.constructor = l.DOMException
                }

                function fetch(p, v) {
                    return new Promise(function(_, C) {
                        var P = new Request(p, v);
                        if (P.signal && P.signal.aborted) return C(new l.DOMException("Aborted", "AbortError"));
                        var T = new XMLHttpRequest;

                        function abortXhr() {
                            T.abort()
                        }
                        T.onload = function() {
                            var l, c, p = {
                                status: T.status,
                                statusText: T.statusText,
                                headers: (l = T.getAllResponseHeaders() || "", c = new Headers, l.replace(/\r?\n[\t ]+/g, " ").split(/\r?\n/).forEach(function(l) {
                                    var p = l.split(":"),
                                        v = p.shift().trim();
                                    if (v) {
                                        var _ = p.join(":").trim();
                                        c.append(v, _)
                                    }
                                }), c)
                            };
                            p.url = "responseURL" in T ? T.responseURL : p.headers.get("X-Request-URL");
                            var v = "response" in T ? T.response : T.responseText;
                            _(new Response(v, p))
                        }, T.onerror = function() {
                            C(TypeError("Network request failed"))
                        }, T.ontimeout = function() {
                            C(TypeError("Network request failed"))
                        }, T.onabort = function() {
                            C(new l.DOMException("Aborted", "AbortError"))
                        }, T.open(P.method, P.url, !0), "include" === P.credentials ? T.withCredentials = !0 : "omit" === P.credentials && (T.withCredentials = !1), "responseType" in T && c.blob && (T.responseType = "blob"), P.headers.forEach(function(l, c) {
                            T.setRequestHeader(c, l)
                        }), P.signal && (P.signal.addEventListener("abort", abortXhr), T.onreadystatechange = function() {
                            4 === T.readyState && P.signal.removeEventListener("abort", abortXhr)
                        }), T.send(void 0 === P._bodyInit ? null : P._bodyInit)
                    })
                }
                fetch.polyfill = !0, v.fetch || (v.fetch = fetch, v.Headers = Headers, v.Request = Request, v.Response = Response), l.Headers = Headers, l.Request = Request, l.Response = Response, l.fetch = fetch, Object.defineProperty(l, "__esModule", {
                    value: !0
                })
            })({}), v.fetch.ponyfill = !0, delete v.fetch.polyfill, (c = v.fetch).default = v.fetch, c.fetch = v.fetch, c.Headers = v.Headers, c.Request = v.Request, c.Response = v.Response, l.exports = c
        },
        1454: function(l) {
            "use strict";
            var c = "%[a-f0-9]{2}",
                p = RegExp("(" + c + ")|([^%]+?)", "gi"),
                v = RegExp("(" + c + ")+", "gi");
            l.exports = function(l) {
                if ("string" != typeof l) throw TypeError("Expected `encodedURI` to be of type `string`, got `" + typeof l + "`");
                try {
                    return l = l.replace(/\+/g, " "), decodeURIComponent(l)
                } catch (c) {
                    return function(l) {
                        for (var c = {
                                "%FE%FF": "��",
                                "%FF%FE": "��"
                            }, _ = v.exec(l); _;) {
                            try {
                                c[_[0]] = decodeURIComponent(_[0])
                            } catch (l) {
                                var C = function(l) {
                                    try {
                                        return decodeURIComponent(l)
                                    } catch (_) {
                                        for (var c = l.match(p) || [], v = 1; v < c.length; v++) c = (l = (function decodeComponents(l, c) {
                                            try {
                                                return [decodeURIComponent(l.join(""))]
                                            } catch (l) {}
                                            if (1 === l.length) return l;
                                            c = c || 1;
                                            var p = l.slice(0, c),
                                                v = l.slice(c);
                                            return Array.prototype.concat.call([], decodeComponents(p), decodeComponents(v))
                                        })(c, v).join("")).match(p) || [];
                                        return l
                                    }
                                }(_[0]);
                                C !== _[0] && (c[_[0]] = C)
                            }
                            _ = v.exec(l)
                        }
                        c["%C2"] = "�";
                        for (var P = Object.keys(c), T = 0; T < P.length; T++) {
                            var M = P[T];
                            l = l.replace(RegExp(M, "g"), c[M])
                        }
                        return l
                    }(l)
                }
            }
        },
        9944: function(l) {
            "use strict";
            var c, p = "object" == typeof Reflect ? Reflect : null,
                v = p && "function" == typeof p.apply ? p.apply : function(l, c, p) {
                    return Function.prototype.apply.call(l, c, p)
                };
            c = p && "function" == typeof p.ownKeys ? p.ownKeys : Object.getOwnPropertySymbols ? function(l) {
                return Object.getOwnPropertyNames(l).concat(Object.getOwnPropertySymbols(l))
            } : function(l) {
                return Object.getOwnPropertyNames(l)
            };
            var _ = Number.isNaN || function(l) {
                return l != l
            };

            function EventEmitter() {
                EventEmitter.init.call(this)
            }
            l.exports = EventEmitter, l.exports.once = function(l, c) {
                return new Promise(function(p, v) {
                    function errorListener(p) {
                        l.removeListener(c, resolver), v(p)
                    }

                    function resolver() {
                        "function" == typeof l.removeListener && l.removeListener("error", errorListener), p([].slice.call(arguments))
                    }
                    eventTargetAgnosticAddListener(l, c, resolver, {
                        once: !0
                    }), "error" !== c && "function" == typeof l.on && eventTargetAgnosticAddListener(l, "error", errorListener, {
                        once: !0
                    })
                })
            }, EventEmitter.EventEmitter = EventEmitter, EventEmitter.prototype._events = void 0, EventEmitter.prototype._eventsCount = 0, EventEmitter.prototype._maxListeners = void 0;
            var C = 10;

            function checkListener(l) {
                if ("function" != typeof l) throw TypeError('The "listener" argument must be of type Function. Received type ' + typeof l)
            }

            function _getMaxListeners(l) {
                return void 0 === l._maxListeners ? EventEmitter.defaultMaxListeners : l._maxListeners
            }

            function _addListener(l, c, p, v) {
                if (checkListener(p), void 0 === (C = l._events) ? (C = l._events = Object.create(null), l._eventsCount = 0) : (void 0 !== C.newListener && (l.emit("newListener", c, p.listener ? p.listener : p), C = l._events), P = C[c]), void 0 === P) P = C[c] = p, ++l._eventsCount;
                else if ("function" == typeof P ? P = C[c] = v ? [p, P] : [P, p] : v ? P.unshift(p) : P.push(p), (_ = _getMaxListeners(l)) > 0 && P.length > _ && !P.warned) {
                    P.warned = !0;
                    var _, C, P, T = Error("Possible EventEmitter memory leak detected. " + P.length + " " + String(c) + " listeners added. Use emitter.setMaxListeners() to increase limit");
                    T.name = "MaxListenersExceededWarning", T.emitter = l, T.type = c, T.count = P.length, console && console.warn && console.warn(T)
                }
                return l
            }

            function onceWrapper() {
                if (!this.fired) return (this.target.removeListener(this.type, this.wrapFn), this.fired = !0, 0 == arguments.length) ? this.listener.call(this.target) : this.listener.apply(this.target, arguments)
            }

            function _onceWrap(l, c, p) {
                var v = {
                        fired: !1,
                        wrapFn: void 0,
                        target: l,
                        type: c,
                        listener: p
                    },
                    _ = onceWrapper.bind(v);
                return _.listener = p, v.wrapFn = _, _
            }

            function _listeners(l, c, p) {
                var v = l._events;
                if (void 0 === v) return [];
                var _ = v[c];
                return void 0 === _ ? [] : "function" == typeof _ ? p ? [_.listener || _] : [_] : p ? function(l) {
                    for (var c = Array(l.length), p = 0; p < c.length; ++p) c[p] = l[p].listener || l[p];
                    return c
                }(_) : arrayClone(_, _.length)
            }

            function listenerCount(l) {
                var c = this._events;
                if (void 0 !== c) {
                    var p = c[l];
                    if ("function" == typeof p) return 1;
                    if (void 0 !== p) return p.length
                }
                return 0
            }

            function arrayClone(l, c) {
                for (var p = Array(c), v = 0; v < c; ++v) p[v] = l[v];
                return p
            }

            function eventTargetAgnosticAddListener(l, c, p, v) {
                if ("function" == typeof l.on) v.once ? l.once(c, p) : l.on(c, p);
                else if ("function" == typeof l.addEventListener) l.addEventListener(c, function wrapListener(_) {
                    v.once && l.removeEventListener(c, wrapListener), p(_)
                });
                else throw TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof l)
            }
            Object.defineProperty(EventEmitter, "defaultMaxListeners", {
                enumerable: !0,
                get: function() {
                    return C
                },
                set: function(l) {
                    if ("number" != typeof l || l < 0 || _(l)) throw RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + l + ".");
                    C = l
                }
            }), EventEmitter.init = function() {
                (void 0 === this._events || this._events === Object.getPrototypeOf(this)._events) && (this._events = Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0
            }, EventEmitter.prototype.setMaxListeners = function(l) {
                if ("number" != typeof l || l < 0 || _(l)) throw RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + l + ".");
                return this._maxListeners = l, this
            }, EventEmitter.prototype.getMaxListeners = function() {
                return _getMaxListeners(this)
            }, EventEmitter.prototype.emit = function(l) {
                for (var c = [], p = 1; p < arguments.length; p++) c.push(arguments[p]);
                var _ = "error" === l,
                    C = this._events;
                if (void 0 !== C) _ = _ && void 0 === C.error;
                else if (!_) return !1;
                if (_) {
                    if (c.length > 0 && (P = c[0]), P instanceof Error) throw P;
                    var P, T = Error("Unhandled error." + (P ? " (" + P.message + ")" : ""));
                    throw T.context = P, T
                }
                var M = C[l];
                if (void 0 === M) return !1;
                if ("function" == typeof M) v(M, this, c);
                else
                    for (var z = M.length, J = arrayClone(M, z), p = 0; p < z; ++p) v(J[p], this, c);
                return !0
            }, EventEmitter.prototype.addListener = function(l, c) {
                return _addListener(this, l, c, !1)
            }, EventEmitter.prototype.on = EventEmitter.prototype.addListener, EventEmitter.prototype.prependListener = function(l, c) {
                return _addListener(this, l, c, !0)
            }, EventEmitter.prototype.once = function(l, c) {
                return checkListener(c), this.on(l, _onceWrap(this, l, c)), this
            }, EventEmitter.prototype.prependOnceListener = function(l, c) {
                return checkListener(c), this.prependListener(l, _onceWrap(this, l, c)), this
            }, EventEmitter.prototype.removeListener = function(l, c) {
                var p, v, _, C, P;
                if (checkListener(c), void 0 === (v = this._events) || void 0 === (p = v[l])) return this;
                if (p === c || p.listener === c) 0 == --this._eventsCount ? this._events = Object.create(null) : (delete v[l], v.removeListener && this.emit("removeListener", l, p.listener || c));
                else if ("function" != typeof p) {
                    for (_ = -1, C = p.length - 1; C >= 0; C--)
                        if (p[C] === c || p[C].listener === c) {
                            P = p[C].listener, _ = C;
                            break
                        }
                    if (_ < 0) return this;
                    0 === _ ? p.shift() : function(l, c) {
                        for (; c + 1 < l.length; c++) l[c] = l[c + 1];
                        l.pop()
                    }(p, _), 1 === p.length && (v[l] = p[0]), void 0 !== v.removeListener && this.emit("removeListener", l, P || c)
                }
                return this
            }, EventEmitter.prototype.off = EventEmitter.prototype.removeListener, EventEmitter.prototype.removeAllListeners = function(l) {
                var c, p, v;
                if (void 0 === (p = this._events)) return this;
                if (void 0 === p.removeListener) return 0 == arguments.length ? (this._events = Object.create(null), this._eventsCount = 0) : void 0 !== p[l] && (0 == --this._eventsCount ? this._events = Object.create(null) : delete p[l]), this;
                if (0 == arguments.length) {
                    var _, C = Object.keys(p);
                    for (v = 0; v < C.length; ++v) "removeListener" !== (_ = C[v]) && this.removeAllListeners(_);
                    return this.removeAllListeners("removeListener"), this._events = Object.create(null), this._eventsCount = 0, this
                }
                if ("function" == typeof(c = p[l])) this.removeListener(l, c);
                else if (void 0 !== c)
                    for (v = c.length - 1; v >= 0; v--) this.removeListener(l, c[v]);
                return this
            }, EventEmitter.prototype.listeners = function(l) {
                return _listeners(this, l, !0)
            }, EventEmitter.prototype.rawListeners = function(l) {
                return _listeners(this, l, !1)
            }, EventEmitter.listenerCount = function(l, c) {
                return "function" == typeof l.listenerCount ? l.listenerCount(c) : listenerCount.call(l, c)
            }, EventEmitter.prototype.listenerCount = listenerCount, EventEmitter.prototype.eventNames = function() {
                return this._eventsCount > 0 ? c(this._events) : []
            }
        },
        5479: function(l) {
            "use strict";
            l.exports = function(l, c) {
                for (var p = {}, v = Object.keys(l), _ = Array.isArray(c), C = 0; C < v.length; C++) {
                    var P = v[C],
                        T = l[P];
                    (_ ? -1 !== c.indexOf(P) : c(P, T, l)) && (p[P] = T)
                }
                return p
            }
        },
        9736: function(l, c, p) {
            l = p.nmd(l);
            var v, _, C, P = "__lodash_hash_undefined__",
                T = "[object Arguments]",
                M = "[object Array]",
                z = "[object Boolean]",
                J = "[object Date]",
                Q = "[object Error]",
                X = "[object Function]",
                es = "[object Map]",
                eo = "[object Number]",
                el = "[object Object]",
                ec = "[object Promise]",
                eh = "[object RegExp]",
                ed = "[object Set]",
                ef = "[object String]",
                ep = "[object WeakMap]",
                eg = "[object ArrayBuffer]",
                em = "[object DataView]",
                ey = /^\[object .+?Constructor\]$/,
                eb = /^(?:0|[1-9]\d*)$/,
                ew = {};
            ew["[object Float32Array]"] = ew["[object Float64Array]"] = ew["[object Int8Array]"] = ew["[object Int16Array]"] = ew["[object Int32Array]"] = ew["[object Uint8Array]"] = ew["[object Uint8ClampedArray]"] = ew["[object Uint16Array]"] = ew["[object Uint32Array]"] = !0, ew[T] = ew[M] = ew[eg] = ew[z] = ew[em] = ew[J] = ew[Q] = ew[X] = ew[es] = ew[eo] = ew[el] = ew[eh] = ew[ed] = ew[ef] = ew[ep] = !1;
            var ex = "object" == typeof p.g && p.g && p.g.Object === Object && p.g,
                e_ = "object" == typeof self && self && self.Object === Object && self,
                eE = ex || e_ || Function("return this")(),
                eA = c && !c.nodeType && c,
                eC = eA && l && !l.nodeType && l,
                eS = eC && eC.exports === eA,
                eN = eS && ex.process,
                eP = function() {
                    try {
                        return eN && eN.binding && eN.binding("util")
                    } catch (l) {}
                }(),
                eD = eP && eP.isTypedArray;

            function mapToArray(l) {
                var c = -1,
                    p = Array(l.size);
                return l.forEach(function(l, v) {
                    p[++c] = [v, l]
                }), p
            }

            function setToArray(l) {
                var c = -1,
                    p = Array(l.size);
                return l.forEach(function(l) {
                    p[++c] = l
                }), p
            }
            var ek = Array.prototype,
                eI = Function.prototype,
                eO = Object.prototype,
                ej = eE["__core-js_shared__"],
                eT = eI.toString,
                eR = eO.hasOwnProperty,
                eL = (v = /[^.]+$/.exec(ej && ej.keys && ej.keys.IE_PROTO || "")) ? "Symbol(src)_1." + v : "",
                eM = eO.toString,
                eU = RegExp("^" + eT.call(eR).replace(/[\\^$.*+?()[\]{}|]/g, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"),
                eB = eS ? eE.Buffer : void 0,
                eF = eE.Symbol,
                eH = eE.Uint8Array,
                eV = eO.propertyIsEnumerable,
                ez = ek.splice,
                eW = eF ? eF.toStringTag : void 0,
                eG = Object.getOwnPropertySymbols,
                eK = eB ? eB.isBuffer : void 0,
                eZ = (_ = Object.keys, C = Object, function(l) {
                    return _(C(l))
                }),
                eJ = getNative(eE, "DataView"),
                eQ = getNative(eE, "Map"),
                e$ = getNative(eE, "Promise"),
                eY = getNative(eE, "Set"),
                eX = getNative(eE, "WeakMap"),
                e0 = getNative(Object, "create"),
                e1 = toSource(eJ),
                e2 = toSource(eQ),
                e5 = toSource(e$),
                e3 = toSource(eY),
                e6 = toSource(eX),
                e4 = eF ? eF.prototype : void 0,
                e8 = e4 ? e4.valueOf : void 0;

            function Hash(l) {
                var c = -1,
                    p = null == l ? 0 : l.length;
                for (this.clear(); ++c < p;) {
                    var v = l[c];
                    this.set(v[0], v[1])
                }
            }

            function ListCache(l) {
                var c = -1,
                    p = null == l ? 0 : l.length;
                for (this.clear(); ++c < p;) {
                    var v = l[c];
                    this.set(v[0], v[1])
                }
            }

            function MapCache(l) {
                var c = -1,
                    p = null == l ? 0 : l.length;
                for (this.clear(); ++c < p;) {
                    var v = l[c];
                    this.set(v[0], v[1])
                }
            }

            function SetCache(l) {
                var c = -1,
                    p = null == l ? 0 : l.length;
                for (this.__data__ = new MapCache; ++c < p;) this.add(l[c])
            }

            function Stack(l) {
                var c = this.__data__ = new ListCache(l);
                this.size = c.size
            }

            function assocIndexOf(l, c) {
                for (var p = l.length; p--;)
                    if (eq(l[p][0], c)) return p;
                return -1
            }

            function baseGetTag(l) {
                return null == l ? void 0 === l ? "[object Undefined]" : "[object Null]" : eW && eW in Object(l) ? function(l) {
                    var c = eR.call(l, eW),
                        p = l[eW];
                    try {
                        l[eW] = void 0;
                        var v = !0
                    } catch (l) {}
                    var _ = eM.call(l);
                    return v && (c ? l[eW] = p : delete l[eW]), _
                }(l) : eM.call(l)
            }

            function baseIsArguments(l) {
                return isObjectLike(l) && baseGetTag(l) == T
            }

            function equalArrays(l, c, p, v, _, C) {
                var P = 1 & p,
                    T = l.length,
                    M = c.length;
                if (T != M && !(P && M > T)) return !1;
                var z = C.get(l);
                if (z && C.get(c)) return z == c;
                var J = -1,
                    Q = !0,
                    X = 2 & p ? new SetCache : void 0;
                for (C.set(l, c), C.set(c, l); ++J < T;) {
                    var es = l[J],
                        eo = c[J];
                    if (v) var el = P ? v(eo, es, J, c, l, C) : v(es, eo, J, l, c, C);
                    if (void 0 !== el) {
                        if (el) continue;
                        Q = !1;
                        break
                    }
                    if (X) {
                        if (! function(l, c) {
                                for (var p = -1, v = null == l ? 0 : l.length; ++p < v;)
                                    if (c(l[p], p, l)) return !0;
                                return !1
                            }(c, function(l, c) {
                                if (!X.has(c) && (es === l || _(es, l, p, v, C))) return X.push(c)
                            })) {
                            Q = !1;
                            break
                        }
                    } else if (!(es === eo || _(es, eo, p, v, C))) {
                        Q = !1;
                        break
                    }
                }
                return C.delete(l), C.delete(c), Q
            }

            function getAllKeys(l) {
                var c;
                return c = function(l) {
                    return null != l && isLength(l.length) && !isFunction(l) ? function(l, c) {
                        var p, v = ts(l),
                            _ = !v && tn(l),
                            C = !v && !_ && ta(l),
                            P = !v && !_ && !C && to(l),
                            T = v || _ || C || P,
                            M = T ? function(l, c) {
                                for (var p = -1, v = Array(l); ++p < l;) v[p] = c(p);
                                return v
                            }(l.length, String) : [],
                            z = M.length;
                        for (var J in l) eR.call(l, J) && !(T && ("length" == J || C && ("offset" == J || "parent" == J) || P && ("buffer" == J || "byteLength" == J || "byteOffset" == J) || (p = null == (p = z) ? 9007199254740991 : p) && ("number" == typeof J || eb.test(J)) && J > -1 && J % 1 == 0 && J < p)) && M.push(J);
                        return M
                    }(l) : function(l) {
                        if (c = l && l.constructor, l !== ("function" == typeof c && c.prototype || eO)) return eZ(l);
                        var c, p = [];
                        for (var v in Object(l)) eR.call(l, v) && "constructor" != v && p.push(v);
                        return p
                    }(l)
                }(l), ts(l) ? c : function(l, c) {
                    for (var p = -1, v = c.length, _ = l.length; ++p < v;) l[_ + p] = c[p];
                    return l
                }(c, e9(l))
            }

            function getMapData(l, c) {
                var p, v = l.__data__;
                return ("string" == (p = typeof c) || "number" == p || "symbol" == p || "boolean" == p ? "__proto__" !== c : null === c) ? v["string" == typeof c ? "string" : "hash"] : v.map
            }

            function getNative(l, c) {
                var p = null == l ? void 0 : l[c];
                return !(!isObject(p) || eL && eL in p) && (isFunction(p) ? eU : ey).test(toSource(p)) ? p : void 0
            }
            Hash.prototype.clear = function() {
                this.__data__ = e0 ? e0(null) : {}, this.size = 0
            }, Hash.prototype.delete = function(l) {
                var c = this.has(l) && delete this.__data__[l];
                return this.size -= c ? 1 : 0, c
            }, Hash.prototype.get = function(l) {
                var c = this.__data__;
                if (e0) {
                    var p = c[l];
                    return p === P ? void 0 : p
                }
                return eR.call(c, l) ? c[l] : void 0
            }, Hash.prototype.has = function(l) {
                var c = this.__data__;
                return e0 ? void 0 !== c[l] : eR.call(c, l)
            }, Hash.prototype.set = function(l, c) {
                var p = this.__data__;
                return this.size += this.has(l) ? 0 : 1, p[l] = e0 && void 0 === c ? P : c, this
            }, ListCache.prototype.clear = function() {
                this.__data__ = [], this.size = 0
            }, ListCache.prototype.delete = function(l) {
                var c = this.__data__,
                    p = assocIndexOf(c, l);
                return !(p < 0) && (p == c.length - 1 ? c.pop() : ez.call(c, p, 1), --this.size, !0)
            }, ListCache.prototype.get = function(l) {
                var c = this.__data__,
                    p = assocIndexOf(c, l);
                return p < 0 ? void 0 : c[p][1]
            }, ListCache.prototype.has = function(l) {
                return assocIndexOf(this.__data__, l) > -1
            }, ListCache.prototype.set = function(l, c) {
                var p = this.__data__,
                    v = assocIndexOf(p, l);
                return v < 0 ? (++this.size, p.push([l, c])) : p[v][1] = c, this
            }, MapCache.prototype.clear = function() {
                this.size = 0, this.__data__ = {
                    hash: new Hash,
                    map: new(eQ || ListCache),
                    string: new Hash
                }
            }, MapCache.prototype.delete = function(l) {
                var c = getMapData(this, l).delete(l);
                return this.size -= c ? 1 : 0, c
            }, MapCache.prototype.get = function(l) {
                return getMapData(this, l).get(l)
            }, MapCache.prototype.has = function(l) {
                return getMapData(this, l).has(l)
            }, MapCache.prototype.set = function(l, c) {
                var p = getMapData(this, l),
                    v = p.size;
                return p.set(l, c), this.size += p.size == v ? 0 : 1, this
            }, SetCache.prototype.add = SetCache.prototype.push = function(l) {
                return this.__data__.set(l, P), this
            }, SetCache.prototype.has = function(l) {
                return this.__data__.has(l)
            }, Stack.prototype.clear = function() {
                this.__data__ = new ListCache, this.size = 0
            }, Stack.prototype.delete = function(l) {
                var c = this.__data__,
                    p = c.delete(l);
                return this.size = c.size, p
            }, Stack.prototype.get = function(l) {
                return this.__data__.get(l)
            }, Stack.prototype.has = function(l) {
                return this.__data__.has(l)
            }, Stack.prototype.set = function(l, c) {
                var p = this.__data__;
                if (p instanceof ListCache) {
                    var v = p.__data__;
                    if (!eQ || v.length < 199) return v.push([l, c]), this.size = ++p.size, this;
                    p = this.__data__ = new MapCache(v)
                }
                return p.set(l, c), this.size = p.size, this
            };
            var e9 = eG ? function(l) {
                    return null == l ? [] : function(l, c) {
                        for (var p = -1, v = null == l ? 0 : l.length, _ = 0, C = []; ++p < v;) {
                            var P = l[p];
                            c(P, p, l) && (C[_++] = P)
                        }
                        return C
                    }(eG(l = Object(l)), function(c) {
                        return eV.call(l, c)
                    })
                } : function() {
                    return []
                },
                e7 = baseGetTag;

            function toSource(l) {
                if (null != l) {
                    try {
                        return eT.call(l)
                    } catch (l) {}
                    try {
                        return l + ""
                    } catch (l) {}
                }
                return ""
            }

            function eq(l, c) {
                return l === c || l != l && c != c
            }(eJ && e7(new eJ(new ArrayBuffer(1))) != em || eQ && e7(new eQ) != es || e$ && e7(e$.resolve()) != ec || eY && e7(new eY) != ed || eX && e7(new eX) != ep) && (e7 = function(l) {
                var c = baseGetTag(l),
                    p = c == el ? l.constructor : void 0,
                    v = p ? toSource(p) : "";
                if (v) switch (v) {
                    case e1:
                        return em;
                    case e2:
                        return es;
                    case e5:
                        return ec;
                    case e3:
                        return ed;
                    case e6:
                        return ep
                }
                return c
            });
            var tn = baseIsArguments(function() {
                    return arguments
                }()) ? baseIsArguments : function(l) {
                    return isObjectLike(l) && eR.call(l, "callee") && !eV.call(l, "callee")
                },
                ts = Array.isArray,
                ta = eK || function() {
                    return !1
                };

            function isFunction(l) {
                if (!isObject(l)) return !1;
                var c = baseGetTag(l);
                return c == X || "[object GeneratorFunction]" == c || "[object AsyncFunction]" == c || "[object Proxy]" == c
            }

            function isLength(l) {
                return "number" == typeof l && l > -1 && l % 1 == 0 && l <= 9007199254740991
            }

            function isObject(l) {
                var c = typeof l;
                return null != l && ("object" == c || "function" == c)
            }

            function isObjectLike(l) {
                return null != l && "object" == typeof l
            }
            var to = eD ? function(l) {
                return eD(l)
            } : function(l) {
                return isObjectLike(l) && isLength(l.length) && !!ew[baseGetTag(l)]
            };
            l.exports = function(l, c) {
                return function baseIsEqual(l, c, p, v, _) {
                    return l === c || (null != l && null != c && (isObjectLike(l) || isObjectLike(c)) ? function(l, c, p, v, _, C) {
                        var P = ts(l),
                            X = ts(c),
                            ec = P ? M : e7(l),
                            ep = X ? M : e7(c);
                        ec = ec == T ? el : ec, ep = ep == T ? el : ep;
                        var ey = ec == el,
                            eb = ep == el,
                            ew = ec == ep;
                        if (ew && ta(l)) {
                            if (!ta(c)) return !1;
                            P = !0, ey = !1
                        }
                        if (ew && !ey) return C || (C = new Stack), P || to(l) ? equalArrays(l, c, p, v, _, C) : function(l, c, p, v, _, C, P) {
                            switch (p) {
                                case em:
                                    if (l.byteLength != c.byteLength || l.byteOffset != c.byteOffset) break;
                                    l = l.buffer, c = c.buffer;
                                case eg:
                                    if (l.byteLength != c.byteLength || !C(new eH(l), new eH(c))) break;
                                    return !0;
                                case z:
                                case J:
                                case eo:
                                    return eq(+l, +c);
                                case Q:
                                    return l.name == c.name && l.message == c.message;
                                case eh:
                                case ef:
                                    return l == c + "";
                                case es:
                                    var T = mapToArray;
                                case ed:
                                    var M = 1 & v;
                                    if (T || (T = setToArray), l.size != c.size && !M) break;
                                    var X = P.get(l);
                                    if (X) return X == c;
                                    v |= 2, P.set(l, c);
                                    var el = equalArrays(T(l), T(c), v, _, C, P);
                                    return P.delete(l), el;
                                case "[object Symbol]":
                                    if (e8) return e8.call(l) == e8.call(c)
                            }
                            return !1
                        }(l, c, ec, p, v, _, C);
                        if (!(1 & p)) {
                            var ex = ey && eR.call(l, "__wrapped__"),
                                e_ = eb && eR.call(c, "__wrapped__");
                            if (ex || e_) {
                                var eE = ex ? l.value() : l,
                                    eA = e_ ? c.value() : c;
                                return C || (C = new Stack), _(eE, eA, p, v, C)
                            }
                        }
                        return !!ew && (C || (C = new Stack), function(l, c, p, v, _, C) {
                            var P = 1 & p,
                                T = getAllKeys(l),
                                M = T.length;
                            if (M != getAllKeys(c).length && !P) return !1;
                            for (var z = M; z--;) {
                                var J = T[z];
                                if (!(P ? J in c : eR.call(c, J))) return !1
                            }
                            var Q = C.get(l);
                            if (Q && C.get(c)) return Q == c;
                            var X = !0;
                            C.set(l, c), C.set(c, l);
                            for (var es = P; ++z < M;) {
                                var eo = l[J = T[z]],
                                    el = c[J];
                                if (v) var ec = P ? v(el, eo, J, c, l, C) : v(eo, el, J, l, c, C);
                                if (!(void 0 === ec ? eo === el || _(eo, el, p, v, C) : ec)) {
                                    X = !1;
                                    break
                                }
                                es || (es = "constructor" == J)
                            }
                            if (X && !es) {
                                var eh = l.constructor,
                                    ed = c.constructor;
                                eh != ed && "constructor" in l && "constructor" in c && !("function" == typeof eh && eh instanceof eh && "function" == typeof ed && ed instanceof ed) && (X = !1)
                            }
                            return C.delete(l), C.delete(c), X
                        }(l, c, p, v, _, C))
                    }(l, c, p, v, baseIsEqual, _) : l != l && c != c)
                }(l, c)
            }
        },
        3742: function(l, c, p) {
            "use strict";
            p.d(c, {
                Y: function() {
                    return M
                },
                Z: function() {
                    return I18nProvider
                }
            });
            var v = p(1248),
                _ = p(6497),
                C = p(9120),
                P = p(3008),
                T = p(7833),
                __assign = function() {
                    return (__assign = Object.assign || function(l) {
                        for (var c, p = 1, v = arguments.length; p < v; p++)
                            for (var _ in c = arguments[p]) Object.prototype.hasOwnProperty.call(c, _) && (l[_] = c[_]);
                        return l
                    }).apply(this, arguments)
                },
                M = (0, v.createContext)({
                    ns: {},
                    config: {}
                });

            function I18nProvider(l) {
                var c, p, z = l.lang,
                    J = l.namespaces,
                    Q = l.children,
                    X = l.config,
                    es = (0, T.Z)().lang,
                    eo = (0, _.useRouter)() || {},
                    el = eo.locale,
                    ec = eo.defaultLocale,
                    eh = (0, v.useContext)(M),
                    ed = __assign(__assign(__assign({}, "undefined" == typeof window ? {} : (null === (p = null === (c = window.__NEXT_DATA__) || void 0 === c ? void 0 : c.props) || void 0 === p ? void 0 : p.__namespaces) || {}), eh.ns), void 0 === J ? {} : J),
                    ef = z || es || el || ec || "",
                    ep = __assign(__assign({}, eh.config), void 0 === X ? {} : X),
                    eg = (ep.localesToIgnore || ["default"]).includes(ef),
                    em = new Intl.PluralRules(eg ? void 0 : ef),
                    ey = (0, P.Z)({
                        config: ep,
                        allNamespaces: ed,
                        pluralRules: em,
                        lang: ef
                    });
                return v.createElement(C.Z.Provider, {
                    value: {
                        lang: ef,
                        t: ey
                    }
                }, v.createElement(M.Provider, {
                    value: {
                        ns: ed,
                        config: ep
                    }
                }, Q))
            }
        },
        8851: function(l, c, p) {
            "use strict";
            p.d(c, {
                Z: function() {
                    return Trans
                }
            });
            var v = p(1248),
                _ = p(7833),
                C = /<(\w+) *>(.*?)<\/\1 *>|<(\w+) *\/>/,
                P = /(?:\r\n|\r|\n)/g;

            function Trans(l) {
                var c = l.i18nKey,
                    p = l.values,
                    T = l.components,
                    M = l.fallback,
                    z = l.defaultTrans,
                    J = l.ns,
                    Q = (0, _.Z)(J),
                    X = Q.t,
                    es = Q.lang;
                return (0, v.useMemo)(function() {
                    var l = X(c, p, {
                        fallback: M,
                        default: z
                    });
                    return l && T && 0 !== T.length ? function formatElements(l, c) {
                        void 0 === c && (c = []);
                        var p = l.replace(P, "").split(C);
                        if (1 === p.length) return l;
                        var _ = [],
                            T = p.shift();
                        return T && _.push(T), (function getElements(l) {
                            if (!l.length) return [];
                            var c = l.slice(0, 4),
                                p = c[0],
                                v = c[1],
                                _ = c[2];
                            return [
                                [p || _, v || "", c[3]]
                            ].concat(getElements(l.slice(4, l.length)))
                        })(p).forEach(function(l, p) {
                            var C = l[0],
                                P = l[1],
                                T = l[2],
                                M = c[C] || v.createElement(v.Fragment, null);
                            _.push((0, v.cloneElement)(M, {
                                key: p
                            }, P ? formatElements(P, c) : M.props.children)), T && _.push(T)
                        }), _
                    }(l, T) : l
                }, [c, p, T, es])
            }
        },
        9120: function(l, c, p) {
            "use strict";
            var v, _ = p(1248);
            "function" == typeof _.createContext && (v = (0, _.createContext)({
                t: function(l) {
                    return Array.isArray(l) ? l[0] : l
                },
                lang: ""
            })), c.Z = v
        },
        3008: function(l, c, p) {
            "use strict";
            p.d(c, {
                Z: function() {
                    return transCore
                }
            });
            var __assign = function() {
                return (__assign = Object.assign || function(l) {
                    for (var c, p = 1, v = arguments.length; p < v; p++)
                        for (var _ in c = arguments[p]) Object.prototype.hasOwnProperty.call(c, _) && (l[_] = c[_]);
                    return l
                }).apply(this, arguments)
            };

            function transCore(l) {
                var c = l.config,
                    p = l.allNamespaces,
                    v = l.pluralRules,
                    _ = l.lang,
                    C = c.logger,
                    P = void 0 === C ? missingKeyLogger : C,
                    T = c.allowEmptyStrings,
                    M = void 0 === T || T,
                    interpolateUnknown = function(l, p) {
                        return Array.isArray(l) ? l.map(function(l) {
                            return interpolateUnknown(l, p)
                        }) : l instanceof Object ? function objectInterpolation(l) {
                            var c = l.obj,
                                p = l.query,
                                v = l.config,
                                _ = l.lang;
                            return p && 0 !== Object.keys(p).length && Object.keys(c).forEach(function(l) {
                                c[l] instanceof Object && objectInterpolation({
                                    obj: c[l],
                                    query: p,
                                    config: v,
                                    lang: _
                                }), "string" == typeof c[l] && (c[l] = interpolation({
                                    text: c[l],
                                    query: p,
                                    config: v,
                                    lang: _
                                }))
                            }), c
                        }({
                            obj: l,
                            query: p,
                            config: c,
                            lang: _
                        }) : interpolation({
                            text: l,
                            query: p,
                            config: c,
                            lang: _
                        })
                    },
                    t = function(l, _, C) {
                        void 0 === l && (l = "");
                        var T, z = Array.isArray(l) ? l[0] : l,
                            J = c.nsSeparator,
                            Q = c.loggerEnvironment,
                            X = void 0 === Q ? "browser" : Q,
                            es = function(l, c) {
                                if (!c) return {
                                    i18nKey: l
                                };
                                var p = l.indexOf(c);
                                return p < 0 ? {
                                    i18nKey: l
                                } : {
                                    namespace: l.slice(0, p),
                                    i18nKey: l.slice(p + c.length)
                                }
                            }(z, void 0 === J ? ":" : J),
                            eo = es.i18nKey,
                            el = es.namespace,
                            ec = void 0 === el ? null !== (T = null == C ? void 0 : C.ns) && void 0 !== T ? T : c.defaultNS : el,
                            eh = ec && p[ec] || {},
                            ed = function(l, c, p, v, _) {
                                if (!_ || "number" != typeof _.count) return p;
                                var C = "".concat(p, "_").concat(_.count);
                                if (void 0 !== getDicValue(c, C, v)) return C;
                                var P = "".concat(p, "_").concat(l.select(_.count));
                                if (void 0 !== getDicValue(c, P, v)) return P;
                                var T = "".concat(p, ".").concat(_.count);
                                if (void 0 !== getDicValue(c, T, v)) return T;
                                var M = "".concat(p, ".").concat(l.select(_.count));
                                return void 0 !== getDicValue(c, M, v) ? M : p
                            }(v, eh, eo, c, _),
                            ef = getDicValue(eh, ed, c, C),
                            ep = "object" == typeof ef ? JSON.parse(JSON.stringify(ef)) : ef,
                            eg = void 0 === ep || "object" == typeof ep && !Object.keys(ep).length || "" === ep && !M,
                            em = "string" == typeof(null == C ? void 0 : C.fallback) ? [C.fallback] : (null == C ? void 0 : C.fallback) || [];
                        if (eg && ("both" === X || X === ("undefined" == typeof window ? "node" : "browser")) && P({
                                namespace: ec,
                                i18nKey: eo
                            }), eg && Array.isArray(em) && em.length) {
                            var ey = em[0],
                                eb = em.slice(1);
                            if ("string" == typeof ey) return t(ey, _, __assign(__assign({}, C), {
                                fallback: eb
                            }))
                        }
                        return eg && C && C.hasOwnProperty("default") && !(null == em ? void 0 : em.length) ? C.default ? interpolateUnknown(C.default, _) : C.default : eg ? z : interpolateUnknown(ep, _)
                    };
                return t
            }

            function getDicValue(l, c, p, v) {
                void 0 === c && (c = ""), void 0 === v && (v = {
                    returnObjects: !1
                });
                var _ = (p || {}).keySeparator,
                    C = void 0 === _ ? "." : _,
                    P = C ? c.split(C) : [c];
                if (c === C && v.returnObjects) return l;
                var T = P.reduce(function(l, c) {
                    if ("string" == typeof l) return {};
                    var p = l[c];
                    return p || ("string" == typeof p ? p : {})
                }, l);
                if ("string" == typeof T || T instanceof Object && v.returnObjects) return T
            }

            function interpolation(l) {
                var c = l.text,
                    p = l.query,
                    v = l.config,
                    _ = l.lang;
                if (!c || !p) return c || "";
                var escapeRegex = function(l) {
                        return l.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&")
                    },
                    C = v.interpolation || {},
                    P = C.format,
                    T = void 0 === P ? null : P,
                    M = C.prefix,
                    z = void 0 === M ? "{{" : M,
                    J = C.suffix,
                    Q = void 0 === J ? "}}" : J,
                    X = "" === Q ? "" : "(?:[\\s,]+([\\w-]*))?\\s*".concat(escapeRegex(Q));
                return Object.keys(p).reduce(function(l, c) {
                    var v = RegExp("".concat(escapeRegex(z), "\\s*").concat(c).concat(X), "gm");
                    return l.replace(v, function(l, v) {
                        return v && T ? T(p[c], v, _) : p[c]
                    })
                }, c)
            }

            function missingKeyLogger(l) {
                l.namespace, l.i18nKey
            }
        },
        7833: function(l, c, p) {
            "use strict";
            p.d(c, {
                Z: function() {
                    return useTranslation
                }
            });
            var v = p(1248),
                __assign = function() {
                    return (__assign = Object.assign || function(l) {
                        for (var c, p = 1, v = arguments.length; p < v; p++)
                            for (var _ in c = arguments[p]) Object.prototype.hasOwnProperty.call(c, _) && (l[_] = c[_]);
                        return l
                    }).apply(this, arguments)
                };

            function wrapTWithDefaultNs(l, c) {
                return "string" != typeof c ? l : function(p, v, _) {
                    return l(p, v, __assign({
                        ns: c
                    }, _))
                }
            }
            var _ = p(9120),
                C = p(3008),
                useTranslation_assign = function() {
                    return (useTranslation_assign = Object.assign || function(l) {
                        for (var c, p = 1, v = arguments.length; p < v; p++)
                            for (var _ in c = arguments[p]) Object.prototype.hasOwnProperty.call(c, _) && (l[_] = c[_]);
                        return l
                    }).apply(this, arguments)
                };

            function useTranslation(l) {
                var c = globalThis.__NEXT_TRANSLATE__;
                return ((null == c ? void 0 : c.config) ? function(l) {
                    var c, p = null !== (c = globalThis.__NEXT_TRANSLATE__) && void 0 !== c ? c : {},
                        v = p.lang,
                        _ = p.namespaces,
                        P = p.config,
                        T = (P.localesToIgnore || ["default"]).includes(v);
                    return {
                        t: wrapTWithDefaultNs((0, C.Z)({
                            config: P,
                            allNamespaces: _,
                            pluralRules: new Intl.PluralRules(T ? void 0 : v),
                            lang: v
                        }), l),
                        lang: v
                    }
                } : function(l) {
                    var c = (0, v.useContext)(_.Z);
                    return (0, v.useMemo)(function() {
                        return useTranslation_assign(useTranslation_assign({}, c), {
                            t: wrapTWithDefaultNs(c.t, l)
                        })
                    }, [c, l])
                })(l)
            }
        },
        1390: function(l, c, p) {
            "use strict";
            var v, _;
            l.exports = (null == (v = p.g.process) ? void 0 : v.env) && "object" == typeof(null == (_ = p.g.process) ? void 0 : _.env) ? p.g.process : p(8587)
        },
        8587: function(l) {
            ! function() {
                var c = {
                        229: function(l) {
                            var c, p, v, _ = l.exports = {};

                            function defaultSetTimout() {
                                throw Error("setTimeout has not been defined")
                            }

                            function defaultClearTimeout() {
                                throw Error("clearTimeout has not been defined")
                            }

                            function runTimeout(l) {
                                if (c === setTimeout) return setTimeout(l, 0);
                                if ((c === defaultSetTimout || !c) && setTimeout) return c = setTimeout, setTimeout(l, 0);
                                try {
                                    return c(l, 0)
                                } catch (p) {
                                    try {
                                        return c.call(null, l, 0)
                                    } catch (p) {
                                        return c.call(this, l, 0)
                                    }
                                }
                            }! function() {
                                try {
                                    c = "function" == typeof setTimeout ? setTimeout : defaultSetTimout
                                } catch (l) {
                                    c = defaultSetTimout
                                }
                                try {
                                    p = "function" == typeof clearTimeout ? clearTimeout : defaultClearTimeout
                                } catch (l) {
                                    p = defaultClearTimeout
                                }
                            }();
                            var C = [],
                                P = !1,
                                T = -1;

                            function cleanUpNextTick() {
                                P && v && (P = !1, v.length ? C = v.concat(C) : T = -1, C.length && drainQueue())
                            }

                            function drainQueue() {
                                if (!P) {
                                    var l = runTimeout(cleanUpNextTick);
                                    P = !0;
                                    for (var c = C.length; c;) {
                                        for (v = C, C = []; ++T < c;) v && v[T].run();
                                        T = -1, c = C.length
                                    }
                                    v = null, P = !1,
                                        function(l) {
                                            if (p === clearTimeout) return clearTimeout(l);
                                            if ((p === defaultClearTimeout || !p) && clearTimeout) return p = clearTimeout, clearTimeout(l);
                                            try {
                                                p(l)
                                            } catch (c) {
                                                try {
                                                    return p.call(null, l)
                                                } catch (c) {
                                                    return p.call(this, l)
                                                }
                                            }
                                        }(l)
                                }
                            }

                            function Item(l, c) {
                                this.fun = l, this.array = c
                            }

                            function noop() {}
                            _.nextTick = function(l) {
                                var c = Array(arguments.length - 1);
                                if (arguments.length > 1)
                                    for (var p = 1; p < arguments.length; p++) c[p - 1] = arguments[p];
                                C.push(new Item(l, c)), 1 !== C.length || P || runTimeout(drainQueue)
                            }, Item.prototype.run = function() {
                                this.fun.apply(null, this.array)
                            }, _.title = "browser", _.browser = !0, _.env = {}, _.argv = [], _.version = "", _.versions = {}, _.on = noop, _.addListener = noop, _.once = noop, _.off = noop, _.removeListener = noop, _.removeAllListeners = noop, _.emit = noop, _.prependListener = noop, _.prependOnceListener = noop, _.listeners = function(l) {
                                return []
                            }, _.binding = function(l) {
                                throw Error("process.binding is not supported")
                            }, _.cwd = function() {
                                return "/"
                            }, _.chdir = function(l) {
                                throw Error("process.chdir is not supported")
                            }, _.umask = function() {
                                return 0
                            }
                        }
                    },
                    p = {};

                function __nccwpck_require__(l) {
                    var v = p[l];
                    if (void 0 !== v) return v.exports;
                    var _ = p[l] = {
                            exports: {}
                        },
                        C = !0;
                    try {
                        c[l](_, _.exports, __nccwpck_require__), C = !1
                    } finally {
                        C && delete p[l]
                    }
                    return _.exports
                }
                __nccwpck_require__.ab = "//";
                var v = __nccwpck_require__(229);
                l.exports = v
            }()
        },
        8821: function(l, c, p) {
            l.exports = p(1142)
        },
        4389: function(l, c, p) {
            l.exports = p(8461)
        },
        8735: function(l, c, p) {
            l.exports = p(7406)
        },
        6497: function(l, c, p) {
            l.exports = p(7013)
        },
        9842: function(l, c, p) {
            "use strict";
            let v = p(2941),
                _ = p(1454),
                C = p(2520),
                P = p(5479),
                isNullOrUndefined = l => null == l,
                T = Symbol("encodeFragmentIdentifier");

            function validateArrayFormatSeparator(l) {
                if ("string" != typeof l || 1 !== l.length) throw TypeError("arrayFormatSeparator must be single character string")
            }

            function encode(l, c) {
                return c.encode ? c.strict ? v(l) : encodeURIComponent(l) : l
            }

            function decode(l, c) {
                return c.decode ? _(l) : l
            }

            function removeHash(l) {
                let c = l.indexOf("#");
                return -1 !== c && (l = l.slice(0, c)), l
            }

            function extract(l) {
                l = removeHash(l);
                let c = l.indexOf("?");
                return -1 === c ? "" : l.slice(c + 1)
            }

            function parseValue(l, c) {
                return c.parseNumbers && !Number.isNaN(Number(l)) && "string" == typeof l && "" !== l.trim() ? l = Number(l) : c.parseBooleans && null !== l && ("true" === l.toLowerCase() || "false" === l.toLowerCase()) && (l = "true" === l.toLowerCase()), l
            }

            function parse(l, c) {
                validateArrayFormatSeparator((c = Object.assign({
                    decode: !0,
                    sort: !0,
                    arrayFormat: "none",
                    arrayFormatSeparator: ",",
                    parseNumbers: !1,
                    parseBooleans: !1
                }, c)).arrayFormatSeparator);
                let p = function(l) {
                        let c;
                        switch (l.arrayFormat) {
                            case "index":
                                return (l, p, v) => {
                                    if (c = /\[(\d*)\]$/.exec(l), l = l.replace(/\[\d*\]$/, ""), !c) {
                                        v[l] = p;
                                        return
                                    }
                                    void 0 === v[l] && (v[l] = {}), v[l][c[1]] = p
                                };
                            case "bracket":
                                return (l, p, v) => {
                                    if (c = /(\[\])$/.exec(l), l = l.replace(/\[\]$/, ""), !c) {
                                        v[l] = p;
                                        return
                                    }
                                    if (void 0 === v[l]) {
                                        v[l] = [p];
                                        return
                                    }
                                    v[l] = [].concat(v[l], p)
                                };
                            case "colon-list-separator":
                                return (l, p, v) => {
                                    if (c = /(:list)$/.exec(l), l = l.replace(/:list$/, ""), !c) {
                                        v[l] = p;
                                        return
                                    }
                                    if (void 0 === v[l]) {
                                        v[l] = [p];
                                        return
                                    }
                                    v[l] = [].concat(v[l], p)
                                };
                            case "comma":
                            case "separator":
                                return (c, p, v) => {
                                    let _ = "string" == typeof p && p.includes(l.arrayFormatSeparator),
                                        C = "string" == typeof p && !_ && decode(p, l).includes(l.arrayFormatSeparator);
                                    p = C ? decode(p, l) : p;
                                    let P = _ || C ? p.split(l.arrayFormatSeparator).map(c => decode(c, l)) : null === p ? p : decode(p, l);
                                    v[c] = P
                                };
                            case "bracket-separator":
                                return (c, p, v) => {
                                    let _ = /(\[\])$/.test(c);
                                    if (c = c.replace(/\[\]$/, ""), !_) {
                                        v[c] = p ? decode(p, l) : p;
                                        return
                                    }
                                    let C = null === p ? [] : p.split(l.arrayFormatSeparator).map(c => decode(c, l));
                                    if (void 0 === v[c]) {
                                        v[c] = C;
                                        return
                                    }
                                    v[c] = [].concat(v[c], C)
                                };
                            default:
                                return (l, c, p) => {
                                    if (void 0 === p[l]) {
                                        p[l] = c;
                                        return
                                    }
                                    p[l] = [].concat(p[l], c)
                                }
                        }
                    }(c),
                    v = Object.create(null);
                if ("string" != typeof l || !(l = l.trim().replace(/^[?#&]/, ""))) return v;
                for (let _ of l.split("&")) {
                    if ("" === _) continue;
                    let [l, P] = C(c.decode ? _.replace(/\+/g, " ") : _, "=");
                    P = void 0 === P ? null : ["comma", "separator", "bracket-separator"].includes(c.arrayFormat) ? P : decode(P, c), p(decode(l, c), P, v)
                }
                for (let l of Object.keys(v)) {
                    let p = v[l];
                    if ("object" == typeof p && null !== p)
                        for (let l of Object.keys(p)) p[l] = parseValue(p[l], c);
                    else v[l] = parseValue(p, c)
                }
                return !1 === c.sort ? v : (!0 === c.sort ? Object.keys(v).sort() : Object.keys(v).sort(c.sort)).reduce((l, c) => {
                    let p = v[c];
                    return p && "object" == typeof p && !Array.isArray(p) ? l[c] = function keysSorter(l) {
                        return Array.isArray(l) ? l.sort() : "object" == typeof l ? keysSorter(Object.keys(l)).sort((l, c) => Number(l) - Number(c)).map(c => l[c]) : l
                    }(p) : l[c] = p, l
                }, Object.create(null))
            }
            c.extract = extract, c.parse = parse, c.stringify = (l, c) => {
                if (!l) return "";
                validateArrayFormatSeparator((c = Object.assign({
                    encode: !0,
                    strict: !0,
                    arrayFormat: "none",
                    arrayFormatSeparator: ","
                }, c)).arrayFormatSeparator);
                let shouldFilter = p => c.skipNull && isNullOrUndefined(l[p]) || c.skipEmptyString && "" === l[p],
                    p = function(l) {
                        switch (l.arrayFormat) {
                            case "index":
                                return c => (p, v) => {
                                    let _ = p.length;
                                    return void 0 === v || l.skipNull && null === v || l.skipEmptyString && "" === v ? p : null === v ? [...p, [encode(c, l), "[", _, "]"].join("")] : [...p, [encode(c, l), "[", encode(_, l), "]=", encode(v, l)].join("")]
                                };
                            case "bracket":
                                return c => (p, v) => void 0 === v || l.skipNull && null === v || l.skipEmptyString && "" === v ? p : null === v ? [...p, [encode(c, l), "[]"].join("")] : [...p, [encode(c, l), "[]=", encode(v, l)].join("")];
                            case "colon-list-separator":
                                return c => (p, v) => void 0 === v || l.skipNull && null === v || l.skipEmptyString && "" === v ? p : null === v ? [...p, [encode(c, l), ":list="].join("")] : [...p, [encode(c, l), ":list=", encode(v, l)].join("")];
                            case "comma":
                            case "separator":
                            case "bracket-separator":
                                {
                                    let c = "bracket-separator" === l.arrayFormat ? "[]=" : "=";
                                    return p => (v, _) => void 0 === _ || l.skipNull && null === _ || l.skipEmptyString && "" === _ ? v : (_ = null === _ ? "" : _, 0 === v.length) ? [
                                        [encode(p, l), c, encode(_, l)].join("")
                                    ] : [
                                        [v, encode(_, l)].join(l.arrayFormatSeparator)
                                    ]
                                }
                            default:
                                return c => (p, v) => void 0 === v || l.skipNull && null === v || l.skipEmptyString && "" === v ? p : null === v ? [...p, encode(c, l)] : [...p, [encode(c, l), "=", encode(v, l)].join("")]
                        }
                    }(c),
                    v = {};
                for (let c of Object.keys(l)) shouldFilter(c) || (v[c] = l[c]);
                let _ = Object.keys(v);
                return !1 !== c.sort && _.sort(c.sort), _.map(v => {
                    let _ = l[v];
                    return void 0 === _ ? "" : null === _ ? encode(v, c) : Array.isArray(_) ? 0 === _.length && "bracket-separator" === c.arrayFormat ? encode(v, c) + "[]" : _.reduce(p(v), []).join("&") : encode(v, c) + "=" + encode(_, c)
                }).filter(l => l.length > 0).join("&")
            }, c.parseUrl = (l, c) => {
                c = Object.assign({
                    decode: !0
                }, c);
                let [p, v] = C(l, "#");
                return Object.assign({
                    url: p.split("?")[0] || "",
                    query: parse(extract(l), c)
                }, c && c.parseFragmentIdentifier && v ? {
                    fragmentIdentifier: decode(v, c)
                } : {})
            }, c.stringifyUrl = (l, p) => {
                p = Object.assign({
                    encode: !0,
                    strict: !0,
                    [T]: !0
                }, p);
                let v = removeHash(l.url).split("?")[0] || "",
                    _ = c.extract(l.url),
                    C = c.parse(_, {
                        sort: !1
                    }),
                    P = Object.assign(C, l.query),
                    M = c.stringify(P, p);
                M && (M = `?${M}`);
                let z = function(l) {
                    let c = "",
                        p = l.indexOf("#");
                    return -1 !== p && (c = l.slice(p)), c
                }(l.url);
                return l.fragmentIdentifier && (z = `#${p[T]?encode(l.fragmentIdentifier,p):l.fragmentIdentifier}`), `${v}${M}${z}`
            }, c.pick = (l, p, v) => {
                v = Object.assign({
                    parseFragmentIdentifier: !0,
                    [T]: !1
                }, v);
                let {
                    url: _,
                    query: C,
                    fragmentIdentifier: M
                } = c.parseUrl(l, v);
                return c.stringifyUrl({
                    url: _,
                    query: P(C, p),
                    fragmentIdentifier: M
                }, v)
            }, c.exclude = (l, p, v) => {
                let _ = Array.isArray(p) ? l => !p.includes(l) : (l, c) => !p(l, c);
                return c.pick(l, _, v)
            }
        },
        941: function(l) {
            "use strict";

            function tryStringify(l) {
                try {
                    return JSON.stringify(l)
                } catch (l) {
                    return '"[Circular]"'
                }
            }
            l.exports = function(l, c, p) {
                var v = p && p.stringify || tryStringify;
                if ("object" == typeof l && null !== l) {
                    var _ = c.length + 1;
                    if (1 === _) return l;
                    var C = Array(_);
                    C[0] = v(l);
                    for (var P = 1; P < _; P++) C[P] = v(c[P]);
                    return C.join(" ")
                }
                if ("string" != typeof l) return l;
                var T = c.length;
                if (0 === T) return l;
                for (var M = "", z = 0, J = -1, Q = l && l.length || 0, X = 0; X < Q;) {
                    if (37 === l.charCodeAt(X) && X + 1 < Q) {
                        switch (J = J > -1 ? J : 0, l.charCodeAt(X + 1)) {
                            case 100:
                            case 102:
                                if (z >= T || null == c[z]) break;
                                J < X && (M += l.slice(J, X)), M += Number(c[z]), J = X + 2, X++;
                                break;
                            case 105:
                                if (z >= T || null == c[z]) break;
                                J < X && (M += l.slice(J, X)), M += Math.floor(Number(c[z])), J = X + 2, X++;
                                break;
                            case 79:
                            case 111:
                            case 106:
                                if (z >= T || void 0 === c[z]) break;
                                J < X && (M += l.slice(J, X));
                                var es = typeof c[z];
                                if ("string" === es) {
                                    M += "'" + c[z] + "'", J = X + 2, X++;
                                    break
                                }
                                if ("function" === es) {
                                    M += c[z].name || "<anonymous>", J = X + 2, X++;
                                    break
                                }
                                M += v(c[z]), J = X + 2, X++;
                                break;
                            case 115:
                                if (z >= T) break;
                                J < X && (M += l.slice(J, X)), M += String(c[z]), J = X + 2, X++;
                                break;
                            case 37:
                                J < X && (M += l.slice(J, X)), M += "%", J = X + 2, X++, z--
                        }++z
                    }++X
                }
                return -1 === J ? l : (J < Q && (M += l.slice(J)), M)
            }
        },
        34: function(l, c, p) {
            "use strict";
            var v = p(1248),
                _ = p(8213);

            function ownKeys(l, c) {
                var p = Object.keys(l);
                if (Object.getOwnPropertySymbols) {
                    var v = Object.getOwnPropertySymbols(l);
                    c && (v = v.filter(function(c) {
                        return Object.getOwnPropertyDescriptor(l, c).enumerable
                    })), p.push.apply(p, v)
                }
                return p
            }

            function _objectSpread2(l) {
                for (var c = 1; c < arguments.length; c++) {
                    var p = null != arguments[c] ? arguments[c] : {};
                    c % 2 ? ownKeys(Object(p), !0).forEach(function(c) {
                        var v, _;
                        v = c, _ = p[c], (v = function(l) {
                            var c = function(l, c) {
                                if ("object" != typeof l || null === l) return l;
                                var p = l[Symbol.toPrimitive];
                                if (void 0 !== p) {
                                    var v = p.call(l, c || "default");
                                    if ("object" != typeof v) return v;
                                    throw TypeError("@@toPrimitive must return a primitive value.")
                                }
                                return ("string" === c ? String : Number)(l)
                            }(l, "string");
                            return "symbol" == typeof c ? c : String(c)
                        }(v)) in l ? Object.defineProperty(l, v, {
                            value: _,
                            enumerable: !0,
                            configurable: !0,
                            writable: !0
                        }) : l[v] = _
                    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(l, Object.getOwnPropertyDescriptors(p)) : ownKeys(Object(p)).forEach(function(c) {
                        Object.defineProperty(l, c, Object.getOwnPropertyDescriptor(p, c))
                    })
                }
                return l
            }

            function _extends() {
                return (_extends = Object.assign ? Object.assign.bind() : function(l) {
                    for (var c = 1; c < arguments.length; c++) {
                        var p = arguments[c];
                        for (var v in p) Object.prototype.hasOwnProperty.call(p, v) && (l[v] = p[v])
                    }
                    return l
                }).apply(this, arguments)
            }

            function _objectWithoutProperties(l, c) {
                if (null == l) return {};
                var p, v, _ = function(l, c) {
                    if (null == l) return {};
                    var p, v, _ = {},
                        C = Object.keys(l);
                    for (v = 0; v < C.length; v++) p = C[v], c.indexOf(p) >= 0 || (_[p] = l[p]);
                    return _
                }(l, c);
                if (Object.getOwnPropertySymbols) {
                    var C = Object.getOwnPropertySymbols(l);
                    for (v = 0; v < C.length; v++) p = C[v], !(c.indexOf(p) >= 0) && Object.prototype.propertyIsEnumerable.call(l, p) && (_[p] = l[p])
                }
                return _
            }

            function _arrayLikeToArray(l, c) {
                (null == c || c > l.length) && (c = l.length);
                for (var p = 0, v = Array(c); p < c; p++) v[p] = l[p];
                return v
            }
            var C = "undefined" != typeof window && void 0 !== window.document && void 0 !== window.document.createElement ? v.useLayoutEffect : v.useEffect;

            function useEventCallback(l) {
                var c = v.useRef(l);
                return C(function() {
                    c.current = l
                }), v.useCallback(function() {
                    for (var l = arguments.length, p = Array(l), v = 0; v < l; v++) p[v] = arguments[v];
                    return c.current.apply(void 0, p)
                }, [])
            }
            var createCountUpInstance = function(l, c) {
                    var p = c.decimal,
                        v = c.decimals,
                        C = c.duration,
                        P = c.easingFn,
                        T = c.end,
                        M = c.formattingFn,
                        z = c.numerals,
                        J = c.prefix,
                        Q = c.separator,
                        X = c.start,
                        es = c.suffix,
                        eo = c.useEasing,
                        el = c.useGrouping,
                        ec = c.useIndianSeparators,
                        eh = c.enableScrollSpy,
                        ed = c.scrollSpyDelay,
                        ef = c.scrollSpyOnce,
                        ep = c.plugin;
                    return new _.CountUp(l, T, {
                        startVal: X,
                        duration: C,
                        decimal: p,
                        decimalPlaces: v,
                        easingFn: P,
                        formattingFn: M,
                        numerals: z,
                        separator: Q,
                        prefix: J,
                        suffix: es,
                        plugin: ep,
                        useEasing: eo,
                        useIndianSeparators: ec,
                        useGrouping: el,
                        enableScrollSpy: eh,
                        scrollSpyDelay: ed,
                        scrollSpyOnce: ef
                    })
                },
                P = ["ref", "startOnMount", "enableReinitialize", "delay", "onEnd", "onStart", "onPauseResume", "onReset", "onUpdate"],
                T = {
                    decimal: ".",
                    separator: ",",
                    delay: null,
                    prefix: "",
                    suffix: "",
                    duration: 2,
                    start: 0,
                    decimals: 0,
                    startOnMount: !0,
                    enableReinitialize: !0,
                    useEasing: !0,
                    useGrouping: !0,
                    useIndianSeparators: !1
                },
                useCountUp = function(l) {
                    var c = Object.fromEntries(Object.entries(l).filter(function(l) {
                            return void 0 !== (function(l) {
                                if (Array.isArray(l)) return l
                            }(l) || function(l, c) {
                                var p = null == l ? null : "undefined" != typeof Symbol && l[Symbol.iterator] || l["@@iterator"];
                                if (null != p) {
                                    var v, _, C, P, T = [],
                                        M = !0,
                                        z = !1;
                                    try {
                                        if (C = (p = p.call(l)).next, 0 === c) {
                                            if (Object(p) !== p) return;
                                            M = !1
                                        } else
                                            for (; !(M = (v = C.call(p)).done) && (T.push(v.value), T.length !== c); M = !0);
                                    } catch (l) {
                                        z = !0, _ = l
                                    } finally {
                                        try {
                                            if (!M && null != p.return && (P = p.return(), Object(P) !== P)) return
                                        } finally {
                                            if (z) throw _
                                        }
                                    }
                                    return T
                                }
                            }(l, 2) || function(l, c) {
                                if (l) {
                                    if ("string" == typeof l) return _arrayLikeToArray(l, c);
                                    var p = Object.prototype.toString.call(l).slice(8, -1);
                                    if ("Object" === p && l.constructor && (p = l.constructor.name), "Map" === p || "Set" === p) return Array.from(l);
                                    if ("Arguments" === p || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(p)) return _arrayLikeToArray(l, c)
                                }
                            }(l, 2) || function() {
                                throw TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
                            }())[1]
                        })),
                        p = v.useMemo(function() {
                            return _objectSpread2(_objectSpread2({}, T), c)
                        }, [l]),
                        _ = p.ref,
                        C = p.startOnMount,
                        M = p.enableReinitialize,
                        z = p.delay,
                        J = p.onEnd,
                        Q = p.onStart,
                        X = p.onPauseResume,
                        es = p.onReset,
                        eo = p.onUpdate,
                        el = _objectWithoutProperties(p, P),
                        ec = v.useRef(),
                        eh = v.useRef(),
                        ed = v.useRef(!1),
                        ef = useEventCallback(function() {
                            return createCountUpInstance("string" == typeof _ ? _ : _.current, el)
                        }),
                        ep = useEventCallback(function(l) {
                            var c = ec.current;
                            if (c && !l) return c;
                            var p = ef();
                            return ec.current = p, p
                        }),
                        eg = useEventCallback(function() {
                            var run = function() {
                                return ep(!0).start(function() {
                                    null == J || J({
                                        pauseResume: em,
                                        reset: ey,
                                        start: ew,
                                        update: eb
                                    })
                                })
                            };
                            z && z > 0 ? eh.current = setTimeout(run, 1e3 * z) : run(), null == Q || Q({
                                pauseResume: em,
                                reset: ey,
                                update: eb
                            })
                        }),
                        em = useEventCallback(function() {
                            ep().pauseResume(), null == X || X({
                                reset: ey,
                                start: ew,
                                update: eb
                            })
                        }),
                        ey = useEventCallback(function() {
                            ep().el && (eh.current && clearTimeout(eh.current), ep().reset(), null == es || es({
                                pauseResume: em,
                                start: ew,
                                update: eb
                            }))
                        }),
                        eb = useEventCallback(function(l) {
                            ep().update(l), null == eo || eo({
                                pauseResume: em,
                                reset: ey,
                                start: ew
                            })
                        }),
                        ew = useEventCallback(function() {
                            ey(), eg()
                        }),
                        ex = useEventCallback(function(l) {
                            C && (l && ey(), eg())
                        });
                    return v.useEffect(function() {
                        ed.current ? M && ex(!0) : (ed.current = !0, ex())
                    }, [M, ed, ex, z, l.start, l.suffix, l.prefix, l.duration, l.separator, l.decimals, l.decimal, l.formattingFn]), v.useEffect(function() {
                        return function() {
                            ey()
                        }
                    }, [ey]), {
                        start: ew,
                        pauseResume: em,
                        reset: ey,
                        update: eb,
                        getCountUp: ep
                    }
                },
                M = ["className", "redraw", "containerProps", "children", "style"];
            c.ZP = function(l) {
                var c = l.className,
                    p = l.redraw,
                    _ = l.containerProps,
                    C = l.children,
                    P = l.style,
                    T = _objectWithoutProperties(l, M),
                    z = v.useRef(null),
                    J = v.useRef(!1),
                    Q = useCountUp(_objectSpread2(_objectSpread2({}, T), {}, {
                        ref: z,
                        startOnMount: "function" != typeof C || 0 === l.delay,
                        enableReinitialize: !1
                    })),
                    X = Q.start,
                    es = Q.reset,
                    eo = Q.update,
                    el = Q.pauseResume,
                    ec = Q.getCountUp,
                    eh = useEventCallback(function() {
                        X()
                    }),
                    ed = useEventCallback(function(c) {
                        l.preserveValue || es(), eo(c)
                    }),
                    ef = useEventCallback(function() {
                        if ("function" == typeof l.children && !(z.current instanceof Element)) {
                            console.error('Couldn\'t find attached element to hook the CountUp instance into! Try to attach "containerRef" from the render prop to a an Element, eg. <span ref={containerRef} />.');
                            return
                        }
                        ec()
                    });
                v.useEffect(function() {
                    ef()
                }, [ef]), v.useEffect(function() {
                    J.current && ed(l.end)
                }, [l.end, ed]);
                var ep = p && l;
                return (v.useEffect(function() {
                    p && J.current && eh()
                }, [eh, p, ep]), v.useEffect(function() {
                    !p && J.current && eh()
                }, [eh, p, l.start, l.suffix, l.prefix, l.duration, l.separator, l.decimals, l.decimal, l.className, l.formattingFn]), v.useEffect(function() {
                    J.current = !0
                }, []), "function" == typeof C) ? C({
                    countUpRef: z,
                    start: X,
                    reset: es,
                    update: eo,
                    pauseResume: el,
                    getCountUp: ec
                }) : v.createElement("span", _extends({
                    className: c,
                    ref: z,
                    style: P
                }, _), void 0 !== l.start ? ec().formattingFn(l.start) : "")
            }
        },
        7106: function(l) {
            var c = "undefined" != typeof Element,
                p = "function" == typeof Map,
                v = "function" == typeof Set,
                _ = "function" == typeof ArrayBuffer && !!ArrayBuffer.isView;
            l.exports = function(l, C) {
                try {
                    return function equal(l, C) {
                        if (l === C) return !0;
                        if (l && C && "object" == typeof l && "object" == typeof C) {
                            var P, T, M, z;
                            if (l.constructor !== C.constructor) return !1;
                            if (Array.isArray(l)) {
                                if ((P = l.length) != C.length) return !1;
                                for (T = P; 0 != T--;)
                                    if (!equal(l[T], C[T])) return !1;
                                return !0
                            }
                            if (p && l instanceof Map && C instanceof Map) {
                                if (l.size !== C.size) return !1;
                                for (z = l.entries(); !(T = z.next()).done;)
                                    if (!C.has(T.value[0])) return !1;
                                for (z = l.entries(); !(T = z.next()).done;)
                                    if (!equal(T.value[1], C.get(T.value[0]))) return !1;
                                return !0
                            }
                            if (v && l instanceof Set && C instanceof Set) {
                                if (l.size !== C.size) return !1;
                                for (z = l.entries(); !(T = z.next()).done;)
                                    if (!C.has(T.value[0])) return !1;
                                return !0
                            }
                            if (_ && ArrayBuffer.isView(l) && ArrayBuffer.isView(C)) {
                                if ((P = l.length) != C.length) return !1;
                                for (T = P; 0 != T--;)
                                    if (l[T] !== C[T]) return !1;
                                return !0
                            }
                            if (l.constructor === RegExp) return l.source === C.source && l.flags === C.flags;
                            if (l.valueOf !== Object.prototype.valueOf && "function" == typeof l.valueOf && "function" == typeof C.valueOf) return l.valueOf() === C.valueOf();
                            if (l.toString !== Object.prototype.toString && "function" == typeof l.toString && "function" == typeof C.toString) return l.toString() === C.toString();
                            if ((P = (M = Object.keys(l)).length) !== Object.keys(C).length) return !1;
                            for (T = P; 0 != T--;)
                                if (!Object.prototype.hasOwnProperty.call(C, M[T])) return !1;
                            if (c && l instanceof Element) return !1;
                            for (T = P; 0 != T--;)
                                if (("_owner" !== M[T] && "__v" !== M[T] && "__o" !== M[T] || !l.$$typeof) && !equal(l[M[T]], C[M[T]])) return !1;
                            return !0
                        }
                        return l != l && C != C
                    }(l, C)
                } catch (l) {
                    if ((l.message || "").match(/stack|recursion/i)) return console.warn("react-fast-compare cannot handle circular refs"), !1;
                    throw l
                }
            }
        },
        5916: function(l, c, p) {
            "use strict";

            function _extends() {
                return (_extends = Object.assign ? Object.assign.bind() : function(l) {
                    for (var c = 1; c < arguments.length; c++) {
                        var p = arguments[c];
                        for (var v in p) Object.prototype.hasOwnProperty.call(p, v) && (l[v] = p[v])
                    }
                    return l
                }).apply(this, arguments)
            }

            function _objectWithoutPropertiesLoose(l, c) {
                if (null == l) return {};
                var p, v, _ = {},
                    C = Object.keys(l);
                for (v = 0; v < C.length; v++) p = C[v], c.indexOf(p) >= 0 || (_[p] = l[p]);
                return _
            }

            function _setPrototypeOf(l, c) {
                return (_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(l, c) {
                    return l.__proto__ = c, l
                })(l, c)
            }

            function _inheritsLoose(l, c) {
                l.prototype = Object.create(c.prototype), l.prototype.constructor = l, _setPrototypeOf(l, c)
            }

            function replaceClassName(l, c) {
                return l.replace(RegExp("(^|\\s)" + c + "(?:\\s|$)", "g"), "$1").replace(/\s+/g, " ").replace(/^\s*|\s*$/g, "")
            }
            p.d(c, {
                Z: function() {
                    return eo
                }
            });
            var v = p(1248),
                _ = p(2336),
                C = {
                    disabled: !1
                },
                P = v.createContext(null),
                forceReflow = function(l) {
                    return l.scrollTop
                },
                T = "unmounted",
                M = "exited",
                z = "entering",
                J = "entered",
                Q = "exiting",
                X = function(l) {
                    function Transition(c, p) {
                        v = l.call(this, c, p) || this;
                        var v, _, C = p && !p.isMounting ? c.enter : c.appear;
                        return v.appearStatus = null, c.in ? C ? (_ = M, v.appearStatus = z) : _ = J : _ = c.unmountOnExit || c.mountOnEnter ? T : M, v.state = {
                            status: _
                        }, v.nextCallback = null, v
                    }
                    _inheritsLoose(Transition, l), Transition.getDerivedStateFromProps = function(l, c) {
                        return l.in && c.status === T ? {
                            status: M
                        } : null
                    };
                    var c = Transition.prototype;
                    return c.componentDidMount = function() {
                        this.updateStatus(!0, this.appearStatus)
                    }, c.componentDidUpdate = function(l) {
                        var c = null;
                        if (l !== this.props) {
                            var p = this.state.status;
                            this.props.in ? p !== z && p !== J && (c = z) : (p === z || p === J) && (c = Q)
                        }
                        this.updateStatus(!1, c)
                    }, c.componentWillUnmount = function() {
                        this.cancelNextCallback()
                    }, c.getTimeouts = function() {
                        var l, c, p, v = this.props.timeout;
                        return l = c = p = v, null != v && "number" != typeof v && (l = v.exit, c = v.enter, p = void 0 !== v.appear ? v.appear : c), {
                            exit: l,
                            enter: c,
                            appear: p
                        }
                    }, c.updateStatus = function(l, c) {
                        if (void 0 === l && (l = !1), null !== c) {
                            if (this.cancelNextCallback(), c === z) {
                                if (this.props.unmountOnExit || this.props.mountOnEnter) {
                                    var p = this.props.nodeRef ? this.props.nodeRef.current : _.findDOMNode(this);
                                    p && forceReflow(p)
                                }
                                this.performEnter(l)
                            } else this.performExit()
                        } else this.props.unmountOnExit && this.state.status === M && this.setState({
                            status: T
                        })
                    }, c.performEnter = function(l) {
                        var c = this,
                            p = this.props.enter,
                            v = this.context ? this.context.isMounting : l,
                            P = this.props.nodeRef ? [v] : [_.findDOMNode(this), v],
                            T = P[0],
                            M = P[1],
                            Q = this.getTimeouts(),
                            X = v ? Q.appear : Q.enter;
                        if (!l && !p || C.disabled) {
                            this.safeSetState({
                                status: J
                            }, function() {
                                c.props.onEntered(T)
                            });
                            return
                        }
                        this.props.onEnter(T, M), this.safeSetState({
                            status: z
                        }, function() {
                            c.props.onEntering(T, M), c.onTransitionEnd(X, function() {
                                c.safeSetState({
                                    status: J
                                }, function() {
                                    c.props.onEntered(T, M)
                                })
                            })
                        })
                    }, c.performExit = function() {
                        var l = this,
                            c = this.props.exit,
                            p = this.getTimeouts(),
                            v = this.props.nodeRef ? void 0 : _.findDOMNode(this);
                        if (!c || C.disabled) {
                            this.safeSetState({
                                status: M
                            }, function() {
                                l.props.onExited(v)
                            });
                            return
                        }
                        this.props.onExit(v), this.safeSetState({
                            status: Q
                        }, function() {
                            l.props.onExiting(v), l.onTransitionEnd(p.exit, function() {
                                l.safeSetState({
                                    status: M
                                }, function() {
                                    l.props.onExited(v)
                                })
                            })
                        })
                    }, c.cancelNextCallback = function() {
                        null !== this.nextCallback && (this.nextCallback.cancel(), this.nextCallback = null)
                    }, c.safeSetState = function(l, c) {
                        c = this.setNextCallback(c), this.setState(l, c)
                    }, c.setNextCallback = function(l) {
                        var c = this,
                            p = !0;
                        return this.nextCallback = function(v) {
                            p && (p = !1, c.nextCallback = null, l(v))
                        }, this.nextCallback.cancel = function() {
                            p = !1
                        }, this.nextCallback
                    }, c.onTransitionEnd = function(l, c) {
                        this.setNextCallback(c);
                        var p = this.props.nodeRef ? this.props.nodeRef.current : _.findDOMNode(this),
                            v = null == l && !this.props.addEndListener;
                        if (!p || v) {
                            setTimeout(this.nextCallback, 0);
                            return
                        }
                        if (this.props.addEndListener) {
                            var C = this.props.nodeRef ? [this.nextCallback] : [p, this.nextCallback],
                                P = C[0],
                                T = C[1];
                            this.props.addEndListener(P, T)
                        }
                        null != l && setTimeout(this.nextCallback, l)
                    }, c.render = function() {
                        var l = this.state.status;
                        if (l === T) return null;
                        var c = this.props,
                            p = c.children,
                            _ = (c.in, c.mountOnEnter, c.unmountOnExit, c.appear, c.enter, c.exit, c.timeout, c.addEndListener, c.onEnter, c.onEntering, c.onEntered, c.onExit, c.onExiting, c.onExited, c.nodeRef, _objectWithoutPropertiesLoose(c, ["children", "in", "mountOnEnter", "unmountOnExit", "appear", "enter", "exit", "timeout", "addEndListener", "onEnter", "onEntering", "onEntered", "onExit", "onExiting", "onExited", "nodeRef"]));
                        return v.createElement(P.Provider, {
                            value: null
                        }, "function" == typeof p ? p(l, _) : v.cloneElement(v.Children.only(p), _))
                    }, Transition
                }(v.Component);

            function noop() {}
            X.contextType = P, X.propTypes = {}, X.defaultProps = { in: !1,
                mountOnEnter: !1,
                unmountOnExit: !1,
                appear: !1,
                enter: !0,
                exit: !0,
                onEnter: noop,
                onEntering: noop,
                onEntered: noop,
                onExit: noop,
                onExiting: noop,
                onExited: noop
            }, X.UNMOUNTED = T, X.EXITED = M, X.ENTERING = z, X.ENTERED = J, X.EXITING = Q;
            var removeClass = function(l, c) {
                    return l && c && c.split(" ").forEach(function(c) {
                        l.classList ? l.classList.remove(c) : "string" == typeof l.className ? l.className = replaceClassName(l.className, c) : l.setAttribute("class", replaceClassName(l.className && l.className.baseVal || "", c))
                    })
                },
                es = function(l) {
                    function CSSTransition() {
                        for (var c, p = arguments.length, v = Array(p), _ = 0; _ < p; _++) v[_] = arguments[_];
                        return (c = l.call.apply(l, [this].concat(v)) || this).appliedClasses = {
                            appear: {},
                            enter: {},
                            exit: {}
                        }, c.onEnter = function(l, p) {
                            var v = c.resolveArguments(l, p),
                                _ = v[0],
                                C = v[1];
                            c.removeClasses(_, "exit"), c.addClass(_, C ? "appear" : "enter", "base"), c.props.onEnter && c.props.onEnter(l, p)
                        }, c.onEntering = function(l, p) {
                            var v = c.resolveArguments(l, p),
                                _ = v[0],
                                C = v[1];
                            c.addClass(_, C ? "appear" : "enter", "active"), c.props.onEntering && c.props.onEntering(l, p)
                        }, c.onEntered = function(l, p) {
                            var v = c.resolveArguments(l, p),
                                _ = v[0],
                                C = v[1] ? "appear" : "enter";
                            c.removeClasses(_, C), c.addClass(_, C, "done"), c.props.onEntered && c.props.onEntered(l, p)
                        }, c.onExit = function(l) {
                            var p = c.resolveArguments(l)[0];
                            c.removeClasses(p, "appear"), c.removeClasses(p, "enter"), c.addClass(p, "exit", "base"), c.props.onExit && c.props.onExit(l)
                        }, c.onExiting = function(l) {
                            var p = c.resolveArguments(l)[0];
                            c.addClass(p, "exit", "active"), c.props.onExiting && c.props.onExiting(l)
                        }, c.onExited = function(l) {
                            var p = c.resolveArguments(l)[0];
                            c.removeClasses(p, "exit"), c.addClass(p, "exit", "done"), c.props.onExited && c.props.onExited(l)
                        }, c.resolveArguments = function(l, p) {
                            return c.props.nodeRef ? [c.props.nodeRef.current, l] : [l, p]
                        }, c.getClassNames = function(l) {
                            var p = c.props.classNames,
                                v = "string" == typeof p,
                                _ = v ? (v && p ? p + "-" : "") + l : p[l],
                                C = v ? _ + "-active" : p[l + "Active"],
                                P = v ? _ + "-done" : p[l + "Done"];
                            return {
                                baseClassName: _,
                                activeClassName: C,
                                doneClassName: P
                            }
                        }, c
                    }
                    _inheritsLoose(CSSTransition, l);
                    var c = CSSTransition.prototype;
                    return c.addClass = function(l, c, p) {
                        var v, _ = this.getClassNames(c)[p + "ClassName"],
                            C = this.getClassNames("enter").doneClassName;
                        "appear" === c && "done" === p && C && (_ += " " + C), "active" === p && l && forceReflow(l), _ && (this.appliedClasses[c][p] = _, v = _, l && v && v.split(" ").forEach(function(c) {
                            var p, v;
                            return p = l, v = c, void(p.classList ? p.classList.add(v) : (p.classList ? v && p.classList.contains(v) : -1 !== (" " + (p.className.baseVal || p.className) + " ").indexOf(" " + v + " ")) || ("string" == typeof p.className ? p.className = p.className + " " + v : p.setAttribute("class", (p.className && p.className.baseVal || "") + " " + v)))
                        }))
                    }, c.removeClasses = function(l, c) {
                        var p = this.appliedClasses[c],
                            v = p.base,
                            _ = p.active,
                            C = p.done;
                        this.appliedClasses[c] = {}, v && removeClass(l, v), _ && removeClass(l, _), C && removeClass(l, C)
                    }, c.render = function() {
                        var l = this.props,
                            c = (l.classNames, _objectWithoutPropertiesLoose(l, ["classNames"]));
                        return v.createElement(X, _extends({}, c, {
                            onEnter: this.onEnter,
                            onEntered: this.onEntered,
                            onEntering: this.onEntering,
                            onExit: this.onExit,
                            onExiting: this.onExiting,
                            onExited: this.onExited
                        }))
                    }, CSSTransition
                }(v.Component);
            es.defaultProps = {
                classNames: ""
            }, es.propTypes = {};
            var eo = es
        },
        427: function(l, c) {
            "use strict";
            Object.defineProperty(c, "__esModule", {
                value: !0
            }), c.safeJsonParse = function(l) {
                if ("string" != typeof l) throw Error(`Cannot safe json parse value of type ${typeof l}`);
                try {
                    return JSON.parse(l)
                } catch (c) {
                    return l
                }
            }, c.safeJsonStringify = function(l) {
                return "string" == typeof l ? l : JSON.stringify(l, (l, c) => void 0 === c ? null : c)
            }
        },
        2520: function(l) {
            "use strict";
            l.exports = (l, c) => {
                if (!("string" == typeof l && "string" == typeof c)) throw TypeError("Expected the arguments to be of type `string`");
                if ("" === c) return [l];
                let p = l.indexOf(c);
                return -1 === p ? [l] : [l.slice(0, p), l.slice(p + c.length)]
            }
        },
        2941: function(l) {
            "use strict";
            l.exports = l => encodeURIComponent(l).replace(/[!'()*]/g, l => `%${l.charCodeAt(0).toString(16).toUpperCase()}`)
        },
        7622: function(l, c, p) {
            "use strict";
            p.d(c, {
                ZP: function() {
                    return M
                },
                kY: function() {
                    return C.kY
                }
            });
            var v = p(1248),
                _ = p(1266),
                C = p(2843);
            let P = v.use || (l => {
                    if ("pending" === l.status) throw l;
                    if ("fulfilled" === l.status) return l.value;
                    if ("rejected" === l.status) throw l.reason;
                    throw l.status = "pending", l.then(c => {
                        l.status = "fulfilled", l.value = c
                    }, c => {
                        l.status = "rejected", l.reason = c
                    }), l
                }),
                T = {
                    dedupe: !0
                };
            C.$l.defineProperty(C.J$, "defaultValue", {
                value: C.u_
            });
            let M = (0, C.s6)((l, c, p) => {
                let {
                    cache: M,
                    compare: z,
                    suspense: J,
                    fallbackData: Q,
                    revalidateOnMount: X,
                    revalidateIfStale: es,
                    refreshInterval: eo,
                    refreshWhenHidden: el,
                    refreshWhenOffline: ec,
                    keepPreviousData: eh
                } = p, [ed, ef, ep, eg] = C.DY.get(M), [em, ey] = (0, C.qC)(l), eb = (0, v.useRef)(!1), ew = (0, v.useRef)(!1), ex = (0, v.useRef)(em), e_ = (0, v.useRef)(c), eE = (0, v.useRef)(p), getConfig = () => eE.current, isActive = () => getConfig().isVisible() && getConfig().isOnline(), [eA, eC, eS, eN] = (0, C.JN)(M, em), eP = (0, v.useRef)({}).current, eD = (0, C.o8)(Q) ? p.fallback[em] : Q, isEqual = (l, c) => {
                    for (let p in eP)
                        if ("data" === p) {
                            if (!z(l[p], c[p]) && (!(0, C.o8)(l[p]) || !z(eU, c[p]))) return !1
                        } else if (c[p] !== l[p]) return !1;
                    return !0
                }, ek = (0, v.useMemo)(() => {
                    let l = !!em && !!c && ((0, C.o8)(X) ? !getConfig().isPaused() && !J && (!!(0, C.o8)(es) || es) : X),
                        getSelectedCache = c => {
                            let p = (0, C.PM)(c);
                            return (delete p._k, l) ? {
                                isValidating: !0,
                                isLoading: !0,
                                ...p
                            } : p
                        },
                        p = eA(),
                        v = eN(),
                        _ = getSelectedCache(p),
                        P = p === v ? _ : getSelectedCache(v),
                        T = _;
                    return [() => {
                        let l = getSelectedCache(eA()),
                            c = isEqual(l, T);
                        return c ? (T.data = l.data, T.isLoading = l.isLoading, T.isValidating = l.isValidating, T.error = l.error, T) : (T = l, l)
                    }, () => P]
                }, [M, em]), eI = (0, _.useSyncExternalStore)((0, v.useCallback)(l => eS(em, (c, p) => {
                    isEqual(p, c) || l()
                }), [M, em]), ek[0], ek[1]), eO = !eb.current, ej = ed[em] && ed[em].length > 0, eT = eI.data, eR = (0, C.o8)(eT) ? eD : eT, eL = eI.error, eM = (0, v.useRef)(eR), eU = eh ? (0, C.o8)(eT) ? eM.current : eT : eR, eB = (!ej || !!(0, C.o8)(eL)) && (eO && !(0, C.o8)(X) ? X : !getConfig().isPaused() && (J ? !(0, C.o8)(eR) && es : (0, C.o8)(eR) || es)), eF = !!(em && c && eO && eB), eH = (0, C.o8)(eI.isValidating) ? eF : eI.isValidating, eV = (0, C.o8)(eI.isLoading) ? eF : eI.isLoading, ez = (0, v.useCallback)(async l => {
                    let c, v;
                    let _ = e_.current;
                    if (!em || !_ || ew.current || getConfig().isPaused()) return !1;
                    let P = !0,
                        T = l || {},
                        M = !ep[em] || !T.dedupe,
                        callbackSafeguard = () => C.w6 ? !ew.current && em === ex.current && eb.current : em === ex.current,
                        J = {
                            isValidating: !1,
                            isLoading: !1
                        },
                        finishRequestAndUpdateState = () => {
                            eC(J)
                        },
                        cleanupState = () => {
                            let l = ep[em];
                            l && l[1] === v && delete ep[em]
                        },
                        Q = {
                            isValidating: !0
                        };
                    (0, C.o8)(eA().data) && (Q.isLoading = !0);
                    try {
                        if (M && (eC(Q), p.loadingTimeout && (0, C.o8)(eA().data) && setTimeout(() => {
                                P && callbackSafeguard() && getConfig().onLoadingSlow(em, p)
                            }, p.loadingTimeout), ep[em] = [_(ey), (0, C.u3)()]), [c, v] = ep[em], c = await c, M && setTimeout(cleanupState, p.dedupingInterval), !ep[em] || ep[em][1] !== v) return M && callbackSafeguard() && getConfig().onDiscarded(em), !1;
                        J.error = C.i_;
                        let l = ef[em];
                        if (!(0, C.o8)(l) && (v <= l[0] || v <= l[1] || 0 === l[1])) return finishRequestAndUpdateState(), M && callbackSafeguard() && getConfig().onDiscarded(em), !1;
                        let T = eA().data;
                        J.data = z(T, c) ? T : c, M && callbackSafeguard() && getConfig().onSuccess(c, em, p)
                    } catch (p) {
                        cleanupState();
                        let l = getConfig(),
                            {
                                shouldRetryOnError: c
                            } = l;
                        !l.isPaused() && (J.error = p, M && callbackSafeguard() && (l.onError(p, em, l), (!0 === c || (0, C.mf)(c) && c(p)) && isActive() && l.onErrorRetry(p, em, l, l => {
                            let c = ed[em];
                            c && c[0] && c[0](C.sj.ERROR_REVALIDATE_EVENT, l)
                        }, {
                            retryCount: (T.retryCount || 0) + 1,
                            dedupe: !0
                        })))
                    }
                    return P = !1, finishRequestAndUpdateState(), !0
                }, [em, M]), eW = (0, v.useCallback)((...l) => (0, C.BN)(M, ex.current, ...l), []);
                if ((0, C.LI)(() => {
                        e_.current = c, eE.current = p, (0, C.o8)(eT) || (eM.current = eT)
                    }), (0, C.LI)(() => {
                        if (!em) return;
                        let l = ez.bind(C.i_, T),
                            c = 0,
                            p = (0, C.ko)(em, ed, (p, v = {}) => {
                                if (p == C.sj.FOCUS_EVENT) {
                                    let p = Date.now();
                                    getConfig().revalidateOnFocus && p > c && isActive() && (c = p + getConfig().focusThrottleInterval, l())
                                } else if (p == C.sj.RECONNECT_EVENT) getConfig().revalidateOnReconnect && isActive() && l();
                                else if (p == C.sj.MUTATE_EVENT) return ez();
                                else if (p == C.sj.ERROR_REVALIDATE_EVENT) return ez(v)
                            });
                        return ew.current = !1, ex.current = em, eb.current = !0, eC({
                            _k: ey
                        }), eB && ((0, C.o8)(eR) || C.W6 ? l() : (0, C.kw)(l)), () => {
                            ew.current = !0, p()
                        }
                    }, [em]), (0, C.LI)(() => {
                        let l;

                        function next() {
                            let c = (0, C.mf)(eo) ? eo(eA().data) : eo;
                            c && -1 !== l && (l = setTimeout(execute, c))
                        }

                        function execute() {
                            !eA().error && (el || getConfig().isVisible()) && (ec || getConfig().isOnline()) ? ez(T).then(next) : next()
                        }
                        return next(), () => {
                            l && (clearTimeout(l), l = -1)
                        }
                    }, [eo, el, ec, em]), (0, v.useDebugValue)(eU), J && (0, C.o8)(eR) && em) {
                    if (!C.w6 && C.W6) throw Error("Fallback data is required when using suspense in SSR.");
                    e_.current = c, eE.current = p, ew.current = !1;
                    let l = eg[em];
                    if (!(0, C.o8)(l)) {
                        let c = eW(l);
                        P(c)
                    }
                    if ((0, C.o8)(eL)) {
                        let l = ez(T);
                        (0, C.o8)(eU) || (l.status = "fulfilled", l.value = !0), P(l)
                    } else throw eL
                }
                return {
                    mutate: eW,
                    get data() {
                        return eP.data = !0, eU
                    },
                    get error() {
                        return eP.error = !0, eL
                    },
                    get isValidating() {
                        return eP.isValidating = !0, eH
                    },
                    get isLoading() {
                        return eP.isLoading = !0, eV
                    }
                }
            })
        },
        9243: function(l, c, p) {
            "use strict";
            p.r(c), p.d(c, {
                __assign: function() {
                    return __assign
                },
                __asyncDelegator: function() {
                    return __asyncDelegator
                },
                __asyncGenerator: function() {
                    return __asyncGenerator
                },
                __asyncValues: function() {
                    return __asyncValues
                },
                __await: function() {
                    return __await
                },
                __awaiter: function() {
                    return __awaiter
                },
                __classPrivateFieldGet: function() {
                    return __classPrivateFieldGet
                },
                __classPrivateFieldSet: function() {
                    return __classPrivateFieldSet
                },
                __createBinding: function() {
                    return __createBinding
                },
                __decorate: function() {
                    return __decorate
                },
                __exportStar: function() {
                    return __exportStar
                },
                __extends: function() {
                    return __extends
                },
                __generator: function() {
                    return __generator
                },
                __importDefault: function() {
                    return __importDefault
                },
                __importStar: function() {
                    return __importStar
                },
                __makeTemplateObject: function() {
                    return __makeTemplateObject
                },
                __metadata: function() {
                    return __metadata
                },
                __param: function() {
                    return __param
                },
                __read: function() {
                    return __read
                },
                __rest: function() {
                    return __rest
                },
                __spread: function() {
                    return __spread
                },
                __spreadArrays: function() {
                    return __spreadArrays
                },
                __values: function() {
                    return __values
                }
            });
            /*! *****************************************************************************
            Copyright (c) Microsoft Corporation.

            Permission to use, copy, modify, and/or distribute this software for any
            purpose with or without fee is hereby granted.

            THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
            REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
            AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
            INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
            LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
            OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
            PERFORMANCE OF THIS SOFTWARE.
            ***************************************************************************** */
            var extendStatics = function(l, c) {
                return (extendStatics = Object.setPrototypeOf || ({
                    __proto__: []
                }) instanceof Array && function(l, c) {
                    l.__proto__ = c
                } || function(l, c) {
                    for (var p in c) c.hasOwnProperty(p) && (l[p] = c[p])
                })(l, c)
            };

            function __extends(l, c) {
                function __() {
                    this.constructor = l
                }
                extendStatics(l, c), l.prototype = null === c ? Object.create(c) : (__.prototype = c.prototype, new __)
            }
            var __assign = function() {
                return (__assign = Object.assign || function(l) {
                    for (var c, p = 1, v = arguments.length; p < v; p++)
                        for (var _ in c = arguments[p]) Object.prototype.hasOwnProperty.call(c, _) && (l[_] = c[_]);
                    return l
                }).apply(this, arguments)
            };

            function __rest(l, c) {
                var p = {};
                for (var v in l) Object.prototype.hasOwnProperty.call(l, v) && 0 > c.indexOf(v) && (p[v] = l[v]);
                if (null != l && "function" == typeof Object.getOwnPropertySymbols)
                    for (var _ = 0, v = Object.getOwnPropertySymbols(l); _ < v.length; _++) 0 > c.indexOf(v[_]) && Object.prototype.propertyIsEnumerable.call(l, v[_]) && (p[v[_]] = l[v[_]]);
                return p
            }

            function __decorate(l, c, p, v) {
                var _, C = arguments.length,
                    P = C < 3 ? c : null === v ? v = Object.getOwnPropertyDescriptor(c, p) : v;
                if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) P = Reflect.decorate(l, c, p, v);
                else
                    for (var T = l.length - 1; T >= 0; T--)(_ = l[T]) && (P = (C < 3 ? _(P) : C > 3 ? _(c, p, P) : _(c, p)) || P);
                return C > 3 && P && Object.defineProperty(c, p, P), P
            }

            function __param(l, c) {
                return function(p, v) {
                    c(p, v, l)
                }
            }

            function __metadata(l, c) {
                if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(l, c)
            }

            function __awaiter(l, c, p, v) {
                return new(p || (p = Promise))(function(_, C) {
                    function fulfilled(l) {
                        try {
                            step(v.next(l))
                        } catch (l) {
                            C(l)
                        }
                    }

                    function rejected(l) {
                        try {
                            step(v.throw(l))
                        } catch (l) {
                            C(l)
                        }
                    }

                    function step(l) {
                        var c;
                        l.done ? _(l.value) : ((c = l.value) instanceof p ? c : new p(function(l) {
                            l(c)
                        })).then(fulfilled, rejected)
                    }
                    step((v = v.apply(l, c || [])).next())
                })
            }

            function __generator(l, c) {
                var p, v, _, C, P = {
                    label: 0,
                    sent: function() {
                        if (1 & _[0]) throw _[1];
                        return _[1]
                    },
                    trys: [],
                    ops: []
                };
                return C = {
                    next: verb(0),
                    throw: verb(1),
                    return: verb(2)
                }, "function" == typeof Symbol && (C[Symbol.iterator] = function() {
                    return this
                }), C;

                function verb(C) {
                    return function(T) {
                        return function(C) {
                            if (p) throw TypeError("Generator is already executing.");
                            for (; P;) try {
                                if (p = 1, v && (_ = 2 & C[0] ? v.return : C[0] ? v.throw || ((_ = v.return) && _.call(v), 0) : v.next) && !(_ = _.call(v, C[1])).done) return _;
                                switch (v = 0, _ && (C = [2 & C[0], _.value]), C[0]) {
                                    case 0:
                                    case 1:
                                        _ = C;
                                        break;
                                    case 4:
                                        return P.label++, {
                                            value: C[1],
                                            done: !1
                                        };
                                    case 5:
                                        P.label++, v = C[1], C = [0];
                                        continue;
                                    case 7:
                                        C = P.ops.pop(), P.trys.pop();
                                        continue;
                                    default:
                                        if (!(_ = (_ = P.trys).length > 0 && _[_.length - 1]) && (6 === C[0] || 2 === C[0])) {
                                            P = 0;
                                            continue
                                        }
                                        if (3 === C[0] && (!_ || C[1] > _[0] && C[1] < _[3])) {
                                            P.label = C[1];
                                            break
                                        }
                                        if (6 === C[0] && P.label < _[1]) {
                                            P.label = _[1], _ = C;
                                            break
                                        }
                                        if (_ && P.label < _[2]) {
                                            P.label = _[2], P.ops.push(C);
                                            break
                                        }
                                        _[2] && P.ops.pop(), P.trys.pop();
                                        continue
                                }
                                C = c.call(l, P)
                            } catch (l) {
                                C = [6, l], v = 0
                            } finally {
                                p = _ = 0
                            }
                            if (5 & C[0]) throw C[1];
                            return {
                                value: C[0] ? C[1] : void 0,
                                done: !0
                            }
                        }([C, T])
                    }
                }
            }

            function __createBinding(l, c, p, v) {
                void 0 === v && (v = p), l[v] = c[p]
            }

            function __exportStar(l, c) {
                for (var p in l) "default" === p || c.hasOwnProperty(p) || (c[p] = l[p])
            }

            function __values(l) {
                var c = "function" == typeof Symbol && Symbol.iterator,
                    p = c && l[c],
                    v = 0;
                if (p) return p.call(l);
                if (l && "number" == typeof l.length) return {
                    next: function() {
                        return l && v >= l.length && (l = void 0), {
                            value: l && l[v++],
                            done: !l
                        }
                    }
                };
                throw TypeError(c ? "Object is not iterable." : "Symbol.iterator is not defined.")
            }

            function __read(l, c) {
                var p = "function" == typeof Symbol && l[Symbol.iterator];
                if (!p) return l;
                var v, _, C = p.call(l),
                    P = [];
                try {
                    for (;
                        (void 0 === c || c-- > 0) && !(v = C.next()).done;) P.push(v.value)
                } catch (l) {
                    _ = {
                        error: l
                    }
                } finally {
                    try {
                        v && !v.done && (p = C.return) && p.call(C)
                    } finally {
                        if (_) throw _.error
                    }
                }
                return P
            }

            function __spread() {
                for (var l = [], c = 0; c < arguments.length; c++) l = l.concat(__read(arguments[c]));
                return l
            }

            function __spreadArrays() {
                for (var l = 0, c = 0, p = arguments.length; c < p; c++) l += arguments[c].length;
                for (var v = Array(l), _ = 0, c = 0; c < p; c++)
                    for (var C = arguments[c], P = 0, T = C.length; P < T; P++, _++) v[_] = C[P];
                return v
            }

            function __await(l) {
                return this instanceof __await ? (this.v = l, this) : new __await(l)
            }

            function __asyncGenerator(l, c, p) {
                if (!Symbol.asyncIterator) throw TypeError("Symbol.asyncIterator is not defined.");
                var v, _ = p.apply(l, c || []),
                    C = [];
                return v = {}, verb("next"), verb("throw"), verb("return"), v[Symbol.asyncIterator] = function() {
                    return this
                }, v;

                function verb(l) {
                    _[l] && (v[l] = function(c) {
                        return new Promise(function(p, v) {
                            C.push([l, c, p, v]) > 1 || resume(l, c)
                        })
                    })
                }

                function resume(l, c) {
                    try {
                        var p;
                        (p = _[l](c)).value instanceof __await ? Promise.resolve(p.value.v).then(fulfill, reject) : settle(C[0][2], p)
                    } catch (l) {
                        settle(C[0][3], l)
                    }
                }

                function fulfill(l) {
                    resume("next", l)
                }

                function reject(l) {
                    resume("throw", l)
                }

                function settle(l, c) {
                    l(c), C.shift(), C.length && resume(C[0][0], C[0][1])
                }
            }

            function __asyncDelegator(l) {
                var c, p;
                return c = {}, verb("next"), verb("throw", function(l) {
                    throw l
                }), verb("return"), c[Symbol.iterator] = function() {
                    return this
                }, c;

                function verb(v, _) {
                    c[v] = l[v] ? function(c) {
                        return (p = !p) ? {
                            value: __await(l[v](c)),
                            done: "return" === v
                        } : _ ? _(c) : c
                    } : _
                }
            }

            function __asyncValues(l) {
                if (!Symbol.asyncIterator) throw TypeError("Symbol.asyncIterator is not defined.");
                var c, p = l[Symbol.asyncIterator];
                return p ? p.call(l) : (l = __values(l), c = {}, verb("next"), verb("throw"), verb("return"), c[Symbol.asyncIterator] = function() {
                    return this
                }, c);

                function verb(p) {
                    c[p] = l[p] && function(c) {
                        return new Promise(function(v, _) {
                            ! function(l, c, p, v) {
                                Promise.resolve(v).then(function(c) {
                                    l({
                                        value: c,
                                        done: p
                                    })
                                }, c)
                            }(v, _, (c = l[p](c)).done, c.value)
                        })
                    }
                }
            }

            function __makeTemplateObject(l, c) {
                return Object.defineProperty ? Object.defineProperty(l, "raw", {
                    value: c
                }) : l.raw = c, l
            }

            function __importStar(l) {
                if (l && l.__esModule) return l;
                var c = {};
                if (null != l)
                    for (var p in l) Object.hasOwnProperty.call(l, p) && (c[p] = l[p]);
                return c.default = l, c
            }

            function __importDefault(l) {
                return l && l.__esModule ? l : {
                    default: l
                }
            }

            function __classPrivateFieldGet(l, c) {
                if (!c.has(l)) throw TypeError("attempted to get private field on non-instance");
                return c.get(l)
            }

            function __classPrivateFieldSet(l, c, p) {
                if (!c.has(l)) throw TypeError("attempted to set private field on non-instance");
                return c.set(l, p), p
            }
        },
        4713: function(l, c, p) {
            "use strict";
            /**
             * @license React
             * use-sync-external-store-shim.production.min.js
             *
             * Copyright (c) Facebook, Inc. and its affiliates.
             *
             * This source code is licensed under the MIT license found in the
             * LICENSE file in the root directory of this source tree.
             */
            var v = p(1248),
                _ = "function" == typeof Object.is ? Object.is : function(l, c) {
                    return l === c && (0 !== l || 1 / l == 1 / c) || l != l && c != c
                },
                C = v.useState,
                P = v.useEffect,
                T = v.useLayoutEffect,
                M = v.useDebugValue;

            function r(l) {
                var c = l.getSnapshot;
                l = l.value;
                try {
                    var p = c();
                    return !_(l, p)
                } catch (l) {
                    return !0
                }
            }
            var z = "undefined" == typeof window || void 0 === window.document || void 0 === window.document.createElement ? function(l, c) {
                return c()
            } : function(l, c) {
                var p = c(),
                    v = C({
                        inst: {
                            value: p,
                            getSnapshot: c
                        }
                    }),
                    _ = v[0].inst,
                    z = v[1];
                return T(function() {
                    _.value = p, _.getSnapshot = c, r(_) && z({
                        inst: _
                    })
                }, [l, p, c]), P(function() {
                    return r(_) && z({
                        inst: _
                    }), l(function() {
                        r(_) && z({
                            inst: _
                        })
                    })
                }, [l]), M(p), p
            };
            c.useSyncExternalStore = void 0 !== v.useSyncExternalStore ? v.useSyncExternalStore : z
        },
        1266: function(l, c, p) {
            "use strict";
            l.exports = p(4713)
        },
        6840: function(l, c, p) {
            (window.__NEXT_P = window.__NEXT_P || []).push(["/_app", function() {
                return p(8810)
            }])
        },
        3303: function(l, c, p) {
            "use strict";
            l.exports = {
                defaultLocale: "__default",
                interpolation: {
                    format: (l, c, p) => {
                        try {
                            let _ = v[c][p];
                            return _.format(l)
                        } catch (c) {
                            return l
                        }
                    }
                },
                loadLocaleFrom: (l, c) => p(1539)("./".concat(l.replace("__default", "en"), "/").concat(c, ".json")).then(l => l.default),
                locales: ["en", "ja", "ko", "ru", "tr", "vi", "zh-CN", "__default"],
                localesToIgnore: "__default",
                pages: {
                    "*": ["common"],
                    "/": ["index", "invite-code-form"],
                    "/about": ["about"],
                    "/airdrop": ["airdrop", "invite-code-form"],
                    "/airdrop/early-access": ["early-access", "invite-code-form"],
                    "/airdrop/early-access/bridge": ["bridge"],
                    "/bridge": ["bridge"],
                    "/devs": ["devs"],
                    "/leaderboard": ["leaderboard"]
                }
            };
            let v = {
                dateTime: {
                    en: new Intl.DateTimeFormat("en-US"),
                    ja: new Intl.DateTimeFormat("ja-JP"),
                    ko: new Intl.DateTimeFormat("ko-KR"),
                    ru: new Intl.DateTimeFormat("ru-RU"),
                    tr: new Intl.DateTimeFormat("tr-TR"),
                    vi: new Intl.DateTimeFormat("vi-VN"),
                    "zh-CN": new Intl.DateTimeFormat("zh-CN")
                },
                list: {
                    en: new Intl.ListFormat("en-US"),
                    ja: new Intl.ListFormat("ja-JP"),
                    ko: new Intl.ListFormat("ko-KR"),
                    ru: new Intl.ListFormat("ru-RU"),
                    tr: new Intl.ListFormat("tr-TR"),
                    vi: new Intl.ListFormat("vi-VN"),
                    "zh-CN": new Intl.ListFormat("zh-CN")
                },
                number: {
                    en: new Intl.NumberFormat("en-US", {
                        useGrouping: "min2"
                    }),
                    ja: new Intl.NumberFormat("ja-JP"),
                    ko: new Intl.NumberFormat("ko-KR"),
                    ru: new Intl.NumberFormat("ru-RU"),
                    tr: new Intl.NumberFormat("tr-TR"),
                    vi: new Intl.NumberFormat("vi-VN"),
                    "zh-CN": new Intl.NumberFormat("zh-CN")
                },
                relativeTime: {
                    en: new Intl.RelativeTimeFormat("en-US"),
                    ja: new Intl.RelativeTimeFormat("ja-JP"),
                    ko: new Intl.RelativeTimeFormat("ko-KR"),
                    ru: new Intl.RelativeTimeFormat("ru-RU"),
                    tr: new Intl.RelativeTimeFormat("tr-TR"),
                    vi: new Intl.RelativeTimeFormat("vi-VN"),
                    "zh-CN": new Intl.RelativeTimeFormat("zh-CN")
                }
            }
        },
        9045: function(l, c, p) {
            "use strict";
            Object.defineProperty(c, "__esModule", {
                value: !0
            }), Object.defineProperty(c, "Image", {
                enumerable: !0,
                get: function() {
                    return el
                }
            });
            let v = p(314),
                _ = p(420),
                C = _._(p(1248)),
                P = v._(p(2336)),
                T = v._(p(8461)),
                M = p(3429),
                z = p(2654),
                J = p(5980);
            p(9468);
            let Q = p(5623),
                X = v._(p(160)),
                es = {
                    deviceSizes: [640, 750, 828, 1080, 1200, 1920, 2048, 3840],
                    imageSizes: [16, 32, 48, 64, 96, 128, 256, 384],
                    path: "/_next/image",
                    loader: "default",
                    dangerouslyAllowSVG: !1,
                    unoptimized: !1
                };

            function handleLoading(l, c, p, v, _, C) {
                let P = null == l ? void 0 : l.src;
                if (!l || l["data-loaded-src"] === P) return;
                l["data-loaded-src"] = P;
                let T = "decode" in l ? l.decode() : Promise.resolve();
                T.catch(() => {}).then(() => {
                    if (l.parentElement && l.isConnected) {
                        if ("empty" !== c && _(!0), null == p ? void 0 : p.current) {
                            let c = new Event("load");
                            Object.defineProperty(c, "target", {
                                writable: !1,
                                value: l
                            });
                            let v = !1,
                                _ = !1;
                            p.current({ ...c,
                                nativeEvent: c,
                                currentTarget: l,
                                target: l,
                                isDefaultPrevented: () => v,
                                isPropagationStopped: () => _,
                                persist: () => {},
                                preventDefault: () => {
                                    v = !0, c.preventDefault()
                                },
                                stopPropagation: () => {
                                    _ = !0, c.stopPropagation()
                                }
                            })
                        }(null == v ? void 0 : v.current) && v.current(l)
                    }
                })
            }

            function getDynamicProps(l) {
                let [c, p] = C.version.split("."), v = parseInt(c, 10), _ = parseInt(p, 10);
                return v > 18 || 18 === v && _ >= 3 ? {
                    fetchPriority: l
                } : {
                    fetchpriority: l
                }
            }
            let eo = (0, C.forwardRef)((l, c) => {
                let {
                    src: p,
                    srcSet: v,
                    sizes: _,
                    height: P,
                    width: T,
                    decoding: M,
                    className: z,
                    style: J,
                    fetchPriority: Q,
                    placeholder: X,
                    loading: es,
                    unoptimized: eo,
                    fill: el,
                    onLoadRef: ec,
                    onLoadingCompleteRef: eh,
                    setBlurComplete: ed,
                    setShowAltText: ef,
                    onLoad: ep,
                    onError: eg,
                    ...em
                } = l;
                return C.default.createElement("img", { ...em,
                    ...getDynamicProps(Q),
                    loading: es,
                    width: T,
                    height: P,
                    decoding: M,
                    "data-nimg": el ? "fill" : "1",
                    className: z,
                    style: J,
                    sizes: _,
                    srcSet: v,
                    src: p,
                    ref: (0, C.useCallback)(l => {
                        c && ("function" == typeof c ? c(l) : "object" == typeof c && (c.current = l)), l && (eg && (l.src = l.src), l.complete && handleLoading(l, X, ec, eh, ed, eo))
                    }, [p, X, ec, eh, ed, eg, eo, c]),
                    onLoad: l => {
                        let c = l.currentTarget;
                        handleLoading(c, X, ec, eh, ed, eo)
                    },
                    onError: l => {
                        ef(!0), "empty" !== X && ed(!0), eg && eg(l)
                    }
                })
            });

            function ImagePreload(l) {
                let {
                    isAppRouter: c,
                    imgAttributes: p
                } = l, v = {
                    as: "image",
                    imageSrcSet: p.srcSet,
                    imageSizes: p.sizes,
                    crossOrigin: p.crossOrigin,
                    referrerPolicy: p.referrerPolicy,
                    ...getDynamicProps(p.fetchPriority)
                };
                return c && P.default.preload ? (P.default.preload(p.src, v), null) : C.default.createElement(T.default, null, C.default.createElement("link", {
                    key: "__nimg-" + p.src + p.srcSet + p.sizes,
                    rel: "preload",
                    href: p.srcSet ? void 0 : p.src,
                    ...v
                }))
            }
            let el = (0, C.forwardRef)((l, c) => {
                let p = (0, C.useContext)(Q.RouterContext),
                    v = (0, C.useContext)(J.ImageConfigContext),
                    _ = (0, C.useMemo)(() => {
                        let l = es || v || z.imageConfigDefault,
                            c = [...l.deviceSizes, ...l.imageSizes].sort((l, c) => l - c),
                            p = l.deviceSizes.sort((l, c) => l - c);
                        return { ...l,
                            allSizes: c,
                            deviceSizes: p
                        }
                    }, [v]),
                    {
                        onLoad: P,
                        onLoadingComplete: T
                    } = l,
                    el = (0, C.useRef)(P);
                (0, C.useEffect)(() => {
                    el.current = P
                }, [P]);
                let ec = (0, C.useRef)(T);
                (0, C.useEffect)(() => {
                    ec.current = T
                }, [T]);
                let [eh, ed] = (0, C.useState)(!1), [ef, ep] = (0, C.useState)(!1), {
                    props: eg,
                    meta: em
                } = (0, M.getImgProps)(l, {
                    defaultLoader: X.default,
                    imgConf: _,
                    blurComplete: eh,
                    showAltText: ef
                });
                return C.default.createElement(C.default.Fragment, null, C.default.createElement(eo, { ...eg,
                    unoptimized: em.unoptimized,
                    placeholder: em.placeholder,
                    fill: em.fill,
                    onLoadRef: el,
                    onLoadingCompleteRef: ec,
                    setBlurComplete: ed,
                    setShowAltText: ep,
                    ref: c
                }), em.priority ? C.default.createElement(ImagePreload, {
                    isAppRouter: !p,
                    imgAttributes: eg
                }) : null)
            });
            ("function" == typeof c.default || "object" == typeof c.default && null !== c.default) && void 0 === c.default.__esModule && (Object.defineProperty(c.default, "__esModule", {
                value: !0
            }), Object.assign(c.default, c), l.exports = c.default)
        },
        1142: function(l, c, p) {
            "use strict";
            Object.defineProperty(c, "__esModule", {
                    value: !0
                }),
                function(l, c) {
                    for (var p in c) Object.defineProperty(l, p, {
                        enumerable: !0,
                        get: c[p]
                    })
                }(c, {
                    noSSR: function() {
                        return noSSR
                    },
                    default: function() {
                        return dynamic
                    }
                });
            let v = p(314),
                _ = (p(1248), v._(p(669)));

            function convertModule(l) {
                return {
                    default: (null == l ? void 0 : l.default) || l
                }
            }

            function noSSR(l, c) {
                return delete c.webpack, delete c.modules, l(c)
            }

            function dynamic(l, c) {
                let p = _.default,
                    v = {
                        loading: l => {
                            let {
                                error: c,
                                isLoading: p,
                                pastDelay: v
                            } = l;
                            return null
                        }
                    };
                l instanceof Promise ? v.loader = () => l : "function" == typeof l ? v.loader = l : "object" == typeof l && (v = { ...v,
                    ...l
                }), v = { ...v,
                    ...c
                };
                let C = v.loader;
                return (v.loadableGenerated && (v = { ...v,
                    ...v.loadableGenerated
                }, delete v.loadableGenerated), "boolean" != typeof v.ssr || v.ssr) ? p({ ...v,
                    loader: () => null != C ? C().then(convertModule) : Promise.resolve(convertModule(() => null))
                }) : (delete v.webpack, delete v.modules, noSSR(p, v))
            }("function" == typeof c.default || "object" == typeof c.default && null !== c.default) && void 0 === c.default.__esModule && (Object.defineProperty(c.default, "__esModule", {
                value: !0
            }), Object.assign(c.default, c), l.exports = c.default)
        },
        3429: function(l, c, p) {
            "use strict";
            Object.defineProperty(c, "__esModule", {
                value: !0
            }), Object.defineProperty(c, "getImgProps", {
                enumerable: !0,
                get: function() {
                    return getImgProps
                }
            }), p(9468);
            let v = p(9170),
                _ = p(2654);

            function isStaticRequire(l) {
                return void 0 !== l.default
            }

            function getInt(l) {
                return void 0 === l ? l : "number" == typeof l ? Number.isFinite(l) ? l : NaN : "string" == typeof l && /^[0-9]+$/.test(l) ? parseInt(l, 10) : NaN
            }

            function getImgProps(l, c) {
                var p;
                let C, P, T, {
                        src: M,
                        sizes: z,
                        unoptimized: J = !1,
                        priority: Q = !1,
                        loading: X,
                        className: es,
                        quality: eo,
                        width: el,
                        height: ec,
                        fill: eh = !1,
                        style: ed,
                        onLoad: ef,
                        onLoadingComplete: ep,
                        placeholder: eg = "empty",
                        blurDataURL: em,
                        fetchPriority: ey,
                        layout: eb,
                        objectFit: ew,
                        objectPosition: ex,
                        lazyBoundary: e_,
                        lazyRoot: eE,
                        ...eA
                    } = l,
                    {
                        imgConf: eC,
                        showAltText: eS,
                        blurComplete: eN,
                        defaultLoader: eP
                    } = c,
                    eD = eC || _.imageConfigDefault;
                if ("allSizes" in eD) C = eD;
                else {
                    let l = [...eD.deviceSizes, ...eD.imageSizes].sort((l, c) => l - c),
                        c = eD.deviceSizes.sort((l, c) => l - c);
                    C = { ...eD,
                        allSizes: l,
                        deviceSizes: c
                    }
                }
                let ek = eA.loader || eP;
                delete eA.loader, delete eA.srcSet;
                let eI = "__next_img_default" in ek;
                if (eI) {
                    if ("custom" === C.loader) throw Error('Image with src "' + M + '" is missing "loader" prop.\nRead more: https://nextjs.org/docs/messages/next-image-missing-loader')
                } else {
                    let l = ek;
                    ek = c => {
                        let {
                            config: p,
                            ...v
                        } = c;
                        return l(v)
                    }
                }
                if (eb) {
                    "fill" === eb && (eh = !0);
                    let l = {
                        intrinsic: {
                            maxWidth: "100%",
                            height: "auto"
                        },
                        responsive: {
                            width: "100%",
                            height: "auto"
                        }
                    }[eb];
                    l && (ed = { ...ed,
                        ...l
                    });
                    let c = {
                        responsive: "100vw",
                        fill: "100vw"
                    }[eb];
                    c && !z && (z = c)
                }
                let eO = "",
                    ej = getInt(el),
                    eT = getInt(ec);
                if ("object" == typeof(p = M) && (isStaticRequire(p) || void 0 !== p.src)) {
                    let l = isStaticRequire(M) ? M.default : M;
                    if (!l.src) throw Error("An object should only be passed to the image component src parameter if it comes from a static image import. It must include src. Received " + JSON.stringify(l));
                    if (!l.height || !l.width) throw Error("An object should only be passed to the image component src parameter if it comes from a static image import. It must include height and width. Received " + JSON.stringify(l));
                    if (P = l.blurWidth, T = l.blurHeight, em = em || l.blurDataURL, eO = l.src, !eh) {
                        if (ej || eT) {
                            if (ej && !eT) {
                                let c = ej / l.width;
                                eT = Math.round(l.height * c)
                            } else if (!ej && eT) {
                                let c = eT / l.height;
                                ej = Math.round(l.width * c)
                            }
                        } else ej = l.width, eT = l.height
                    }
                }
                let eR = !Q && ("lazy" === X || void 0 === X);
                (!(M = "string" == typeof M ? M : eO) || M.startsWith("data:") || M.startsWith("blob:")) && (J = !0, eR = !1), C.unoptimized && (J = !0), eI && M.endsWith(".svg") && !C.dangerouslyAllowSVG && (J = !0), Q && (ey = "high");
                let eL = getInt(eo),
                    eM = Object.assign(eh ? {
                        position: "absolute",
                        height: "100%",
                        width: "100%",
                        left: 0,
                        top: 0,
                        right: 0,
                        bottom: 0,
                        objectFit: ew,
                        objectPosition: ex
                    } : {}, eS ? {} : {
                        color: "transparent"
                    }, ed),
                    eU = eN || "empty" === eg ? null : "blur" === eg ? 'url("data:image/svg+xml;charset=utf-8,' + (0, v.getImageBlurSvg)({
                        widthInt: ej,
                        heightInt: eT,
                        blurWidth: P,
                        blurHeight: T,
                        blurDataURL: em || "",
                        objectFit: eM.objectFit
                    }) + '")' : 'url("' + eg + '")',
                    eB = eU ? {
                        backgroundSize: eM.objectFit || "cover",
                        backgroundPosition: eM.objectPosition || "50% 50%",
                        backgroundRepeat: "no-repeat",
                        backgroundImage: eU
                    } : {},
                    eF = function(l) {
                        let {
                            config: c,
                            src: p,
                            unoptimized: v,
                            width: _,
                            quality: C,
                            sizes: P,
                            loader: T
                        } = l;
                        if (v) return {
                            src: p,
                            srcSet: void 0,
                            sizes: void 0
                        };
                        let {
                            widths: M,
                            kind: z
                        } = function(l, c, p) {
                            let {
                                deviceSizes: v,
                                allSizes: _
                            } = l;
                            if (p) {
                                let l = /(^|\s)(1?\d?\d)vw/g,
                                    c = [];
                                for (let v; v = l.exec(p); v) c.push(parseInt(v[2]));
                                if (c.length) {
                                    let l = .01 * Math.min(...c);
                                    return {
                                        widths: _.filter(c => c >= v[0] * l),
                                        kind: "w"
                                    }
                                }
                                return {
                                    widths: _,
                                    kind: "w"
                                }
                            }
                            if ("number" != typeof c) return {
                                widths: v,
                                kind: "w"
                            };
                            let C = [...new Set([c, 2 * c].map(l => _.find(c => c >= l) || _[_.length - 1]))];
                            return {
                                widths: C,
                                kind: "x"
                            }
                        }(c, _, P), J = M.length - 1;
                        return {
                            sizes: P || "w" !== z ? P : "100vw",
                            srcSet: M.map((l, v) => T({
                                config: c,
                                src: p,
                                quality: C,
                                width: l
                            }) + " " + ("w" === z ? l : v + 1) + z).join(", "),
                            src: T({
                                config: c,
                                src: p,
                                quality: C,
                                width: M[J]
                            })
                        }
                    }({
                        config: C,
                        src: M,
                        unoptimized: J,
                        width: ej,
                        quality: eL,
                        sizes: z,
                        loader: ek
                    }),
                    eH = { ...eA,
                        loading: eR ? "lazy" : X,
                        fetchPriority: ey,
                        width: ej,
                        height: eT,
                        decoding: "async",
                        className: es,
                        style: { ...eM,
                            ...eB
                        },
                        sizes: eF.sizes,
                        srcSet: eF.srcSet,
                        src: eF.src
                    },
                    eV = {
                        unoptimized: J,
                        priority: Q,
                        placeholder: eg,
                        fill: eh
                    };
                return {
                    props: eH,
                    meta: eV
                }
            }
        },
        9170: function(l, c) {
            "use strict";

            function getImageBlurSvg(l) {
                let {
                    widthInt: c,
                    heightInt: p,
                    blurWidth: v,
                    blurHeight: _,
                    blurDataURL: C,
                    objectFit: P
                } = l, T = v ? 40 * v : c, M = _ ? 40 * _ : p, z = T && M ? "viewBox='0 0 " + T + " " + M + "'" : "";
                return "%3Csvg xmlns='http://www.w3.org/2000/svg' " + z + "%3E%3Cfilter id='b' color-interpolation-filters='sRGB'%3E%3CfeGaussianBlur stdDeviation='20'/%3E%3CfeColorMatrix values='1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 100 -1' result='s'/%3E%3CfeFlood x='0' y='0' width='100%25' height='100%25'/%3E%3CfeComposite operator='out' in='s'/%3E%3CfeComposite in2='SourceGraphic'/%3E%3CfeGaussianBlur stdDeviation='20'/%3E%3C/filter%3E%3Cimage width='100%25' height='100%25' x='0' y='0' preserveAspectRatio='" + (z ? "none" : "contain" === P ? "xMidYMid" : "cover" === P ? "xMidYMid slice" : "none") + "' style='filter: url(%23b);' href='" + C + "'/%3E%3C/svg%3E"
            }
            Object.defineProperty(c, "__esModule", {
                value: !0
            }), Object.defineProperty(c, "getImageBlurSvg", {
                enumerable: !0,
                get: function() {
                    return getImageBlurSvg
                }
            })
        },
        7406: function(l, c, p) {
            "use strict";
            Object.defineProperty(c, "__esModule", {
                    value: !0
                }),
                function(l, c) {
                    for (var p in c) Object.defineProperty(l, p, {
                        enumerable: !0,
                        get: c[p]
                    })
                }(c, {
                    default: function() {
                        return M
                    },
                    unstable_getImgProps: function() {
                        return unstable_getImgProps
                    }
                });
            let v = p(314),
                _ = p(3429),
                C = p(9468),
                P = p(9045),
                T = v._(p(160)),
                unstable_getImgProps = l => {
                    (0, C.warnOnce)("Warning: unstable_getImgProps() is experimental and may change or be removed at any time. Use at your own risk.");
                    let {
                        props: c
                    } = (0, _.getImgProps)(l, {
                        defaultLoader: T.default,
                        imgConf: {
                            deviceSizes: [640, 750, 828, 1080, 1200, 1920, 2048, 3840],
                            imageSizes: [16, 32, 48, 64, 96, 128, 256, 384],
                            path: "/_next/image",
                            loader: "default",
                            dangerouslyAllowSVG: !1,
                            unoptimized: !1
                        }
                    });
                    for (let [l, p] of Object.entries(c)) void 0 === p && delete c[l];
                    return {
                        props: c
                    }
                },
                M = P.Image
        },
        160: function(l, c) {
            "use strict";

            function defaultLoader(l) {
                let {
                    config: c,
                    src: p,
                    width: v,
                    quality: _
                } = l;
                return c.path + "?url=" + encodeURIComponent(p) + "&w=" + v + "&q=" + (_ || 75)
            }
            Object.defineProperty(c, "__esModule", {
                value: !0
            }), Object.defineProperty(c, "default", {
                enumerable: !0,
                get: function() {
                    return p
                }
            }), defaultLoader.__next_img_default = !0;
            let p = defaultLoader
        },
        4018: function(l, c, p) {
            "use strict";
            Object.defineProperty(c, "__esModule", {
                value: !0
            }), Object.defineProperty(c, "LoadableContext", {
                enumerable: !0,
                get: function() {
                    return C
                }
            });
            let v = p(314),
                _ = v._(p(1248)),
                C = _.default.createContext(null)
        },
        669: function(l, c, p) {
            "use strict";
            /**
            @copyright (c) 2017-present James Kyle <me@thejameskyle.com>
             MIT License
             Permission is hereby granted, free of charge, to any person obtaining
            a copy of this software and associated documentation files (the
            "Software"), to deal in the Software without restriction, including
            without limitation the rights to use, copy, modify, merge, publish,
            distribute, sublicense, and/or sell copies of the Software, and to
            permit persons to whom the Software is furnished to do so, subject to
            the following conditions:
             The above copyright notice and this permission notice shall be
            included in all copies or substantial portions of the Software.
             THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
            EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
            MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
            NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
            LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
            OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
            WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE
            */
            Object.defineProperty(c, "__esModule", {
                value: !0
            }), Object.defineProperty(c, "default", {
                enumerable: !0,
                get: function() {
                    return z
                }
            });
            let v = p(314),
                _ = v._(p(1248)),
                C = p(4018),
                P = [],
                T = [],
                M = !1;

            function load(l) {
                let c = l(),
                    p = {
                        loading: !0,
                        loaded: null,
                        error: null
                    };
                return p.promise = c.then(l => (p.loading = !1, p.loaded = l, l)).catch(l => {
                    throw p.loading = !1, p.error = l, l
                }), p
            }
            let LoadableSubscription = class LoadableSubscription {
                promise() {
                    return this._res.promise
                }
                retry() {
                    this._clearTimeouts(), this._res = this._loadFn(this._opts.loader), this._state = {
                        pastDelay: !1,
                        timedOut: !1
                    };
                    let {
                        _res: l,
                        _opts: c
                    } = this;
                    l.loading && ("number" == typeof c.delay && (0 === c.delay ? this._state.pastDelay = !0 : this._delay = setTimeout(() => {
                        this._update({
                            pastDelay: !0
                        })
                    }, c.delay)), "number" == typeof c.timeout && (this._timeout = setTimeout(() => {
                        this._update({
                            timedOut: !0
                        })
                    }, c.timeout))), this._res.promise.then(() => {
                        this._update({}), this._clearTimeouts()
                    }).catch(l => {
                        this._update({}), this._clearTimeouts()
                    }), this._update({})
                }
                _update(l) {
                    this._state = { ...this._state,
                        error: this._res.error,
                        loaded: this._res.loaded,
                        loading: this._res.loading,
                        ...l
                    }, this._callbacks.forEach(l => l())
                }
                _clearTimeouts() {
                    clearTimeout(this._delay), clearTimeout(this._timeout)
                }
                getCurrentValue() {
                    return this._state
                }
                subscribe(l) {
                    return this._callbacks.add(l), () => {
                        this._callbacks.delete(l)
                    }
                }
                constructor(l, c) {
                    this._loadFn = l, this._opts = c, this._callbacks = new Set, this._delay = null, this._timeout = null, this.retry()
                }
            };

            function Loadable(l) {
                return function(l, c) {
                    let p = Object.assign({
                            loader: null,
                            loading: null,
                            delay: 200,
                            timeout: null,
                            webpack: null,
                            modules: null
                        }, c),
                        v = null;

                    function init() {
                        if (!v) {
                            let c = new LoadableSubscription(l, p);
                            v = {
                                getCurrentValue: c.getCurrentValue.bind(c),
                                subscribe: c.subscribe.bind(c),
                                retry: c.retry.bind(c),
                                promise: c.promise.bind(c)
                            }
                        }
                        return v.promise()
                    }
                    if (!M) {
                        let l = p.webpack ? p.webpack() : p.modules;
                        l && T.push(c => {
                            for (let p of l)
                                if (c.includes(p)) return init()
                        })
                    }

                    function LoadableComponent(l, c) {
                        ! function() {
                            init();
                            let l = _.default.useContext(C.LoadableContext);
                            l && Array.isArray(p.modules) && p.modules.forEach(c => {
                                l(c)
                            })
                        }();
                        let P = _.default.useSyncExternalStore(v.subscribe, v.getCurrentValue, v.getCurrentValue);
                        return _.default.useImperativeHandle(c, () => ({
                            retry: v.retry
                        }), []), _.default.useMemo(() => {
                            var c;
                            return P.loading || P.error ? _.default.createElement(p.loading, {
                                isLoading: P.loading,
                                pastDelay: P.pastDelay,
                                timedOut: P.timedOut,
                                error: P.error,
                                retry: v.retry
                            }) : P.loaded ? _.default.createElement((c = P.loaded) && c.default ? c.default : c, l) : null
                        }, [l, P])
                    }
                    return LoadableComponent.preload = () => init(), LoadableComponent.displayName = "LoadableComponent", _.default.forwardRef(LoadableComponent)
                }(load, l)
            }

            function flushInitializers(l, c) {
                let p = [];
                for (; l.length;) {
                    let v = l.pop();
                    p.push(v(c))
                }
                return Promise.all(p).then(() => {
                    if (l.length) return flushInitializers(l, c)
                })
            }
            Loadable.preloadAll = () => new Promise((l, c) => {
                flushInitializers(P).then(l, c)
            }), Loadable.preloadReady = l => (void 0 === l && (l = []), new Promise(c => {
                let res = () => (M = !0, c());
                flushInitializers(T, l).then(res, res)
            })), window.__NEXT_PRELOADREADY = Loadable.preloadReady;
            let z = Loadable
        },
        6179: function(l, c, p) {
            "use strict";
            var v, _;

            function endpoint(l) {
                let c = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "v1";
                return "".concat("https://waitlist-api.prod.blast.io", "/").concat(c, "/").concat(l.replace(/^\/(.*)$/, "$1"))
            }

            function get(l) {
                let c = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                return fetch(l, {
                    credentials: "include",
                    headers: {
                        "Content-Type": "application/json"
                    },
                    method: "GET",
                    ...c
                }).then(l => l.json())
            }
            async function getWithErrorHandling(l) {
                let c = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},
                    p = await fetch(l, {
                        credentials: "include",
                        headers: {
                            "Content-Type": "application/json"
                        },
                        method: "GET",
                        ...c
                    });
                if (!p.ok) throw new ApiError(p);
                return await p.json()
            }
            p.d(c, {
                FP: function() {
                    return endpoint
                },
                U2: function() {
                    return get
                },
                eF: function() {
                    return v
                },
                i3: function() {
                    return getWithErrorHandling
                }
            }), (_ = v || (v = {}))[_.DiscordMissingInvite = -1e3] = "DiscordMissingInvite", _[_.DiscordAlreadyLinked = -1001] = "DiscordAlreadyLinked", _[_.DiscordSuccessAndFinalized = -1002] = "DiscordSuccessAndFinalized", _[_.DiscordSuccessNotFinalized = -1003] = "DiscordSuccessNotFinalized", _[_.DiscordUnknownError = -1004] = "DiscordUnknownError", _[_.TwitterMissingInvite = -2005] = "TwitterMissingInvite", _[_.TwitterAlreadyLinked = -2006] = "TwitterAlreadyLinked", _[_.TwitterSuccessAndFinalized = -2007] = "TwitterSuccessAndFinalized", _[_.TwitterSuccessNotFinalized = -2008] = "TwitterSuccessNotFinalized", _[_.TwitterUnknownError = -2009] = "TwitterUnknownError";
            let ApiError = class ApiError extends Error {
                constructor(l) {
                    super(l.statusText), this.code = l.status
                }
            }
        },
        3685: function(l, c, p) {
            "use strict";
            p.d(c, {
                z: function() {
                    return P
                },
                o: function() {
                    return T
                }
            });
            var v = p(4817),
                _ = p(1248),
                C = p(1389);
            let P = _.forwardRef((l, c) => {
                let {
                    children: p,
                    focus: _ = "self",
                    glow: P = !1,
                    hover: M = "self",
                    onClick: z,
                    stretch: J = !1,
                    text: Q = "variant",
                    variant: X = "primary",
                    ...es
                } = l, eo = P && !es.disabled, el = {
                    primary: (0, C.m)("bg-yellow-300", "group" === _ && "group-focus-visible:bg-white", "self" === _ && "focus-visible:bg-white", "group" === M && "group-hover:bg-white", "self" === M && "hover:bg-white", "variant" === Q && "text-black", "current" === Q && "text-current"),
                    secondary: (0, C.m)("bg-yellow-100", "group" === _ && "group-focus-visible:bg-white", "self" === _ && "focus-visible:bg-white", "group" === M && "group-hover:bg-white", "self" === M && "hover:bg-white", "variant" === Q && "text-black", "current" === Q && "text-current"),
                    tertiary: (0, C.m)("bg-black", "group" === _ && "group-focus-visible:text-black group-focus:bg-white", "self" === _ && "focus-visible:text-black focus-visible:bg-white", "group" === M && "group-hover:bg-white group-hover:text-black", "self" === M && "hover:bg-white hover:text-black", "variant" === Q && "text-yellow-100", "current" === Q && "text-current")
                };
                return (0, v.jsx)("div", {
                    className: (0, C.m)("transition-[filter]", eo && "primary" === X && "drop-shadow-glow-sm-yellow-300", eo && "secondary" === X && "drop-shadow-glow-sm-yellow-300", eo && "hover:drop-shadow-glow-sm-white-300"),
                    children: (0, v.jsx)("button", { ...es,
                        ref: c,
                        onClick: z,
                        tabIndex: "group" === _ ? -1 : es.tabIndex,
                        className: (0, C.m)("disabled:cursor-not-allowed disabled:bg-camo-300 disabled:text-gray-800", "typography-brand-body-l-caps min-h-[40px] px-6 py-2 transition-colors will-change-transform [transform:translateZ(0)]", T, J && "w-full", el[X]),
                        children: p
                    })
                })
            });
            P.displayName = "Button";
            let T = "rounded-bl-md rounded-tr-md [clip-path:polygon(20px_0,100%_0,100%_50%,calc(100%-20px)_100%,0_100%,0_50%)]"
        },
        2244: function(l, c, p) {
            "use strict";
            p.d(c, {
                ye: function() {
                    return ContentFrame
                },
                xi: function() {
                    return ContentFrameHead
                }
            });
            var v = p(4817),
                _ = p(1248),
                C = p(1389);

            function getComponentName(l) {
                let c = l.type,
                    p = "string" == typeof c ? c : c.displayName || c.name || "Unknown";
                return p
            }
            let P = {
                large: {
                    cornerSize: 56,
                    defaultHeaderRatio: .5,
                    pb: "pb-14",
                    pt: "pt-[72px]",
                    px: "px-8",
                    pyHeader: "py-3",
                    topCornerMultiplier: 2,
                    topCornerSize: 24
                },
                small: {
                    cornerSize: 10,
                    defaultHeaderRatio: .8,
                    pb: "pb-[18px]",
                    pt: "pt-[30px]",
                    px: "px-6",
                    pyHeader: "py-1",
                    topCornerMultiplier: 1,
                    topCornerSize: 10
                }
            };

            function ContentFrame(l) {
                let {
                    children: c,
                    className: p,
                    frameSize: T = "large",
                    variant: M = "light",
                    ...z
                } = l, J = _.useRef(null), Q = _.useRef(null), {
                    cornerSize: X,
                    defaultHeaderRatio: es,
                    pb: eo,
                    pt: el,
                    px: ec,
                    pyHeader: eh,
                    topCornerMultiplier: ed,
                    topCornerSize: ef
                } = P[T], ep = "".concat(X, "px"), eg = "".concat(ef, "px"), [em, ey] = _.useState("polygon(45% ".concat(eg, ", 50% 0, 100% 0, 100% calc(100% - ").concat(ep, "), calc(100% - ").concat(ep, ") 100%, 0 100%, 0 ").concat(3 * ef, "px, ").concat(2 * ef, "px ").concat(eg, ")"));
                return _.useEffect(() => {
                    var l, c;
                    let p = null === (l = J.current) || void 0 === l ? void 0 : l.getBoundingClientRect().width,
                        v = null === (c = Q.current) || void 0 === c ? void 0 : c.getBoundingClientRect().width;
                    if ("number" == typeof v) {
                        let l = null != p ? p : v * es,
                            c = Math.max(v - l, ef * (ed + 2));
                        ey("polygon(".concat(c - ef, "px ").concat(eg, ", ").concat(c, "px 0, 100% 0, 100% calc(100% - ").concat(ep, "), calc(100% - ").concat(ep, ") 100%, 0 100%, 0 ").concat(ef * (ed + 1), "px, ").concat(ef * ed, "px ").concat(eg, ")"))
                    }
                }, [ep, es, T, ed, ef, eg]), (0, v.jsx)("div", {
                    ref: Q,
                    style: {
                        clipPath: em
                    },
                    className: (0, C.m)("rounded-[6px] p-[1px]", "light" === M && "bg-camo-400", "dark" === M && "bg-camo-700", p),
                    ...z,
                    children: (0, v.jsx)("div", {
                        style: {
                            clipPath: em
                        },
                        className: (0, C.m)("relative h-max w-max rounded-[5px] bg-camo-700", ec, eo, el),
                        children: _.Children.map(c, l => _.isValidElement(l) && "function" == typeof l.type ? "ContentFrameHead" === getComponentName(l) ? (0, v.jsx)("div", {
                            ref: J,
                            className: (0, C.m)("absolute right-0 top-0", ec, eh),
                            children: l
                        }) : "ContentFrameFoot" === getComponentName(l) ? (0, v.jsx)("div", {
                            className: "absolute bottom-5 left-8",
                            children: l
                        }) : l : l)
                    })
                })
            }
            let ContentFrameHead = l => (0, v.jsx)(v.Fragment, {
                children: l.children
            });
            ContentFrameHead.displayName = "ContentFrameHead"
        },
        4656: function(l, c, p) {
            "use strict";
            p.d(c, {
                u_: function() {
                    return Modal
                },
                Io: function() {
                    return P
                }
            });
            var v = p(4817);
            p(1248);
            var _ = p(2244),
                C = p(5447);

            function Modal(l) {
                let {
                    ariaLabel: c,
                    children: p,
                    closeOnBackdropClick: P = !0,
                    closeOnEscape: T = !0,
                    onClose: M,
                    open: z,
                    variant: J = "translucent"
                } = l;
                return (0, v.jsx)(C.a, {
                    autoFocus: !1,
                    backdropStyle: J,
                    closeOnBackdropClick: P,
                    closeOnEscape: T,
                    isOpen: z,
                    onClose: M,
                    children: (0, v.jsx)("div", {
                        className: "pointer-events-none absolute inset-0 z-50 flex items-center justify-center",
                        children: (0, v.jsx)(_.ye, {
                            "aria-modal": !0,
                            "aria-label": c,
                            className: "pointer-events-auto",
                            frameSize: "large",
                            role: "dialog",
                            variant: "translucent" === J ? "light" : "dark",
                            children: p
                        })
                    })
                })
            }
            let P = _.xi
        },
        5447: function(l, c, p) {
            "use strict";
            p.d(c, {
                a: function() {
                    return Overlay
                }
            });
            var v, _, C = p(4817),
                P = p(1248);

            function _extends() {
                return (_extends = Object.assign ? Object.assign.bind() : function(l) {
                    for (var c = 1; c < arguments.length; c++) {
                        var p = arguments[c];
                        for (var v in p) Object.prototype.hasOwnProperty.call(p, v) && (l[v] = p[v])
                    }
                    return l
                }).apply(this, arguments)
            }
            var T = "data-focus-lock",
                M = "data-focus-lock-disabled",
                z = {
                    width: "1px",
                    height: "0px",
                    padding: 0,
                    overflow: "hidden",
                    position: "fixed",
                    top: "1px",
                    left: "1px"
                },
                InFocusGuard = function(l) {
                    var c = l.children;
                    return P.createElement(P.Fragment, null, P.createElement("div", {
                        key: "guard-first",
                        "data-focus-guard": !0,
                        "data-focus-auto-guard": !0,
                        style: z
                    }), c, c && P.createElement("div", {
                        key: "guard-last",
                        "data-focus-guard": !0,
                        "data-focus-auto-guard": !0,
                        style: z
                    }))
                };
            InFocusGuard.propTypes = {}, InFocusGuard.defaultProps = {
                children: null
            };
            var __assign = function() {
                return (__assign = Object.assign || function(l) {
                    for (var c, p = 1, v = arguments.length; p < v; p++)
                        for (var _ in c = arguments[p]) Object.prototype.hasOwnProperty.call(c, _) && (l[_] = c[_]);
                    return l
                }).apply(this, arguments)
            };

            function ItoI(l) {
                return l
            }

            function innerCreateMedium(l, c) {
                void 0 === c && (c = ItoI);
                var p = [],
                    v = !1;
                return {
                    read: function() {
                        if (v) throw Error("Sidecar: could not `read` from an `assigned` medium. `read` could be used only with `useMedium`.");
                        return p.length ? p[p.length - 1] : l
                    },
                    useMedium: function(l) {
                        var _ = c(l, v);
                        return p.push(_),
                            function() {
                                p = p.filter(function(l) {
                                    return l !== _
                                })
                            }
                    },
                    assignSyncMedium: function(l) {
                        for (v = !0; p.length;) {
                            var c = p;
                            p = [], c.forEach(l)
                        }
                        p = {
                            push: function(c) {
                                return l(c)
                            },
                            filter: function() {
                                return p
                            }
                        }
                    },
                    assignMedium: function(l) {
                        v = !0;
                        var c = [];
                        if (p.length) {
                            var _ = p;
                            p = [], _.forEach(l), c = p
                        }
                        var executeQueue = function() {
                                var p = c;
                                c = [], p.forEach(l)
                            },
                            cycle = function() {
                                return Promise.resolve().then(executeQueue)
                            };
                        cycle(), p = {
                            push: function(l) {
                                c.push(l), cycle()
                            },
                            filter: function(l) {
                                return c = c.filter(l), p
                            }
                        }
                    }
                }
            }

            function createMedium(l, c) {
                return void 0 === c && (c = ItoI), innerCreateMedium(l, c)
            }
            "function" == typeof SuppressedError && SuppressedError;
            var J = createMedium({}, function(l) {
                    return {
                        target: l.target,
                        currentTarget: l.currentTarget
                    }
                }),
                Q = createMedium(),
                X = createMedium(),
                es = ((v = innerCreateMedium(null)).options = __assign({
                    async: !0,
                    ssr: !1
                }, {
                    async: !0
                }), v),
                eo = [],
                el = P.forwardRef(function(l, c) {
                    var p, v, _, C, X = P.useState(),
                        el = X[0],
                        ec = X[1],
                        eh = P.useRef(),
                        ed = P.useRef(!1),
                        ef = P.useRef(null),
                        ep = l.children,
                        eg = l.disabled,
                        em = l.noFocusGuards,
                        ey = l.persistentFocus,
                        eb = l.crossFrame,
                        ew = l.autoFocus,
                        ex = (l.allowTextSelection, l.group),
                        e_ = l.className,
                        eE = l.whiteList,
                        eA = l.hasPositiveIndices,
                        eC = l.shards,
                        eS = void 0 === eC ? eo : eC,
                        eN = l.as,
                        eP = void 0 === eN ? "div" : eN,
                        eD = l.lockProps,
                        ek = void 0 === eD ? {} : eD,
                        eI = l.sideCar,
                        eO = l.returnFocus,
                        ej = l.focusOptions,
                        eT = l.onActivation,
                        eR = l.onDeactivation,
                        eL = P.useState({})[0],
                        eM = P.useCallback(function() {
                            ef.current = ef.current || document && document.activeElement, eh.current && eT && eT(eh.current), ed.current = !0
                        }, [eT]),
                        eU = P.useCallback(function() {
                            ed.current = !1, eR && eR(eh.current)
                        }, [eR]);
                    (0, P.useEffect)(function() {
                        eg || (ef.current = null)
                    }, []);
                    var eB = P.useCallback(function(l) {
                            var c = ef.current;
                            if (c && c.focus) {
                                var p = "function" == typeof eO ? eO(c) : eO;
                                if (p) {
                                    var v = "object" == typeof p ? p : void 0;
                                    ef.current = null, l ? Promise.resolve().then(function() {
                                        return c.focus(v)
                                    }) : c.focus(v)
                                }
                            }
                        }, [eO]),
                        eF = P.useCallback(function(l) {
                            ed.current && J.useMedium(l)
                        }, []),
                        eH = Q.useMedium,
                        eV = P.useCallback(function(l) {
                            eh.current !== l && (eh.current = l, ec(l))
                        }, []),
                        ez = _extends(((C = {})[M] = eg && "disabled", C[T] = ex, C), ek),
                        eW = !0 !== em,
                        eG = eW && "tail" !== em,
                        eK = (p = [c, eV], v = function(l) {
                            return p.forEach(function(c) {
                                return "function" == typeof c ? c(l) : c && (c.current = l), c
                            })
                        }, (_ = (0, P.useState)(function() {
                            return {
                                value: null,
                                callback: v,
                                facade: {
                                    get current() {
                                        return _.value
                                    },
                                    set current(value) {
                                        var l = _.value;
                                        l !== value && (_.value = value, _.callback(value, l))
                                    }
                                }
                            }
                        })[0]).callback = v, _.facade);
                    return P.createElement(P.Fragment, null, eW && [P.createElement("div", {
                        key: "guard-first",
                        "data-focus-guard": !0,
                        tabIndex: eg ? -1 : 0,
                        style: z
                    }), eA ? P.createElement("div", {
                        key: "guard-nearest",
                        "data-focus-guard": !0,
                        tabIndex: eg ? -1 : 1,
                        style: z
                    }) : null], !eg && P.createElement(eI, {
                        id: eL,
                        sideCar: es,
                        observed: el,
                        disabled: eg,
                        persistentFocus: ey,
                        crossFrame: eb,
                        autoFocus: ew,
                        whiteList: eE,
                        shards: eS,
                        onActivation: eM,
                        onDeactivation: eU,
                        returnFocus: eB,
                        focusOptions: ej
                    }), P.createElement(eP, _extends({
                        ref: eK
                    }, ez, {
                        className: e_,
                        onBlur: eH,
                        onFocus: eF
                    }), ep), eG && P.createElement("div", {
                        "data-focus-guard": !0,
                        tabIndex: eg ? -1 : 0,
                        style: z
                    }))
                });

            function _setPrototypeOf(l, c) {
                return (_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(l, c) {
                    return l.__proto__ = c, l
                })(l, c)
            }

            function _typeof(l) {
                return (_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(l) {
                    return typeof l
                } : function(l) {
                    return l && "function" == typeof Symbol && l.constructor === Symbol && l !== Symbol.prototype ? "symbol" : typeof l
                })(l)
            }
            el.propTypes = {}, el.defaultProps = {
                children: void 0,
                disabled: !1,
                returnFocus: !1,
                focusOptions: void 0,
                noFocusGuards: !1,
                autoFocus: !0,
                persistentFocus: !1,
                crossFrame: !0,
                hasPositiveIndices: void 0,
                allowTextSelection: void 0,
                group: void 0,
                className: void 0,
                whiteList: void 0,
                shards: void 0,
                as: "div",
                lockProps: {},
                onActivation: void 0,
                onDeactivation: void 0
            };
            var toArray = function(l) {
                    for (var c = Array(l.length), p = 0; p < l.length; ++p) c[p] = l[p];
                    return c
                },
                asArray = function(l) {
                    return Array.isArray(l) ? l : [l]
                },
                getFirst = function(l) {
                    return Array.isArray(l) ? l[0] : l
                },
                isElementHidden = function(l) {
                    if (l.nodeType !== Node.ELEMENT_NODE) return !1;
                    var c = window.getComputedStyle(l, null);
                    return !!c && !!c.getPropertyValue && ("none" === c.getPropertyValue("display") || "hidden" === c.getPropertyValue("visibility"))
                },
                getParentNode = function(l) {
                    return l.parentNode && l.parentNode.nodeType === Node.DOCUMENT_FRAGMENT_NODE ? l.parentNode.host : l.parentNode
                },
                isTopNode = function(l) {
                    return l === document || l && l.nodeType === Node.DOCUMENT_NODE
                },
                isVisibleCached = function(l, c) {
                    var p, v = l.get(c);
                    if (void 0 !== v) return v;
                    var _ = (p = isVisibleCached.bind(void 0, l), !c || isTopNode(c) || !isElementHidden(c) && p(getParentNode(c)));
                    return l.set(c, _), _
                },
                isAutoFocusAllowedCached = function(l, c) {
                    var p, v = l.get(c);
                    if (void 0 !== v) return v;
                    var _ = (p = isAutoFocusAllowedCached.bind(void 0, l), !c || !!isTopNode(c) || !!isAutoFocusAllowed(c) && p(getParentNode(c)));
                    return l.set(c, _), _
                },
                getDataset = function(l) {
                    return l.dataset
                },
                isHTMLInputElement = function(l) {
                    return "INPUT" === l.tagName
                },
                isRadioElement = function(l) {
                    return isHTMLInputElement(l) && "radio" === l.type
                },
                isAutoFocusAllowed = function(l) {
                    return ![!0, "true", ""].includes(l.getAttribute("data-no-autofocus"))
                },
                isGuard = function(l) {
                    var c;
                    return !!(l && (null === (c = getDataset(l)) || void 0 === c ? void 0 : c.focusGuard))
                },
                isNotAGuard = function(l) {
                    return !isGuard(l)
                },
                isDefined = function(l) {
                    return !!l
                },
                tabSort = function(l, c) {
                    var p = l.tabIndex - c.tabIndex,
                        v = l.index - c.index;
                    if (p) {
                        if (!l.tabIndex) return 1;
                        if (!c.tabIndex) return -1
                    }
                    return p || v
                },
                orderByTabIndex = function(l, c, p) {
                    return toArray(l).map(function(l, c) {
                        return {
                            node: l,
                            index: c,
                            tabIndex: p && -1 === l.tabIndex ? (l.dataset || {}).focusGuard ? 0 : -1 : l.tabIndex
                        }
                    }).filter(function(l) {
                        return !c || l.tabIndex >= 0
                    }).sort(tabSort)
                },
                ec = "button:enabled,select:enabled,textarea:enabled,input:enabled,a[href],area[href],summary,iframe,object,embed,audio[controls],video[controls],[tabindex],[contenteditable],[autofocus]",
                eh = "".concat(ec, ", [data-focus-guard]"),
                getFocusablesWithShadowDom = function(l, c) {
                    return toArray((l.shadowRoot || l).children).reduce(function(l, p) {
                        return l.concat(p.matches(c ? eh : ec) ? [p] : [], getFocusablesWithShadowDom(p))
                    }, [])
                },
                getFocusablesWithIFrame = function(l, c) {
                    var p;
                    return l instanceof HTMLIFrameElement && (null === (p = l.contentDocument) || void 0 === p ? void 0 : p.body) ? getFocusables([l.contentDocument.body], c) : [l]
                },
                getFocusables = function(l, c) {
                    return l.reduce(function(l, p) {
                        var v, _ = getFocusablesWithShadowDom(p, c),
                            C = (v = []).concat.apply(v, _.map(function(l) {
                                return getFocusablesWithIFrame(l, c)
                            }));
                        return l.concat(C, p.parentNode ? toArray(p.parentNode.querySelectorAll(ec)).filter(function(l) {
                            return l === p
                        }) : [])
                    }, [])
                },
                filterFocusable = function(l, c) {
                    return toArray(l).filter(function(l) {
                        return isVisibleCached(c, l)
                    }).filter(function(l) {
                        return !((isHTMLInputElement(l) || "BUTTON" === l.tagName) && ("hidden" === l.type || l.disabled))
                    })
                },
                filterAutoFocusable = function(l, c) {
                    return void 0 === c && (c = new Map), toArray(l).filter(function(l) {
                        return isAutoFocusAllowedCached(c, l)
                    })
                },
                getTabbableNodes = function(l, c, p) {
                    return orderByTabIndex(filterFocusable(getFocusables(l, p), c), !0, p)
                },
                getFocusableNodes = function(l, c) {
                    return orderByTabIndex(filterFocusable(getFocusables(l), c), !1)
                },
                contains = function(l, c) {
                    return l.shadowRoot ? contains(l.shadowRoot, c) : !!(void 0 !== Object.getPrototypeOf(l).contains && Object.getPrototypeOf(l).contains.call(l, c)) || toArray(l.children).some(function(l) {
                        var p;
                        if (l instanceof HTMLIFrameElement) {
                            var v = null === (p = l.contentDocument) || void 0 === p ? void 0 : p.body;
                            return !!v && contains(v, c)
                        }
                        return contains(l, c)
                    })
                },
                safeProbe = function(l) {
                    try {
                        return l()
                    } catch (l) {
                        return
                    }
                },
                getActiveElement = function(l) {
                    if (void 0 === l && (l = document), l && l.activeElement) {
                        var c = l.activeElement;
                        return c.shadowRoot ? getActiveElement(c.shadowRoot) : c instanceof HTMLIFrameElement && safeProbe(function() {
                            return c.contentWindow.document
                        }) ? getActiveElement(c.contentWindow.document) : c
                    }
                },
                focusIsHidden = function(l) {
                    void 0 === l && (l = document);
                    var c = getActiveElement(l);
                    return !!c && toArray(l.querySelectorAll("[".concat("data-no-focus-lock", "]"))).some(function(l) {
                        return contains(l, c)
                    })
                },
                filterNested = function(l) {
                    for (var c = new Set, p = l.length, v = 0; v < p; v += 1)
                        for (var _ = v + 1; _ < p; _ += 1) {
                            var C = l[v].compareDocumentPosition(l[_]);
                            (C & Node.DOCUMENT_POSITION_CONTAINED_BY) > 0 && c.add(_), (C & Node.DOCUMENT_POSITION_CONTAINS) > 0 && c.add(v)
                        }
                    return l.filter(function(l, p) {
                        return !c.has(p)
                    })
                },
                getTopParent = function(l) {
                    return l.parentNode ? getTopParent(l.parentNode) : l
                },
                getAllAffectedNodes = function(l) {
                    return asArray(l).filter(Boolean).reduce(function(l, c) {
                        var p = c.getAttribute(T);
                        return l.push.apply(l, p ? filterNested(toArray(getTopParent(c).querySelectorAll("[".concat(T, '="').concat(p, '"]:not([').concat(M, '="disabled"])')))) : [c]), l
                    }, [])
                },
                focusInside = function(l, c) {
                    return void 0 === c && (c = getActiveElement(getFirst(l).ownerDocument)), !!c && (!c.dataset || !c.dataset.focusGuard) && getAllAffectedNodes(l).some(function(l) {
                        var p;
                        return contains(l, c) || (p = c, !!toArray(l.querySelectorAll("iframe")).some(function(l) {
                            return l === p
                        }))
                    })
                },
                focusOn = function(l, c) {
                    "focus" in l && l.focus(c), "contentWindow" in l && l.contentWindow && l.contentWindow.focus()
                },
                correctNode = function(l, c) {
                    return isRadioElement(l) && l.name && c.filter(isRadioElement).filter(function(c) {
                        return c.name === l.name
                    }).filter(function(l) {
                        return l.checked
                    })[0] || l
                },
                correctNodes = function(l) {
                    var c = new Set;
                    return l.forEach(function(p) {
                        return c.add(correctNode(p, l))
                    }), l.filter(function(l) {
                        return c.has(l)
                    })
                },
                pickFirstFocus = function(l) {
                    return l[0] && l.length > 1 ? correctNode(l[0], l) : l[0]
                },
                pickFocusable = function(l, c) {
                    return l.length > 1 ? l.indexOf(correctNode(l[c], l)) : c
                },
                ed = "NEW_FOCUS",
                newFocus = function(l, c, p, v) {
                    var _ = l.length,
                        C = l[0],
                        P = l[_ - 1],
                        T = isGuard(p);
                    if (!(p && l.indexOf(p) >= 0)) {
                        var M = void 0 !== p ? c.indexOf(p) : -1,
                            z = v ? c.indexOf(v) : M,
                            J = v ? l.indexOf(v) : -1,
                            Q = M - z,
                            X = c.indexOf(C),
                            es = c.indexOf(P),
                            eo = correctNodes(c),
                            el = (void 0 !== p ? eo.indexOf(p) : -1) - (v ? eo.indexOf(v) : M),
                            ec = pickFocusable(l, 0),
                            eh = pickFocusable(l, _ - 1);
                        if (-1 === M || -1 === J) return ed;
                        if (!Q && J >= 0) return J;
                        if (M <= X && T && Math.abs(Q) > 1) return eh;
                        if (M >= es && T && Math.abs(Q) > 1) return ec;
                        if (Q && Math.abs(el) > 1) return J;
                        if (M <= X) return eh;
                        if (M > es) return ec;
                        if (Q) return Math.abs(Q) > 1 ? J : (_ + J + Q) % _
                    }
                },
                pickAutofocus = function(l, c, p) {
                    var v = filterAutoFocusable(l.map(function(l) {
                        return l.node
                    }).filter(function(l) {
                        var c, v = null === (c = getDataset(l)) || void 0 === c ? void 0 : c.autofocus;
                        return l.autofocus || void 0 !== v && "false" !== v || p.indexOf(l) >= 0
                    }));
                    return v && v.length ? pickFirstFocus(v) : pickFirstFocus(filterAutoFocusable(c))
                },
                getParents = function(l, c) {
                    return void 0 === c && (c = []), c.push(l), l.parentNode && getParents(l.parentNode.host || l.parentNode, c), c
                },
                getCommonParent = function(l, c) {
                    for (var p = getParents(l), v = getParents(c), _ = 0; _ < p.length; _ += 1) {
                        var C = p[_];
                        if (v.indexOf(C) >= 0) return C
                    }
                    return !1
                },
                getTopCommonParent = function(l, c, p) {
                    var v = asArray(l),
                        _ = asArray(c),
                        C = v[0],
                        P = !1;
                    return _.filter(Boolean).forEach(function(l) {
                        P = getCommonParent(P || l, l) || P, p.filter(Boolean).forEach(function(l) {
                            var c = getCommonParent(C, l);
                            c && (P = !P || contains(c, P) ? c : getCommonParent(c, P))
                        })
                    }), P
                },
                reorderNodes = function(l, c) {
                    var p = new Map;
                    return c.forEach(function(l) {
                        return p.set(l.node, l)
                    }), l.map(function(l) {
                        return p.get(l)
                    }).filter(isDefined)
                },
                focusSolver = function(l, c) {
                    var p = getActiveElement(asArray(l).length > 0 ? document : getFirst(l).ownerDocument),
                        v = getAllAffectedNodes(l).filter(isNotAGuard),
                        _ = getTopCommonParent(p || l, l, v),
                        C = new Map,
                        P = getFocusableNodes(v, C),
                        T = getTabbableNodes(v, C).filter(function(l) {
                            return isNotAGuard(l.node)
                        });
                    if (T[0] || (T = P)[0]) {
                        var M = getFocusableNodes([_], C).map(function(l) {
                                return l.node
                            }),
                            z = reorderNodes(M, T),
                            J = z.map(function(l) {
                                return l.node
                            }),
                            Q = newFocus(J, M, p, c);
                        if (Q === ed) {
                            var X = pickAutofocus(P, J, v.reduce(function(l, c) {
                                return l.concat(filterFocusable(toArray(c.querySelectorAll("[".concat("data-autofocus-inside", "]"))).map(function(l) {
                                    return getFocusables([l])
                                }).reduce(function(l, c) {
                                    return l.concat(c)
                                }, []), C))
                            }, []));
                            return X ? {
                                node: X
                            } : void console.warn("focus-lock: cannot find any node to move focus into")
                        }
                        return void 0 === Q ? Q : z[Q]
                    }
                },
                ef = 0,
                ep = !1,
                moveFocusInside = function(l, c, p) {
                    void 0 === p && (p = {});
                    var v = focusSolver(l, c);
                    if (!ep && v) {
                        if (ef > 2) {
                            console.error("FocusLock: focus-fighting detected. Only one focus management system could be active. See https://github.com/theKashey/focus-lock/#focus-fighting"), ep = !0, setTimeout(function() {
                                ep = !1
                            }, 1);
                            return
                        }
                        ef++, focusOn(v.node, p.focusOptions), ef--
                    }
                },
                expandFocusableNodes = function(l) {
                    var c = getAllAffectedNodes(l).filter(isNotAGuard),
                        p = getTopCommonParent(l, l, c),
                        v = new Map,
                        _ = getTabbableNodes([p], v, !0),
                        C = getTabbableNodes(c, v).filter(function(l) {
                            return isNotAGuard(l.node)
                        }).map(function(l) {
                            return l.node
                        });
                    return _.map(function(l) {
                        var c = l.node;
                        return {
                            node: c,
                            index: l.index,
                            lockItem: C.indexOf(c) >= 0,
                            guard: isGuard(c)
                        }
                    })
                };

            function deferAction(l) {
                setTimeout(l, 1)
            }
            var eg = null,
                em = null,
                ey = null,
                eb = !1,
                recordPortal = function(l, c) {
                    ey = {
                        observerNode: l,
                        portaledElement: c
                    }
                };

            function autoGuard(l, c, p, v) {
                var _ = null,
                    C = l;
                do {
                    var P = v[C];
                    if (P.guard) P.node.dataset.focusAutoGuard && (_ = P);
                    else if (P.lockItem) {
                        if (C !== l) return;
                        _ = null
                    } else break
                } while ((C += p) !== c);
                _ && (_.node.tabIndex = 0)
            }
            var extractRef = function(l) {
                    return l && "current" in l ? l.current : l
                },
                activateTrap = function() {
                    var l = !1;
                    if (eg) {
                        var c = eg,
                            p = c.observed,
                            v = c.persistentFocus,
                            _ = c.autoFocus,
                            C = c.shards,
                            P = c.crossFrame,
                            T = c.focusOptions,
                            M = p || ey && ey.portaledElement,
                            z = document && document.activeElement;
                        if (M) {
                            var J = [M].concat(C.map(extractRef).filter(Boolean));
                            if ((!z || (eg.whiteList || function() {
                                    return !0
                                })(z)) && (v || (P ? !!eb : "meanwhile" === eb) || !(document && document.activeElement === document.body || focusIsHidden()) || !em && _) && (M && !(focusInside(J) || z && J.some(function(l) {
                                    return function checkInHost(l, c, p) {
                                        return c && (c.host === l && (!c.activeElement || p.contains(c.activeElement)) || c.parentNode && checkInHost(l, c.parentNode, p))
                                    }(z, l, l)
                                }) || ey && ey.portaledElement === z) && (document && !em && z && !_ ? (z.blur && z.blur(), document.body.focus()) : (l = moveFocusInside(J, em, {
                                    focusOptions: T
                                }), ey = {})), eb = !1, em = document && document.activeElement), document) {
                                var Q = document && document.activeElement,
                                    X = expandFocusableNodes(J),
                                    es = X.map(function(l) {
                                        return l.node
                                    }).indexOf(Q);
                                es > -1 && (X.filter(function(l) {
                                    var c = l.guard,
                                        p = l.node;
                                    return c && p.dataset.focusAutoGuard
                                }).forEach(function(l) {
                                    return l.node.removeAttribute("tabIndex")
                                }), autoGuard(es, X.length, 1, X), autoGuard(es, -1, -1, X))
                            }
                        }
                    }
                    return l
                },
                onTrap = function(l) {
                    activateTrap() && l && (l.stopPropagation(), l.preventDefault())
                },
                onBlur = function() {
                    return deferAction(activateTrap)
                },
                onWindowBlur = function() {
                    eb = "just", deferAction(function() {
                        eb = "meanwhile"
                    })
                },
                attachHandler = function() {
                    document.addEventListener("focusin", onTrap), document.addEventListener("focusout", onBlur), window.addEventListener("blur", onWindowBlur)
                },
                detachHandler = function() {
                    document.removeEventListener("focusin", onTrap), document.removeEventListener("focusout", onBlur), window.removeEventListener("blur", onWindowBlur)
                };
            J.assignSyncMedium(function(l) {
                var c = l.target,
                    p = l.currentTarget;
                p.contains(c) || recordPortal(p, c)
            }), Q.assignMedium(onBlur), X.assignMedium(function(l) {
                return l({
                    moveFocusInside: moveFocusInside,
                    focusInside: focusInside
                })
            });
            var ew = (_ = function(l) {
                    var c = l.slice(-1)[0];
                    c && !eg && attachHandler();
                    var p = eg,
                        v = p && c && c.id === p.id;
                    eg = c, !p || v || (p.onDeactivation(), l.filter(function(l) {
                        return l.id === p.id
                    }).length || p.returnFocus(!c)), c ? (em = null, v && p.observed === c.observed || c.onActivation(), activateTrap(!0), deferAction(activateTrap)) : (detachHandler(), em = null)
                }, function(l) {
                    var c, p, v, C, T = [];

                    function emitChange() {
                        _(C = T.map(function(l) {
                            return l.props
                        }).filter(function(l) {
                            return !l.disabled
                        }))
                    }
                    var M = function(c) {
                        function SideEffect() {
                            return c.apply(this, arguments) || this
                        }
                        SideEffect.prototype = Object.create(c.prototype), SideEffect.prototype.constructor = SideEffect, _setPrototypeOf(SideEffect, c), SideEffect.peek = function() {
                            return C
                        };
                        var p = SideEffect.prototype;
                        return p.componentDidMount = function() {
                            T.push(this), emitChange()
                        }, p.componentDidUpdate = function() {
                            emitChange()
                        }, p.componentWillUnmount = function() {
                            var l = T.indexOf(this);
                            T.splice(l, 1), emitChange()
                        }, p.render = function() {
                            return P.createElement(l, this.props)
                        }, SideEffect
                    }(P.PureComponent);
                    return c = "displayName", p = "SideEffect(" + (l.displayName || l.name || "Component") + ")", v = function(l, c) {
                        if ("object" !== _typeof(l) || null === l) return l;
                        var p = l[Symbol.toPrimitive];
                        if (void 0 !== p) {
                            var v = p.call(l, c || "default");
                            if ("object" !== _typeof(v)) return v;
                            throw TypeError("@@toPrimitive must return a primitive value.")
                        }
                        return ("string" === c ? String : Number)(l)
                    }(c, "string"), (c = "symbol" === _typeof(v) ? v : String(v)) in M ? Object.defineProperty(M, c, {
                        value: p,
                        enumerable: !0,
                        configurable: !0,
                        writable: !0
                    }) : M[c] = p, M
                })(function() {
                    return null
                }),
                ex = P.forwardRef(function(l, c) {
                    return P.createElement(el, _extends({
                        sideCar: ew,
                        ref: c
                    }, l))
                }),
                e_ = el.propTypes || {};
            e_.sideCar,
                function(l, c) {
                    if (null != l) {
                        var p, v, _ = {},
                            C = Object.keys(l);
                        for (v = 0; v < C.length; v++) c.indexOf(p = C[v]) >= 0 || (_[p] = l[p])
                    }
                }(e_, ["sideCar"]), ex.propTypes = {};
            var eE = p(1389),
                eA = p(7657),
                eC = p(3460),
                eS = p(5834);

            function Overlay(l) {
                let {
                    autoFocus: c = !0,
                    backdropStyle: p = "translucent",
                    children: v,
                    closeOnBackdropClick: _ = !0,
                    closeOnEscape: T = !0,
                    closeOnOutsideClick: M = !0,
                    isOpen: z,
                    lockFocus: J = !0,
                    lockScroll: Q = !0,
                    onClose: X
                } = l, [es, eo] = P.useState(null);
                return (0, eC.Pr)(Q && z), P.useEffect(() => {
                    if (!z || !T) return;
                    let handleKeyDown = l => {
                        "Escape" === l.key && (null == X || X())
                    };
                    return document.addEventListener("keydown", handleKeyDown), () => document.removeEventListener("keydown", handleKeyDown)
                }, [T, z, X]), P.useEffect(() => {
                    if (!z || !M || !es) return;
                    let handleClick = l => {
                            es.contains(l.target) || null == X || X()
                        },
                        l = setTimeout(() => {
                            document.addEventListener("click", handleClick)
                        }, 0);
                    return () => {
                        clearTimeout(l), document.removeEventListener("click", handleClick)
                    }
                }, [M, es, z, X]), (0, C.jsx)(eS.h_, {
                    children: (0, C.jsx)(eA.WV, {
                        appear: !1,
                        in: z,
                        children: (0, C.jsxs)("div", {
                            ref: eo,
                            className: "pointer-events-none fixed inset-0 z-50",
                            children: ["none" !== p && (0, C.jsx)("div", {
                                onClick: _ ? X : void 0,
                                className: (0, eE.m)("pointer-events-auto absolute inset-0", "translucent" === p && "bg-black/90", "opaque" === p && "bg-black/100")
                            }), (0, C.jsx)(ex, {
                                autoFocus: c,
                                className: "pointer-events-auto",
                                disabled: !J,
                                children: v
                            })]
                        })
                    })
                })
            }
        },
        5834: function(l, c, p) {
            "use strict";
            p.d(c, {
                zx: function() {
                    return M.z
                },
                Vq: function() {
                    return Dialog
                },
                JO: function() {
                    return es
                },
                hU: function() {
                    return IconButton
                },
                aN: function() {
                    return Loader
                },
                v2: function() {
                    return Menu
                },
                u_: function() {
                    return eo.u_
                },
                Io: function() {
                    return eo.Io
                },
                J2: function() {
                    return Popover
                },
                L_: function() {
                    return eL
                },
                h_: function() {
                    return eB
                },
                u: function() {
                    return Tooltip
                }
            });
            var v, _, C, P, T, M = p(3685),
                z = p(2244),
                J = p(4817),
                Q = p(1248),
                X = p(1389);
            let Dialog = l => (0, J.jsxs)("div", {
                    className: (0, X.m)("translate-x typography-brand-body-l relative w-full rounded-lg px-11 py-4", "info" === l.variant && "bg-yellow-100 text-black", "error" === l.variant && "bg-mars-400 text-yellow-100", "notify" === l.variant && "bg-camo-500 text-yellow-100"),
                    children: [l.children, (0, J.jsx)("div", {
                        "aria-hidden": !0,
                        className: (0, X.m)("absolute -top-2 left-0", "info" === l.variant && "text-yellow-100", "error" === l.variant && "text-mars-400", "notify" === l.variant && "text-camo-500"),
                        children: (0, J.jsx)("svg", {
                            fill: "none",
                            height: "19",
                            width: "263",
                            xmlns: "http://www.w3.org/2000/svg",
                            children: (0, J.jsx)("path", {
                                d: "M.00094438 18.9998 262.211 18.9999V9.43519L242.839-.0000017 49.3963.0000162 30.0255 9.43525 9.56557 9.43524c-5.2824 0-9.56462515 4.28226-9.56462562 9.56456Z",
                                fill: "currentColor"
                            })
                        })
                    })]
                }),
                es = Q.forwardRef((l, c) => {
                    let {
                        height: p = 24,
                        name: v,
                        width: _ = 24,
                        ...C
                    } = l;
                    return (0, J.jsx)("svg", {
                        ref: c,
                        style: {
                            height: p,
                            width: _
                        },
                        viewBox: "0 0 24 24",
                        ...C,
                        children: (0, J.jsx)("use", {
                            xlinkHref: "/icons/library.svg#".concat(v)
                        })
                    })
                });
            es.displayName = "Icon";
            let IconButton = l => {
                    let {
                        ariaLabelCase: c = "uppercase",
                        name: p,
                        onClick: v,
                        renderAriaLabel: _,
                        variant: C = "primary",
                        ...P
                    } = l;
                    return (0, J.jsxs)("button", { ...P,
                        onClick: v,
                        className: (0, X.m)("primary" === C && "text-yellow-300", "secondary" === C && "text-yellow-100", "tertiary" === C && "text-camo-300", "before" === _ && "flex-row overflow-hidden", "after" === _ && "flex-row-reverse overflow-hidden", "uppercase" === c ? "uppercase" : "", "interactive-text flex items-center gap-1 disabled:cursor-not-allowed"),
                        title: "title" === _ ? P["aria-label"] : P.title,
                        children: [("before" === _ || "after" === _) && (0, J.jsx)("span", {
                            className: "flex-1 overflow-hidden text-ellipsis whitespace-nowrap",
                            children: P["aria-label"]
                        }), (0, J.jsx)(es, {
                            name: p
                        })]
                    })
                },
                Loader = () => (0, J.jsxs)("div", {
                    className: "flex gap-1",
                    children: [(0, J.jsx)("div", {
                        className: "h-6 w-[3px] animate-loader-camo [animation-delay:0ms]"
                    }), (0, J.jsx)("div", {
                        className: "h-6 w-[3px] animate-loader-camo [animation-delay:250ms]"
                    }), (0, J.jsx)("div", {
                        className: "h-6 w-[3px] animate-loader-camo [animation-delay:500ms]"
                    })]
                });

            function Menu(l) {
                let {
                    idFunction: c = l => String(l),
                    items: p,
                    labelFunction: v = l => String(l),
                    onSelect: _,
                    selectedItem: C
                } = l, [P, T] = Q.useState(-1);
                return (0, J.jsx)("div", {
                    className: "flex w-64 flex-col gap-0.5",
                    onKeyDown: function(l) {
                        switch (l.key) {
                            case "ArrowDown":
                                T(l => Math.min(l + 1, p.length - 1));
                                break;
                            case "ArrowUp":
                                T(l => Math.max(l - 1, 0));
                                break;
                            case "Enter":
                            case " ":
                                {
                                    let l = p[P];l && _(l)
                                }
                        }
                    },
                    role: "menu",
                    children: p.map((l, p) => (0, J.jsx)(MenuItem, {
                        active: p === P,
                        label: v(l),
                        onClick: () => _(l),
                        onMouseEnter: () => T(p),
                        selected: l === C
                    }, c(l)))
                })
            }

            function MenuItem(l) {
                let {
                    active: c,
                    label: p,
                    selected: v,
                    ..._
                } = l;
                return (0, J.jsxs)("div", {
                    role: "menuitem",
                    tabIndex: c ? 0 : -1,
                    className: (0, X.m)("typography-brand-body-l-caps flex h-8 cursor-pointer items-center justify-between rounded px-4 text-camo-200 focus:outline-none", v && "bg-camo-600 text-yellow-100", c && "bg-white text-camo-700"),
                    ..._,
                    children: [(0, J.jsx)("div", {
                        children: p
                    }), v && (0, J.jsx)(es, {
                        name: "checkmark-circle"
                    })]
                })
            }
            var eo = p(4656),
                el = p(5447),
                ec = p(2336);

            function getWindow(l) {
                if (null == l) return window;
                if ("[object Window]" !== l.toString()) {
                    var c = l.ownerDocument;
                    return c && c.defaultView || window
                }
                return l
            }

            function isElement(l) {
                var c = getWindow(l).Element;
                return l instanceof c || l instanceof Element
            }

            function isHTMLElement(l) {
                var c = getWindow(l).HTMLElement;
                return l instanceof c || l instanceof HTMLElement
            }

            function isShadowRoot(l) {
                if ("undefined" == typeof ShadowRoot) return !1;
                var c = getWindow(l).ShadowRoot;
                return l instanceof c || l instanceof ShadowRoot
            }
            var eh = Math.max,
                ed = Math.min,
                ef = Math.round;

            function getUAString() {
                var l = navigator.userAgentData;
                return null != l && l.brands && Array.isArray(l.brands) ? l.brands.map(function(l) {
                    return l.brand + "/" + l.version
                }).join(" ") : navigator.userAgent
            }

            function isLayoutViewport() {
                return !/^((?!chrome|android).)*safari/i.test(getUAString())
            }

            function getBoundingClientRect(l, c, p) {
                void 0 === c && (c = !1), void 0 === p && (p = !1);
                var v = l.getBoundingClientRect(),
                    _ = 1,
                    C = 1;
                c && isHTMLElement(l) && (_ = l.offsetWidth > 0 && ef(v.width) / l.offsetWidth || 1, C = l.offsetHeight > 0 && ef(v.height) / l.offsetHeight || 1);
                var P = (isElement(l) ? getWindow(l) : window).visualViewport,
                    T = !isLayoutViewport() && p,
                    M = (v.left + (T && P ? P.offsetLeft : 0)) / _,
                    z = (v.top + (T && P ? P.offsetTop : 0)) / C,
                    J = v.width / _,
                    Q = v.height / C;
                return {
                    width: J,
                    height: Q,
                    top: z,
                    right: M + J,
                    bottom: z + Q,
                    left: M,
                    x: M,
                    y: z
                }
            }

            function getWindowScroll(l) {
                var c = getWindow(l);
                return {
                    scrollLeft: c.pageXOffset,
                    scrollTop: c.pageYOffset
                }
            }

            function getNodeName(l) {
                return l ? (l.nodeName || "").toLowerCase() : null
            }

            function getDocumentElement(l) {
                return ((isElement(l) ? l.ownerDocument : l.document) || window.document).documentElement
            }

            function getWindowScrollBarX(l) {
                return getBoundingClientRect(getDocumentElement(l)).left + getWindowScroll(l).scrollLeft
            }

            function getComputedStyle(l) {
                return getWindow(l).getComputedStyle(l)
            }

            function isScrollParent(l) {
                var c = getComputedStyle(l),
                    p = c.overflow,
                    v = c.overflowX,
                    _ = c.overflowY;
                return /auto|scroll|overlay|hidden/.test(p + _ + v)
            }

            function getLayoutRect(l) {
                var c = getBoundingClientRect(l),
                    p = l.offsetWidth,
                    v = l.offsetHeight;
                return 1 >= Math.abs(c.width - p) && (p = c.width), 1 >= Math.abs(c.height - v) && (v = c.height), {
                    x: l.offsetLeft,
                    y: l.offsetTop,
                    width: p,
                    height: v
                }
            }

            function getParentNode(l) {
                return "html" === getNodeName(l) ? l : l.assignedSlot || l.parentNode || (isShadowRoot(l) ? l.host : null) || getDocumentElement(l)
            }

            function listScrollParents(l, c) {
                void 0 === c && (c = []);
                var p, v = function getScrollParent(l) {
                        return ["html", "body", "#document"].indexOf(getNodeName(l)) >= 0 ? l.ownerDocument.body : isHTMLElement(l) && isScrollParent(l) ? l : getScrollParent(getParentNode(l))
                    }(l),
                    _ = v === (null == (p = l.ownerDocument) ? void 0 : p.body),
                    C = getWindow(v),
                    P = _ ? [C].concat(C.visualViewport || [], isScrollParent(v) ? v : []) : v,
                    T = c.concat(P);
                return _ ? T : T.concat(listScrollParents(getParentNode(P)))
            }

            function getTrueOffsetParent(l) {
                return isHTMLElement(l) && "fixed" !== getComputedStyle(l).position ? l.offsetParent : null
            }

            function getOffsetParent(l) {
                for (var c = getWindow(l), p = getTrueOffsetParent(l); p && ["table", "td", "th"].indexOf(getNodeName(p)) >= 0 && "static" === getComputedStyle(p).position;) p = getTrueOffsetParent(p);
                return p && ("html" === getNodeName(p) || "body" === getNodeName(p) && "static" === getComputedStyle(p).position) ? c : p || function(l) {
                    var c = /firefox/i.test(getUAString());
                    if (/Trident/i.test(getUAString()) && isHTMLElement(l) && "fixed" === getComputedStyle(l).position) return null;
                    var p = getParentNode(l);
                    for (isShadowRoot(p) && (p = p.host); isHTMLElement(p) && 0 > ["html", "body"].indexOf(getNodeName(p));) {
                        var v = getComputedStyle(p);
                        if ("none" !== v.transform || "none" !== v.perspective || "paint" === v.contain || -1 !== ["transform", "perspective"].indexOf(v.willChange) || c && "filter" === v.willChange || c && v.filter && "none" !== v.filter) return p;
                        p = p.parentNode
                    }
                    return null
                }(l) || c
            }
            var ep = "bottom",
                eg = "right",
                em = "left",
                ey = "auto",
                eb = ["top", ep, eg, em],
                ew = "start",
                ex = "viewport",
                e_ = "popper",
                eE = eb.reduce(function(l, c) {
                    return l.concat([c + "-" + ew, c + "-end"])
                }, []),
                eA = [].concat(eb, [ey]).reduce(function(l, c) {
                    return l.concat([c, c + "-" + ew, c + "-end"])
                }, []),
                eC = ["beforeRead", "read", "afterRead", "beforeMain", "main", "afterMain", "beforeWrite", "write", "afterWrite"],
                eS = {
                    placement: "bottom",
                    modifiers: [],
                    strategy: "absolute"
                };

            function areValidElements() {
                for (var l = arguments.length, c = Array(l), p = 0; p < l; p++) c[p] = arguments[p];
                return !c.some(function(l) {
                    return !(l && "function" == typeof l.getBoundingClientRect)
                })
            }
            var eN = {
                passive: !0
            };

            function getBasePlacement(l) {
                return l.split("-")[0]
            }

            function getVariation(l) {
                return l.split("-")[1]
            }

            function getMainAxisFromPlacement(l) {
                return ["top", "bottom"].indexOf(l) >= 0 ? "x" : "y"
            }

            function computeOffsets(l) {
                var c, p = l.reference,
                    v = l.element,
                    _ = l.placement,
                    C = _ ? getBasePlacement(_) : null,
                    P = _ ? getVariation(_) : null,
                    T = p.x + p.width / 2 - v.width / 2,
                    M = p.y + p.height / 2 - v.height / 2;
                switch (C) {
                    case "top":
                        c = {
                            x: T,
                            y: p.y - v.height
                        };
                        break;
                    case ep:
                        c = {
                            x: T,
                            y: p.y + p.height
                        };
                        break;
                    case eg:
                        c = {
                            x: p.x + p.width,
                            y: M
                        };
                        break;
                    case em:
                        c = {
                            x: p.x - v.width,
                            y: M
                        };
                        break;
                    default:
                        c = {
                            x: p.x,
                            y: p.y
                        }
                }
                var z = C ? getMainAxisFromPlacement(C) : null;
                if (null != z) {
                    var J = "y" === z ? "height" : "width";
                    switch (P) {
                        case ew:
                            c[z] = c[z] - (p[J] / 2 - v[J] / 2);
                            break;
                        case "end":
                            c[z] = c[z] + (p[J] / 2 - v[J] / 2)
                    }
                }
                return c
            }
            var eP = {
                top: "auto",
                right: "auto",
                bottom: "auto",
                left: "auto"
            };

            function mapToStyles(l) {
                var c, p, v, _, C, P, T, M = l.popper,
                    z = l.popperRect,
                    J = l.placement,
                    Q = l.variation,
                    X = l.offsets,
                    es = l.position,
                    eo = l.gpuAcceleration,
                    el = l.adaptive,
                    ec = l.roundOffsets,
                    eh = l.isFixed,
                    ed = X.x,
                    ey = void 0 === ed ? 0 : ed,
                    eb = X.y,
                    ew = void 0 === eb ? 0 : eb,
                    ex = "function" == typeof ec ? ec({
                        x: ey,
                        y: ew
                    }) : {
                        x: ey,
                        y: ew
                    };
                ey = ex.x, ew = ex.y;
                var e_ = X.hasOwnProperty("x"),
                    eE = X.hasOwnProperty("y"),
                    eA = em,
                    eC = "top",
                    eS = window;
                if (el) {
                    var eN = getOffsetParent(M),
                        eD = "clientHeight",
                        ek = "clientWidth";
                    eN === getWindow(M) && "static" !== getComputedStyle(eN = getDocumentElement(M)).position && "absolute" === es && (eD = "scrollHeight", ek = "scrollWidth"), ("top" === J || (J === em || J === eg) && "end" === Q) && (eC = ep, ew -= (eh && eN === eS && eS.visualViewport ? eS.visualViewport.height : eN[eD]) - z.height, ew *= eo ? 1 : -1), (J === em || ("top" === J || J === ep) && "end" === Q) && (eA = eg, ey -= (eh && eN === eS && eS.visualViewport ? eS.visualViewport.width : eN[ek]) - z.width, ey *= eo ? 1 : -1)
                }
                var eI = Object.assign({
                        position: es
                    }, el && eP),
                    eO = !0 === ec ? (c = {
                        x: ey,
                        y: ew
                    }, p = getWindow(M), v = c.x, _ = c.y, {
                        x: ef(v * (C = p.devicePixelRatio || 1)) / C || 0,
                        y: ef(_ * C) / C || 0
                    }) : {
                        x: ey,
                        y: ew
                    };
                return (ey = eO.x, ew = eO.y, eo) ? Object.assign({}, eI, ((T = {})[eC] = eE ? "0" : "", T[eA] = e_ ? "0" : "", T.transform = 1 >= (eS.devicePixelRatio || 1) ? "translate(" + ey + "px, " + ew + "px)" : "translate3d(" + ey + "px, " + ew + "px, 0)", T)) : Object.assign({}, eI, ((P = {})[eC] = eE ? ew + "px" : "", P[eA] = e_ ? ey + "px" : "", P.transform = "", P))
            }
            var eD = {
                left: "right",
                right: "left",
                bottom: "top",
                top: "bottom"
            };

            function getOppositePlacement(l) {
                return l.replace(/left|right|bottom|top/g, function(l) {
                    return eD[l]
                })
            }
            var ek = {
                start: "end",
                end: "start"
            };

            function getOppositeVariationPlacement(l) {
                return l.replace(/start|end/g, function(l) {
                    return ek[l]
                })
            }

            function contains(l, c) {
                var p = c.getRootNode && c.getRootNode();
                if (l.contains(c)) return !0;
                if (p && isShadowRoot(p)) {
                    var v = c;
                    do {
                        if (v && l.isSameNode(v)) return !0;
                        v = v.parentNode || v.host
                    } while (v)
                }
                return !1
            }

            function rectToClientRect(l) {
                return Object.assign({}, l, {
                    left: l.x,
                    top: l.y,
                    right: l.x + l.width,
                    bottom: l.y + l.height
                })
            }

            function getClientRectFromMixedType(l, c, p) {
                var v, _, C, P, T, M, z, J, Q, X;
                return c === ex ? rectToClientRect(function(l, c) {
                    var p = getWindow(l),
                        v = getDocumentElement(l),
                        _ = p.visualViewport,
                        C = v.clientWidth,
                        P = v.clientHeight,
                        T = 0,
                        M = 0;
                    if (_) {
                        C = _.width, P = _.height;
                        var z = isLayoutViewport();
                        (z || !z && "fixed" === c) && (T = _.offsetLeft, M = _.offsetTop)
                    }
                    return {
                        width: C,
                        height: P,
                        x: T + getWindowScrollBarX(l),
                        y: M
                    }
                }(l, p)) : isElement(c) ? ((v = getBoundingClientRect(c, !1, "fixed" === p)).top = v.top + c.clientTop, v.left = v.left + c.clientLeft, v.bottom = v.top + c.clientHeight, v.right = v.left + c.clientWidth, v.width = c.clientWidth, v.height = c.clientHeight, v.x = v.left, v.y = v.top, v) : rectToClientRect((_ = getDocumentElement(l), P = getDocumentElement(_), T = getWindowScroll(_), M = null == (C = _.ownerDocument) ? void 0 : C.body, z = eh(P.scrollWidth, P.clientWidth, M ? M.scrollWidth : 0, M ? M.clientWidth : 0), J = eh(P.scrollHeight, P.clientHeight, M ? M.scrollHeight : 0, M ? M.clientHeight : 0), Q = -T.scrollLeft + getWindowScrollBarX(_), X = -T.scrollTop, "rtl" === getComputedStyle(M || P).direction && (Q += eh(P.clientWidth, M ? M.clientWidth : 0) - z), {
                    width: z,
                    height: J,
                    x: Q,
                    y: X
                }))
            }

            function getFreshSideObject() {
                return {
                    top: 0,
                    right: 0,
                    bottom: 0,
                    left: 0
                }
            }

            function mergePaddingObject(l) {
                return Object.assign({}, getFreshSideObject(), l)
            }

            function expandToHashMap(l, c) {
                return c.reduce(function(c, p) {
                    return c[p] = l, c
                }, {})
            }

            function detectOverflow(l, c) {
                void 0 === c && (c = {});
                var p, v, _, C, P, T, M, z = c,
                    J = z.placement,
                    Q = void 0 === J ? l.placement : J,
                    X = z.strategy,
                    es = void 0 === X ? l.strategy : X,
                    eo = z.boundary,
                    el = z.rootBoundary,
                    ec = z.elementContext,
                    ef = void 0 === ec ? e_ : ec,
                    em = z.altBoundary,
                    ey = z.padding,
                    ew = void 0 === ey ? 0 : ey,
                    eE = mergePaddingObject("number" != typeof ew ? ew : expandToHashMap(ew, eb)),
                    eA = l.rects.popper,
                    eC = l.elements[void 0 !== em && em ? ef === e_ ? "reference" : e_ : ef],
                    eS = (p = isElement(eC) ? eC : eC.contextElement || getDocumentElement(l.elements.popper), T = (P = [].concat("clippingParents" === (v = void 0 === eo ? "clippingParents" : eo) ? (_ = listScrollParents(getParentNode(p)), isElement(C = ["absolute", "fixed"].indexOf(getComputedStyle(p).position) >= 0 && isHTMLElement(p) ? getOffsetParent(p) : p) ? _.filter(function(l) {
                        return isElement(l) && contains(l, C) && "body" !== getNodeName(l)
                    }) : []) : [].concat(v), [void 0 === el ? ex : el]))[0], (M = P.reduce(function(l, c) {
                        var v = getClientRectFromMixedType(p, c, es);
                        return l.top = eh(v.top, l.top), l.right = ed(v.right, l.right), l.bottom = ed(v.bottom, l.bottom), l.left = eh(v.left, l.left), l
                    }, getClientRectFromMixedType(p, T, es))).width = M.right - M.left, M.height = M.bottom - M.top, M.x = M.left, M.y = M.top, M),
                    eN = getBoundingClientRect(l.elements.reference),
                    eP = computeOffsets({
                        reference: eN,
                        element: eA,
                        strategy: "absolute",
                        placement: Q
                    }),
                    eD = rectToClientRect(Object.assign({}, eA, eP)),
                    ek = ef === e_ ? eD : eN,
                    eI = {
                        top: eS.top - ek.top + eE.top,
                        bottom: ek.bottom - eS.bottom + eE.bottom,
                        left: eS.left - ek.left + eE.left,
                        right: ek.right - eS.right + eE.right
                    },
                    eO = l.modifiersData.offset;
                if (ef === e_ && eO) {
                    var ej = eO[Q];
                    Object.keys(eI).forEach(function(l) {
                        var c = [eg, ep].indexOf(l) >= 0 ? 1 : -1,
                            p = ["top", ep].indexOf(l) >= 0 ? "y" : "x";
                        eI[l] += ej[p] * c
                    })
                }
                return eI
            }

            function within(l, c, p) {
                return eh(l, ed(c, p))
            }

            function getSideOffsets(l, c, p) {
                return void 0 === p && (p = {
                    x: 0,
                    y: 0
                }), {
                    top: l.top - c.height - p.y,
                    right: l.right - c.width + p.x,
                    bottom: l.bottom - c.height + p.y,
                    left: l.left - c.width - p.x
                }
            }

            function isAnySideFullyClipped(l) {
                return ["top", eg, ep, em].some(function(c) {
                    return l[c] >= 0
                })
            }
            var eI = (C = void 0 === (_ = (v = {
                    defaultModifiers: [{
                        name: "eventListeners",
                        enabled: !0,
                        phase: "write",
                        fn: function() {},
                        effect: function(l) {
                            var c = l.state,
                                p = l.instance,
                                v = l.options,
                                _ = v.scroll,
                                C = void 0 === _ || _,
                                P = v.resize,
                                T = void 0 === P || P,
                                M = getWindow(c.elements.popper),
                                z = [].concat(c.scrollParents.reference, c.scrollParents.popper);
                            return C && z.forEach(function(l) {
                                    l.addEventListener("scroll", p.update, eN)
                                }), T && M.addEventListener("resize", p.update, eN),
                                function() {
                                    C && z.forEach(function(l) {
                                        l.removeEventListener("scroll", p.update, eN)
                                    }), T && M.removeEventListener("resize", p.update, eN)
                                }
                        },
                        data: {}
                    }, {
                        name: "popperOffsets",
                        enabled: !0,
                        phase: "read",
                        fn: function(l) {
                            var c = l.state,
                                p = l.name;
                            c.modifiersData[p] = computeOffsets({
                                reference: c.rects.reference,
                                element: c.rects.popper,
                                strategy: "absolute",
                                placement: c.placement
                            })
                        },
                        data: {}
                    }, {
                        name: "computeStyles",
                        enabled: !0,
                        phase: "beforeWrite",
                        fn: function(l) {
                            var c = l.state,
                                p = l.options,
                                v = p.gpuAcceleration,
                                _ = p.adaptive,
                                C = p.roundOffsets,
                                P = void 0 === C || C,
                                T = {
                                    placement: getBasePlacement(c.placement),
                                    variation: getVariation(c.placement),
                                    popper: c.elements.popper,
                                    popperRect: c.rects.popper,
                                    gpuAcceleration: void 0 === v || v,
                                    isFixed: "fixed" === c.options.strategy
                                };
                            null != c.modifiersData.popperOffsets && (c.styles.popper = Object.assign({}, c.styles.popper, mapToStyles(Object.assign({}, T, {
                                offsets: c.modifiersData.popperOffsets,
                                position: c.options.strategy,
                                adaptive: void 0 === _ || _,
                                roundOffsets: P
                            })))), null != c.modifiersData.arrow && (c.styles.arrow = Object.assign({}, c.styles.arrow, mapToStyles(Object.assign({}, T, {
                                offsets: c.modifiersData.arrow,
                                position: "absolute",
                                adaptive: !1,
                                roundOffsets: P
                            })))), c.attributes.popper = Object.assign({}, c.attributes.popper, {
                                "data-popper-placement": c.placement
                            })
                        },
                        data: {}
                    }, {
                        name: "applyStyles",
                        enabled: !0,
                        phase: "write",
                        fn: function(l) {
                            var c = l.state;
                            Object.keys(c.elements).forEach(function(l) {
                                var p = c.styles[l] || {},
                                    v = c.attributes[l] || {},
                                    _ = c.elements[l];
                                isHTMLElement(_) && getNodeName(_) && (Object.assign(_.style, p), Object.keys(v).forEach(function(l) {
                                    var c = v[l];
                                    !1 === c ? _.removeAttribute(l) : _.setAttribute(l, !0 === c ? "" : c)
                                }))
                            })
                        },
                        effect: function(l) {
                            var c = l.state,
                                p = {
                                    popper: {
                                        position: c.options.strategy,
                                        left: "0",
                                        top: "0",
                                        margin: "0"
                                    },
                                    arrow: {
                                        position: "absolute"
                                    },
                                    reference: {}
                                };
                            return Object.assign(c.elements.popper.style, p.popper), c.styles = p, c.elements.arrow && Object.assign(c.elements.arrow.style, p.arrow),
                                function() {
                                    Object.keys(c.elements).forEach(function(l) {
                                        var v = c.elements[l],
                                            _ = c.attributes[l] || {},
                                            C = Object.keys(c.styles.hasOwnProperty(l) ? c.styles[l] : p[l]).reduce(function(l, c) {
                                                return l[c] = "", l
                                            }, {});
                                        isHTMLElement(v) && getNodeName(v) && (Object.assign(v.style, C), Object.keys(_).forEach(function(l) {
                                            v.removeAttribute(l)
                                        }))
                                    })
                                }
                        },
                        requires: ["computeStyles"]
                    }, {
                        name: "offset",
                        enabled: !0,
                        phase: "main",
                        requires: ["popperOffsets"],
                        fn: function(l) {
                            var c = l.state,
                                p = l.options,
                                v = l.name,
                                _ = p.offset,
                                C = void 0 === _ ? [0, 0] : _,
                                P = eA.reduce(function(l, p) {
                                    var v, _, P, T, M, z;
                                    return l[p] = (v = c.rects, P = [em, "top"].indexOf(_ = getBasePlacement(p)) >= 0 ? -1 : 1, M = (T = "function" == typeof C ? C(Object.assign({}, v, {
                                        placement: p
                                    })) : C)[0], z = T[1], M = M || 0, z = (z || 0) * P, [em, eg].indexOf(_) >= 0 ? {
                                        x: z,
                                        y: M
                                    } : {
                                        x: M,
                                        y: z
                                    }), l
                                }, {}),
                                T = P[c.placement],
                                M = T.x,
                                z = T.y;
                            null != c.modifiersData.popperOffsets && (c.modifiersData.popperOffsets.x += M, c.modifiersData.popperOffsets.y += z), c.modifiersData[v] = P
                        }
                    }, {
                        name: "flip",
                        enabled: !0,
                        phase: "main",
                        fn: function(l) {
                            var c = l.state,
                                p = l.options,
                                v = l.name;
                            if (!c.modifiersData[v]._skip) {
                                for (var _ = p.mainAxis, C = void 0 === _ || _, P = p.altAxis, T = void 0 === P || P, M = p.fallbackPlacements, z = p.padding, J = p.boundary, Q = p.rootBoundary, X = p.altBoundary, es = p.flipVariations, eo = void 0 === es || es, el = p.allowedAutoPlacements, ec = c.options.placement, eh = getBasePlacement(ec) === ec, ed = M || (eh || !eo ? [getOppositePlacement(ec)] : function(l) {
                                        if (getBasePlacement(l) === ey) return [];
                                        var c = getOppositePlacement(l);
                                        return [getOppositeVariationPlacement(l), c, getOppositeVariationPlacement(c)]
                                    }(ec)), ef = [ec].concat(ed).reduce(function(l, p) {
                                        var v, _, C, P, T, M, X, es, ec, eh, ed, ef;
                                        return l.concat(getBasePlacement(p) === ey ? (_ = (v = {
                                            placement: p,
                                            boundary: J,
                                            rootBoundary: Q,
                                            padding: z,
                                            flipVariations: eo,
                                            allowedAutoPlacements: el
                                        }).placement, C = v.boundary, P = v.rootBoundary, T = v.padding, M = v.flipVariations, es = void 0 === (X = v.allowedAutoPlacements) ? eA : X, 0 === (ed = (eh = (ec = getVariation(_)) ? M ? eE : eE.filter(function(l) {
                                            return getVariation(l) === ec
                                        }) : eb).filter(function(l) {
                                            return es.indexOf(l) >= 0
                                        })).length && (ed = eh), Object.keys(ef = ed.reduce(function(l, p) {
                                            return l[p] = detectOverflow(c, {
                                                placement: p,
                                                boundary: C,
                                                rootBoundary: P,
                                                padding: T
                                            })[getBasePlacement(p)], l
                                        }, {})).sort(function(l, c) {
                                            return ef[l] - ef[c]
                                        })) : p)
                                    }, []), ex = c.rects.reference, e_ = c.rects.popper, eC = new Map, eS = !0, eN = ef[0], eP = 0; eP < ef.length; eP++) {
                                    var eD = ef[eP],
                                        ek = getBasePlacement(eD),
                                        eI = getVariation(eD) === ew,
                                        eO = ["top", ep].indexOf(ek) >= 0,
                                        ej = eO ? "width" : "height",
                                        eT = detectOverflow(c, {
                                            placement: eD,
                                            boundary: J,
                                            rootBoundary: Q,
                                            altBoundary: X,
                                            padding: z
                                        }),
                                        eR = eO ? eI ? eg : em : eI ? ep : "top";
                                    ex[ej] > e_[ej] && (eR = getOppositePlacement(eR));
                                    var eL = getOppositePlacement(eR),
                                        eM = [];
                                    if (C && eM.push(eT[ek] <= 0), T && eM.push(eT[eR] <= 0, eT[eL] <= 0), eM.every(function(l) {
                                            return l
                                        })) {
                                        eN = eD, eS = !1;
                                        break
                                    }
                                    eC.set(eD, eM)
                                }
                                if (eS)
                                    for (var eU = eo ? 3 : 1, _loop = function(l) {
                                            var c = ef.find(function(c) {
                                                var p = eC.get(c);
                                                if (p) return p.slice(0, l).every(function(l) {
                                                    return l
                                                })
                                            });
                                            if (c) return eN = c, "break"
                                        }, eB = eU; eB > 0 && "break" !== _loop(eB); eB--);
                                c.placement !== eN && (c.modifiersData[v]._skip = !0, c.placement = eN, c.reset = !0)
                            }
                        },
                        requiresIfExists: ["offset"],
                        data: {
                            _skip: !1
                        }
                    }, {
                        name: "preventOverflow",
                        enabled: !0,
                        phase: "main",
                        fn: function(l) {
                            var c = l.state,
                                p = l.options,
                                v = l.name,
                                _ = p.mainAxis,
                                C = p.altAxis,
                                P = p.boundary,
                                T = p.rootBoundary,
                                M = p.altBoundary,
                                z = p.padding,
                                J = p.tether,
                                Q = void 0 === J || J,
                                X = p.tetherOffset,
                                es = void 0 === X ? 0 : X,
                                eo = detectOverflow(c, {
                                    boundary: P,
                                    rootBoundary: T,
                                    padding: z,
                                    altBoundary: M
                                }),
                                el = getBasePlacement(c.placement),
                                ec = getVariation(c.placement),
                                ef = !ec,
                                ey = getMainAxisFromPlacement(el),
                                eb = "x" === ey ? "y" : "x",
                                ex = c.modifiersData.popperOffsets,
                                e_ = c.rects.reference,
                                eE = c.rects.popper,
                                eA = "function" == typeof es ? es(Object.assign({}, c.rects, {
                                    placement: c.placement
                                })) : es,
                                eC = "number" == typeof eA ? {
                                    mainAxis: eA,
                                    altAxis: eA
                                } : Object.assign({
                                    mainAxis: 0,
                                    altAxis: 0
                                }, eA),
                                eS = c.modifiersData.offset ? c.modifiersData.offset[c.placement] : null,
                                eN = {
                                    x: 0,
                                    y: 0
                                };
                            if (ex) {
                                if (void 0 === _ || _) {
                                    var eP, eD = "y" === ey ? "top" : em,
                                        ek = "y" === ey ? ep : eg,
                                        eI = "y" === ey ? "height" : "width",
                                        eO = ex[ey],
                                        ej = eO + eo[eD],
                                        eT = eO - eo[ek],
                                        eR = Q ? -eE[eI] / 2 : 0,
                                        eL = ec === ew ? e_[eI] : eE[eI],
                                        eM = ec === ew ? -eE[eI] : -e_[eI],
                                        eU = c.elements.arrow,
                                        eB = Q && eU ? getLayoutRect(eU) : {
                                            width: 0,
                                            height: 0
                                        },
                                        eF = c.modifiersData["arrow#persistent"] ? c.modifiersData["arrow#persistent"].padding : getFreshSideObject(),
                                        eH = eF[eD],
                                        eV = eF[ek],
                                        ez = within(0, e_[eI], eB[eI]),
                                        eW = ef ? e_[eI] / 2 - eR - ez - eH - eC.mainAxis : eL - ez - eH - eC.mainAxis,
                                        eG = ef ? -e_[eI] / 2 + eR + ez + eV + eC.mainAxis : eM + ez + eV + eC.mainAxis,
                                        eK = c.elements.arrow && getOffsetParent(c.elements.arrow),
                                        eZ = eK ? "y" === ey ? eK.clientTop || 0 : eK.clientLeft || 0 : 0,
                                        eJ = null != (eP = null == eS ? void 0 : eS[ey]) ? eP : 0,
                                        eQ = eO + eW - eJ - eZ,
                                        e$ = eO + eG - eJ,
                                        eY = within(Q ? ed(ej, eQ) : ej, eO, Q ? eh(eT, e$) : eT);
                                    ex[ey] = eY, eN[ey] = eY - eO
                                }
                                if (void 0 !== C && C) {
                                    var eX, e0, e1 = "x" === ey ? "top" : em,
                                        e2 = "x" === ey ? ep : eg,
                                        e5 = ex[eb],
                                        e3 = "y" === eb ? "height" : "width",
                                        e6 = e5 + eo[e1],
                                        e4 = e5 - eo[e2],
                                        e8 = -1 !== ["top", em].indexOf(el),
                                        e9 = null != (e0 = null == eS ? void 0 : eS[eb]) ? e0 : 0,
                                        e7 = e8 ? e6 : e5 - e_[e3] - eE[e3] - e9 + eC.altAxis,
                                        tn = e8 ? e5 + e_[e3] + eE[e3] - e9 - eC.altAxis : e4,
                                        ts = Q && e8 ? (eX = within(e7, e5, tn)) > tn ? tn : eX : within(Q ? e7 : e6, e5, Q ? tn : e4);
                                    ex[eb] = ts, eN[eb] = ts - e5
                                }
                                c.modifiersData[v] = eN
                            }
                        },
                        requiresIfExists: ["offset"]
                    }, {
                        name: "arrow",
                        enabled: !0,
                        phase: "main",
                        fn: function(l) {
                            var c, p, v = l.state,
                                _ = l.name,
                                C = l.options,
                                P = v.elements.arrow,
                                T = v.modifiersData.popperOffsets,
                                M = getBasePlacement(v.placement),
                                z = getMainAxisFromPlacement(M),
                                J = [em, eg].indexOf(M) >= 0 ? "height" : "width";
                            if (P && T) {
                                var Q = mergePaddingObject("number" != typeof(c = "function" == typeof(c = C.padding) ? c(Object.assign({}, v.rects, {
                                        placement: v.placement
                                    })) : c) ? c : expandToHashMap(c, eb)),
                                    X = getLayoutRect(P),
                                    es = "y" === z ? "top" : em,
                                    eo = "y" === z ? ep : eg,
                                    el = v.rects.reference[J] + v.rects.reference[z] - T[z] - v.rects.popper[J],
                                    ec = T[z] - v.rects.reference[z],
                                    eh = getOffsetParent(P),
                                    ed = eh ? "y" === z ? eh.clientHeight || 0 : eh.clientWidth || 0 : 0,
                                    ef = Q[es],
                                    ey = ed - X[J] - Q[eo],
                                    ew = ed / 2 - X[J] / 2 + (el / 2 - ec / 2),
                                    ex = within(ef, ew, ey);
                                v.modifiersData[_] = ((p = {})[z] = ex, p.centerOffset = ex - ew, p)
                            }
                        },
                        effect: function(l) {
                            var c = l.state,
                                p = l.options.element,
                                v = void 0 === p ? "[data-popper-arrow]" : p;
                            null != v && ("string" != typeof v || (v = c.elements.popper.querySelector(v))) && contains(c.elements.popper, v) && (c.elements.arrow = v)
                        },
                        requires: ["popperOffsets"],
                        requiresIfExists: ["preventOverflow"]
                    }, {
                        name: "hide",
                        enabled: !0,
                        phase: "main",
                        requiresIfExists: ["preventOverflow"],
                        fn: function(l) {
                            var c = l.state,
                                p = l.name,
                                v = c.rects.reference,
                                _ = c.rects.popper,
                                C = c.modifiersData.preventOverflow,
                                P = detectOverflow(c, {
                                    elementContext: "reference"
                                }),
                                T = detectOverflow(c, {
                                    altBoundary: !0
                                }),
                                M = getSideOffsets(P, v),
                                z = getSideOffsets(T, _, C),
                                J = isAnySideFullyClipped(M),
                                Q = isAnySideFullyClipped(z);
                            c.modifiersData[p] = {
                                referenceClippingOffsets: M,
                                popperEscapeOffsets: z,
                                isReferenceHidden: J,
                                hasPopperEscaped: Q
                            }, c.attributes.popper = Object.assign({}, c.attributes.popper, {
                                "data-popper-reference-hidden": J,
                                "data-popper-escaped": Q
                            })
                        }
                    }]
                }).defaultModifiers) ? [] : _, T = void 0 === (P = v.defaultOptions) ? eS : P, function(l, c, p) {
                    void 0 === p && (p = T);
                    var v, _ = {
                            placement: "bottom",
                            orderedModifiers: [],
                            options: Object.assign({}, eS, T),
                            modifiersData: {},
                            elements: {
                                reference: l,
                                popper: c
                            },
                            attributes: {},
                            styles: {}
                        },
                        P = [],
                        M = !1,
                        z = {
                            state: _,
                            setOptions: function(p) {
                                var v, M, J, Q, X, es = "function" == typeof p ? p(_.options) : p;
                                cleanupModifierEffects(), _.options = Object.assign({}, T, _.options, es), _.scrollParents = {
                                    reference: isElement(l) ? listScrollParents(l) : l.contextElement ? listScrollParents(l.contextElement) : [],
                                    popper: listScrollParents(c)
                                };
                                var eo = (M = Object.keys(v = [].concat(C, _.options.modifiers).reduce(function(l, c) {
                                    var p = l[c.name];
                                    return l[c.name] = p ? Object.assign({}, p, c, {
                                        options: Object.assign({}, p.options, c.options),
                                        data: Object.assign({}, p.data, c.data)
                                    }) : c, l
                                }, {})).map(function(l) {
                                    return v[l]
                                }), J = new Map, Q = new Set, X = [], M.forEach(function(l) {
                                    J.set(l.name, l)
                                }), M.forEach(function(l) {
                                    Q.has(l.name) || function sort(l) {
                                        Q.add(l.name), [].concat(l.requires || [], l.requiresIfExists || []).forEach(function(l) {
                                            if (!Q.has(l)) {
                                                var c = J.get(l);
                                                c && sort(c)
                                            }
                                        }), X.push(l)
                                    }(l)
                                }), eC.reduce(function(l, c) {
                                    return l.concat(X.filter(function(l) {
                                        return l.phase === c
                                    }))
                                }, []));
                                return _.orderedModifiers = eo.filter(function(l) {
                                    return l.enabled
                                }), _.orderedModifiers.forEach(function(l) {
                                    var c = l.name,
                                        p = l.options,
                                        v = l.effect;
                                    if ("function" == typeof v) {
                                        var C = v({
                                            state: _,
                                            name: c,
                                            instance: z,
                                            options: void 0 === p ? {} : p
                                        });
                                        P.push(C || function() {})
                                    }
                                }), z.update()
                            },
                            forceUpdate: function() {
                                if (!M) {
                                    var l, c, p, v, C, P, T, J, Q, X, es, eo, el = _.elements,
                                        ec = el.reference,
                                        eh = el.popper;
                                    if (areValidElements(ec, eh)) {
                                        _.rects = {
                                            reference: (c = getOffsetParent(eh), p = "fixed" === _.options.strategy, v = isHTMLElement(c), J = isHTMLElement(c) && (P = ef((C = c.getBoundingClientRect()).width) / c.offsetWidth || 1, T = ef(C.height) / c.offsetHeight || 1, 1 !== P || 1 !== T), Q = getDocumentElement(c), X = getBoundingClientRect(ec, J, p), es = {
                                                scrollLeft: 0,
                                                scrollTop: 0
                                            }, eo = {
                                                x: 0,
                                                y: 0
                                            }, (v || !v && !p) && (("body" !== getNodeName(c) || isScrollParent(Q)) && (es = (l = c) !== getWindow(l) && isHTMLElement(l) ? {
                                                scrollLeft: l.scrollLeft,
                                                scrollTop: l.scrollTop
                                            } : getWindowScroll(l)), isHTMLElement(c) ? (eo = getBoundingClientRect(c, !0), eo.x += c.clientLeft, eo.y += c.clientTop) : Q && (eo.x = getWindowScrollBarX(Q))), {
                                                x: X.left + es.scrollLeft - eo.x,
                                                y: X.top + es.scrollTop - eo.y,
                                                width: X.width,
                                                height: X.height
                                            }),
                                            popper: getLayoutRect(eh)
                                        }, _.reset = !1, _.placement = _.options.placement, _.orderedModifiers.forEach(function(l) {
                                            return _.modifiersData[l.name] = Object.assign({}, l.data)
                                        });
                                        for (var ed = 0; ed < _.orderedModifiers.length; ed++) {
                                            if (!0 === _.reset) {
                                                _.reset = !1, ed = -1;
                                                continue
                                            }
                                            var ep = _.orderedModifiers[ed],
                                                eg = ep.fn,
                                                em = ep.options,
                                                ey = void 0 === em ? {} : em,
                                                eb = ep.name;
                                            "function" == typeof eg && (_ = eg({
                                                state: _,
                                                options: ey,
                                                name: eb,
                                                instance: z
                                            }) || _)
                                        }
                                    }
                                }
                            },
                            update: function() {
                                return v || (v = new Promise(function(l) {
                                    Promise.resolve().then(function() {
                                        v = void 0, l(new Promise(function(l) {
                                            z.forceUpdate(), l(_)
                                        }))
                                    })
                                })), v
                            },
                            destroy: function() {
                                cleanupModifierEffects(), M = !0
                            }
                        };
                    if (!areValidElements(l, c)) return z;

                    function cleanupModifierEffects() {
                        P.forEach(function(l) {
                            return l()
                        }), P = []
                    }
                    return z.setOptions(p).then(function(l) {
                        !M && p.onFirstUpdate && p.onFirstUpdate(l)
                    }), z
                }),
                eO = p(7106),
                ej = p.n(eO),
                fromEntries = function(l) {
                    return l.reduce(function(l, c) {
                        var p = c[0],
                            v = c[1];
                        return l[p] = v, l
                    }, {})
                },
                eT = "undefined" != typeof window && window.document && window.document.createElement ? Q.useLayoutEffect : Q.useEffect,
                eR = [],
                usePopper = function(l, c, p) {
                    void 0 === p && (p = {});
                    var v = Q.useRef(null),
                        _ = {
                            onFirstUpdate: p.onFirstUpdate,
                            placement: p.placement || "bottom",
                            strategy: p.strategy || "absolute",
                            modifiers: p.modifiers || eR
                        },
                        C = Q.useState({
                            styles: {
                                popper: {
                                    position: _.strategy,
                                    left: "0",
                                    top: "0"
                                },
                                arrow: {
                                    position: "absolute"
                                }
                            },
                            attributes: {}
                        }),
                        P = C[0],
                        T = C[1],
                        M = Q.useMemo(function() {
                            return {
                                name: "updateState",
                                enabled: !0,
                                phase: "write",
                                fn: function(l) {
                                    var c = l.state,
                                        p = Object.keys(c.elements);
                                    ec.flushSync(function() {
                                        T({
                                            styles: fromEntries(p.map(function(l) {
                                                return [l, c.styles[l] || {}]
                                            })),
                                            attributes: fromEntries(p.map(function(l) {
                                                return [l, c.attributes[l]]
                                            }))
                                        })
                                    })
                                },
                                requires: ["computeStyles"]
                            }
                        }, []),
                        z = Q.useMemo(function() {
                            var l = {
                                onFirstUpdate: _.onFirstUpdate,
                                placement: _.placement,
                                strategy: _.strategy,
                                modifiers: [].concat(_.modifiers, [M, {
                                    name: "applyStyles",
                                    enabled: !1
                                }])
                            };
                            return ej()(v.current, l) ? v.current || l : (v.current = l, l)
                        }, [_.onFirstUpdate, _.placement, _.strategy, _.modifiers, M]),
                        J = Q.useRef();
                    return eT(function() {
                        J.current && J.current.setOptions(z)
                    }, [z]), eT(function() {
                        if (null != l && null != c) {
                            var v = (p.createPopper || eI)(l, c, z);
                            return J.current = v,
                                function() {
                                    v.destroy(), J.current = null
                                }
                        }
                    }, [l, c, p.createPopper]), {
                        state: J.current ? J.current.state : null,
                        styles: P.styles,
                        attributes: P.attributes,
                        update: J.current ? J.current.update : null,
                        forceUpdate: J.current ? J.current.forceUpdate : null
                    }
                };

            function Popover(l) {
                let {
                    children: c,
                    contentFrameProps: p,
                    isOpen: v,
                    offset: _ = [0, 8],
                    onClose: C,
                    overlayProps: P,
                    placement: T = "bottom",
                    referenceElement: M
                } = l, [X, es] = Q.useState(null), {
                    attributes: eo,
                    styles: ec
                } = usePopper(M, X, {
                    placement: T,
                    modifiers: [{
                        name: "offset",
                        options: {
                            offset: _
                        }
                    }]
                });
                return (0, J.jsx)(el.a, {
                    autoFocus: !1,
                    backdropStyle: "none",
                    isOpen: v,
                    lockFocus: !1,
                    lockScroll: !1,
                    onClose: C,
                    ...P,
                    children: (0, J.jsx)("div", {
                        ref: es,
                        style: ec.popper,
                        ...eo.popper,
                        children: (0, J.jsx)(z.ye, {
                            frameSize: "small",
                            ...p,
                            children: c
                        })
                    })
                })
            }
            let eL = z.xi;
            var eM = p(8821),
                eU = p.n(eM);
            let eB = eU()(() => Promise.resolve(l => {
                if ("undefined" == typeof document) return null;
                let {
                    children: c,
                    container: p = document.body
                } = l;
                return (0, J.jsx)(J.Fragment, {
                    children: ec.createPortal((0, J.jsx)(J.Fragment, {
                        children: c
                    }), p)
                })
            }), {
                ssr: !1
            });
            var eF = p(3460);

            function Tooltip(l) {
                let {
                    children: c,
                    contentFrameProps: p,
                    offset: v = [0, 8],
                    overlayProps: _,
                    placement: C = "bottom",
                    referenceElement: P
                } = l, [T, M] = Q.useState(!1), X = (0, eF.Nr)(T, 100), [es, eo] = Q.useState(null), {
                    attributes: ec,
                    styles: eh
                } = usePopper(P, es, {
                    placement: C,
                    modifiers: [{
                        name: "offset",
                        options: {
                            offset: v
                        }
                    }]
                });
                return Q.useEffect(() => {
                    let handleMouseEnter = () => M(!0),
                        handleMouseLeave = () => M(!1);
                    return null == P || P.addEventListener("mouseenter", handleMouseEnter), null == P || P.addEventListener("mouseleave", handleMouseLeave), null == es || es.addEventListener("mouseenter", handleMouseEnter), null == es || es.addEventListener("mouseleave", handleMouseLeave), () => {
                        null == P || P.removeEventListener("mouseenter", handleMouseEnter), null == P || P.removeEventListener("mouseleave", handleMouseLeave), null == es || es.removeEventListener("mouseenter", handleMouseEnter), null == es || es.removeEventListener("mouseleave", handleMouseLeave)
                    }
                }, [P, es]), (0, J.jsx)(el.a, {
                    autoFocus: !1,
                    backdropStyle: "none",
                    closeOnOutsideClick: !1,
                    isOpen: X,
                    lockFocus: !1,
                    lockScroll: !1,
                    ..._,
                    children: (0, J.jsx)("div", {
                        ref: eo,
                        style: eh.popper,
                        ...ec.popper,
                        children: (0, J.jsx)(z.ye, {
                            frameSize: "small",
                            ...p,
                            children: c
                        })
                    })
                })
            }
        },
        8347: function(l, c, p) {
            "use strict";
            p.d(c, {
                r: function() {
                    return Blockie
                },
                y: function() {
                    return DappModal
                }
            });
            var v = p(4817);
            p(1248);
            var _ = [, , , , ];

            function o() {
                var l = _[0] ^ _[0] << 11;
                return _[0] = _[1], _[1] = _[2], _[2] = _[3], _[3] = _[3] ^ _[3] >> 19 ^ l ^ l >> 8, (_[3] >>> 0) / 2147483648
            }

            function r() {
                return "hsl(" + Math.floor(360 * o()) + "," + (60 * o() + 40) + "%," + 25 * (o() + o() + o() + o()) + "%)"
            }

            function render(l, c) {
                var p = function(l) {
                        for (var c = Math.ceil(l / 2), p = l - c, v = [], _ = 0; l > _; _++) {
                            for (var C = [], P = 0; c > P; P++) C[P] = Math.floor(2.3 * o());
                            var T = C.slice(0, p);
                            T.reverse(), C = C.concat(T);
                            for (var M = 0; M < C.length; M++) v.push(C[M])
                        }
                        return v
                    }(l.size),
                    v = Math.sqrt(p.length);
                c.width = c.height = l.size * l.scale;
                var _ = c.getContext("2d");
                _.fillStyle = l.bgcolor, _.fillRect(0, 0, c.width, c.height), _.fillStyle = l.color;
                for (var C = 0; C < p.length; C++)
                    if (p[C]) {
                        var P = Math.floor(C / v),
                            T = C % v;
                        _.fillStyle = 1 == p[C] ? l.color : l.spotcolor, _.fillRect(T * l.scale, P * l.scale, l.scale, l.scale)
                    }
                return c
            }
            var C = {
                create: function(l) {
                    var c, p, l = (c = l || {}, (p = {}).seed = c.seed || Math.floor(1e16 * Math.random()).toString(16), function(l) {
                            for (var c = 0; c < _.length; c++) _[c] = 0;
                            for (var c = 0; c < l.length; c++) _[c % 4] = (_[c % 4] << 5) - _[c % 4] + l.charCodeAt(c)
                        }(p.seed), p.size = c.size || 8, p.scale = c.scale || 4, p.color = c.color || r(), p.bgcolor = c.bgcolor || r(), p.spotcolor = c.spotcolor || r(), p),
                        v = document.createElement("canvas");
                    return render(l, v), v
                },
                render
            };
            let Blockie = l => {
                let {
                    address: c,
                    size: p = "48px"
                } = l, _ = c.toLowerCase(), P = C.create({
                    seed: _
                }).toDataURL();
                return (0, v.jsx)("img", {
                    alt: c,
                    className: "rounded-full",
                    src: P,
                    style: {
                        height: "".concat(p),
                        width: "".concat(p)
                    }
                })
            };
            var P = p(8851),
                T = p(7833),
                M = p(8735),
                z = p.n(M),
                J = p(5834),
                Q = p(8397),
                X = p(6597);
            let DappModal = l => {
                let {
                    loadingConnector: c,
                    onConnector: p,
                    ..._
                } = l, {
                    t: C
                } = (0, T.Z)("common");
                return (0, v.jsxs)(J.u_, {
                    ariaLabel: C("aria-label_dapp_modal"),
                    ..._,
                    children: [(0, v.jsx)(J.Io, {
                        children: (0, v.jsx)("h2", {
                            className: "typography-brand-body-l-caps text-yellow-100",
                            children: C("h2_dapp_modal")
                        })
                    }), (0, v.jsxs)("div", {
                        className: "flex w-max flex-col gap-6",
                        children: [Array.from(X.pZ.entries()).map(l => {
                            let [_, P] = l;
                            return (0, v.jsx)(Q.h, {
                                smallerText: !0,
                                stretch: !0,
                                isWalletPending: _ === (null == c ? void 0 : c.id),
                                onClick: () => p(P),
                                pendingText: C(P.name.toLowerCase()),
                                variant: "secondary",
                                children: (0, v.jsxs)("div", {
                                    className: "flex w-full items-center justify-start gap-3",
                                    children: [(0, v.jsx)(z(), {
                                        alt: P.name,
                                        height: 24,
                                        src: P.logo,
                                        width: 24
                                    }), C(P.name.toLowerCase())]
                                })
                            }, _)
                        }), (0, v.jsx)("div", {
                            className: "typography-brand-body mt-2 w-72 text-yellow-100",
                            children: (0, v.jsx)(P.Z, {
                                i18nKey: "common:terms_of_service",
                                components: {
                                    0: (0, v.jsx)("a", {
                                        className: "interactive-text text-yellow-300",
                                        href: "https://drive.google.com/file/d/1ic_cky5FbcNsoYnEQQxOjxmgRVjQuA9K/view?usp=drive_link",
                                        target: "_blank"
                                    }),
                                    1: (0, v.jsx)("a", {
                                        className: "interactive-text text-yellow-300",
                                        href: "https://drive.google.com/file/d/1NgcThJTcqHVJfsqch-rqE4RneKvDFzsW/view?usp=drive_link",
                                        target: "_blank"
                                    })
                                }
                            })
                        })]
                    })]
                })
            }
        },
        6597: function(l, c, p) {
            "use strict";
            p.d(c, {
                GU: function() {
                    return CoinbaseWallet
                },
                wR: function() {
                    return Connector
                },
                be: function() {
                    return WalletConnect
                },
                pZ: function() {
                    return ig
                }
            });
            var v, _, C = {};
            p.r(C), p.d(C, {
                identity: function() {
                    return ex
                }
            });
            var P = {};
            p.r(P), p.d(P, {
                base2: function() {
                    return e_
                }
            });
            var T = {};
            p.r(T), p.d(T, {
                base8: function() {
                    return eE
                }
            });
            var M = {};
            p.r(M), p.d(M, {
                base10: function() {
                    return eA
                }
            });
            var z = {};
            p.r(z), p.d(z, {
                base16: function() {
                    return eC
                },
                base16upper: function() {
                    return eS
                }
            });
            var J = {};
            p.r(J), p.d(J, {
                base32: function() {
                    return eN
                },
                base32hex: function() {
                    return eI
                },
                base32hexpad: function() {
                    return ej
                },
                base32hexpadupper: function() {
                    return eT
                },
                base32hexupper: function() {
                    return eO
                },
                base32pad: function() {
                    return eD
                },
                base32padupper: function() {
                    return ek
                },
                base32upper: function() {
                    return eP
                },
                base32z: function() {
                    return eR
                }
            });
            var Q = {};
            p.r(Q), p.d(Q, {
                base36: function() {
                    return eL
                },
                base36upper: function() {
                    return eM
                }
            });
            var X = {};
            p.r(X), p.d(X, {
                base58btc: function() {
                    return eU
                },
                base58flickr: function() {
                    return eB
                }
            });
            var es = {};
            p.r(es), p.d(es, {
                base64: function() {
                    return eF
                },
                base64pad: function() {
                    return eH
                },
                base64url: function() {
                    return eV
                },
                base64urlpad: function() {
                    return ez
                }
            });
            var eo = {};
            p.r(eo), p.d(eo, {
                base256emoji: function() {
                    return eZ
                }
            });
            var el = {};
            p.r(el), p.d(el, {
                sha256: function() {
                    return eQ
                },
                sha512: function() {
                    return e$
                }
            });
            var ec = {};
            p.r(ec), p.d(ec, {
                identity: function() {
                    return eY
                }
            });
            var eh = {};
            p.r(eh), p.d(eh, {
                code: function() {
                    return e0
                },
                decode: function() {
                    return raw_decode
                },
                encode: function() {
                    return raw_encode
                },
                name: function() {
                    return eX
                }
            });
            var ed = {};
            p.r(ed), p.d(ed, {
                code: function() {
                    return e3
                },
                decode: function() {
                    return json_decode
                },
                encode: function() {
                    return json_encode
                },
                name: function() {
                    return e5
                }
            });
            var ef = p(9944),
                ep = p.n(ef),
                eg = p(3001),
                em = p(221),
                ey = p(4510),
                eb = p(5419),
                ew = p(4066);

            function as_uint8array_asUint8Array(l) {
                return null != globalThis.Buffer ? new Uint8Array(l.buffer, l.byteOffset, l.byteLength) : l
            }

            function allocUnsafe(l = 0) {
                return null != globalThis.Buffer && null != globalThis.Buffer.allocUnsafe ? as_uint8array_asUint8Array(globalThis.Buffer.allocUnsafe(l)) : new Uint8Array(l)
            }

            function concat(l, c) {
                c || (c = l.reduce((l, c) => l + c.length, 0));
                let p = allocUnsafe(c),
                    v = 0;
                for (let c of l) p.set(c, v), v += c.length;
                return as_uint8array_asUint8Array(p)
            }
            var base_x = function(l, c) {
                if (l.length >= 255) throw TypeError("Alphabet too long");
                for (var p = new Uint8Array(256), v = 0; v < p.length; v++) p[v] = 255;
                for (var _ = 0; _ < l.length; _++) {
                    var C = l.charAt(_),
                        P = C.charCodeAt(0);
                    if (255 !== p[P]) throw TypeError(C + " is ambiguous");
                    p[P] = _
                }
                var T = l.length,
                    M = l.charAt(0),
                    z = Math.log(T) / Math.log(256),
                    J = Math.log(256) / Math.log(T);

                function decodeUnsafe(l) {
                    if ("string" != typeof l) throw TypeError("Expected String");
                    if (0 === l.length) return new Uint8Array;
                    var c = 0;
                    if (" " !== l[0]) {
                        for (var v = 0, _ = 0; l[c] === M;) v++, c++;
                        for (var C = (l.length - c) * z + 1 >>> 0, P = new Uint8Array(C); l[c];) {
                            var J = p[l.charCodeAt(c)];
                            if (255 === J) return;
                            for (var Q = 0, X = C - 1;
                                (0 !== J || Q < _) && -1 !== X; X--, Q++) J += T * P[X] >>> 0, P[X] = J % 256 >>> 0, J = J / 256 >>> 0;
                            if (0 !== J) throw Error("Non-zero carry");
                            _ = Q, c++
                        }
                        if (" " !== l[c]) {
                            for (var es = C - _; es !== C && 0 === P[es];) es++;
                            for (var eo = new Uint8Array(v + (C - es)), el = v; es !== C;) eo[el++] = P[es++];
                            return eo
                        }
                    }
                }
                return {
                    encode: function(c) {
                        if (c instanceof Uint8Array || (ArrayBuffer.isView(c) ? c = new Uint8Array(c.buffer, c.byteOffset, c.byteLength) : Array.isArray(c) && (c = Uint8Array.from(c))), !(c instanceof Uint8Array)) throw TypeError("Expected Uint8Array");
                        if (0 === c.length) return "";
                        for (var p = 0, v = 0, _ = 0, C = c.length; _ !== C && 0 === c[_];) _++, p++;
                        for (var P = (C - _) * J + 1 >>> 0, z = new Uint8Array(P); _ !== C;) {
                            for (var Q = c[_], X = 0, es = P - 1;
                                (0 !== Q || X < v) && -1 !== es; es--, X++) Q += 256 * z[es] >>> 0, z[es] = Q % T >>> 0, Q = Q / T >>> 0;
                            if (0 !== Q) throw Error("Non-zero carry");
                            v = X, _++
                        }
                        for (var eo = P - v; eo !== P && 0 === z[eo];) eo++;
                        for (var el = M.repeat(p); eo < P; ++eo) el += l.charAt(z[eo]);
                        return el
                    },
                    decodeUnsafe: decodeUnsafe,
                    decode: function(l) {
                        var p = decodeUnsafe(l);
                        if (p) return p;
                        throw Error(`Non-${c} character`)
                    }
                }
            };
            new Uint8Array(0);
            let equals = (l, c) => {
                    if (l === c) return !0;
                    if (l.byteLength !== c.byteLength) return !1;
                    for (let p = 0; p < l.byteLength; p++)
                        if (l[p] !== c[p]) return !1;
                    return !0
                },
                coerce = l => {
                    if (l instanceof Uint8Array && "Uint8Array" === l.constructor.name) return l;
                    if (l instanceof ArrayBuffer) return new Uint8Array(l);
                    if (ArrayBuffer.isView(l)) return new Uint8Array(l.buffer, l.byteOffset, l.byteLength);
                    throw Error("Unknown type, must be binary type")
                },
                bytes_fromString = l => new TextEncoder().encode(l),
                bytes_toString = l => new TextDecoder().decode(l);
            let Encoder = class Encoder {
                constructor(l, c, p) {
                    this.name = l, this.prefix = c, this.baseEncode = p
                }
                encode(l) {
                    if (l instanceof Uint8Array) return `${this.prefix}${this.baseEncode(l)}`;
                    throw Error("Unknown type, must be binary type")
                }
            };
            let Decoder = class Decoder {
                constructor(l, c, p) {
                    if (this.name = l, this.prefix = c, void 0 === c.codePointAt(0)) throw Error("Invalid prefix character");
                    this.prefixCodePoint = c.codePointAt(0), this.baseDecode = p
                }
                decode(l) {
                    if ("string" == typeof l) {
                        if (l.codePointAt(0) !== this.prefixCodePoint) throw Error(`Unable to decode multibase string ${JSON.stringify(l)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
                        return this.baseDecode(l.slice(this.prefix.length))
                    }
                    throw Error("Can only multibase decode strings")
                }
                or(l) {
                    return or(this, l)
                }
            };
            let ComposedDecoder = class ComposedDecoder {
                constructor(l) {
                    this.decoders = l
                }
                or(l) {
                    return or(this, l)
                }
                decode(l) {
                    let c = l[0],
                        p = this.decoders[c];
                    if (p) return p.decode(l);
                    throw RangeError(`Unable to decode multibase string ${JSON.stringify(l)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`)
                }
            };
            let or = (l, c) => new ComposedDecoder({ ...l.decoders || {
                    [l.prefix]: l
                },
                ...c.decoders || {
                    [c.prefix]: c
                }
            });
            let Codec = class Codec {
                constructor(l, c, p, v) {
                    this.name = l, this.prefix = c, this.baseEncode = p, this.baseDecode = v, this.encoder = new Encoder(l, c, p), this.decoder = new Decoder(l, c, v)
                }
                encode(l) {
                    return this.encoder.encode(l)
                }
                decode(l) {
                    return this.decoder.decode(l)
                }
            };
            let from = ({
                    name: l,
                    prefix: c,
                    encode: p,
                    decode: v
                }) => new Codec(l, c, p, v),
                baseX = ({
                    prefix: l,
                    name: c,
                    alphabet: p
                }) => {
                    let {
                        encode: v,
                        decode: _
                    } = base_x(p, c);
                    return from({
                        prefix: l,
                        name: c,
                        encode: v,
                        decode: l => coerce(_(l))
                    })
                },
                decode = (l, c, p, v) => {
                    let _ = {};
                    for (let l = 0; l < c.length; ++l) _[c[l]] = l;
                    let C = l.length;
                    for (;
                        "=" === l[C - 1];) --C;
                    let P = new Uint8Array(C * p / 8 | 0),
                        T = 0,
                        M = 0,
                        z = 0;
                    for (let c = 0; c < C; ++c) {
                        let C = _[l[c]];
                        if (void 0 === C) throw SyntaxError(`Non-${v} character`);
                        M = M << p | C, (T += p) >= 8 && (T -= 8, P[z++] = 255 & M >> T)
                    }
                    if (T >= p || 255 & M << 8 - T) throw SyntaxError("Unexpected end of data");
                    return P
                },
                encode = (l, c, p) => {
                    let v = "=" === c[c.length - 1],
                        _ = (1 << p) - 1,
                        C = "",
                        P = 0,
                        T = 0;
                    for (let v = 0; v < l.length; ++v)
                        for (T = T << 8 | l[v], P += 8; P > p;) P -= p, C += c[_ & T >> P];
                    if (P && (C += c[_ & T << p - P]), v)
                        for (; C.length * p & 7;) C += "=";
                    return C
                },
                rfc4648 = ({
                    name: l,
                    prefix: c,
                    bitsPerChar: p,
                    alphabet: v
                }) => from({
                    prefix: c,
                    name: l,
                    encode: l => encode(l, v, p),
                    decode: c => decode(c, v, p, l)
                }),
                ex = from({
                    prefix: "\x00",
                    name: "identity",
                    encode: l => bytes_toString(l),
                    decode: l => bytes_fromString(l)
                }),
                e_ = rfc4648({
                    prefix: "0",
                    name: "base2",
                    alphabet: "01",
                    bitsPerChar: 1
                }),
                eE = rfc4648({
                    prefix: "7",
                    name: "base8",
                    alphabet: "01234567",
                    bitsPerChar: 3
                }),
                eA = baseX({
                    prefix: "9",
                    name: "base10",
                    alphabet: "0123456789"
                }),
                eC = rfc4648({
                    prefix: "f",
                    name: "base16",
                    alphabet: "0123456789abcdef",
                    bitsPerChar: 4
                }),
                eS = rfc4648({
                    prefix: "F",
                    name: "base16upper",
                    alphabet: "0123456789ABCDEF",
                    bitsPerChar: 4
                }),
                eN = rfc4648({
                    prefix: "b",
                    name: "base32",
                    alphabet: "abcdefghijklmnopqrstuvwxyz234567",
                    bitsPerChar: 5
                }),
                eP = rfc4648({
                    prefix: "B",
                    name: "base32upper",
                    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
                    bitsPerChar: 5
                }),
                eD = rfc4648({
                    prefix: "c",
                    name: "base32pad",
                    alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
                    bitsPerChar: 5
                }),
                ek = rfc4648({
                    prefix: "C",
                    name: "base32padupper",
                    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
                    bitsPerChar: 5
                }),
                eI = rfc4648({
                    prefix: "v",
                    name: "base32hex",
                    alphabet: "0123456789abcdefghijklmnopqrstuv",
                    bitsPerChar: 5
                }),
                eO = rfc4648({
                    prefix: "V",
                    name: "base32hexupper",
                    alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
                    bitsPerChar: 5
                }),
                ej = rfc4648({
                    prefix: "t",
                    name: "base32hexpad",
                    alphabet: "0123456789abcdefghijklmnopqrstuv=",
                    bitsPerChar: 5
                }),
                eT = rfc4648({
                    prefix: "T",
                    name: "base32hexpadupper",
                    alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
                    bitsPerChar: 5
                }),
                eR = rfc4648({
                    prefix: "h",
                    name: "base32z",
                    alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
                    bitsPerChar: 5
                }),
                eL = baseX({
                    prefix: "k",
                    name: "base36",
                    alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
                }),
                eM = baseX({
                    prefix: "K",
                    name: "base36upper",
                    alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
                }),
                eU = baseX({
                    name: "base58btc",
                    prefix: "z",
                    alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
                }),
                eB = baseX({
                    name: "base58flickr",
                    prefix: "Z",
                    alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
                }),
                eF = rfc4648({
                    prefix: "m",
                    name: "base64",
                    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
                    bitsPerChar: 6
                }),
                eH = rfc4648({
                    prefix: "M",
                    name: "base64pad",
                    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
                    bitsPerChar: 6
                }),
                eV = rfc4648({
                    prefix: "u",
                    name: "base64url",
                    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
                    bitsPerChar: 6
                }),
                ez = rfc4648({
                    prefix: "U",
                    name: "base64urlpad",
                    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
                    bitsPerChar: 6
                }),
                eW = Array.from("\uD83D\uDE80\uD83E\uDE90☄\uD83D\uDEF0\uD83C\uDF0C\uD83C\uDF11\uD83C\uDF12\uD83C\uDF13\uD83C\uDF14\uD83C\uDF15\uD83C\uDF16\uD83C\uDF17\uD83C\uDF18\uD83C\uDF0D\uD83C\uDF0F\uD83C\uDF0E\uD83D\uDC09☀\uD83D\uDCBB\uD83D\uDDA5\uD83D\uDCBE\uD83D\uDCBF\uD83D\uDE02❤\uD83D\uDE0D\uD83E\uDD23\uD83D\uDE0A\uD83D\uDE4F\uD83D\uDC95\uD83D\uDE2D\uD83D\uDE18\uD83D\uDC4D\uD83D\uDE05\uD83D\uDC4F\uD83D\uDE01\uD83D\uDD25\uD83E\uDD70\uD83D\uDC94\uD83D\uDC96\uD83D\uDC99\uD83D\uDE22\uD83E\uDD14\uD83D\uDE06\uD83D\uDE44\uD83D\uDCAA\uD83D\uDE09☺\uD83D\uDC4C\uD83E\uDD17\uD83D\uDC9C\uD83D\uDE14\uD83D\uDE0E\uD83D\uDE07\uD83C\uDF39\uD83E\uDD26\uD83C\uDF89\uD83D\uDC9E✌✨\uD83E\uDD37\uD83D\uDE31\uD83D\uDE0C\uD83C\uDF38\uD83D\uDE4C\uD83D\uDE0B\uD83D\uDC97\uD83D\uDC9A\uD83D\uDE0F\uD83D\uDC9B\uD83D\uDE42\uD83D\uDC93\uD83E\uDD29\uD83D\uDE04\uD83D\uDE00\uD83D\uDDA4\uD83D\uDE03\uD83D\uDCAF\uD83D\uDE48\uD83D\uDC47\uD83C\uDFB6\uD83D\uDE12\uD83E\uDD2D❣\uD83D\uDE1C\uD83D\uDC8B\uD83D\uDC40\uD83D\uDE2A\uD83D\uDE11\uD83D\uDCA5\uD83D\uDE4B\uD83D\uDE1E\uD83D\uDE29\uD83D\uDE21\uD83E\uDD2A\uD83D\uDC4A\uD83E\uDD73\uD83D\uDE25\uD83E\uDD24\uD83D\uDC49\uD83D\uDC83\uD83D\uDE33✋\uD83D\uDE1A\uD83D\uDE1D\uD83D\uDE34\uD83C\uDF1F\uD83D\uDE2C\uD83D\uDE43\uD83C\uDF40\uD83C\uDF37\uD83D\uDE3B\uD83D\uDE13⭐✅\uD83E\uDD7A\uD83C\uDF08\uD83D\uDE08\uD83E\uDD18\uD83D\uDCA6✔\uD83D\uDE23\uD83C\uDFC3\uD83D\uDC90☹\uD83C\uDF8A\uD83D\uDC98\uD83D\uDE20☝\uD83D\uDE15\uD83C\uDF3A\uD83C\uDF82\uD83C\uDF3B\uD83D\uDE10\uD83D\uDD95\uD83D\uDC9D\uD83D\uDE4A\uD83D\uDE39\uD83D\uDDE3\uD83D\uDCAB\uD83D\uDC80\uD83D\uDC51\uD83C\uDFB5\uD83E\uDD1E\uD83D\uDE1B\uD83D\uDD34\uD83D\uDE24\uD83C\uDF3C\uD83D\uDE2B⚽\uD83E\uDD19☕\uD83C\uDFC6\uD83E\uDD2B\uD83D\uDC48\uD83D\uDE2E\uD83D\uDE46\uD83C\uDF7B\uD83C\uDF43\uD83D\uDC36\uD83D\uDC81\uD83D\uDE32\uD83C\uDF3F\uD83E\uDDE1\uD83C\uDF81⚡\uD83C\uDF1E\uD83C\uDF88❌✊\uD83D\uDC4B\uD83D\uDE30\uD83E\uDD28\uD83D\uDE36\uD83E\uDD1D\uD83D\uDEB6\uD83D\uDCB0\uD83C\uDF53\uD83D\uDCA2\uD83E\uDD1F\uD83D\uDE41\uD83D\uDEA8\uD83D\uDCA8\uD83E\uDD2C✈\uD83C\uDF80\uD83C\uDF7A\uD83E\uDD13\uD83D\uDE19\uD83D\uDC9F\uD83C\uDF31\uD83D\uDE16\uD83D\uDC76\uD83E\uDD74▶➡❓\uD83D\uDC8E\uD83D\uDCB8⬇\uD83D\uDE28\uD83C\uDF1A\uD83E\uDD8B\uD83D\uDE37\uD83D\uDD7A⚠\uD83D\uDE45\uD83D\uDE1F\uD83D\uDE35\uD83D\uDC4E\uD83E\uDD32\uD83E\uDD20\uD83E\uDD27\uD83D\uDCCC\uD83D\uDD35\uD83D\uDC85\uD83E\uDDD0\uD83D\uDC3E\uD83C\uDF52\uD83D\uDE17\uD83E\uDD11\uD83C\uDF0A\uD83E\uDD2F\uD83D\uDC37☎\uD83D\uDCA7\uD83D\uDE2F\uD83D\uDC86\uD83D\uDC46\uD83C\uDFA4\uD83D\uDE47\uD83C\uDF51❄\uD83C\uDF34\uD83D\uDCA3\uD83D\uDC38\uD83D\uDC8C\uD83D\uDCCD\uD83E\uDD40\uD83E\uDD22\uD83D\uDC45\uD83D\uDCA1\uD83D\uDCA9\uD83D\uDC50\uD83D\uDCF8\uD83D\uDC7B\uD83E\uDD10\uD83E\uDD2E\uD83C\uDFBC\uD83E\uDD75\uD83D\uDEA9\uD83C\uDF4E\uD83C\uDF4A\uD83D\uDC7C\uD83D\uDC8D\uD83D\uDCE3\uD83E\uDD42"),
                eG = eW.reduce((l, c, p) => (l[p] = c, l), []),
                eK = eW.reduce((l, c, p) => (l[c.codePointAt(0)] = p, l), []),
                eZ = from({
                    prefix: "\uD83D\uDE80",
                    name: "base256emoji",
                    encode: function(l) {
                        return l.reduce((l, c) => l += eG[c], "")
                    },
                    decode: function(l) {
                        let c = [];
                        for (let p of l) {
                            let l = eK[p.codePointAt(0)];
                            if (void 0 === l) throw Error(`Non-base256emoji character: ${p}`);
                            c.push(l)
                        }
                        return new Uint8Array(c)
                    }
                });

            function varint_encode(l, c, p) {
                c = c || [];
                for (var v = p = p || 0; l >= 2147483648;) c[p++] = 255 & l | 128, l /= 128;
                for (; - 128 & l;) c[p++] = 255 & l | 128, l >>>= 7;
                return c[p] = 0 | l, varint_encode.bytes = p - v + 1, c
            }

            function read(l, c) {
                var p, v = 0,
                    c = c || 0,
                    _ = 0,
                    C = c,
                    P = l.length;
                do {
                    if (C >= P) throw read.bytes = 0, RangeError("Could not decode varint");
                    p = l[C++], v += _ < 28 ? (127 & p) << _ : (127 & p) * Math.pow(2, _), _ += 7
                } while (p >= 128);
                return read.bytes = C - c, v
            }
            var eJ = {
                encode: varint_encode,
                decode: read,
                encodingLength: function(l) {
                    return l < 128 ? 1 : l < 16384 ? 2 : l < 2097152 ? 3 : l < 268435456 ? 4 : l < 34359738368 ? 5 : l < 4398046511104 ? 6 : l < 562949953421312 ? 7 : l < 72057594037927940 ? 8 : l < 0x7fffffffffffffff ? 9 : 10
                }
            };
            let src_varint_decode = (l, c = 0) => {
                    let p = eJ.decode(l, c);
                    return [p, eJ.decode.bytes]
                },
                encodeTo = (l, c, p = 0) => (eJ.encode(l, c, p), c),
                encodingLength = l => eJ.encodingLength(l),
                create = (l, c) => {
                    let p = c.byteLength,
                        v = encodingLength(l),
                        _ = v + encodingLength(p),
                        C = new Uint8Array(_ + p);
                    return encodeTo(l, C, 0), encodeTo(p, C, v), C.set(c, _), new Digest(l, p, c, C)
                },
                digest_decode = l => {
                    let c = coerce(l),
                        [p, v] = src_varint_decode(c),
                        [_, C] = src_varint_decode(c.subarray(v)),
                        P = c.subarray(v + C);
                    if (P.byteLength !== _) throw Error("Incorrect length");
                    return new Digest(p, _, P, c)
                },
                digest_equals = (l, c) => l === c || l.code === c.code && l.size === c.size && equals(l.bytes, c.bytes);
            let Digest = class Digest {
                constructor(l, c, p, v) {
                    this.code = l, this.size = c, this.digest = p, this.bytes = v
                }
            };
            let hasher_from = ({
                name: l,
                code: c,
                encode: p
            }) => new Hasher(l, c, p);
            let Hasher = class Hasher {
                constructor(l, c, p) {
                    this.name = l, this.code = c, this.encode = p
                }
                digest(l) {
                    if (l instanceof Uint8Array) {
                        let c = this.encode(l);
                        return c instanceof Uint8Array ? create(this.code, c) : c.then(l => create(this.code, l))
                    }
                    throw Error("Unknown type, must be binary type")
                }
            };
            let sha = l => async c => new Uint8Array(await crypto.subtle.digest(l, c)),
                eQ = hasher_from({
                    name: "sha2-256",
                    code: 18,
                    encode: sha("SHA-256")
                }),
                e$ = hasher_from({
                    name: "sha2-512",
                    code: 19,
                    encode: sha("SHA-512")
                }),
                eY = {
                    code: 0,
                    name: "identity",
                    encode: coerce,
                    digest: l => create(0, coerce(l))
                },
                eX = "raw",
                e0 = 85,
                raw_encode = l => coerce(l),
                raw_decode = l => coerce(l),
                e1 = new TextEncoder,
                e2 = new TextDecoder,
                e5 = "json",
                e3 = 512,
                json_encode = l => e1.encode(JSON.stringify(l)),
                json_decode = l => JSON.parse(e2.decode(l));
            let CID = class CID {
                constructor(l, c, p, v) {
                    this.code = c, this.version = l, this.multihash = p, this.bytes = v, this.byteOffset = v.byteOffset, this.byteLength = v.byteLength, this.asCID = this, this._baseCache = new Map, Object.defineProperties(this, {
                        byteOffset: e7,
                        byteLength: e7,
                        code: e9,
                        version: e9,
                        multihash: e9,
                        bytes: e9,
                        _baseCache: e7,
                        asCID: e7
                    })
                }
                toV0() {
                    if (0 === this.version) return this; {
                        let {
                            code: l,
                            multihash: c
                        } = this;
                        if (l !== e6) throw Error("Cannot convert a non dag-pb CID to CIDv0");
                        if (c.code !== e4) throw Error("Cannot convert non sha2-256 multihash CID to CIDv0");
                        return CID.createV0(c)
                    }
                }
                toV1() {
                    switch (this.version) {
                        case 0:
                            {
                                let {
                                    code: l,
                                    digest: c
                                } = this.multihash,
                                p = create(l, c);
                                return CID.createV1(this.code, p)
                            }
                        case 1:
                            return this;
                        default:
                            throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`)
                    }
                }
                equals(l) {
                    return l && this.code === l.code && this.version === l.version && digest_equals(this.multihash, l.multihash)
                }
                toString(l) {
                    let {
                        bytes: c,
                        version: p,
                        _baseCache: v
                    } = this;
                    return 0 === p ? toStringV0(c, v, l || eU.encoder) : toStringV1(c, v, l || eN.encoder)
                }
                toJSON() {
                    return {
                        code: this.code,
                        version: this.version,
                        hash: this.multihash.bytes
                    }
                }
                get[Symbol.toStringTag]() {
                    return "CID"
                }[Symbol.for("nodejs.util.inspect.custom")]() {
                    return "CID(" + this.toString() + ")"
                }
                static isCID(l) {
                    return deprecate(/^0\.0/, tn), !!(l && (l[e8] || l.asCID === l))
                }
                get toBaseEncodedString() {
                    throw Error("Deprecated, use .toString()")
                }
                get codec() {
                    throw Error('"codec" property is deprecated, use integer "code" property instead')
                }
                get buffer() {
                    throw Error("Deprecated .buffer property, use .bytes to get Uint8Array instead")
                }
                get multibaseName() {
                    throw Error('"multibaseName" property is deprecated')
                }
                get prefix() {
                    throw Error('"prefix" property is deprecated')
                }
                static asCID(l) {
                    if (l instanceof CID) return l;
                    if (null != l && l.asCID === l) {
                        let {
                            version: c,
                            code: p,
                            multihash: v,
                            bytes: _
                        } = l;
                        return new CID(c, p, v, _ || encodeCID(c, p, v.bytes))
                    }
                    if (null == l || !0 !== l[e8]) return null; {
                        let {
                            version: c,
                            multihash: p,
                            code: v
                        } = l, _ = digest_decode(p);
                        return CID.create(c, v, _)
                    }
                }
                static create(l, c, p) {
                    if ("number" != typeof c) throw Error("String codecs are no longer supported");
                    switch (l) {
                        case 0:
                            if (c === e6) return new CID(l, c, p, p.bytes);
                            throw Error(`Version 0 CID must use dag-pb (code: ${e6}) block encoding`);
                        case 1:
                            {
                                let v = encodeCID(l, c, p.bytes);
                                return new CID(l, c, p, v)
                            }
                        default:
                            throw Error("Invalid version")
                    }
                }
                static createV0(l) {
                    return CID.create(0, e6, l)
                }
                static createV1(l, c) {
                    return CID.create(1, l, c)
                }
                static decode(l) {
                    let [c, p] = CID.decodeFirst(l);
                    if (p.length) throw Error("Incorrect length");
                    return c
                }
                static decodeFirst(l) {
                    let c = CID.inspectBytes(l),
                        p = c.size - c.multihashSize,
                        v = coerce(l.subarray(p, p + c.multihashSize));
                    if (v.byteLength !== c.multihashSize) throw Error("Incorrect length");
                    let _ = v.subarray(c.multihashSize - c.digestSize),
                        C = new Digest(c.multihashCode, c.digestSize, _, v),
                        P = 0 === c.version ? CID.createV0(C) : CID.createV1(c.codec, C);
                    return [P, l.subarray(c.size)]
                }
                static inspectBytes(l) {
                    let c = 0,
                        next = () => {
                            let [p, v] = src_varint_decode(l.subarray(c));
                            return c += v, p
                        },
                        p = next(),
                        v = e6;
                    if (18 === p ? (p = 0, c = 0) : 1 === p && (v = next()), 0 !== p && 1 !== p) throw RangeError(`Invalid CID version ${p}`);
                    let _ = c,
                        C = next(),
                        P = next(),
                        T = c + P;
                    return {
                        version: p,
                        codec: v,
                        multihashCode: C,
                        digestSize: P,
                        multihashSize: T - _,
                        size: T
                    }
                }
                static parse(l, c) {
                    let [p, v] = parseCIDtoBytes(l, c), _ = CID.decode(v);
                    return _._baseCache.set(p, l), _
                }
            };
            let parseCIDtoBytes = (l, c) => {
                    switch (l[0]) {
                        case "Q":
                            return [eU.prefix, (c || eU).decode(`${eU.prefix}${l}`)];
                        case eU.prefix:
                            return [eU.prefix, (c || eU).decode(l)];
                        case eN.prefix:
                            return [eN.prefix, (c || eN).decode(l)];
                        default:
                            if (null == c) throw Error("To parse non base32 or base58btc encoded CID multibase decoder must be provided");
                            return [l[0], c.decode(l)]
                    }
                },
                toStringV0 = (l, c, p) => {
                    let {
                        prefix: v
                    } = p;
                    if (v !== eU.prefix) throw Error(`Cannot string encode V0 in ${p.name} encoding`);
                    let _ = c.get(v);
                    if (null != _) return _; {
                        let _ = p.encode(l).slice(1);
                        return c.set(v, _), _
                    }
                },
                toStringV1 = (l, c, p) => {
                    let {
                        prefix: v
                    } = p, _ = c.get(v);
                    if (null != _) return _; {
                        let _ = p.encode(l);
                        return c.set(v, _), _
                    }
                },
                e6 = 112,
                e4 = 18,
                encodeCID = (l, c, p) => {
                    let v = encodingLength(l),
                        _ = v + encodingLength(c),
                        C = new Uint8Array(_ + p.byteLength);
                    return encodeTo(l, C, 0), encodeTo(c, C, v), C.set(p, _), C
                },
                e8 = Symbol.for("@ipld/js-cid/CID"),
                e9 = {
                    writable: !1,
                    configurable: !1,
                    enumerable: !0
                },
                e7 = {
                    writable: !1,
                    enumerable: !1,
                    configurable: !1
                },
                deprecate = (l, c) => {
                    if (l.test("0.0.0-dev")) console.warn(c);
                    else throw Error(c)
                },
                tn = `CID.isCID(v) is deprecated and will be removed in the next major release.
Following code pattern:

if (CID.isCID(value)) {
  doSomethingWithCID(value)
}

Is replaced with:

const cid = CID.asCID(value)
if (cid) {
  // Make sure to use cid instead of value
  doSomethingWithCID(cid)
}
`,
                ts = { ...C,
                    ...P,
                    ...T,
                    ...M,
                    ...z,
                    ...J,
                    ...Q,
                    ...X,
                    ...es,
                    ...eo
                };

            function createCodec(l, c, p, v) {
                return {
                    name: l,
                    prefix: c,
                    encoder: {
                        name: l,
                        prefix: c,
                        encode: p
                    },
                    decoder: {
                        decode: v
                    }
                }
            }({ ...el,
                ...ec
            });
            let ta = createCodec("utf8", "u", l => {
                    let c = new TextDecoder("utf8");
                    return "u" + c.decode(l)
                }, l => {
                    let c = new TextEncoder;
                    return c.encode(l.substring(1))
                }),
                to = createCodec("ascii", "a", l => {
                    let c = "a";
                    for (let p = 0; p < l.length; p++) c += String.fromCharCode(l[p]);
                    return c
                }, l => {
                    l = l.substring(1);
                    let c = allocUnsafe(l.length);
                    for (let p = 0; p < l.length; p++) c[p] = l.charCodeAt(p);
                    return c
                }),
                tl = {
                    utf8: ta,
                    "utf-8": ta,
                    hex: ts.base16,
                    latin1: to,
                    ascii: to,
                    binary: to,
                    ...ts
                };

            function from_string_fromString(l, c = "utf8") {
                let p = tl[c];
                if (!p) throw Error(`Unsupported encoding "${c}"`);
                return ("utf8" === c || "utf-8" === c) && null != globalThis.Buffer && null != globalThis.Buffer.from ? as_uint8array_asUint8Array(globalThis.Buffer.from(l, "utf-8")) : p.decoder.decode(`${p.prefix}${l}`)
            }

            function to_string_toString(l, c = "utf8") {
                let p = tl[c];
                if (!p) throw Error(`Unsupported encoding "${c}"`);
                return ("utf8" === c || "utf-8" === c) && null != globalThis.Buffer && null != globalThis.Buffer.from ? globalThis.Buffer.from(l.buffer, l.byteOffset, l.byteLength).toString("utf8") : p.encoder.encode(l).substring(1)
            }
            var tc = p(1390),
                __spreadArray = function(l, c, p) {
                    if (p || 2 == arguments.length)
                        for (var v, _ = 0, C = c.length; _ < C; _++) !v && _ in c || (v || (v = Array.prototype.slice.call(c, 0, _)), v[_] = c[_]);
                    return l.concat(v || Array.prototype.slice.call(c))
                },
                BrowserInfo = function(l, c, p) {
                    this.name = l, this.version = c, this.os = p, this.type = "browser"
                },
                NodeInfo = function(l) {
                    this.version = l, this.type = "node", this.name = "node", this.os = tc.platform
                },
                SearchBotDeviceInfo = function(l, c, p, v) {
                    this.name = l, this.version = c, this.os = p, this.bot = v, this.type = "bot-device"
                },
                BotInfo = function() {
                    this.type = "bot", this.bot = !0, this.name = "bot", this.version = null, this.os = null
                },
                ReactNativeInfo = function() {
                    this.type = "react-native", this.name = "react-native", this.version = null, this.os = null
                },
                th = /(nuhk|curl|Googlebot|Yammybot|Openbot|Slurp|MSNBot|Ask\ Jeeves\/Teoma|ia_archiver)/,
                td = [
                    ["aol", /AOLShield\/([0-9\._]+)/],
                    ["edge", /Edge\/([0-9\._]+)/],
                    ["edge-ios", /EdgiOS\/([0-9\._]+)/],
                    ["yandexbrowser", /YaBrowser\/([0-9\._]+)/],
                    ["kakaotalk", /KAKAOTALK\s([0-9\.]+)/],
                    ["samsung", /SamsungBrowser\/([0-9\.]+)/],
                    ["silk", /\bSilk\/([0-9._-]+)\b/],
                    ["miui", /MiuiBrowser\/([0-9\.]+)$/],
                    ["beaker", /BeakerBrowser\/([0-9\.]+)/],
                    ["edge-chromium", /EdgA?\/([0-9\.]+)/],
                    ["chromium-webview", /(?!Chrom.*OPR)wv\).*Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/],
                    ["chrome", /(?!Chrom.*OPR)Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/],
                    ["phantomjs", /PhantomJS\/([0-9\.]+)(:?\s|$)/],
                    ["crios", /CriOS\/([0-9\.]+)(:?\s|$)/],
                    ["firefox", /Firefox\/([0-9\.]+)(?:\s|$)/],
                    ["fxios", /FxiOS\/([0-9\.]+)/],
                    ["opera-mini", /Opera Mini.*Version\/([0-9\.]+)/],
                    ["opera", /Opera\/([0-9\.]+)(?:\s|$)/],
                    ["opera", /OPR\/([0-9\.]+)(:?\s|$)/],
                    ["pie", /^Microsoft Pocket Internet Explorer\/(\d+\.\d+)$/],
                    ["pie", /^Mozilla\/\d\.\d+\s\(compatible;\s(?:MSP?IE|MSInternet Explorer) (\d+\.\d+);.*Windows CE.*\)$/],
                    ["netfront", /^Mozilla\/\d\.\d+.*NetFront\/(\d.\d)/],
                    ["ie", /Trident\/7\.0.*rv\:([0-9\.]+).*\).*Gecko$/],
                    ["ie", /MSIE\s([0-9\.]+);.*Trident\/[4-7].0/],
                    ["ie", /MSIE\s(7\.0)/],
                    ["bb10", /BB10;\sTouch.*Version\/([0-9\.]+)/],
                    ["android", /Android\s([0-9\.]+)/],
                    ["ios", /Version\/([0-9\._]+).*Mobile.*Safari.*/],
                    ["safari", /Version\/([0-9\._]+).*Safari/],
                    ["facebook", /FB[AS]V\/([0-9\.]+)/],
                    ["instagram", /Instagram\s([0-9\.]+)/],
                    ["ios-webview", /AppleWebKit\/([0-9\.]+).*Mobile/],
                    ["ios-webview", /AppleWebKit\/([0-9\.]+).*Gecko\)$/],
                    ["curl", /^curl\/([0-9\.]+)$/],
                    ["searchbot", /alexa|bot|crawl(er|ing)|facebookexternalhit|feedburner|google web preview|nagios|postrank|pingdom|slurp|spider|yahoo!|yandex/]
                ],
                tf = [
                    ["iOS", /iP(hone|od|ad)/],
                    ["Android OS", /Android/],
                    ["BlackBerry OS", /BlackBerry|BB10/],
                    ["Windows Mobile", /IEMobile/],
                    ["Amazon OS", /Kindle/],
                    ["Windows 3.11", /Win16/],
                    ["Windows 95", /(Windows 95)|(Win95)|(Windows_95)/],
                    ["Windows 98", /(Windows 98)|(Win98)/],
                    ["Windows 2000", /(Windows NT 5.0)|(Windows 2000)/],
                    ["Windows XP", /(Windows NT 5.1)|(Windows XP)/],
                    ["Windows Server 2003", /(Windows NT 5.2)/],
                    ["Windows Vista", /(Windows NT 6.0)/],
                    ["Windows 7", /(Windows NT 6.1)/],
                    ["Windows 8", /(Windows NT 6.2)/],
                    ["Windows 8.1", /(Windows NT 6.3)/],
                    ["Windows 10", /(Windows NT 10.0)/],
                    ["Windows ME", /Windows ME/],
                    ["Windows CE", /Windows CE|WinCE|Microsoft Pocket Internet Explorer/],
                    ["Open BSD", /OpenBSD/],
                    ["Sun OS", /SunOS/],
                    ["Chrome OS", /CrOS/],
                    ["Linux", /(Linux)|(X11)/],
                    ["Mac OS", /(Mac_PowerPC)|(Macintosh)/],
                    ["QNX", /QNX/],
                    ["BeOS", /BeOS/],
                    ["OS/2", /OS\/2/]
                ];

            function parseUserAgent(l) {
                var c = "" !== l && td.reduce(function(c, p) {
                    var v = p[0],
                        _ = p[1];
                    if (c) return c;
                    var C = _.exec(l);
                    return !!C && [v, C]
                }, !1);
                if (!c) return null;
                var p = c[0],
                    v = c[1];
                if ("searchbot" === p) return new BotInfo;
                var _ = v[1] && v[1].split(".").join("_").split("_").slice(0, 3);
                _ ? _.length < 3 && (_ = __spreadArray(__spreadArray([], _, !0), function(l) {
                    for (var c = [], p = 0; p < l; p++) c.push("0");
                    return c
                }(3 - _.length), !0)) : _ = [];
                var C = _.join("."),
                    P = function(l) {
                        for (var c = 0, p = tf.length; c < p; c++) {
                            var v = tf[c],
                                _ = v[0];
                            if (v[1].exec(l)) return _
                        }
                        return null
                    }(l),
                    T = th.exec(l);
                return T && T[1] ? new SearchBotDeviceInfo(p, C, P, T[1]) : new BrowserInfo(p, C, P)
            }
            var tp = p(9044),
                tg = p(6525),
                tm = p(1976),
                ty = p(9842);
            p(6375);
            let tb = {
                waku: {
                    publish: "waku_publish",
                    batchPublish: "waku_batchPublish",
                    subscribe: "waku_subscribe",
                    batchSubscribe: "waku_batchSubscribe",
                    subscription: "waku_subscription",
                    unsubscribe: "waku_unsubscribe",
                    batchUnsubscribe: "waku_batchUnsubscribe"
                },
                irn: {
                    publish: "irn_publish",
                    batchPublish: "irn_batchPublish",
                    subscribe: "irn_subscribe",
                    batchSubscribe: "irn_batchSubscribe",
                    subscription: "irn_subscription",
                    unsubscribe: "irn_unsubscribe",
                    batchUnsubscribe: "irn_batchUnsubscribe"
                },
                iridium: {
                    publish: "iridium_publish",
                    batchPublish: "iridium_batchPublish",
                    subscribe: "iridium_subscribe",
                    batchSubscribe: "iridium_batchSubscribe",
                    subscription: "iridium_subscription",
                    unsubscribe: "iridium_unsubscribe",
                    batchUnsubscribe: "iridium_batchUnsubscribe"
                }
            };
            var tw = p(1390);

            function K(l, c) {
                return l.includes(":") ? [l] : c.chains || []
            }
            let tx = "base10",
                t_ = "base16",
                tE = "base64pad",
                tA = "utf8";

            function Dn() {
                let l = (0, ey.randomBytes)(32);
                return to_string_toString(l, t_)
            }

            function Mn(l) {
                let c = (0, eb.vp)(from_string_fromString(l, tA));
                return to_string_toString(c, t_)
            }

            function $(l) {
                return Number(to_string_toString(l, tx))
            }

            function ee(l) {
                let c = from_string_fromString(l, tE),
                    p = c.slice(0, 1);
                if (1 === $(p)) {
                    let l = c.slice(1, 33),
                        v = c.slice(33, 45),
                        _ = c.slice(45);
                    return {
                        type: p,
                        sealed: _,
                        iv: v,
                        senderPublicKey: l
                    }
                }
                let v = c.slice(1, 13),
                    _ = c.slice(13);
                return {
                    type: p,
                    sealed: _,
                    iv: v
                }
            }

            function Re(l) {
                let c = l ? .type || 0;
                if (1 === c) {
                    if (typeof l ? .senderPublicKey > "u") throw Error("missing sender public key");
                    if (typeof l ? .receiverPublicKey > "u") throw Error("missing receiver public key")
                }
                return {
                    type: c,
                    senderPublicKey: l ? .senderPublicKey,
                    receiverPublicKey: l ? .receiverPublicKey
                }
            }

            function Fn(l) {
                return 1 === l.type && "string" == typeof l.senderPublicKey && "string" == typeof l.receiverPublicKey
            }
            var tC = Object.defineProperty,
                tS = Object.getOwnPropertySymbols,
                tN = Object.prototype.hasOwnProperty,
                tP = Object.prototype.propertyIsEnumerable,
                Ue = (l, c, p) => c in l ? tC(l, c, {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: p
                }) : l[c] = p,
                _e = (l, c) => {
                    for (var p in c || (c = {})) tN.call(c, p) && Ue(l, p, c[p]);
                    if (tS)
                        for (var p of tS(c)) tP.call(c, p) && Ue(l, p, c[p]);
                    return l
                };
            let tD = {
                reactNative: "react-native",
                node: "node",
                browser: "browser",
                unknown: "unknown"
            };

            function te() {
                return "u" > typeof tw && "u" > typeof tw.versions && "u" > typeof tw.versions.node
            }

            function j() {
                return !(0, tg.getDocument)() && !!(0, tg.getNavigator)() && "ReactNative" === navigator.product
            }

            function q() {
                return !te() && !!(0, tg.getNavigator)()
            }

            function R() {
                return j() ? tD.reactNative : te() ? tD.node : q() ? tD.browser : tD.unknown
            }

            function O(l, c) {
                return l.filter(l => c.includes(l)).length === l.length
            }

            function et(l) {
                return Object.fromEntries(l.entries())
            }

            function nt(l) {
                return new Map(Object.entries(l))
            }

            function st(l = tp.FIVE_MINUTES, c) {
                let p, v, _;
                let C = (0, tp.toMiliseconds)(l || tp.FIVE_MINUTES);
                return {
                    resolve: l => {
                        _ && p && (clearTimeout(_), p(l))
                    },
                    reject: l => {
                        _ && v && (clearTimeout(_), v(l))
                    },
                    done: () => new Promise((l, P) => {
                        _ = setTimeout(() => {
                            P(Error(c))
                        }, C), p = l, v = P
                    })
                }
            }

            function it(l, c, p) {
                return new Promise(async (v, _) => {
                    let C = setTimeout(() => _(Error(p)), c);
                    try {
                        let c = await l;
                        v(c)
                    } catch (l) {
                        _(l)
                    }
                    clearTimeout(C)
                })
            }

            function re(l, c) {
                if ("string" == typeof c && c.startsWith(`${l}:`)) return c;
                if ("topic" === l.toLowerCase()) {
                    if ("string" != typeof c) throw Error('Value must be "string" for expirer target type: topic');
                    return `topic:${c}`
                }
                if ("id" === l.toLowerCase()) {
                    if ("number" != typeof c) throw Error('Value must be "number" for expirer target type: id');
                    return `id:${c}`
                }
                throw Error(`Unknown expirer target type: ${l}`)
            }

            function ut(l) {
                let [c, p] = l.split(":"), v = {
                    id: void 0,
                    topic: void 0
                };
                if ("topic" === c && "string" == typeof p) v.topic = p;
                else if ("id" === c && Number.isInteger(Number(p))) v.id = Number(p);
                else throw Error(`Invalid target, expected id:number or topic:string, got ${c}:${p}`);
                return v
            }

            function lt(l, c) {
                return (0, tp.fromMiliseconds)((c || Date.now()) + (0, tp.toMiliseconds)(l))
            }

            function dt(l) {
                return Date.now() >= (0, tp.toMiliseconds)(l)
            }

            function ft(l, c) {
                return `${l}${c?`:${c}`:""}`
            }

            function S(l = [], c = []) {
                return [...new Set([...l, ...c])]
            }
            async function pt({
                id: l,
                topic: c,
                wcDeepLink: v
            }) {
                try {
                    if (!v) return;
                    let _ = "string" == typeof v ? JSON.parse(v) : v,
                        C = _ ? .href;
                    if ("string" != typeof C) return;
                    C.endsWith("/") && (C = C.slice(0, -1));
                    let P = `${C}/wc?requestId=${l}&sessionTopic=${c}`,
                        T = R();
                    T === tD.browser ? P.startsWith("https://") ? window.open(P, "_blank", "noreferrer noopener") : window.open(P, "_self", "noreferrer noopener") : T === tD.reactNative && "u" > typeof(null == p.g ? void 0 : p.g.Linking) && await p.g.Linking.openURL(P)
                } catch (l) {
                    console.error(l)
                }
            }

            function mt(l) {
                return l ? .relay || {
                    protocol: "irn"
                }
            }

            function yt(l) {
                let c = tb[l];
                if (typeof c > "u") throw Error(`Relay Protocol not supported: ${l}`);
                return c
            }
            var tk = Object.defineProperty,
                tI = Object.getOwnPropertySymbols,
                tO = Object.prototype.hasOwnProperty,
                tj = Object.prototype.propertyIsEnumerable,
                qe = (l, c, p) => c in l ? tk(l, c, {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: p
                }) : l[c] = p,
                Et = (l, c) => {
                    for (var p in c || (c = {})) tO.call(c, p) && qe(l, p, c[p]);
                    if (tI)
                        for (var p of tI(c)) tj.call(c, p) && qe(l, p, c[p]);
                    return l
                };

            function A(l) {
                let c = [];
                return l.forEach(l => {
                    let [p, v] = l.split(":");
                    c.push(`${p}:${v}`)
                }), c
            }

            function oe(l) {
                return l.includes(":")
            }

            function Xe(l) {
                return oe(l) ? l.split(":")[0] : l
            }
            Object.prototype.hasOwnProperty, Object.prototype.propertyIsEnumerable;
            let tT = {
                    INVALID_METHOD: {
                        message: "Invalid method.",
                        code: 1001
                    },
                    INVALID_EVENT: {
                        message: "Invalid event.",
                        code: 1002
                    },
                    INVALID_UPDATE_REQUEST: {
                        message: "Invalid update request.",
                        code: 1003
                    },
                    INVALID_EXTEND_REQUEST: {
                        message: "Invalid extend request.",
                        code: 1004
                    },
                    INVALID_SESSION_SETTLE_REQUEST: {
                        message: "Invalid session settle request.",
                        code: 1005
                    },
                    UNAUTHORIZED_METHOD: {
                        message: "Unauthorized method.",
                        code: 3001
                    },
                    UNAUTHORIZED_EVENT: {
                        message: "Unauthorized event.",
                        code: 3002
                    },
                    UNAUTHORIZED_UPDATE_REQUEST: {
                        message: "Unauthorized update request.",
                        code: 3003
                    },
                    UNAUTHORIZED_EXTEND_REQUEST: {
                        message: "Unauthorized extend request.",
                        code: 3004
                    },
                    USER_REJECTED: {
                        message: "User rejected.",
                        code: 5e3
                    },
                    USER_REJECTED_CHAINS: {
                        message: "User rejected chains.",
                        code: 5001
                    },
                    USER_REJECTED_METHODS: {
                        message: "User rejected methods.",
                        code: 5002
                    },
                    USER_REJECTED_EVENTS: {
                        message: "User rejected events.",
                        code: 5003
                    },
                    UNSUPPORTED_CHAINS: {
                        message: "Unsupported chains.",
                        code: 5100
                    },
                    UNSUPPORTED_METHODS: {
                        message: "Unsupported methods.",
                        code: 5101
                    },
                    UNSUPPORTED_EVENTS: {
                        message: "Unsupported events.",
                        code: 5102
                    },
                    UNSUPPORTED_ACCOUNTS: {
                        message: "Unsupported accounts.",
                        code: 5103
                    },
                    UNSUPPORTED_NAMESPACE_KEY: {
                        message: "Unsupported namespace key.",
                        code: 5104
                    },
                    USER_DISCONNECTED: {
                        message: "User disconnected.",
                        code: 6e3
                    },
                    SESSION_SETTLEMENT_FAILED: {
                        message: "Session settlement failed.",
                        code: 7e3
                    },
                    WC_METHOD_UNSUPPORTED: {
                        message: "Unsupported wc_ method.",
                        code: 10001
                    }
                },
                tR = {
                    NOT_INITIALIZED: {
                        message: "Not initialized.",
                        code: 1
                    },
                    NO_MATCHING_KEY: {
                        message: "No matching key.",
                        code: 2
                    },
                    RESTORE_WILL_OVERRIDE: {
                        message: "Restore will override.",
                        code: 3
                    },
                    RESUBSCRIBED: {
                        message: "Resubscribed.",
                        code: 4
                    },
                    MISSING_OR_INVALID: {
                        message: "Missing or invalid.",
                        code: 5
                    },
                    EXPIRED: {
                        message: "Expired.",
                        code: 6
                    },
                    UNKNOWN_TYPE: {
                        message: "Unknown type.",
                        code: 7
                    },
                    MISMATCHED_TOPIC: {
                        message: "Mismatched topic.",
                        code: 8
                    },
                    NON_CONFORMING_NAMESPACES: {
                        message: "Non conforming namespaces.",
                        code: 9
                    }
                };

            function N(l, c) {
                let {
                    message: p,
                    code: v
                } = tR[l];
                return {
                    message: c ? `${p} ${c}` : p,
                    code: v
                }
            }

            function U(l, c) {
                let {
                    message: p,
                    code: v
                } = tT[l];
                return {
                    message: c ? `${p} ${c}` : p,
                    code: v
                }
            }

            function D(l, c) {
                return !!Array.isArray(l) && (!("u" > typeof c) || !l.length || l.every(c))
            }

            function B(l) {
                return Object.getPrototypeOf(l) === Object.prototype && Object.keys(l).length
            }

            function w(l) {
                return typeof l > "u"
            }

            function h(l, c) {
                return !!(c && w(l)) || "string" == typeof l && !!l.trim().length
            }

            function G(l, c) {
                return !!(c && w(l)) || "number" == typeof l && !isNaN(l)
            }

            function k(l) {
                return !!(h(l, !1) && l.includes(":")) && 2 === l.split(":").length
            }

            function ie(l) {
                let c = !0;
                return D(l) ? l.length && (c = l.every(l => h(l, !1))) : c = !1, c
            }

            function ce(l, c) {
                let p = null;
                return Object.values(l).forEach(l => {
                    var v;
                    let _;
                    if (p) return;
                    let C = (v = `${c}, namespace`, _ = null, ie(l ? .methods) ? ie(l ? .events) || (_ = U("UNSUPPORTED_EVENTS", `${v}, events should be an array of strings or empty array for no events`)) : _ = U("UNSUPPORTED_METHODS", `${v}, methods should be an array of strings or empty array for no methods`), _);
                    C && (p = C)
                }), p
            }

            function cn(l, c) {
                let p = null;
                if (l && B(l)) {
                    let v;
                    let _ = ce(l, c);
                    _ && (p = _);
                    let C = (v = null, Object.values(l).forEach(l => {
                        var p, _;
                        let C;
                        if (v) return;
                        let P = (p = l ? .accounts, _ = `${c} namespace`, C = null, D(p) ? p.forEach(l => {
                            C || function(l) {
                                if (h(l, !1) && l.includes(":")) {
                                    let c = l.split(":");
                                    if (3 === c.length) {
                                        let l = c[0] + ":" + c[1];
                                        return !!c[2] && k(l)
                                    }
                                }
                                return !1
                            }(l) || (C = U("UNSUPPORTED_ACCOUNTS", `${_}, account ${l} should be a string and conform to "namespace:chainId:address" format`))
                        }) : C = U("UNSUPPORTED_ACCOUNTS", `${_}, accounts should be an array of strings conforming to "namespace:chainId:address" format`), C);
                        P && (v = P)
                    }), v);
                    C && (p = C)
                } else p = N("MISSING_OR_INVALID", `${c}, namespaces should be an object with data`);
                return p
            }

            function an(l) {
                return h(l.protocol, !0)
            }

            function xt(l) {
                return "u" > typeof l
            }

            function Gt(l, c) {
                return !(!k(c) || !(function(l) {
                    let c = [];
                    return Object.values(l).forEach(l => {
                        c.push(...A(l.accounts))
                    }), c
                })(l).includes(c))
            }

            function un(l, c, p) {
                let v = null,
                    _ = function(l) {
                        let c = {};
                        return Object.keys(l).forEach(p => {
                            var v;
                            p.includes(":") ? c[p] = l[p] : null == (v = l[p].chains) || v.forEach(v => {
                                c[v] = {
                                    methods: l[p].methods,
                                    events: l[p].events
                                }
                            })
                        }), c
                    }(l),
                    C = function(l) {
                        let c = {};
                        return Object.keys(l).forEach(p => {
                            if (p.includes(":")) c[p] = l[p];
                            else {
                                let v = A(l[p].accounts);
                                v ? .forEach(v => {
                                    c[v] = {
                                        accounts: l[p].accounts.filter(l => l.includes(`${v}:`)),
                                        methods: l[p].methods,
                                        events: l[p].events
                                    }
                                })
                            }
                        }), c
                    }(c),
                    P = Object.keys(_),
                    T = Object.keys(C),
                    M = ln(Object.keys(l)),
                    z = ln(Object.keys(c)),
                    J = M.filter(l => !z.includes(l));
                return J.length && (v = N("NON_CONFORMING_NAMESPACES", `${p} namespaces keys don't satisfy requiredNamespaces.
      Required: ${J.toString()}
      Received: ${Object.keys(c).toString()}`)), O(P, T) || (v = N("NON_CONFORMING_NAMESPACES", `${p} namespaces chains don't satisfy required namespaces.
      Required: ${P.toString()}
      Approved: ${T.toString()}`)), Object.keys(c).forEach(l => {
                    if (!l.includes(":") || v) return;
                    let _ = A(c[l].accounts);
                    _.includes(l) || (v = N("NON_CONFORMING_NAMESPACES", `${p} namespaces accounts don't satisfy namespace accounts for ${l}
        Required: ${l}
        Approved: ${_.toString()}`))
                }), P.forEach(l => {
                    v || (O(_[l].methods, C[l].methods) ? O(_[l].events, C[l].events) || (v = N("NON_CONFORMING_NAMESPACES", `${p} namespaces events don't satisfy namespace events for ${l}`)) : v = N("NON_CONFORMING_NAMESPACES", `${p} namespaces methods don't satisfy namespace methods for ${l}`))
                }), v
            }

            function ln(l) {
                return [...new Set(l.map(l => l.includes(":") ? l.split(":")[0] : l))]
            }

            function Zt() {
                let l = R();
                return new Promise(c => {
                    switch (l) {
                        case tD.browser:
                            c(q() && navigator ? .onLine);
                            break;
                        case tD.reactNative:
                            c(fn());
                            break;
                        case tD.node:
                        default:
                            c(!0)
                    }
                })
            }
            async function fn() {
                if (j() && "u" > typeof p.g && null != p.g && p.g.NetInfo) {
                    let l = await (null == p.g ? void 0 : p.g.NetInfo.fetch());
                    return l ? .isConnected
                }
                return !0
            }
            let tL = {};
            let er = class er {
                static get(l) {
                    return tL[l]
                }
                static set(l, c) {
                    tL[l] = c
                }
                static delete(l) {
                    delete tL[l]
                }
            };
            var tM = p(7251),
                tU = p(8889),
                tB = p(3387),
                tF = p(6920);
            let n = class n extends tF.q {
                constructor(l) {
                    super(), this.opts = l, this.protocol = "wc", this.version = 2
                }
            };
            let index_es_h = class index_es_h extends tF.q {
                constructor(l, c) {
                    super(), this.core = l, this.logger = c, this.records = new Map
                }
            };
            let a = class a {
                constructor(l, c) {
                    this.logger = l, this.core = c
                }
            };
            let u = class u extends tF.q {
                constructor(l, c) {
                    super(), this.relayer = l, this.logger = c
                }
            };
            let g = class g extends tF.q {
                constructor(l) {
                    super()
                }
            };
            let index_es_p = class index_es_p {
                constructor(l, c, p, v) {
                    this.core = l, this.logger = c, this.name = p
                }
            };
            let d = class d extends tF.q {
                constructor(l, c) {
                    super(), this.relayer = l, this.logger = c
                }
            };
            let E = class E extends tF.q {
                constructor(l, c) {
                    super(), this.core = l, this.logger = c
                }
            };
            let y = class y {
                constructor(l, c) {
                    this.projectId = l, this.logger = c
                }
            };
            let b = class b {
                constructor(l) {
                    this.opts = l, this.protocol = "wc", this.version = 2
                }
            };
            let index_es_S = class index_es_S {
                constructor(l) {
                    this.client = l
                }
            };
            let JSONStringify = l => JSON.stringify(l, (l, c) => "bigint" == typeof c ? c.toString() + "n" : c),
                JSONParse = l => {
                    let c = l.replace(/([\[:])?(\d{17,}|(?:[9](?:[1-9]07199254740991|0[1-9]7199254740991|00[8-9]199254740991|007[2-9]99254740991|007199[3-9]54740991|0071992[6-9]4740991|00719925[5-9]740991|007199254[8-9]40991|0071992547[5-9]0991|00719925474[1-9]991|00719925474099[2-9])))([,\}\]])/g, '$1"$2n"$3');
                    return JSON.parse(c, (l, c) => {
                        let p = "string" == typeof c && c.match(/^\d+n$/);
                        return p ? BigInt(c.substring(0, c.length - 1)) : c
                    })
                };

            function esm_safeJsonParse(l) {
                if ("string" != typeof l) throw Error(`Cannot safe json parse value of type ${typeof l}`);
                try {
                    return JSONParse(l)
                } catch (c) {
                    return l
                }
            }

            function safeJsonStringify(l) {
                return "string" == typeof l ? l : JSONStringify(l) || ""
            }
            var tH = p(7425);
            let tV = "base64url",
                tz = "base58btc";

            function encodeJSON(l) {
                return to_string_toString(from_string_fromString(safeJsonStringify(l), "utf8"), tV)
            }

            function encodeIss(l) {
                let c = from_string_fromString("K36", tz),
                    p = "z" + to_string_toString(concat([c, l]), tz);
                return ["did", "key", p].join(":")
            }

            function generateKeyPair(l = (0, ey.randomBytes)(32)) {
                return tH._w(l)
            }
            async function signJWT(l, c, p, v, _ = (0, tp.fromMiliseconds)(Date.now())) {
                var C, P;
                let T = {
                        alg: "EdDSA",
                        typ: "JWT"
                    },
                    M = encodeIss(v.publicKey),
                    z = {
                        iss: M,
                        sub: l,
                        aud: c,
                        iat: _,
                        exp: _ + p
                    },
                    J = from_string_fromString([encodeJSON((C = {
                        header: T,
                        payload: z
                    }).header), encodeJSON(C.payload)].join("."), "utf8"),
                    Q = tH.Xx(v.secretKey, J);
                return [encodeJSON((P = {
                    header: T,
                    payload: z,
                    signature: Q
                }).header), encodeJSON(P.payload), to_string_toString(P.signature, tV)].join(".")
            }
            p(6380);
            let tq = "INTERNAL_ERROR",
                tW = "SERVER_ERROR",
                tG = [-32700, -32600, -32601, -32602, -32603],
                tK = {
                    PARSE_ERROR: {
                        code: -32700,
                        message: "Parse error"
                    },
                    INVALID_REQUEST: {
                        code: -32600,
                        message: "Invalid Request"
                    },
                    METHOD_NOT_FOUND: {
                        code: -32601,
                        message: "Method not found"
                    },
                    INVALID_PARAMS: {
                        code: -32602,
                        message: "Invalid params"
                    },
                    [tq]: {
                        code: -32603,
                        message: "Internal error"
                    },
                    [tW]: {
                        code: -32e3,
                        message: "Server error"
                    }
                };

            function getError(l) {
                return Object.keys(tK).includes(l) ? tK[l] : tK[tW]
            }

            function parseConnectionError(l, c, p) {
                return l.message.includes("getaddrinfo ENOTFOUND") || l.message.includes("connect ECONNREFUSED") ? Error(`Unavailable ${p} RPC url at ${c}`) : l
            }
            var tZ = p(315);

            function payloadId(l = 3) {
                let c = Date.now() * Math.pow(10, l);
                return c + Math.floor(Math.random() * Math.pow(10, l))
            }

            function getBigIntRpcId(l = 6) {
                return BigInt(payloadId(l))
            }

            function formatJsonRpcRequest(l, c, p) {
                return {
                    id: p || payloadId(),
                    jsonrpc: "2.0",
                    method: l,
                    params: c
                }
            }

            function formatJsonRpcResult(l, c) {
                return {
                    id: l,
                    jsonrpc: "2.0",
                    result: c
                }
            }

            function formatJsonRpcError(l, c, p) {
                var v, _;
                return {
                    id: l,
                    jsonrpc: "2.0",
                    error: void 0 === (v = c) ? getError(tq) : ("string" == typeof v && (v = Object.assign(Object.assign({}, getError(tW)), {
                        message: v
                    })), void 0 !== p && (v.data = p), _ = v.code, tG.includes(_) && (v = function(l) {
                        let c = Object.values(tK).find(c => c.code === l);
                        return c || tK[tW]
                    }(v.code)), v)
                }
            }
            let misc_IEvents = class misc_IEvents {};
            let IBaseJsonRpcProvider = class IBaseJsonRpcProvider extends misc_IEvents {
                constructor() {
                    super()
                }
            };
            let IJsonRpcProvider = class IJsonRpcProvider extends IBaseJsonRpcProvider {
                constructor(l) {
                    super()
                }
            };

            function matchRegexProtocol(l, c) {
                let p = function(l) {
                    let c = l.match(RegExp(/^\w+:/, "gi"));
                    if (c && c.length) return c[0]
                }(l);
                return void 0 !== p && new RegExp(c).test(p)
            }

            function isHttpUrl(l) {
                return matchRegexProtocol(l, "^https?:")
            }

            function isWsUrl(l) {
                return matchRegexProtocol(l, "^wss?:")
            }

            function isJsonRpcPayload(l) {
                return "object" == typeof l && "id" in l && "jsonrpc" in l && "2.0" === l.jsonrpc
            }

            function isJsonRpcRequest(l) {
                return isJsonRpcPayload(l) && "method" in l
            }

            function isJsonRpcResponse(l) {
                return isJsonRpcPayload(l) && (isJsonRpcResult(l) || isJsonRpcError(l))
            }

            function isJsonRpcResult(l) {
                return "result" in l
            }

            function isJsonRpcError(l) {
                return "error" in l
            }
            let JsonRpcProvider = class JsonRpcProvider extends IJsonRpcProvider {
                constructor(l) {
                    super(l), this.events = new ef.EventEmitter, this.hasRegisteredEventListeners = !1, this.connection = this.setConnection(l), this.connection.connected && this.registerEventListeners()
                }
                async connect(l = this.connection) {
                    await this.open(l)
                }
                async disconnect() {
                    await this.close()
                }
                on(l, c) {
                    this.events.on(l, c)
                }
                once(l, c) {
                    this.events.once(l, c)
                }
                off(l, c) {
                    this.events.off(l, c)
                }
                removeListener(l, c) {
                    this.events.removeListener(l, c)
                }
                async request(l, c) {
                    return this.requestStrict(formatJsonRpcRequest(l.method, l.params || [], l.id || getBigIntRpcId().toString()), c)
                }
                async requestStrict(l, c) {
                    return new Promise(async (p, v) => {
                        if (!this.connection.connected) try {
                            await this.open()
                        } catch (l) {
                            v(l)
                        }
                        this.events.on(`${l.id}`, l => {
                            isJsonRpcError(l) ? v(l.error) : p(l.result)
                        });
                        try {
                            await this.connection.send(l, c)
                        } catch (l) {
                            v(l)
                        }
                    })
                }
                setConnection(l = this.connection) {
                    return l
                }
                onPayload(l) {
                    this.events.emit("payload", l), isJsonRpcResponse(l) ? this.events.emit(`${l.id}`, l) : this.events.emit("message", {
                        type: l.method,
                        data: l.params
                    })
                }
                onClose(l) {
                    l && 3e3 === l.code && this.events.emit("error", Error(`WebSocket connection closed abnormally with code: ${l.code} ${l.reason?`(${l.reason})`:""}`)), this.events.emit("disconnect")
                }
                async open(l = this.connection) {
                    this.connection === l && this.connection.connected || (this.connection.connected && this.close(), "string" == typeof l && (await this.connection.open(l), l = this.connection), this.connection = this.setConnection(l), await this.connection.open(), this.registerEventListeners(), this.events.emit("connect"))
                }
                async close() {
                    await this.connection.close()
                }
                registerEventListeners() {
                    this.hasRegisteredEventListeners || (this.connection.on("payload", l => this.onPayload(l)), this.connection.on("close", l => this.onClose(l)), this.connection.on("error", l => this.events.emit("error", l)), this.connection.on("register_error", l => this.onClose()), this.hasRegisteredEventListeners = !0)
                }
            };
            let hasBuiltInWebSocket = () => "undefined" != typeof WebSocket || void 0 !== p.g && void 0 !== p.g.WebSocket || "undefined" != typeof window && void 0 !== window.WebSocket || "undefined" != typeof self && void 0 !== self.WebSocket,
                truncateQuery = l => l.split("?")[0],
                tJ = "undefined" != typeof WebSocket ? WebSocket : void 0 !== p.g && void 0 !== p.g.WebSocket ? p.g.WebSocket : "undefined" != typeof window && void 0 !== window.WebSocket ? window.WebSocket : "undefined" != typeof self && void 0 !== self.WebSocket ? self.WebSocket : p(5315);
            var tQ = class {
                    constructor(l) {
                        if (this.url = l, this.events = new ef.EventEmitter, this.registering = !1, !isWsUrl(l)) throw Error(`Provided URL is not compatible with WebSocket connection: ${l}`);
                        this.url = l
                    }
                    get connected() {
                        return void 0 !== this.socket
                    }
                    get connecting() {
                        return this.registering
                    }
                    on(l, c) {
                        this.events.on(l, c)
                    }
                    once(l, c) {
                        this.events.once(l, c)
                    }
                    off(l, c) {
                        this.events.off(l, c)
                    }
                    removeListener(l, c) {
                        this.events.removeListener(l, c)
                    }
                    async open(l = this.url) {
                        await this.register(l)
                    }
                    async close() {
                        return new Promise((l, c) => {
                            if (void 0 === this.socket) {
                                c(Error("Connection already closed"));
                                return
                            }
                            this.socket.onclose = c => {
                                this.onClose(c), l()
                            }, this.socket.close()
                        })
                    }
                    async send(l, c) {
                        void 0 === this.socket && (this.socket = await this.register());
                        try {
                            this.socket.send(safeJsonStringify(l))
                        } catch (c) {
                            this.onError(l.id, c)
                        }
                    }
                    register(l = this.url) {
                        if (!isWsUrl(l)) throw Error(`Provided URL is not compatible with WebSocket connection: ${l}`);
                        if (this.registering) {
                            let l = this.events.getMaxListeners();
                            return (this.events.listenerCount("register_error") >= l || this.events.listenerCount("open") >= l) && this.events.setMaxListeners(l + 1), new Promise((l, c) => {
                                this.events.once("register_error", l => {
                                    this.resetMaxListeners(), c(l)
                                }), this.events.once("open", () => {
                                    if (this.resetMaxListeners(), void 0 === this.socket) return c(Error("WebSocket connection is missing or invalid"));
                                    l(this.socket)
                                })
                            })
                        }
                        return this.url = l, this.registering = !0, new Promise((c, p) => {
                            let v = (0, tZ.isReactNative)() ? void 0 : {
                                    rejectUnauthorized: !RegExp("wss?://localhost(:d{2,5})?").test(l)
                                },
                                _ = new tJ(l, [], v);
                            hasBuiltInWebSocket() ? _.onerror = l => {
                                p(this.emitError(l.error))
                            } : _.on("error", l => {
                                p(this.emitError(l))
                            }), _.onopen = () => {
                                this.onOpen(_), c(_)
                            }
                        })
                    }
                    onOpen(l) {
                        l.onmessage = l => this.onPayload(l), l.onclose = l => this.onClose(l), this.socket = l, this.registering = !1, this.events.emit("open")
                    }
                    onClose(l) {
                        this.socket = void 0, this.registering = !1, this.events.emit("close", l)
                    }
                    onPayload(l) {
                        if (void 0 === l.data) return;
                        let c = "string" == typeof l.data ? esm_safeJsonParse(l.data) : l.data;
                        this.events.emit("payload", c)
                    }
                    onError(l, c) {
                        let p = this.parseError(c),
                            v = p.message || p.toString(),
                            _ = formatJsonRpcError(l, v);
                        this.events.emit("payload", _)
                    }
                    parseError(l, c = this.url) {
                        return parseConnectionError(l, truncateQuery(c), "WS")
                    }
                    resetMaxListeners() {
                        this.events.getMaxListeners() > 10 && this.events.setMaxListeners(10)
                    }
                    emitError(l) {
                        let c = this.parseError(Error((null == l ? void 0 : l.message) || `WebSocket connection failed for host: ${truncateQuery(this.url)}`));
                        return this.events.emit("register_error", c), c
                    }
                },
                t$ = p(9736),
                tY = p.n(t$),
                Vi = function(l, c) {
                    if (l.length >= 255) throw TypeError("Alphabet too long");
                    for (var p = new Uint8Array(256), v = 0; v < p.length; v++) p[v] = 255;
                    for (var _ = 0; _ < l.length; _++) {
                        var C = l.charAt(_),
                            P = C.charCodeAt(0);
                        if (255 !== p[P]) throw TypeError(C + " is ambiguous");
                        p[P] = _
                    }
                    var T = l.length,
                        M = l.charAt(0),
                        z = Math.log(T) / Math.log(256),
                        J = Math.log(256) / Math.log(T);

                    function y(l) {
                        if ("string" != typeof l) throw TypeError("Expected String");
                        if (0 === l.length) return new Uint8Array;
                        var c = 0;
                        if (" " !== l[0]) {
                            for (var v = 0, _ = 0; l[c] === M;) v++, c++;
                            for (var C = (l.length - c) * z + 1 >>> 0, P = new Uint8Array(C); l[c];) {
                                var J = p[l.charCodeAt(c)];
                                if (255 === J) return;
                                for (var Q = 0, X = C - 1;
                                    (0 !== J || Q < _) && -1 !== X; X--, Q++) J += T * P[X] >>> 0, P[X] = J % 256 >>> 0, J = J / 256 >>> 0;
                                if (0 !== J) throw Error("Non-zero carry");
                                _ = Q, c++
                            }
                            if (" " !== l[c]) {
                                for (var es = C - _; es !== C && 0 === P[es];) es++;
                                for (var eo = new Uint8Array(v + (C - es)), el = v; es !== C;) eo[el++] = P[es++];
                                return eo
                            }
                        }
                    }
                    return {
                        encode: function(c) {
                            if (c instanceof Uint8Array || (ArrayBuffer.isView(c) ? c = new Uint8Array(c.buffer, c.byteOffset, c.byteLength) : Array.isArray(c) && (c = Uint8Array.from(c))), !(c instanceof Uint8Array)) throw TypeError("Expected Uint8Array");
                            if (0 === c.length) return "";
                            for (var p = 0, v = 0, _ = 0, C = c.length; _ !== C && 0 === c[_];) _++, p++;
                            for (var P = (C - _) * J + 1 >>> 0, z = new Uint8Array(P); _ !== C;) {
                                for (var Q = c[_], X = 0, es = P - 1;
                                    (0 !== Q || X < v) && -1 !== es; es--, X++) Q += 256 * z[es] >>> 0, z[es] = Q % T >>> 0, Q = Q / T >>> 0;
                                if (0 !== Q) throw Error("Non-zero carry");
                                v = X, _++
                            }
                            for (var eo = P - v; eo !== P && 0 === z[eo];) eo++;
                            for (var el = M.repeat(p); eo < P; ++eo) el += l.charAt(z[eo]);
                            return el
                        },
                        decodeUnsafe: y,
                        decode: function(l) {
                            var p = y(l);
                            if (p) return p;
                            throw Error(`Non-${c} character`)
                        }
                    }
                };
            let index_es_ze = l => {
                    if (l instanceof Uint8Array && "Uint8Array" === l.constructor.name) return l;
                    if (l instanceof ArrayBuffer) return new Uint8Array(l);
                    if (ArrayBuffer.isView(l)) return new Uint8Array(l.buffer, l.byteOffset, l.byteLength);
                    throw Error("Unknown type, must be binary type")
                },
                qi = l => new TextEncoder().encode(l),
                ji = l => new TextDecoder().decode(l);
            let Yi = class Yi {
                constructor(l, c, p) {
                    this.name = l, this.prefix = c, this.baseEncode = p
                }
                encode(l) {
                    if (l instanceof Uint8Array) return `${this.prefix}${this.baseEncode(l)}`;
                    throw Error("Unknown type, must be binary type")
                }
            };
            let Gi = class Gi {
                constructor(l, c, p) {
                    if (this.name = l, this.prefix = c, void 0 === c.codePointAt(0)) throw Error("Invalid prefix character");
                    this.prefixCodePoint = c.codePointAt(0), this.baseDecode = p
                }
                decode(l) {
                    if ("string" == typeof l) {
                        if (l.codePointAt(0) !== this.prefixCodePoint) throw Error(`Unable to decode multibase string ${JSON.stringify(l)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
                        return this.baseDecode(l.slice(this.prefix.length))
                    }
                    throw Error("Can only multibase decode strings")
                }
                or(l) {
                    return index_es_Ne(this, l)
                }
            };
            let Hi = class Hi {
                constructor(l) {
                    this.decoders = l
                }
                or(l) {
                    return index_es_Ne(this, l)
                }
                decode(l) {
                    let c = l[0],
                        p = this.decoders[c];
                    if (p) return p.decode(l);
                    throw RangeError(`Unable to decode multibase string ${JSON.stringify(l)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`)
                }
            };
            let index_es_Ne = (l, c) => new Hi({ ...l.decoders || {
                    [l.prefix]: l
                },
                ...c.decoders || {
                    [c.prefix]: c
                }
            });
            let Ji = class Ji {
                constructor(l, c, p, v) {
                    this.name = l, this.prefix = c, this.baseEncode = p, this.baseDecode = v, this.encoder = new Yi(l, c, p), this.decoder = new Gi(l, c, v)
                }
                encode(l) {
                    return this.encoder.encode(l)
                }
                decode(l) {
                    return this.decoder.decode(l)
                }
            };
            let W = ({
                    name: l,
                    prefix: c,
                    encode: p,
                    decode: v
                }) => new Ji(l, c, p, v),
                index_es_K = ({
                    prefix: l,
                    name: c,
                    alphabet: p
                }) => {
                    let {
                        encode: v,
                        decode: _
                    } = Vi(p, c);
                    return W({
                        prefix: l,
                        name: c,
                        encode: v,
                        decode: l => index_es_ze(_(l))
                    })
                },
                Wi = (l, c, p, v) => {
                    let _ = {};
                    for (let l = 0; l < c.length; ++l) _[c[l]] = l;
                    let C = l.length;
                    for (;
                        "=" === l[C - 1];) --C;
                    let P = new Uint8Array(C * p / 8 | 0),
                        T = 0,
                        M = 0,
                        z = 0;
                    for (let c = 0; c < C; ++c) {
                        let C = _[l[c]];
                        if (void 0 === C) throw SyntaxError(`Non-${v} character`);
                        M = M << p | C, (T += p) >= 8 && (T -= 8, P[z++] = 255 & M >> T)
                    }
                    if (T >= p || 255 & M << 8 - T) throw SyntaxError("Unexpected end of data");
                    return P
                },
                Xi = (l, c, p) => {
                    let v = "=" === c[c.length - 1],
                        _ = (1 << p) - 1,
                        C = "",
                        P = 0,
                        T = 0;
                    for (let v = 0; v < l.length; ++v)
                        for (T = T << 8 | l[v], P += 8; P > p;) P -= p, C += c[_ & T >> P];
                    if (P && (C += c[_ & T << p - P]), v)
                        for (; C.length * p & 7;) C += "=";
                    return C
                },
                index_es_g = ({
                    name: l,
                    prefix: c,
                    bitsPerChar: p,
                    alphabet: v
                }) => W({
                    prefix: c,
                    name: l,
                    encode: l => Xi(l, v, p),
                    decode: c => Wi(c, v, p, l)
                }),
                tX = W({
                    prefix: "\x00",
                    name: "identity",
                    encode: l => ji(l),
                    decode: l => qi(l)
                });
            var t0 = Object.freeze({
                __proto__: null,
                identity: tX
            });
            let t1 = index_es_g({
                prefix: "0",
                name: "base2",
                alphabet: "01",
                bitsPerChar: 1
            });
            var t2 = Object.freeze({
                __proto__: null,
                base2: t1
            });
            let t5 = index_es_g({
                prefix: "7",
                name: "base8",
                alphabet: "01234567",
                bitsPerChar: 3
            });
            var t3 = Object.freeze({
                __proto__: null,
                base8: t5
            });
            let t6 = index_es_K({
                prefix: "9",
                name: "base10",
                alphabet: "0123456789"
            });
            var t4 = Object.freeze({
                __proto__: null,
                base10: t6
            });
            let t8 = index_es_g({
                    prefix: "f",
                    name: "base16",
                    alphabet: "0123456789abcdef",
                    bitsPerChar: 4
                }),
                t9 = index_es_g({
                    prefix: "F",
                    name: "base16upper",
                    alphabet: "0123456789ABCDEF",
                    bitsPerChar: 4
                });
            var t7 = Object.freeze({
                __proto__: null,
                base16: t8,
                base16upper: t9
            });
            let rt = index_es_g({
                    prefix: "b",
                    name: "base32",
                    alphabet: "abcdefghijklmnopqrstuvwxyz234567",
                    bitsPerChar: 5
                }),
                rs = index_es_g({
                    prefix: "B",
                    name: "base32upper",
                    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
                    bitsPerChar: 5
                }),
                ra = index_es_g({
                    prefix: "c",
                    name: "base32pad",
                    alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
                    bitsPerChar: 5
                }),
                ro = index_es_g({
                    prefix: "C",
                    name: "base32padupper",
                    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
                    bitsPerChar: 5
                }),
                rl = index_es_g({
                    prefix: "v",
                    name: "base32hex",
                    alphabet: "0123456789abcdefghijklmnopqrstuv",
                    bitsPerChar: 5
                }),
                rc = index_es_g({
                    prefix: "V",
                    name: "base32hexupper",
                    alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
                    bitsPerChar: 5
                }),
                rh = index_es_g({
                    prefix: "t",
                    name: "base32hexpad",
                    alphabet: "0123456789abcdefghijklmnopqrstuv=",
                    bitsPerChar: 5
                }),
                rd = index_es_g({
                    prefix: "T",
                    name: "base32hexpadupper",
                    alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
                    bitsPerChar: 5
                }),
                rp = index_es_g({
                    prefix: "h",
                    name: "base32z",
                    alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
                    bitsPerChar: 5
                });
            var rg = Object.freeze({
                __proto__: null,
                base32: rt,
                base32upper: rs,
                base32pad: ra,
                base32padupper: ro,
                base32hex: rl,
                base32hexupper: rc,
                base32hexpad: rh,
                base32hexpadupper: rd,
                base32z: rp
            });
            let rm = index_es_K({
                    prefix: "k",
                    name: "base36",
                    alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
                }),
                ry = index_es_K({
                    prefix: "K",
                    name: "base36upper",
                    alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
                });
            var rb = Object.freeze({
                __proto__: null,
                base36: rm,
                base36upper: ry
            });
            let rw = index_es_K({
                    name: "base58btc",
                    prefix: "z",
                    alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
                }),
                rx = index_es_K({
                    name: "base58flickr",
                    prefix: "Z",
                    alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
                });
            var r_ = Object.freeze({
                __proto__: null,
                base58btc: rw,
                base58flickr: rx
            });
            let rE = index_es_g({
                    prefix: "m",
                    name: "base64",
                    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
                    bitsPerChar: 6
                }),
                rA = index_es_g({
                    prefix: "M",
                    name: "base64pad",
                    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
                    bitsPerChar: 6
                }),
                rC = index_es_g({
                    prefix: "u",
                    name: "base64url",
                    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
                    bitsPerChar: 6
                }),
                rS = index_es_g({
                    prefix: "U",
                    name: "base64urlpad",
                    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
                    bitsPerChar: 6
                });
            var rN = Object.freeze({
                __proto__: null,
                base64: rE,
                base64pad: rA,
                base64url: rC,
                base64urlpad: rS
            });
            let rP = Array.from("\uD83D\uDE80\uD83E\uDE90☄\uD83D\uDEF0\uD83C\uDF0C\uD83C\uDF11\uD83C\uDF12\uD83C\uDF13\uD83C\uDF14\uD83C\uDF15\uD83C\uDF16\uD83C\uDF17\uD83C\uDF18\uD83C\uDF0D\uD83C\uDF0F\uD83C\uDF0E\uD83D\uDC09☀\uD83D\uDCBB\uD83D\uDDA5\uD83D\uDCBE\uD83D\uDCBF\uD83D\uDE02❤\uD83D\uDE0D\uD83E\uDD23\uD83D\uDE0A\uD83D\uDE4F\uD83D\uDC95\uD83D\uDE2D\uD83D\uDE18\uD83D\uDC4D\uD83D\uDE05\uD83D\uDC4F\uD83D\uDE01\uD83D\uDD25\uD83E\uDD70\uD83D\uDC94\uD83D\uDC96\uD83D\uDC99\uD83D\uDE22\uD83E\uDD14\uD83D\uDE06\uD83D\uDE44\uD83D\uDCAA\uD83D\uDE09☺\uD83D\uDC4C\uD83E\uDD17\uD83D\uDC9C\uD83D\uDE14\uD83D\uDE0E\uD83D\uDE07\uD83C\uDF39\uD83E\uDD26\uD83C\uDF89\uD83D\uDC9E✌✨\uD83E\uDD37\uD83D\uDE31\uD83D\uDE0C\uD83C\uDF38\uD83D\uDE4C\uD83D\uDE0B\uD83D\uDC97\uD83D\uDC9A\uD83D\uDE0F\uD83D\uDC9B\uD83D\uDE42\uD83D\uDC93\uD83E\uDD29\uD83D\uDE04\uD83D\uDE00\uD83D\uDDA4\uD83D\uDE03\uD83D\uDCAF\uD83D\uDE48\uD83D\uDC47\uD83C\uDFB6\uD83D\uDE12\uD83E\uDD2D❣\uD83D\uDE1C\uD83D\uDC8B\uD83D\uDC40\uD83D\uDE2A\uD83D\uDE11\uD83D\uDCA5\uD83D\uDE4B\uD83D\uDE1E\uD83D\uDE29\uD83D\uDE21\uD83E\uDD2A\uD83D\uDC4A\uD83E\uDD73\uD83D\uDE25\uD83E\uDD24\uD83D\uDC49\uD83D\uDC83\uD83D\uDE33✋\uD83D\uDE1A\uD83D\uDE1D\uD83D\uDE34\uD83C\uDF1F\uD83D\uDE2C\uD83D\uDE43\uD83C\uDF40\uD83C\uDF37\uD83D\uDE3B\uD83D\uDE13⭐✅\uD83E\uDD7A\uD83C\uDF08\uD83D\uDE08\uD83E\uDD18\uD83D\uDCA6✔\uD83D\uDE23\uD83C\uDFC3\uD83D\uDC90☹\uD83C\uDF8A\uD83D\uDC98\uD83D\uDE20☝\uD83D\uDE15\uD83C\uDF3A\uD83C\uDF82\uD83C\uDF3B\uD83D\uDE10\uD83D\uDD95\uD83D\uDC9D\uD83D\uDE4A\uD83D\uDE39\uD83D\uDDE3\uD83D\uDCAB\uD83D\uDC80\uD83D\uDC51\uD83C\uDFB5\uD83E\uDD1E\uD83D\uDE1B\uD83D\uDD34\uD83D\uDE24\uD83C\uDF3C\uD83D\uDE2B⚽\uD83E\uDD19☕\uD83C\uDFC6\uD83E\uDD2B\uD83D\uDC48\uD83D\uDE2E\uD83D\uDE46\uD83C\uDF7B\uD83C\uDF43\uD83D\uDC36\uD83D\uDC81\uD83D\uDE32\uD83C\uDF3F\uD83E\uDDE1\uD83C\uDF81⚡\uD83C\uDF1E\uD83C\uDF88❌✊\uD83D\uDC4B\uD83D\uDE30\uD83E\uDD28\uD83D\uDE36\uD83E\uDD1D\uD83D\uDEB6\uD83D\uDCB0\uD83C\uDF53\uD83D\uDCA2\uD83E\uDD1F\uD83D\uDE41\uD83D\uDEA8\uD83D\uDCA8\uD83E\uDD2C✈\uD83C\uDF80\uD83C\uDF7A\uD83E\uDD13\uD83D\uDE19\uD83D\uDC9F\uD83C\uDF31\uD83D\uDE16\uD83D\uDC76\uD83E\uDD74▶➡❓\uD83D\uDC8E\uD83D\uDCB8⬇\uD83D\uDE28\uD83C\uDF1A\uD83E\uDD8B\uD83D\uDE37\uD83D\uDD7A⚠\uD83D\uDE45\uD83D\uDE1F\uD83D\uDE35\uD83D\uDC4E\uD83E\uDD32\uD83E\uDD20\uD83E\uDD27\uD83D\uDCCC\uD83D\uDD35\uD83D\uDC85\uD83E\uDDD0\uD83D\uDC3E\uD83C\uDF52\uD83D\uDE17\uD83E\uDD11\uD83C\uDF0A\uD83E\uDD2F\uD83D\uDC37☎\uD83D\uDCA7\uD83D\uDE2F\uD83D\uDC86\uD83D\uDC46\uD83C\uDFA4\uD83D\uDE47\uD83C\uDF51❄\uD83C\uDF34\uD83D\uDCA3\uD83D\uDC38\uD83D\uDC8C\uD83D\uDCCD\uD83E\uDD40\uD83E\uDD22\uD83D\uDC45\uD83D\uDCA1\uD83D\uDCA9\uD83D\uDC50\uD83D\uDCF8\uD83D\uDC7B\uD83E\uDD10\uD83E\uDD2E\uD83C\uDFBC\uD83E\uDD75\uD83D\uDEA9\uD83C\uDF4E\uD83C\uDF4A\uD83D\uDC7C\uD83D\uDC8D\uD83D\uDCE3\uD83E\uDD42"),
                rD = rP.reduce((l, c, p) => (l[p] = c, l), []),
                rk = rP.reduce((l, c, p) => (l[c.codePointAt(0)] = p, l), []),
                rI = W({
                    prefix: "\uD83D\uDE80",
                    name: "base256emoji",
                    encode: function(l) {
                        return l.reduce((l, c) => l += rD[c], "")
                    },
                    decode: function(l) {
                        let c = [];
                        for (let p of l) {
                            let l = rk[p.codePointAt(0)];
                            if (void 0 === l) throw Error(`Non-base256emoji character: ${p}`);
                            c.push(l)
                        }
                        return new Uint8Array(c)
                    }
                });
            var rO = Object.freeze({
                __proto__: null,
                base256emoji: rI
            });

            function index_es_Fe(l, c, p) {
                c = c || [], p = p || 0;
                for (var v = p; l >= 2147483648;) c[p++] = 255 & l | 128, l /= 128;
                for (; - 128 & l;) c[p++] = 255 & l | 128, l >>>= 7;
                return c[p] = 0 | l, index_es_Fe.bytes = p - v + 1, c
            }

            function index_es_oe(l, c) {
                var p, v = 0,
                    c = c || 0,
                    _ = 0,
                    C = c,
                    P = l.length;
                do {
                    if (C >= P) throw index_es_oe.bytes = 0, RangeError("Could not decode varint");
                    p = l[C++], v += _ < 28 ? (127 & p) << _ : (127 & p) * Math.pow(2, _), _ += 7
                } while (p >= 128);
                return index_es_oe.bytes = C - c, v
            }
            var rj = {
                encode: index_es_Fe,
                decode: index_es_oe,
                encodingLength: function(l) {
                    return l < 128 ? 1 : l < 16384 ? 2 : l < 2097152 ? 3 : l < 268435456 ? 4 : l < 34359738368 ? 5 : l < 4398046511104 ? 6 : l < 562949953421312 ? 7 : l < 72057594037927940 ? 8 : l < 0x7fffffffffffffff ? 9 : 10
                }
            };
            let index_es_ke = (l, c, p = 0) => (rj.encode(l, c, p), c),
                index_es_Ke = l => rj.encodingLength(l),
                index_es_he = (l, c) => {
                    let p = c.byteLength,
                        v = index_es_Ke(l),
                        _ = v + index_es_Ke(p),
                        C = new Uint8Array(_ + p);
                    return index_es_ke(l, C, 0), index_es_ke(p, C, v), C.set(c, _), new Zs(l, p, c, C)
                };
            let Zs = class Zs {
                constructor(l, c, p, v) {
                    this.code = l, this.size = c, this.digest = p, this.bytes = v
                }
            };
            let index_es_Be = ({
                name: l,
                code: c,
                encode: p
            }) => new index_es_er(l, c, p);
            let index_es_er = class index_es_er {
                constructor(l, c, p) {
                    this.name = l, this.code = c, this.encode = p
                }
                digest(l) {
                    if (l instanceof Uint8Array) {
                        let c = this.encode(l);
                        return c instanceof Uint8Array ? index_es_he(this.code, c) : c.then(l => index_es_he(this.code, l))
                    }
                    throw Error("Unknown type, must be binary type")
                }
            };
            let index_es_Ve = l => async c => new Uint8Array(await crypto.subtle.digest(l, c)),
                rT = index_es_Be({
                    name: "sha2-256",
                    code: 18,
                    encode: index_es_Ve("SHA-256")
                }),
                rR = index_es_Be({
                    name: "sha2-512",
                    code: 19,
                    encode: index_es_Ve("SHA-512")
                });
            var rL = Object.freeze({
                    __proto__: null,
                    sha256: rT,
                    sha512: rR
                }),
                rM = Object.freeze({
                    __proto__: null,
                    identity: {
                        code: 0,
                        name: "identity",
                        encode: index_es_ze,
                        digest: l => index_es_he(0, index_es_ze(l))
                    }
                });
            new TextEncoder, new TextDecoder;
            let rU = { ...t0,
                ...t2,
                ...t3,
                ...t4,
                ...t7,
                ...rg,
                ...rb,
                ...r_,
                ...rN,
                ...rO
            };

            function index_es_Ge(l) {
                return null != globalThis.Buffer ? new Uint8Array(l.buffer, l.byteOffset, l.byteLength) : l
            }

            function index_es_He(l, c, p, v) {
                return {
                    name: l,
                    prefix: c,
                    encoder: {
                        name: l,
                        prefix: c,
                        encode: p
                    },
                    decoder: {
                        decode: v
                    }
                }
            }({ ...rL,
                ...rM
            });
            let rB = index_es_He("utf8", "u", l => "u" + new TextDecoder("utf8").decode(l), l => new TextEncoder().encode(l.substring(1))),
                rF = index_es_He("ascii", "a", l => {
                    let c = "a";
                    for (let p = 0; p < l.length; p++) c += String.fromCharCode(l[p]);
                    return c
                }, l => {
                    l = l.substring(1);
                    let c = function(l = 0) {
                        return null != globalThis.Buffer && null != globalThis.Buffer.allocUnsafe ? index_es_Ge(globalThis.Buffer.allocUnsafe(l)) : new Uint8Array(l)
                    }(l.length);
                    for (let p = 0; p < l.length; p++) c[p] = l.charCodeAt(p);
                    return c
                }),
                rH = {
                    utf8: rB,
                    "utf-8": rB,
                    hex: rU.base16,
                    latin1: rF,
                    ascii: rF,
                    binary: rF,
                    ...rU
                },
                rV = "core",
                rz = `wc@2:${rV}:`,
                rq = {
                    logger: "error"
                },
                rW = {
                    database: ":memory:"
                },
                rG = "client_ed25519_seed",
                rK = tp.ONE_DAY,
                rZ = tp.SIX_HOURS,
                rJ = "wss://relay.walletconnect.com",
                rQ = "wss://relay.walletconnect.org",
                r$ = {
                    message: "relayer_message",
                    message_ack: "relayer_message_ack",
                    connect: "relayer_connect",
                    disconnect: "relayer_disconnect",
                    error: "relayer_error",
                    connection_stalled: "relayer_connection_stalled",
                    publish: "relayer_publish"
                },
                rY = {
                    payload: "payload",
                    connect: "connect",
                    disconnect: "disconnect",
                    error: "error"
                },
                rX = tp.ONE_SECOND,
                r0 = {
                    created: "subscription_created",
                    deleted: "subscription_deleted",
                    sync: "subscription_sync",
                    resubscribed: "subscription_resubscribed"
                },
                r1 = 1e3 * tp.FIVE_SECONDS,
                r2 = {
                    wc_pairingDelete: {
                        req: {
                            ttl: tp.ONE_DAY,
                            prompt: !1,
                            tag: 1e3
                        },
                        res: {
                            ttl: tp.ONE_DAY,
                            prompt: !1,
                            tag: 1001
                        }
                    },
                    wc_pairingPing: {
                        req: {
                            ttl: tp.THIRTY_SECONDS,
                            prompt: !1,
                            tag: 1002
                        },
                        res: {
                            ttl: tp.THIRTY_SECONDS,
                            prompt: !1,
                            tag: 1003
                        }
                    },
                    unregistered_method: {
                        req: {
                            ttl: tp.ONE_DAY,
                            prompt: !1,
                            tag: 0
                        },
                        res: {
                            ttl: tp.ONE_DAY,
                            prompt: !1,
                            tag: 0
                        }
                    }
                },
                r5 = {
                    create: "pairing_create",
                    expire: "pairing_expire",
                    delete: "pairing_delete",
                    ping: "pairing_ping"
                },
                r3 = {
                    created: "history_created",
                    updated: "history_updated",
                    deleted: "history_deleted",
                    sync: "history_sync"
                },
                r6 = {
                    created: "expirer_created",
                    deleted: "expirer_deleted",
                    expired: "expirer_expired",
                    sync: "expirer_sync"
                },
                r4 = "verify-api",
                r8 = "https://verify.walletconnect.com",
                r9 = "https://verify.walletconnect.org";
            let index_es_Rt = class index_es_Rt {
                constructor(l, c) {
                    this.core = l, this.logger = c, this.keychain = new Map, this.name = "keychain", this.version = "0.3", this.initialized = !1, this.storagePrefix = rz, this.init = async () => {
                        if (!this.initialized) {
                            let l = await this.getKeyChain();
                            "u" > typeof l && (this.keychain = l), this.initialized = !0
                        }
                    }, this.has = l => (this.isInitialized(), this.keychain.has(l)), this.set = async (l, c) => {
                        this.isInitialized(), this.keychain.set(l, c), await this.persist()
                    }, this.get = l => {
                        this.isInitialized();
                        let c = this.keychain.get(l);
                        if (typeof c > "u") {
                            let {
                                message: c
                            } = N("NO_MATCHING_KEY", `${this.name}: ${l}`);
                            throw Error(c)
                        }
                        return c
                    }, this.del = async l => {
                        this.isInitialized(), this.keychain.delete(l), await this.persist()
                    }, this.core = l, this.logger = (0, tB.generateChildLogger)(c, this.name)
                }
                get context() {
                    return (0, tB.getLoggerContext)(this.logger)
                }
                get storageKey() {
                    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name
                }
                async setKeyChain(l) {
                    await this.core.storage.setItem(this.storageKey, et(l))
                }
                async getKeyChain() {
                    let l = await this.core.storage.getItem(this.storageKey);
                    return "u" > typeof l ? nt(l) : void 0
                }
                async persist() {
                    await this.setKeyChain(this.keychain)
                }
                isInitialized() {
                    if (!this.initialized) {
                        let {
                            message: l
                        } = N("NOT_INITIALIZED", this.name);
                        throw Error(l)
                    }
                }
            };
            let index_es_t = class index_es_t {
                constructor(l, c, p) {
                    this.core = l, this.logger = c, this.name = "crypto", this.initialized = !1, this.init = async () => {
                        this.initialized || (await this.keychain.init(), this.initialized = !0)
                    }, this.hasKeys = l => (this.isInitialized(), this.keychain.has(l)), this.getClientId = async () => {
                        this.isInitialized();
                        let l = await this.getClientSeed(),
                            c = generateKeyPair(l);
                        return encodeIss(c.publicKey)
                    }, this.generateKeyPair = () => {
                        this.isInitialized();
                        let l = function() {
                            let l = ew.Au();
                            return {
                                privateKey: to_string_toString(l.secretKey, t_),
                                publicKey: to_string_toString(l.publicKey, t_)
                            }
                        }();
                        return this.setPrivateKey(l.publicKey, l.privateKey)
                    }, this.signJWT = async l => {
                        this.isInitialized();
                        let c = await this.getClientSeed(),
                            p = generateKeyPair(c),
                            v = Dn();
                        return await signJWT(v, l, rK, p)
                    }, this.generateSharedKey = (l, c, p) => {
                        this.isInitialized();
                        let v = this.getPrivateKey(l),
                            _ = function(l, c) {
                                let p = ew.gi(from_string_fromString(l, t_), from_string_fromString(c, t_), !0),
                                    v = new em.t(eb.mE, p).expand(32);
                                return to_string_toString(v, t_)
                            }(v, c);
                        return this.setSymKey(_, p)
                    }, this.setSymKey = async (l, c) => {
                        this.isInitialized();
                        let p = c || function(l) {
                            let c = (0, eb.vp)(from_string_fromString(l, t_));
                            return to_string_toString(c, t_)
                        }(l);
                        return await this.keychain.set(p, l), p
                    }, this.deleteKeyPair = async l => {
                        this.isInitialized(), await this.keychain.del(l)
                    }, this.deleteSymKey = async l => {
                        this.isInitialized(), await this.keychain.del(l)
                    }, this.encode = async (l, c, p) => {
                        this.isInitialized();
                        let v = Re(p),
                            _ = safeJsonStringify(c);
                        if (Fn(v)) {
                            let c = v.senderPublicKey,
                                p = v.receiverPublicKey;
                            l = await this.generateSharedKey(c, p)
                        }
                        let C = this.getSymKey(l),
                            {
                                type: P,
                                senderPublicKey: T
                            } = v;
                        return function(l) {
                            var c;
                            let p = (c = "u" > typeof l.type ? l.type : 0, from_string_fromString(`${c}`, tx));
                            if (1 === $(p) && typeof l.senderPublicKey > "u") throw Error("Missing sender public key for type 1 envelope");
                            let v = "u" > typeof l.senderPublicKey ? from_string_fromString(l.senderPublicKey, t_) : void 0,
                                _ = "u" > typeof l.iv ? from_string_fromString(l.iv, t_) : (0, ey.randomBytes)(12),
                                C = new eg.OK(from_string_fromString(l.symKey, t_)).seal(_, from_string_fromString(l.message, tA));
                            return function(l) {
                                if (1 === $(l.type)) {
                                    if (typeof l.senderPublicKey > "u") throw Error("Missing sender public key for type 1 envelope");
                                    return to_string_toString(concat([l.type, l.senderPublicKey, l.iv, l.sealed]), tE)
                                }
                                return to_string_toString(concat([l.type, l.iv, l.sealed]), tE)
                            }({
                                type: p,
                                sealed: C,
                                iv: _,
                                senderPublicKey: v
                            })
                        }({
                            type: P,
                            symKey: C,
                            message: _,
                            senderPublicKey: T
                        })
                    }, this.decode = async (l, c, p) => {
                        this.isInitialized();
                        let v = function(l, c) {
                            let p = ee(l);
                            return Re({
                                type: $(p.type),
                                senderPublicKey: "u" > typeof p.senderPublicKey ? to_string_toString(p.senderPublicKey, t_) : void 0,
                                receiverPublicKey: c ? .receiverPublicKey
                            })
                        }(c, p);
                        if (Fn(v)) {
                            let c = v.receiverPublicKey,
                                p = v.senderPublicKey;
                            l = await this.generateSharedKey(c, p)
                        }
                        try {
                            let p = this.getSymKey(l),
                                v = function(l) {
                                    let c = new eg.OK(from_string_fromString(l.symKey, t_)),
                                        {
                                            sealed: p,
                                            iv: v
                                        } = ee(l.encoded),
                                        _ = c.open(v, p);
                                    if (null === _) throw Error("Failed to decrypt");
                                    return to_string_toString(_, tA)
                                }({
                                    symKey: p,
                                    encoded: c
                                });
                            return esm_safeJsonParse(v)
                        } catch (c) {
                            this.logger.error(`Failed to decode message from topic: '${l}', clientId: '${await this.getClientId()}'`), this.logger.error(c)
                        }
                    }, this.getPayloadType = l => {
                        let c = ee(l);
                        return $(c.type)
                    }, this.getPayloadSenderPublicKey = l => {
                        let c = ee(l);
                        return c.senderPublicKey ? to_string_toString(c.senderPublicKey, t_) : void 0
                    }, this.core = l, this.logger = (0, tB.generateChildLogger)(c, this.name), this.keychain = p || new index_es_Rt(this.core, this.logger)
                }
                get context() {
                    return (0, tB.getLoggerContext)(this.logger)
                }
                async setPrivateKey(l, c) {
                    return await this.keychain.set(l, c), l
                }
                getPrivateKey(l) {
                    return this.keychain.get(l)
                }
                async getClientSeed() {
                    let l = "";
                    try {
                        l = this.keychain.get(rG)
                    } catch {
                        l = Dn(), await this.keychain.set(rG, l)
                    }
                    return function(l, c = "utf8") {
                        let p = rH[c];
                        if (!p) throw Error(`Unsupported encoding "${c}"`);
                        return ("utf8" === c || "utf-8" === c) && null != globalThis.Buffer && null != globalThis.Buffer.from ? index_es_Ge(globalThis.Buffer.from(l, "utf-8")) : p.decoder.decode(`${p.prefix}${l}`)
                    }(l, "base16")
                }
                getSymKey(l) {
                    return this.keychain.get(l)
                }
                isInitialized() {
                    if (!this.initialized) {
                        let {
                            message: l
                        } = N("NOT_INITIALIZED", this.name);
                        throw Error(l)
                    }
                }
            };
            let index_es_St = class index_es_St extends a {
                constructor(l, c) {
                    super(l, c), this.logger = l, this.core = c, this.messages = new Map, this.name = "messages", this.version = "0.3", this.initialized = !1, this.storagePrefix = rz, this.init = async () => {
                        if (!this.initialized) {
                            this.logger.trace("Initialized");
                            try {
                                let l = await this.getRelayerMessages();
                                "u" > typeof l && (this.messages = l), this.logger.debug(`Successfully Restored records for ${this.name}`), this.logger.trace({
                                    type: "method",
                                    method: "restore",
                                    size: this.messages.size
                                })
                            } catch (l) {
                                this.logger.debug(`Failed to Restore records for ${this.name}`), this.logger.error(l)
                            } finally {
                                this.initialized = !0
                            }
                        }
                    }, this.set = async (l, c) => {
                        this.isInitialized();
                        let p = Mn(c),
                            v = this.messages.get(l);
                        return typeof v > "u" && (v = {}), "u" > typeof v[p] || (v[p] = c, this.messages.set(l, v), await this.persist()), p
                    }, this.get = l => {
                        this.isInitialized();
                        let c = this.messages.get(l);
                        return typeof c > "u" && (c = {}), c
                    }, this.has = (l, c) => {
                        this.isInitialized();
                        let p = this.get(l),
                            v = Mn(c);
                        return "u" > typeof p[v]
                    }, this.del = async l => {
                        this.isInitialized(), this.messages.delete(l), await this.persist()
                    }, this.logger = (0, tB.generateChildLogger)(l, this.name), this.core = c
                }
                get context() {
                    return (0, tB.getLoggerContext)(this.logger)
                }
                get storageKey() {
                    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name
                }
                async setRelayerMessages(l) {
                    await this.core.storage.setItem(this.storageKey, et(l))
                }
                async getRelayerMessages() {
                    let l = await this.core.storage.getItem(this.storageKey);
                    return "u" > typeof l ? nt(l) : void 0
                }
                async persist() {
                    await this.setRelayerMessages(this.messages)
                }
                isInitialized() {
                    if (!this.initialized) {
                        let {
                            message: l
                        } = N("NOT_INITIALIZED", this.name);
                        throw Error(l)
                    }
                }
            };
            let Dr = class Dr extends u {
                constructor(l, c) {
                    super(l, c), this.relayer = l, this.logger = c, this.events = new ef.EventEmitter, this.name = "publisher", this.queue = new Map, this.publishTimeout = (0, tp.toMiliseconds)(tp.TEN_SECONDS), this.needsTransportRestart = !1, this.publish = async (l, c, p) => {
                        var v;
                        this.logger.debug("Publishing Payload"), this.logger.trace({
                            type: "method",
                            method: "publish",
                            params: {
                                topic: l,
                                message: c,
                                opts: p
                            }
                        });
                        try {
                            let _ = p ? .ttl || rZ,
                                C = mt(p),
                                P = p ? .prompt || !1,
                                T = p ? .tag || 0,
                                M = p ? .id || getBigIntRpcId().toString(),
                                z = {
                                    topic: l,
                                    message: c,
                                    opts: {
                                        ttl: _,
                                        relay: C,
                                        prompt: P,
                                        tag: T,
                                        id: M
                                    }
                                },
                                J = setTimeout(() => this.queue.set(M, z), this.publishTimeout);
                            try {
                                await await it(this.rpcPublish(l, c, _, C, P, T, M), this.publishTimeout, "Failed to publish payload, please try again."), this.removeRequestFromQueue(M), this.relayer.events.emit(r$.publish, z)
                            } catch (l) {
                                if (this.logger.debug("Publishing Payload stalled"), this.needsTransportRestart = !0, null != (v = p ? .internal) && v.throwOnFailedPublish) throw this.removeRequestFromQueue(M), l;
                                return
                            } finally {
                                clearTimeout(J)
                            }
                            this.logger.debug("Successfully Published Payload"), this.logger.trace({
                                type: "method",
                                method: "publish",
                                params: {
                                    topic: l,
                                    message: c,
                                    opts: p
                                }
                            })
                        } catch (l) {
                            throw this.logger.debug("Failed to Publish Payload"), this.logger.error(l), l
                        }
                    }, this.on = (l, c) => {
                        this.events.on(l, c)
                    }, this.once = (l, c) => {
                        this.events.once(l, c)
                    }, this.off = (l, c) => {
                        this.events.off(l, c)
                    }, this.removeListener = (l, c) => {
                        this.events.removeListener(l, c)
                    }, this.relayer = l, this.logger = (0, tB.generateChildLogger)(c, this.name), this.registerEventListeners()
                }
                get context() {
                    return (0, tB.getLoggerContext)(this.logger)
                }
                rpcPublish(l, c, p, v, _, C, P) {
                    var T, M, z, J;
                    let Q = {
                        method: yt(v.protocol).publish,
                        params: {
                            topic: l,
                            message: c,
                            ttl: p,
                            prompt: _,
                            tag: C
                        },
                        id: P
                    };
                    return w(null == (T = Q.params) ? void 0 : T.prompt) && (null == (M = Q.params) || delete M.prompt), w(null == (z = Q.params) ? void 0 : z.tag) && (null == (J = Q.params) || delete J.tag), this.logger.debug("Outgoing Relay Payload"), this.logger.trace({
                        type: "message",
                        direction: "outgoing",
                        request: Q
                    }), this.relayer.request(Q)
                }
                removeRequestFromQueue(l) {
                    this.queue.delete(l)
                }
                checkQueue() {
                    this.queue.forEach(async l => {
                        let {
                            topic: c,
                            message: p,
                            opts: v
                        } = l;
                        await this.publish(c, p, v)
                    })
                }
                registerEventListeners() {
                    this.relayer.core.heartbeat.on(tU.HEARTBEAT_EVENTS.pulse, () => {
                        if (this.needsTransportRestart) {
                            this.needsTransportRestart = !1, this.relayer.events.emit(r$.connection_stalled);
                            return
                        }
                        this.checkQueue()
                    }), this.relayer.on(r$.message_ack, l => {
                        this.removeRequestFromQueue(l.id.toString())
                    })
                }
            };
            let yr = class yr {
                constructor() {
                    this.map = new Map, this.set = (l, c) => {
                        let p = this.get(l);
                        this.exists(l, c) || this.map.set(l, [...p, c])
                    }, this.get = l => this.map.get(l) || [], this.exists = (l, c) => this.get(l).includes(c), this.delete = (l, c) => {
                        if (typeof c > "u") {
                            this.map.delete(l);
                            return
                        }
                        if (!this.map.has(l)) return;
                        let p = this.get(l);
                        if (!this.exists(l, c)) return;
                        let v = p.filter(l => l !== c);
                        if (!v.length) {
                            this.map.delete(l);
                            return
                        }
                        this.map.set(l, v)
                    }, this.clear = () => {
                        this.map.clear()
                    }
                }
                get topics() {
                    return Array.from(this.map.keys())
                }
            };
            var r7 = Object.defineProperty,
                ne = Object.defineProperties,
                nn = Object.getOwnPropertyDescriptors,
                ns = Object.getOwnPropertySymbols,
                no = Object.prototype.hasOwnProperty,
                nl = Object.prototype.propertyIsEnumerable,
                index_es_Tt = (l, c, p) => c in l ? r7(l, c, {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: p
                }) : l[c] = p,
                V = (l, c) => {
                    for (var p in c || (c = {})) no.call(c, p) && index_es_Tt(l, p, c[p]);
                    if (ns)
                        for (var p of ns(c)) nl.call(c, p) && index_es_Tt(l, p, c[p]);
                    return l
                },
                index_es_De = (l, c) => ne(l, nn(c));
            let index_es_xt = class index_es_xt extends d {
                constructor(l, c) {
                    super(l, c), this.relayer = l, this.logger = c, this.subscriptions = new Map, this.topicMap = new yr, this.events = new ef.EventEmitter, this.name = "subscription", this.version = "0.3", this.pending = new Map, this.cached = [], this.initialized = !1, this.pendingSubscriptionWatchLabel = "pending_sub_watch_label", this.pollingInterval = 20, this.storagePrefix = rz, this.subscribeTimeout = 1e4, this.restartInProgress = !1, this.batchSubscribeTopicsLimit = 500, this.init = async () => {
                        this.initialized || (this.logger.trace("Initialized"), this.registerEventListeners(), this.clientId = await this.relayer.core.crypto.getClientId())
                    }, this.subscribe = async (l, c) => {
                        await this.restartToComplete(), this.isInitialized(), this.logger.debug("Subscribing Topic"), this.logger.trace({
                            type: "method",
                            method: "subscribe",
                            params: {
                                topic: l,
                                opts: c
                            }
                        });
                        try {
                            let p = mt(c),
                                v = {
                                    topic: l,
                                    relay: p
                                };
                            this.pending.set(l, v);
                            let _ = await this.rpcSubscribe(l, p);
                            return this.onSubscribe(_, v), this.logger.debug("Successfully Subscribed Topic"), this.logger.trace({
                                type: "method",
                                method: "subscribe",
                                params: {
                                    topic: l,
                                    opts: c
                                }
                            }), _
                        } catch (l) {
                            throw this.logger.debug("Failed to Subscribe Topic"), this.logger.error(l), l
                        }
                    }, this.unsubscribe = async (l, c) => {
                        await this.restartToComplete(), this.isInitialized(), "u" > typeof c ? .id ? await this.unsubscribeById(l, c.id, c) : await this.unsubscribeByTopic(l, c)
                    }, this.isSubscribed = async l => !!this.topics.includes(l) || await new Promise((c, p) => {
                        let v = new tp.Watch;
                        v.start(this.pendingSubscriptionWatchLabel);
                        let _ = setInterval(() => {
                            !this.pending.has(l) && this.topics.includes(l) && (clearInterval(_), v.stop(this.pendingSubscriptionWatchLabel), c(!0)), v.elapsed(this.pendingSubscriptionWatchLabel) >= r1 && (clearInterval(_), v.stop(this.pendingSubscriptionWatchLabel), p(Error("Subscription resolution timeout")))
                        }, this.pollingInterval)
                    }).catch(() => !1), this.on = (l, c) => {
                        this.events.on(l, c)
                    }, this.once = (l, c) => {
                        this.events.once(l, c)
                    }, this.off = (l, c) => {
                        this.events.off(l, c)
                    }, this.removeListener = (l, c) => {
                        this.events.removeListener(l, c)
                    }, this.restart = async () => {
                        this.restartInProgress = !0, await this.restore(), await this.reset(), this.restartInProgress = !1
                    }, this.relayer = l, this.logger = (0, tB.generateChildLogger)(c, this.name), this.clientId = ""
                }
                get context() {
                    return (0, tB.getLoggerContext)(this.logger)
                }
                get storageKey() {
                    return this.storagePrefix + this.version + this.relayer.core.customStoragePrefix + "//" + this.name
                }
                get length() {
                    return this.subscriptions.size
                }
                get ids() {
                    return Array.from(this.subscriptions.keys())
                }
                get values() {
                    return Array.from(this.subscriptions.values())
                }
                get topics() {
                    return this.topicMap.topics
                }
                hasSubscription(l, c) {
                    let p = !1;
                    try {
                        p = this.getSubscription(l).topic === c
                    } catch {}
                    return p
                }
                onEnable() {
                    this.cached = [], this.initialized = !0
                }
                onDisable() {
                    this.cached = this.values, this.subscriptions.clear(), this.topicMap.clear()
                }
                async unsubscribeByTopic(l, c) {
                    let p = this.topicMap.get(l);
                    await Promise.all(p.map(async p => await this.unsubscribeById(l, p, c)))
                }
                async unsubscribeById(l, c, p) {
                    this.logger.debug("Unsubscribing Topic"), this.logger.trace({
                        type: "method",
                        method: "unsubscribe",
                        params: {
                            topic: l,
                            id: c,
                            opts: p
                        }
                    });
                    try {
                        let v = mt(p);
                        await this.rpcUnsubscribe(l, c, v);
                        let _ = U("USER_DISCONNECTED", `${this.name}, ${l}`);
                        await this.onUnsubscribe(l, c, _), this.logger.debug("Successfully Unsubscribed Topic"), this.logger.trace({
                            type: "method",
                            method: "unsubscribe",
                            params: {
                                topic: l,
                                id: c,
                                opts: p
                            }
                        })
                    } catch (l) {
                        throw this.logger.debug("Failed to Unsubscribe Topic"), this.logger.error(l), l
                    }
                }
                async rpcSubscribe(l, c) {
                    let p = {
                        method: yt(c.protocol).subscribe,
                        params: {
                            topic: l
                        }
                    };
                    this.logger.debug("Outgoing Relay Payload"), this.logger.trace({
                        type: "payload",
                        direction: "outgoing",
                        request: p
                    });
                    try {
                        await await it(this.relayer.request(p), this.subscribeTimeout)
                    } catch {
                        this.logger.debug("Outgoing Relay Subscribe Payload stalled"), this.relayer.events.emit(r$.connection_stalled)
                    }
                    return Mn(l + this.clientId)
                }
                async rpcBatchSubscribe(l) {
                    if (!l.length) return;
                    let c = l[0].relay,
                        p = {
                            method: yt(c.protocol).batchSubscribe,
                            params: {
                                topics: l.map(l => l.topic)
                            }
                        };
                    this.logger.debug("Outgoing Relay Payload"), this.logger.trace({
                        type: "payload",
                        direction: "outgoing",
                        request: p
                    });
                    try {
                        return await await it(this.relayer.request(p), this.subscribeTimeout)
                    } catch {
                        this.logger.debug("Outgoing Relay Payload stalled"), this.relayer.events.emit(r$.connection_stalled)
                    }
                }
                rpcUnsubscribe(l, c, p) {
                    let v = {
                        method: yt(p.protocol).unsubscribe,
                        params: {
                            topic: l,
                            id: c
                        }
                    };
                    return this.logger.debug("Outgoing Relay Payload"), this.logger.trace({
                        type: "payload",
                        direction: "outgoing",
                        request: v
                    }), this.relayer.request(v)
                }
                onSubscribe(l, c) {
                    this.setSubscription(l, index_es_De(V({}, c), {
                        id: l
                    })), this.pending.delete(c.topic)
                }
                onBatchSubscribe(l) {
                    l.length && l.forEach(l => {
                        this.setSubscription(l.id, V({}, l)), this.pending.delete(l.topic)
                    })
                }
                async onUnsubscribe(l, c, p) {
                    this.events.removeAllListeners(c), this.hasSubscription(c, l) && this.deleteSubscription(c, p), await this.relayer.messages.del(l)
                }
                async setRelayerSubscriptions(l) {
                    await this.relayer.core.storage.setItem(this.storageKey, l)
                }
                async getRelayerSubscriptions() {
                    return await this.relayer.core.storage.getItem(this.storageKey)
                }
                setSubscription(l, c) {
                    this.subscriptions.has(l) || (this.logger.debug("Setting subscription"), this.logger.trace({
                        type: "method",
                        method: "setSubscription",
                        id: l,
                        subscription: c
                    }), this.addSubscription(l, c))
                }
                addSubscription(l, c) {
                    this.subscriptions.set(l, V({}, c)), this.topicMap.set(c.topic, l), this.events.emit(r0.created, c)
                }
                getSubscription(l) {
                    this.logger.debug("Getting subscription"), this.logger.trace({
                        type: "method",
                        method: "getSubscription",
                        id: l
                    });
                    let c = this.subscriptions.get(l);
                    if (!c) {
                        let {
                            message: c
                        } = N("NO_MATCHING_KEY", `${this.name}: ${l}`);
                        throw Error(c)
                    }
                    return c
                }
                deleteSubscription(l, c) {
                    this.logger.debug("Deleting subscription"), this.logger.trace({
                        type: "method",
                        method: "deleteSubscription",
                        id: l,
                        reason: c
                    });
                    let p = this.getSubscription(l);
                    this.subscriptions.delete(l), this.topicMap.delete(p.topic, l), this.events.emit(r0.deleted, index_es_De(V({}, p), {
                        reason: c
                    }))
                }
                async persist() {
                    await this.setRelayerSubscriptions(this.values), this.events.emit(r0.sync)
                }
                async reset() {
                    if (this.cached.length) {
                        let l = Math.ceil(this.cached.length / this.batchSubscribeTopicsLimit);
                        for (let c = 0; c < l; c++) {
                            let l = this.cached.splice(0, this.batchSubscribeTopicsLimit);
                            await this.batchSubscribe(l)
                        }
                    }
                    this.events.emit(r0.resubscribed)
                }
                async restore() {
                    try {
                        let l = await this.getRelayerSubscriptions();
                        if (typeof l > "u" || !l.length) return;
                        if (this.subscriptions.size) {
                            let {
                                message: l
                            } = N("RESTORE_WILL_OVERRIDE", this.name);
                            throw this.logger.error(l), this.logger.error(`${this.name}: ${JSON.stringify(this.values)}`), Error(l)
                        }
                        this.cached = l, this.logger.debug(`Successfully Restored subscriptions for ${this.name}`), this.logger.trace({
                            type: "method",
                            method: "restore",
                            subscriptions: this.values
                        })
                    } catch (l) {
                        this.logger.debug(`Failed to Restore subscriptions for ${this.name}`), this.logger.error(l)
                    }
                }
                async batchSubscribe(l) {
                    if (!l.length) return;
                    let c = await this.rpcBatchSubscribe(l);
                    D(c) && this.onBatchSubscribe(c.map((c, p) => index_es_De(V({}, l[p]), {
                        id: c
                    })))
                }
                async onConnect() {
                    this.restartInProgress || (await this.restart(), this.onEnable())
                }
                onDisconnect() {
                    this.onDisable()
                }
                async checkPending() {
                    if (!this.initialized || this.relayer.transportExplicitlyClosed) return;
                    let l = [];
                    this.pending.forEach(c => {
                        l.push(c)
                    }), await this.batchSubscribe(l)
                }
                registerEventListeners() {
                    this.relayer.core.heartbeat.on(tU.HEARTBEAT_EVENTS.pulse, async () => {
                        await this.checkPending()
                    }), this.relayer.on(r$.connect, async () => {
                        await this.onConnect()
                    }), this.relayer.on(r$.disconnect, () => {
                        this.onDisconnect()
                    }), this.events.on(r0.created, async l => {
                        let c = r0.created;
                        this.logger.info(`Emitting ${c}`), this.logger.debug({
                            type: "event",
                            event: c,
                            data: l
                        }), await this.persist()
                    }), this.events.on(r0.deleted, async l => {
                        let c = r0.deleted;
                        this.logger.info(`Emitting ${c}`), this.logger.debug({
                            type: "event",
                            event: c,
                            data: l
                        }), await this.persist()
                    })
                }
                isInitialized() {
                    if (!this.initialized) {
                        let {
                            message: l
                        } = N("NOT_INITIALIZED", this.name);
                        throw Error(l)
                    }
                }
                async restartToComplete() {
                    this.restartInProgress && await new Promise(l => {
                        let c = setInterval(() => {
                            this.restartInProgress || (clearInterval(c), l())
                        }, this.pollingInterval)
                    })
                }
            };
            var nc = Object.defineProperty,
                nh = Object.getOwnPropertySymbols,
                nd = Object.prototype.hasOwnProperty,
                nf = Object.prototype.propertyIsEnumerable,
                index_es_At = (l, c, p) => c in l ? nc(l, c, {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: p
                }) : l[c] = p,
                Rr = (l, c) => {
                    for (var p in c || (c = {})) nd.call(c, p) && index_es_At(l, p, c[p]);
                    if (nh)
                        for (var p of nh(c)) nf.call(c, p) && index_es_At(l, p, c[p]);
                    return l
                };
            let index_es_zt = class index_es_zt extends g {
                constructor(l) {
                    super(l), this.protocol = "wc", this.version = 2, this.events = new ef.EventEmitter, this.name = "relayer", this.transportExplicitlyClosed = !1, this.initialized = !1, this.connectionAttemptInProgress = !1, this.connectionStatusPollingInterval = 20, this.staleConnectionErrors = ["socket hang up", "socket stalled"], this.hasExperiencedNetworkDisruption = !1, this.request = async l => {
                        this.logger.debug("Publishing Request Payload");
                        try {
                            return await this.toEstablishConnection(), await this.provider.request(l)
                        } catch (l) {
                            throw this.logger.debug("Failed to Publish Request"), this.logger.error(l), l
                        }
                    }, this.onPayloadHandler = l => {
                        this.onProviderPayload(l)
                    }, this.onConnectHandler = () => {
                        this.events.emit(r$.connect)
                    }, this.onDisconnectHandler = () => {
                        this.onProviderDisconnect()
                    }, this.onProviderErrorHandler = l => {
                        this.logger.error(l), this.events.emit(r$.error, l), this.logger.info("Fatal socket error received, closing transport"), this.transportClose()
                    }, this.registerProviderListeners = () => {
                        this.provider.on(rY.payload, this.onPayloadHandler), this.provider.on(rY.connect, this.onConnectHandler), this.provider.on(rY.disconnect, this.onDisconnectHandler), this.provider.on(rY.error, this.onProviderErrorHandler)
                    }, this.core = l.core, this.logger = "u" > typeof l.logger && "string" != typeof l.logger ? (0, tB.generateChildLogger)(l.logger, this.name) : (0, tB.pino)((0, tB.getDefaultLoggerOptions)({
                        level: l.logger || "error"
                    })), this.messages = new index_es_St(this.logger, l.core), this.subscriber = new index_es_xt(this, this.logger), this.publisher = new Dr(this, this.logger), this.relayUrl = l ? .relayUrl || rJ, this.projectId = l.projectId, this.provider = {}
                }
                async init() {
                    this.logger.trace("Initialized"), this.registerEventListeners(), await this.createProvider(), await Promise.all([this.messages.init(), this.subscriber.init()]);
                    try {
                        await this.transportOpen()
                    } catch {
                        this.logger.warn(`Connection via ${this.relayUrl} failed, attempting to connect via failover domain ${rQ}...`), await this.restartTransport(rQ)
                    }
                    this.initialized = !0, setTimeout(async () => {
                        0 === this.subscriber.topics.length && (this.logger.info("No topics subscribed to after init, closing transport"), await this.transportClose(), this.transportExplicitlyClosed = !1)
                    }, 1e4)
                }
                get context() {
                    return (0, tB.getLoggerContext)(this.logger)
                }
                get connected() {
                    return this.provider.connection.connected
                }
                get connecting() {
                    return this.provider.connection.connecting
                }
                async publish(l, c, p) {
                    this.isInitialized(), await this.publisher.publish(l, c, p), await this.recordMessageEvent({
                        topic: l,
                        message: c,
                        publishedAt: Date.now()
                    })
                }
                async subscribe(l, c) {
                    var p;
                    let v;
                    this.isInitialized();
                    let _ = (null == (p = this.subscriber.topicMap.get(l)) ? void 0 : p[0]) || "";
                    if (_) return _;
                    let a = c => {
                        c.topic === l && (this.subscriber.off(r0.created, a), v())
                    };
                    return await Promise.all([new Promise(l => {
                        v = l, this.subscriber.on(r0.created, a)
                    }), new Promise(async p => {
                        _ = await this.subscriber.subscribe(l, c), p()
                    })]), _
                }
                async unsubscribe(l, c) {
                    this.isInitialized(), await this.subscriber.unsubscribe(l, c)
                }
                on(l, c) {
                    this.events.on(l, c)
                }
                once(l, c) {
                    this.events.once(l, c)
                }
                off(l, c) {
                    this.events.off(l, c)
                }
                removeListener(l, c) {
                    this.events.removeListener(l, c)
                }
                async transportClose() {
                    this.transportExplicitlyClosed = !0, this.hasExperiencedNetworkDisruption && this.connected ? await it(this.provider.disconnect(), 1e3, "provider.disconnect()").catch(() => this.onProviderDisconnect()) : this.connected && await this.provider.disconnect()
                }
                async transportOpen(l) {
                    if (this.transportExplicitlyClosed = !1, await this.confirmOnlineStateOrThrow(), !this.connectionAttemptInProgress) {
                        l && l !== this.relayUrl && (this.relayUrl = l, await this.transportClose(), await this.createProvider()), this.connectionAttemptInProgress = !0;
                        try {
                            await Promise.all([new Promise(l => {
                                if (!this.initialized) return l();
                                this.subscriber.once(r0.resubscribed, () => {
                                    l()
                                })
                            }), new Promise(async (l, c) => {
                                try {
                                    await it(this.provider.connect(), 1e4, `Socket stalled when trying to connect to ${this.relayUrl}`)
                                } catch (l) {
                                    c(l);
                                    return
                                }
                                l()
                            })])
                        } catch (l) {
                            if (this.logger.error(l), !this.isConnectionStalled(l.message)) throw l;
                            this.provider.events.emit(rY.disconnect)
                        } finally {
                            this.connectionAttemptInProgress = !1, this.hasExperiencedNetworkDisruption = !1
                        }
                    }
                }
                async restartTransport(l) {
                    await this.confirmOnlineStateOrThrow(), this.connectionAttemptInProgress || (this.relayUrl = l || this.relayUrl, await this.transportClose(), await this.createProvider(), await this.transportOpen())
                }
                async confirmOnlineStateOrThrow() {
                    if (!await Zt()) throw Error("No internet connection detected. Please restart your network and try again.")
                }
                isConnectionStalled(l) {
                    return this.staleConnectionErrors.some(c => l.includes(c))
                }
                async createProvider() {
                    this.provider.connection && this.unregisterProviderListeners();
                    let l = await this.core.crypto.signJWT(this.relayUrl);
                    this.provider = new JsonRpcProvider(new tQ(function({
                        protocol: l,
                        version: c,
                        relayUrl: v,
                        sdkVersion: _,
                        auth: C,
                        projectId: P,
                        useOnCloseEvent: T
                    }) {
                        var M;
                        let z;
                        let J = v.split("?"),
                            Q = function(l, c, v) {
                                let _ = function() {
                                        var l;
                                        if (R() === tD.reactNative && "u" > typeof p.g && "u" > typeof(null == p.g ? void 0 : p.g.Platform)) {
                                            let {
                                                OS: l,
                                                Version: c
                                            } = p.g.Platform;
                                            return [l, c].join("-")
                                        }
                                        let c = l ? parseUserAgent(l) : "undefined" == typeof document && "undefined" != typeof navigator && "ReactNative" === navigator.product ? new ReactNativeInfo : "undefined" != typeof navigator ? parseUserAgent(navigator.userAgent) : void 0 !== tc && tc.version ? new NodeInfo(tc.version.slice(1)) : null;
                                        if (null === c) return "unknown";
                                        let v = c.os ? c.os.replace(" ", "").toLowerCase() : "unknown";
                                        return "browser" === c.type ? [v, c.name, c.version].join("-") : [v, c.version].join("-")
                                    }(),
                                    C = function() {
                                        var l;
                                        let c = R();
                                        return c === tD.browser ? [c, (null == (l = (0, tg.getLocation)()) ? void 0 : l.host) || "unknown"].join(":") : c
                                    }();
                                return [
                                    [l, c].join("-"), ["js", v].join("-"), _, C
                                ].join("/")
                            }(l, c, _),
                            X = (M = J[1] || "", z = _e(_e({}, z = ty.parse(M)), {
                                auth: C,
                                ua: Q,
                                projectId: P,
                                useOnCloseEvent: T || void 0
                            }), M = ty.stringify(z));
                        return J[0] + "?" + X
                    }({
                        sdkVersion: "2.10.2",
                        protocol: this.protocol,
                        version: this.version,
                        relayUrl: this.relayUrl,
                        projectId: this.projectId,
                        auth: l,
                        useOnCloseEvent: !0
                    }))), this.registerProviderListeners()
                }
                async recordMessageEvent(l) {
                    let {
                        topic: c,
                        message: p
                    } = l;
                    await this.messages.set(c, p)
                }
                async shouldIgnoreMessageEvent(l) {
                    let {
                        topic: c,
                        message: p
                    } = l;
                    if (!p || 0 === p.length) return this.logger.debug(`Ignoring invalid/empty message: ${p}`), !0;
                    if (!await this.subscriber.isSubscribed(c)) return this.logger.debug(`Ignoring message for non-subscribed topic ${c}`), !0;
                    let v = this.messages.has(c, p);
                    return v && this.logger.debug(`Ignoring duplicate message: ${p}`), v
                }
                async onProviderPayload(l) {
                    if (this.logger.debug("Incoming Relay Payload"), this.logger.trace({
                            type: "payload",
                            direction: "incoming",
                            payload: l
                        }), isJsonRpcRequest(l)) {
                        if (!l.method.endsWith("_subscription")) return;
                        let c = l.params,
                            {
                                topic: p,
                                message: v,
                                publishedAt: _
                            } = c.data,
                            C = {
                                topic: p,
                                message: v,
                                publishedAt: _
                            };
                        this.logger.debug("Emitting Relayer Payload"), this.logger.trace(Rr({
                            type: "event",
                            event: c.id
                        }, C)), this.events.emit(c.id, C), await this.acknowledgePayload(l), await this.onMessageEvent(C)
                    } else isJsonRpcResponse(l) && this.events.emit(r$.message_ack, l)
                }
                async onMessageEvent(l) {
                    await this.shouldIgnoreMessageEvent(l) || (this.events.emit(r$.message, l), await this.recordMessageEvent(l))
                }
                async acknowledgePayload(l) {
                    let c = formatJsonRpcResult(l.id, !0);
                    await this.provider.connection.send(c)
                }
                unregisterProviderListeners() {
                    this.provider.off(rY.payload, this.onPayloadHandler), this.provider.off(rY.connect, this.onConnectHandler), this.provider.off(rY.disconnect, this.onDisconnectHandler), this.provider.off(rY.error, this.onProviderErrorHandler)
                }
                async registerEventListeners() {
                    this.events.on(r$.connection_stalled, () => {
                        this.restartTransport().catch(l => this.logger.error(l))
                    });
                    let l = await Zt();
                    ! function(l) {
                        switch (R()) {
                            case tD.browser:
                                !j() && q() && (window.addEventListener("online", () => l(!0)), window.addEventListener("offline", () => l(!1)));
                                break;
                            case tD.reactNative:
                                j() && "u" > typeof p.g && null != p.g && p.g.NetInfo && p.g ? .NetInfo.addEventListener(c => l(c ? .isConnected));
                            case tD.node:
                        }
                    }(async c => {
                        this.initialized && l !== c && (l = c, c ? await this.restartTransport().catch(l => this.logger.error(l)) : (this.hasExperiencedNetworkDisruption = !0, await this.transportClose().catch(l => this.logger.error(l))))
                    })
                }
                onProviderDisconnect() {
                    this.events.emit(r$.disconnect), this.attemptToReconnect()
                }
                attemptToReconnect() {
                    this.transportExplicitlyClosed || (this.logger.info("attemptToReconnect called. Connecting..."), setTimeout(async () => {
                        await this.restartTransport().catch(l => this.logger.error(l))
                    }, (0, tp.toMiliseconds)(rX)))
                }
                isInitialized() {
                    if (!this.initialized) {
                        let {
                            message: l
                        } = N("NOT_INITIALIZED", this.name);
                        throw Error(l)
                    }
                }
                async toEstablishConnection() {
                    if (await this.confirmOnlineStateOrThrow(), !this.connected) {
                        if (this.connectionAttemptInProgress) return await new Promise(l => {
                            let c = setInterval(() => {
                                this.connected && (clearInterval(c), l())
                            }, this.connectionStatusPollingInterval)
                        });
                        await this.restartTransport()
                    }
                }
            };
            var np = Object.defineProperty,
                ng = Object.getOwnPropertySymbols,
                nm = Object.prototype.hasOwnProperty,
                ny = Object.prototype.propertyIsEnumerable,
                index_es_Lt = (l, c, p) => c in l ? np(l, c, {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: p
                }) : l[c] = p,
                index_es_Ut = (l, c) => {
                    for (var p in c || (c = {})) nm.call(c, p) && index_es_Lt(l, p, c[p]);
                    if (ng)
                        for (var p of ng(c)) ny.call(c, p) && index_es_Lt(l, p, c[p]);
                    return l
                };
            let index_es_Ft = class index_es_Ft extends index_es_p {
                constructor(l, c, p, v = rz, _) {
                    super(l, c, p, v), this.core = l, this.logger = c, this.name = p, this.map = new Map, this.version = "0.3", this.cached = [], this.initialized = !1, this.storagePrefix = rz, this.init = async () => {
                        this.initialized || (this.logger.trace("Initialized"), await this.restore(), this.cached.forEach(l => {
                            var c;
                            this.getKey && null !== l && !w(l) ? this.map.set(this.getKey(l), l) : (null == (c = l ? .proposer) ? void 0 : c.publicKey) ? this.map.set(l.id, l) : l ? .topic && this.map.set(l.topic, l)
                        }), this.cached = [], this.initialized = !0)
                    }, this.set = async (l, c) => {
                        this.isInitialized(), this.map.has(l) ? await this.update(l, c) : (this.logger.debug("Setting value"), this.logger.trace({
                            type: "method",
                            method: "set",
                            key: l,
                            value: c
                        }), this.map.set(l, c), await this.persist())
                    }, this.get = l => (this.isInitialized(), this.logger.debug("Getting value"), this.logger.trace({
                        type: "method",
                        method: "get",
                        key: l
                    }), this.getData(l)), this.getAll = l => (this.isInitialized(), l ? this.values.filter(c => Object.keys(l).every(p => tY()(c[p], l[p]))) : this.values), this.update = async (l, c) => {
                        this.isInitialized(), this.logger.debug("Updating value"), this.logger.trace({
                            type: "method",
                            method: "update",
                            key: l,
                            update: c
                        });
                        let p = index_es_Ut(index_es_Ut({}, this.getData(l)), c);
                        this.map.set(l, p), await this.persist()
                    }, this.delete = async (l, c) => {
                        this.isInitialized(), this.map.has(l) && (this.logger.debug("Deleting value"), this.logger.trace({
                            type: "method",
                            method: "delete",
                            key: l,
                            reason: c
                        }), this.map.delete(l), await this.persist())
                    }, this.logger = (0, tB.generateChildLogger)(c, this.name), this.storagePrefix = v, this.getKey = _
                }
                get context() {
                    return (0, tB.getLoggerContext)(this.logger)
                }
                get storageKey() {
                    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name
                }
                get length() {
                    return this.map.size
                }
                get keys() {
                    return Array.from(this.map.keys())
                }
                get values() {
                    return Array.from(this.map.values())
                }
                async setDataStore(l) {
                    await this.core.storage.setItem(this.storageKey, l)
                }
                async getDataStore() {
                    return await this.core.storage.getItem(this.storageKey)
                }
                getData(l) {
                    let c = this.map.get(l);
                    if (!c) {
                        let {
                            message: c
                        } = N("NO_MATCHING_KEY", `${this.name}: ${l}`);
                        throw this.logger.error(c), Error(c)
                    }
                    return c
                }
                async persist() {
                    await this.setDataStore(this.values)
                }
                async restore() {
                    try {
                        let l = await this.getDataStore();
                        if (typeof l > "u" || !l.length) return;
                        if (this.map.size) {
                            let {
                                message: l
                            } = N("RESTORE_WILL_OVERRIDE", this.name);
                            throw this.logger.error(l), Error(l)
                        }
                        this.cached = l, this.logger.debug(`Successfully Restored value for ${this.name}`), this.logger.trace({
                            type: "method",
                            method: "restore",
                            value: this.values
                        })
                    } catch (l) {
                        this.logger.debug(`Failed to Restore value for ${this.name}`), this.logger.error(l)
                    }
                }
                isInitialized() {
                    if (!this.initialized) {
                        let {
                            message: l
                        } = N("NOT_INITIALIZED", this.name);
                        throw Error(l)
                    }
                }
            };
            let index_es_$t = class index_es_$t {
                constructor(l, c) {
                    this.core = l, this.logger = c, this.name = "pairing", this.version = "0.3", this.events = new(ep()), this.initialized = !1, this.storagePrefix = rz, this.ignoredPayloadTypes = [1], this.registeredMethods = [], this.init = async () => {
                        this.initialized || (await this.pairings.init(), await this.cleanup(), this.registerRelayerEvents(), this.registerExpirerEvents(), this.initialized = !0, this.logger.trace("Initialized"))
                    }, this.register = ({
                        methods: l
                    }) => {
                        this.isInitialized(), this.registeredMethods = [...new Set([...this.registeredMethods, ...l])]
                    }, this.create = async () => {
                        var l;
                        this.isInitialized();
                        let c = Dn(),
                            p = await this.core.crypto.setSymKey(c),
                            v = lt(tp.FIVE_MINUTES),
                            _ = {
                                protocol: "irn"
                            },
                            C = (l = {
                                protocol: this.core.protocol,
                                version: this.core.version,
                                topic: p,
                                symKey: c,
                                relay: _
                            }, `${l.protocol}:${l.topic}@${l.version}?` + ty.stringify(Et({
                                symKey: l.symKey
                            }, function(l, c = "-") {
                                let p = {};
                                return Object.keys(l).forEach(v => {
                                    l[v] && (p["relay" + c + v] = l[v])
                                }), p
                            }(l.relay))));
                        return await this.pairings.set(p, {
                            topic: p,
                            expiry: v,
                            relay: _,
                            active: !1
                        }), await this.core.relayer.subscribe(p), this.core.expirer.set(p, v), {
                            topic: p,
                            uri: C
                        }
                    }, this.pair = async l => {
                        this.isInitialized(), this.isValidPair(l);
                        let {
                            topic: c,
                            symKey: p,
                            relay: v
                        } = function(l) {
                            var c;
                            let p = l.indexOf(":"),
                                v = -1 !== l.indexOf("?") ? l.indexOf("?") : void 0,
                                _ = l.substring(0, p),
                                C = l.substring(p + 1, v).split("@"),
                                P = "u" > typeof v ? l.substring(v) : "",
                                T = ty.parse(P);
                            return {
                                protocol: _,
                                topic: (c = C[0]).startsWith("//") ? c.substring(2) : c,
                                version: parseInt(C[1], 10),
                                symKey: T.symKey,
                                relay: function(l, c = "-") {
                                    let p = {},
                                        v = "relay" + c;
                                    return Object.keys(l).forEach(c => {
                                        if (c.startsWith(v)) {
                                            let _ = c.replace(v, ""),
                                                C = l[c];
                                            p[_] = C
                                        }
                                    }), p
                                }(T)
                            }
                        }(l.uri);
                        if (this.pairings.keys.includes(c) && this.pairings.get(c).active) throw Error(`Pairing already exists: ${c}. Please try again with a new connection URI.`);
                        this.core.crypto.keychain.has(c) || (await this.core.crypto.setSymKey(p, c), await this.core.relayer.subscribe(c, {
                            relay: v
                        }));
                        let _ = lt(tp.FIVE_MINUTES),
                            C = {
                                topic: c,
                                relay: v,
                                expiry: _,
                                active: !1
                            };
                        return await this.pairings.set(c, C), this.core.expirer.set(c, _), l.activatePairing && await this.activate({
                            topic: c
                        }), this.events.emit(r5.create, C), C
                    }, this.activate = async ({
                        topic: l
                    }) => {
                        this.isInitialized();
                        let c = lt(tp.THIRTY_DAYS);
                        await this.pairings.update(l, {
                            active: !0,
                            expiry: c
                        }), this.core.expirer.set(l, c)
                    }, this.ping = async l => {
                        this.isInitialized(), await this.isValidPing(l);
                        let {
                            topic: c
                        } = l;
                        if (this.pairings.keys.includes(c)) {
                            let l = await this.sendRequest(c, "wc_pairingPing", {}),
                                {
                                    done: p,
                                    resolve: v,
                                    reject: _
                                } = st();
                            this.events.once(ft("pairing_ping", l), ({
                                error: l
                            }) => {
                                l ? _(l) : v()
                            }), await p()
                        }
                    }, this.updateExpiry = async ({
                        topic: l,
                        expiry: c
                    }) => {
                        this.isInitialized(), await this.pairings.update(l, {
                            expiry: c
                        })
                    }, this.updateMetadata = async ({
                        topic: l,
                        metadata: c
                    }) => {
                        this.isInitialized(), await this.pairings.update(l, {
                            peerMetadata: c
                        })
                    }, this.getPairings = () => (this.isInitialized(), this.pairings.values), this.disconnect = async l => {
                        this.isInitialized(), await this.isValidDisconnect(l);
                        let {
                            topic: c
                        } = l;
                        this.pairings.keys.includes(c) && (await this.sendRequest(c, "wc_pairingDelete", U("USER_DISCONNECTED")), await this.deletePairing(c))
                    }, this.sendRequest = async (l, c, p) => {
                        let v = formatJsonRpcRequest(c, p),
                            _ = await this.core.crypto.encode(l, v),
                            C = r2[c].req;
                        return this.core.history.set(l, v), this.core.relayer.publish(l, _, C), v.id
                    }, this.sendResult = async (l, c, p) => {
                        let v = formatJsonRpcResult(l, p),
                            _ = await this.core.crypto.encode(c, v),
                            C = await this.core.history.get(c, l),
                            P = r2[C.request.method].res;
                        await this.core.relayer.publish(c, _, P), await this.core.history.resolve(v)
                    }, this.sendError = async (l, c, p) => {
                        let v = formatJsonRpcError(l, p),
                            _ = await this.core.crypto.encode(c, v),
                            C = await this.core.history.get(c, l),
                            P = r2[C.request.method] ? r2[C.request.method].res : r2.unregistered_method.res;
                        await this.core.relayer.publish(c, _, P), await this.core.history.resolve(v)
                    }, this.deletePairing = async (l, c) => {
                        await this.core.relayer.unsubscribe(l), await Promise.all([this.pairings.delete(l, U("USER_DISCONNECTED")), this.core.crypto.deleteSymKey(l), c ? Promise.resolve() : this.core.expirer.del(l)])
                    }, this.cleanup = async () => {
                        let l = this.pairings.getAll().filter(l => dt(l.expiry));
                        await Promise.all(l.map(l => this.deletePairing(l.topic)))
                    }, this.onRelayEventRequest = l => {
                        let {
                            topic: c,
                            payload: p
                        } = l;
                        switch (p.method) {
                            case "wc_pairingPing":
                                return this.onPairingPingRequest(c, p);
                            case "wc_pairingDelete":
                                return this.onPairingDeleteRequest(c, p);
                            default:
                                return this.onUnknownRpcMethodRequest(c, p)
                        }
                    }, this.onRelayEventResponse = async l => {
                        let {
                            topic: c,
                            payload: p
                        } = l, v = (await this.core.history.get(c, p.id)).request.method;
                        return "wc_pairingPing" === v ? this.onPairingPingResponse(c, p) : this.onUnknownRpcMethodResponse(v)
                    }, this.onPairingPingRequest = async (l, c) => {
                        let {
                            id: p
                        } = c;
                        try {
                            this.isValidPing({
                                topic: l
                            }), await this.sendResult(p, l, !0), this.events.emit(r5.ping, {
                                id: p,
                                topic: l
                            })
                        } catch (c) {
                            await this.sendError(p, l, c), this.logger.error(c)
                        }
                    }, this.onPairingPingResponse = (l, c) => {
                        let {
                            id: p
                        } = c;
                        setTimeout(() => {
                            isJsonRpcResult(c) ? this.events.emit(ft("pairing_ping", p), {}) : isJsonRpcError(c) && this.events.emit(ft("pairing_ping", p), {
                                error: c.error
                            })
                        }, 500)
                    }, this.onPairingDeleteRequest = async (l, c) => {
                        let {
                            id: p
                        } = c;
                        try {
                            this.isValidDisconnect({
                                topic: l
                            }), await this.deletePairing(l), this.events.emit(r5.delete, {
                                id: p,
                                topic: l
                            })
                        } catch (c) {
                            await this.sendError(p, l, c), this.logger.error(c)
                        }
                    }, this.onUnknownRpcMethodRequest = async (l, c) => {
                        let {
                            id: p,
                            method: v
                        } = c;
                        try {
                            if (this.registeredMethods.includes(v)) return;
                            let c = U("WC_METHOD_UNSUPPORTED", v);
                            await this.sendError(p, l, c), this.logger.error(c)
                        } catch (c) {
                            await this.sendError(p, l, c), this.logger.error(c)
                        }
                    }, this.onUnknownRpcMethodResponse = l => {
                        this.registeredMethods.includes(l) || this.logger.error(U("WC_METHOD_UNSUPPORTED", l))
                    }, this.isValidPair = l => {
                        if (!xt(l)) {
                            let {
                                message: c
                            } = N("MISSING_OR_INVALID", `pair() params: ${l}`);
                            throw Error(c)
                        }
                        if (! function(l) {
                                if (h(l, !1)) try {
                                    return "u" > typeof new URL(l)
                                } catch {}
                                return !1
                            }(l.uri)) {
                            let {
                                message: c
                            } = N("MISSING_OR_INVALID", `pair() uri: ${l.uri}`);
                            throw Error(c)
                        }
                    }, this.isValidPing = async l => {
                        if (!xt(l)) {
                            let {
                                message: c
                            } = N("MISSING_OR_INVALID", `ping() params: ${l}`);
                            throw Error(c)
                        }
                        let {
                            topic: c
                        } = l;
                        await this.isValidPairingTopic(c)
                    }, this.isValidDisconnect = async l => {
                        if (!xt(l)) {
                            let {
                                message: c
                            } = N("MISSING_OR_INVALID", `disconnect() params: ${l}`);
                            throw Error(c)
                        }
                        let {
                            topic: c
                        } = l;
                        await this.isValidPairingTopic(c)
                    }, this.isValidPairingTopic = async l => {
                        if (!h(l, !1)) {
                            let {
                                message: c
                            } = N("MISSING_OR_INVALID", `pairing topic should be a string: ${l}`);
                            throw Error(c)
                        }
                        if (!this.pairings.keys.includes(l)) {
                            let {
                                message: c
                            } = N("NO_MATCHING_KEY", `pairing topic doesn't exist: ${l}`);
                            throw Error(c)
                        }
                        if (dt(this.pairings.get(l).expiry)) {
                            await this.deletePairing(l);
                            let {
                                message: c
                            } = N("EXPIRED", `pairing topic: ${l}`);
                            throw Error(c)
                        }
                    }, this.core = l, this.logger = (0, tB.generateChildLogger)(c, this.name), this.pairings = new index_es_Ft(this.core, this.logger, this.name, this.storagePrefix)
                }
                get context() {
                    return (0, tB.getLoggerContext)(this.logger)
                }
                isInitialized() {
                    if (!this.initialized) {
                        let {
                            message: l
                        } = N("NOT_INITIALIZED", this.name);
                        throw Error(l)
                    }
                }
                registerRelayerEvents() {
                    this.core.relayer.on(r$.message, async l => {
                        let {
                            topic: c,
                            message: p
                        } = l;
                        if (!this.pairings.keys.includes(c) || this.ignoredPayloadTypes.includes(this.core.crypto.getPayloadType(p))) return;
                        let v = await this.core.crypto.decode(c, p);
                        try {
                            isJsonRpcRequest(v) ? (this.core.history.set(c, v), this.onRelayEventRequest({
                                topic: c,
                                payload: v
                            })) : isJsonRpcResponse(v) && (await this.core.history.resolve(v), await this.onRelayEventResponse({
                                topic: c,
                                payload: v
                            }), this.core.history.delete(c, v.id))
                        } catch (l) {
                            this.logger.error(l)
                        }
                    })
                }
                registerExpirerEvents() {
                    this.core.expirer.on(r6.expired, async l => {
                        let {
                            topic: c
                        } = ut(l.target);
                        c && this.pairings.keys.includes(c) && (await this.deletePairing(c, !0), this.events.emit(r5.expire, {
                            topic: c
                        }))
                    })
                }
            };
            let index_es_Mt = class index_es_Mt extends index_es_h {
                constructor(l, c) {
                    super(l, c), this.core = l, this.logger = c, this.records = new Map, this.events = new ef.EventEmitter, this.name = "history", this.version = "0.3", this.cached = [], this.initialized = !1, this.storagePrefix = rz, this.init = async () => {
                        this.initialized || (this.logger.trace("Initialized"), await this.restore(), this.cached.forEach(l => this.records.set(l.id, l)), this.cached = [], this.registerEventListeners(), this.initialized = !0)
                    }, this.set = (l, c, p) => {
                        if (this.isInitialized(), this.logger.debug("Setting JSON-RPC request history record"), this.logger.trace({
                                type: "method",
                                method: "set",
                                topic: l,
                                request: c,
                                chainId: p
                            }), this.records.has(c.id)) return;
                        let v = {
                            id: c.id,
                            topic: l,
                            request: {
                                method: c.method,
                                params: c.params || null
                            },
                            chainId: p,
                            expiry: lt(tp.THIRTY_DAYS)
                        };
                        this.records.set(v.id, v), this.events.emit(r3.created, v)
                    }, this.resolve = async l => {
                        if (this.isInitialized(), this.logger.debug("Updating JSON-RPC response history record"), this.logger.trace({
                                type: "method",
                                method: "update",
                                response: l
                            }), !this.records.has(l.id)) return;
                        let c = await this.getRecord(l.id);
                        typeof c.response > "u" && (c.response = isJsonRpcError(l) ? {
                            error: l.error
                        } : {
                            result: l.result
                        }, this.records.set(c.id, c), this.events.emit(r3.updated, c))
                    }, this.get = async (l, c) => (this.isInitialized(), this.logger.debug("Getting record"), this.logger.trace({
                        type: "method",
                        method: "get",
                        topic: l,
                        id: c
                    }), await this.getRecord(c)), this.delete = (l, c) => {
                        this.isInitialized(), this.logger.debug("Deleting record"), this.logger.trace({
                            type: "method",
                            method: "delete",
                            id: c
                        }), this.values.forEach(p => {
                            p.topic !== l || "u" > typeof c && p.id !== c || (this.records.delete(p.id), this.events.emit(r3.deleted, p))
                        })
                    }, this.exists = async (l, c) => (this.isInitialized(), !!this.records.has(c) && (await this.getRecord(c)).topic === l), this.on = (l, c) => {
                        this.events.on(l, c)
                    }, this.once = (l, c) => {
                        this.events.once(l, c)
                    }, this.off = (l, c) => {
                        this.events.off(l, c)
                    }, this.removeListener = (l, c) => {
                        this.events.removeListener(l, c)
                    }, this.logger = (0, tB.generateChildLogger)(c, this.name)
                }
                get context() {
                    return (0, tB.getLoggerContext)(this.logger)
                }
                get storageKey() {
                    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name
                }
                get size() {
                    return this.records.size
                }
                get keys() {
                    return Array.from(this.records.keys())
                }
                get values() {
                    return Array.from(this.records.values())
                }
                get pending() {
                    let l = [];
                    return this.values.forEach(c => {
                        if ("u" > typeof c.response) return;
                        let p = {
                            topic: c.topic,
                            request: formatJsonRpcRequest(c.request.method, c.request.params, c.id),
                            chainId: c.chainId
                        };
                        return l.push(p)
                    }), l
                }
                async setJsonRpcRecords(l) {
                    await this.core.storage.setItem(this.storageKey, l)
                }
                async getJsonRpcRecords() {
                    return await this.core.storage.getItem(this.storageKey)
                }
                getRecord(l) {
                    this.isInitialized();
                    let c = this.records.get(l);
                    if (!c) {
                        let {
                            message: c
                        } = N("NO_MATCHING_KEY", `${this.name}: ${l}`);
                        throw Error(c)
                    }
                    return c
                }
                async persist() {
                    await this.setJsonRpcRecords(this.values), this.events.emit(r3.sync)
                }
                async restore() {
                    try {
                        let l = await this.getJsonRpcRecords();
                        if (typeof l > "u" || !l.length) return;
                        if (this.records.size) {
                            let {
                                message: l
                            } = N("RESTORE_WILL_OVERRIDE", this.name);
                            throw this.logger.error(l), Error(l)
                        }
                        this.cached = l, this.logger.debug(`Successfully Restored records for ${this.name}`), this.logger.trace({
                            type: "method",
                            method: "restore",
                            records: this.values
                        })
                    } catch (l) {
                        this.logger.debug(`Failed to Restore records for ${this.name}`), this.logger.error(l)
                    }
                }
                registerEventListeners() {
                    this.events.on(r3.created, l => {
                        let c = r3.created;
                        this.logger.info(`Emitting ${c}`), this.logger.debug({
                            type: "event",
                            event: c,
                            record: l
                        }), this.persist()
                    }), this.events.on(r3.updated, l => {
                        let c = r3.updated;
                        this.logger.info(`Emitting ${c}`), this.logger.debug({
                            type: "event",
                            event: c,
                            record: l
                        }), this.persist()
                    }), this.events.on(r3.deleted, l => {
                        let c = r3.deleted;
                        this.logger.info(`Emitting ${c}`), this.logger.debug({
                            type: "event",
                            event: c,
                            record: l
                        }), this.persist()
                    }), this.core.heartbeat.on(tU.HEARTBEAT_EVENTS.pulse, () => {
                        this.cleanup()
                    })
                }
                cleanup() {
                    try {
                        this.records.forEach(l => {
                            (0, tp.toMiliseconds)(l.expiry || 0) - Date.now() <= 0 && (this.logger.info(`Deleting expired history log: ${l.id}`), this.delete(l.topic, l.id))
                        })
                    } catch (l) {
                        this.logger.warn(l)
                    }
                }
                isInitialized() {
                    if (!this.initialized) {
                        let {
                            message: l
                        } = N("NOT_INITIALIZED", this.name);
                        throw Error(l)
                    }
                }
            };
            let index_es_kt = class index_es_kt extends E {
                constructor(l, c) {
                    super(l, c), this.core = l, this.logger = c, this.expirations = new Map, this.events = new ef.EventEmitter, this.name = "expirer", this.version = "0.3", this.cached = [], this.initialized = !1, this.storagePrefix = rz, this.init = async () => {
                        this.initialized || (this.logger.trace("Initialized"), await this.restore(), this.cached.forEach(l => this.expirations.set(l.target, l)), this.cached = [], this.registerEventListeners(), this.initialized = !0)
                    }, this.has = l => {
                        try {
                            let c = this.formatTarget(l);
                            return "u" > typeof this.getExpiration(c)
                        } catch {
                            return !1
                        }
                    }, this.set = (l, c) => {
                        this.isInitialized();
                        let p = this.formatTarget(l),
                            v = {
                                target: p,
                                expiry: c
                            };
                        this.expirations.set(p, v), this.checkExpiry(p, v), this.events.emit(r6.created, {
                            target: p,
                            expiration: v
                        })
                    }, this.get = l => {
                        this.isInitialized();
                        let c = this.formatTarget(l);
                        return this.getExpiration(c)
                    }, this.del = l => {
                        if (this.isInitialized(), this.has(l)) {
                            let c = this.formatTarget(l),
                                p = this.getExpiration(c);
                            this.expirations.delete(c), this.events.emit(r6.deleted, {
                                target: c,
                                expiration: p
                            })
                        }
                    }, this.on = (l, c) => {
                        this.events.on(l, c)
                    }, this.once = (l, c) => {
                        this.events.once(l, c)
                    }, this.off = (l, c) => {
                        this.events.off(l, c)
                    }, this.removeListener = (l, c) => {
                        this.events.removeListener(l, c)
                    }, this.logger = (0, tB.generateChildLogger)(c, this.name)
                }
                get context() {
                    return (0, tB.getLoggerContext)(this.logger)
                }
                get storageKey() {
                    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name
                }
                get length() {
                    return this.expirations.size
                }
                get keys() {
                    return Array.from(this.expirations.keys())
                }
                get values() {
                    return Array.from(this.expirations.values())
                }
                formatTarget(l) {
                    if ("string" == typeof l) return re("topic", l);
                    if ("number" == typeof l) return re("id", l);
                    let {
                        message: c
                    } = N("UNKNOWN_TYPE", `Target type: ${typeof l}`);
                    throw Error(c)
                }
                async setExpirations(l) {
                    await this.core.storage.setItem(this.storageKey, l)
                }
                async getExpirations() {
                    return await this.core.storage.getItem(this.storageKey)
                }
                async persist() {
                    await this.setExpirations(this.values), this.events.emit(r6.sync)
                }
                async restore() {
                    try {
                        let l = await this.getExpirations();
                        if (typeof l > "u" || !l.length) return;
                        if (this.expirations.size) {
                            let {
                                message: l
                            } = N("RESTORE_WILL_OVERRIDE", this.name);
                            throw this.logger.error(l), Error(l)
                        }
                        this.cached = l, this.logger.debug(`Successfully Restored expirations for ${this.name}`), this.logger.trace({
                            type: "method",
                            method: "restore",
                            expirations: this.values
                        })
                    } catch (l) {
                        this.logger.debug(`Failed to Restore expirations for ${this.name}`), this.logger.error(l)
                    }
                }
                getExpiration(l) {
                    let c = this.expirations.get(l);
                    if (!c) {
                        let {
                            message: c
                        } = N("NO_MATCHING_KEY", `${this.name}: ${l}`);
                        throw this.logger.error(c), Error(c)
                    }
                    return c
                }
                checkExpiry(l, c) {
                    let {
                        expiry: p
                    } = c;
                    (0, tp.toMiliseconds)(p) - Date.now() <= 0 && this.expire(l, c)
                }
                expire(l, c) {
                    this.expirations.delete(l), this.events.emit(r6.expired, {
                        target: l,
                        expiration: c
                    })
                }
                checkExpirations() {
                    this.core.relayer.connected && this.expirations.forEach((l, c) => this.checkExpiry(c, l))
                }
                registerEventListeners() {
                    this.core.heartbeat.on(tU.HEARTBEAT_EVENTS.pulse, () => this.checkExpirations()), this.events.on(r6.created, l => {
                        let c = r6.created;
                        this.logger.info(`Emitting ${c}`), this.logger.debug({
                            type: "event",
                            event: c,
                            data: l
                        }), this.persist()
                    }), this.events.on(r6.expired, l => {
                        let c = r6.expired;
                        this.logger.info(`Emitting ${c}`), this.logger.debug({
                            type: "event",
                            event: c,
                            data: l
                        }), this.persist()
                    }), this.events.on(r6.deleted, l => {
                        let c = r6.deleted;
                        this.logger.info(`Emitting ${c}`), this.logger.debug({
                            type: "event",
                            event: c,
                            data: l
                        }), this.persist()
                    })
                }
                isInitialized() {
                    if (!this.initialized) {
                        let {
                            message: l
                        } = N("NOT_INITIALIZED", this.name);
                        throw Error(l)
                    }
                }
            };
            let index_es_Kt = class index_es_Kt extends y {
                constructor(l, c) {
                    super(l, c), this.projectId = l, this.logger = c, this.name = r4, this.initialized = !1, this.queue = [], this.verifyDisabled = !1, this.init = async () => {
                        if (!(this.verifyDisabled || j()) && q()) {
                            this.verifyUrl !== r8 && this.removeIframe(), this.verifyUrl = r8;
                            try {
                                await this.createIframe()
                            } catch (l) {
                                this.logger.info(`Verify iframe failed to load: ${this.verifyUrl}`), this.logger.info(l)
                            }
                            if (!this.initialized) {
                                this.removeIframe(), this.verifyUrl = r9;
                                try {
                                    await this.createIframe()
                                } catch (l) {
                                    this.logger.info(`Verify iframe failed to load: ${this.verifyUrl}`), this.logger.info(l), this.verifyDisabled = !0
                                }
                            }
                        }
                    }, this.register = async l => {
                        this.initialized ? this.sendPost(l.attestationId) : (this.addToQueue(l.attestationId), await this.init())
                    }, this.resolve = async l => {
                        let c;
                        if (this.isDevEnv) return "";
                        let p = l ? .verifyUrl || r8;
                        try {
                            c = await this.fetchAttestation(l.attestationId, p)
                        } catch (v) {
                            this.logger.info(`failed to resolve attestation: ${l.attestationId} from url: ${p}`), this.logger.info(v), c = await this.fetchAttestation(l.attestationId, r9)
                        }
                        return c
                    }, this.fetchAttestation = async (l, c) => {
                        this.logger.info(`resolving attestation: ${l} from url: ${c}`);
                        let p = this.startAbortTimer(2 * tp.ONE_SECOND),
                            v = await fetch(`${c}/attestation/${l}`, {
                                signal: this.abortController.signal
                            });
                        return clearTimeout(p), 200 === v.status ? await v.json() : void 0
                    }, this.addToQueue = l => {
                        this.queue.push(l)
                    }, this.processQueue = () => {
                        0 !== this.queue.length && (this.queue.forEach(l => this.sendPost(l)), this.queue = [])
                    }, this.sendPost = l => {
                        var c;
                        try {
                            if (!this.iframe) return;
                            null == (c = this.iframe.contentWindow) || c.postMessage(l, "*"), this.logger.info(`postMessage sent: ${l} ${this.verifyUrl}`)
                        } catch {}
                    }, this.createIframe = async () => {
                        let l;
                        let s = c => {
                            "verify_ready" === c.data && (this.initialized = !0, this.processQueue(), window.removeEventListener("message", s), l())
                        };
                        await Promise.race([new Promise(c => {
                            if (document.getElementById(r4)) return c();
                            window.addEventListener("message", s);
                            let p = document.createElement("iframe");
                            p.id = r4, p.src = `${this.verifyUrl}/${this.projectId}`, p.style.display = "none", document.body.append(p), this.iframe = p, l = c
                        }), new Promise((l, c) => setTimeout(() => {
                            window.removeEventListener("message", s), c("verify iframe load timeout")
                        }, (0, tp.toMiliseconds)(tp.FIVE_SECONDS)))])
                    }, this.removeIframe = () => {
                        this.iframe && (this.iframe.remove(), this.iframe = void 0, this.initialized = !1)
                    }, this.logger = (0, tB.generateChildLogger)(c, this.name), this.verifyUrl = r8, this.abortController = new AbortController, this.isDevEnv = te() && ({
                        BUILD_ID: "rPlKWyq5lgx0xpN1VdXrR",
                        NEXT_PUBLIC_APP_ENVIRONMENT: "production",
                        NEXT_PUBLIC_APP_RELEASE_ID: "ba3767f43ffc44e8ba5f21e4cc793c50a7fa8054"
                    }).IS_VITEST
                }
                get context() {
                    return (0, tB.getLoggerContext)(this.logger)
                }
                startAbortTimer(l) {
                    return this.abortController = new AbortController, setTimeout(() => this.abortController.abort(), (0, tp.toMiliseconds)(l))
                }
            };
            var nb = Object.defineProperty,
                nw = Object.getOwnPropertySymbols,
                nx = Object.prototype.hasOwnProperty,
                n_ = Object.prototype.propertyIsEnumerable,
                index_es_Vt = (l, c, p) => c in l ? nb(l, c, {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: p
                }) : l[c] = p,
                index_es_qt = (l, c) => {
                    for (var p in c || (c = {})) nx.call(c, p) && index_es_Vt(l, p, c[p]);
                    if (nw)
                        for (var p of nw(c)) n_.call(c, p) && index_es_Vt(l, p, c[p]);
                    return l
                };
            let index_es_ee = class index_es_ee extends n {
                constructor(l) {
                    super(l), this.protocol = "wc", this.version = 2, this.name = rV, this.events = new ef.EventEmitter, this.initialized = !1, this.on = (l, c) => this.events.on(l, c), this.once = (l, c) => this.events.once(l, c), this.off = (l, c) => this.events.off(l, c), this.removeListener = (l, c) => this.events.removeListener(l, c), this.projectId = l ? .projectId, this.relayUrl = l ? .relayUrl || rJ, this.customStoragePrefix = null != l && l.customStoragePrefix ? `:${l.customStoragePrefix}` : "";
                    let c = "u" > typeof l ? .logger && "string" != typeof l ? .logger ? l.logger : (0, tB.pino)((0, tB.getDefaultLoggerOptions)({
                        level: l ? .logger || rq.logger
                    }));
                    this.logger = (0, tB.generateChildLogger)(c, this.name), this.heartbeat = new tU.HeartBeat, this.crypto = new index_es_t(this, this.logger, l ? .keychain), this.history = new index_es_Mt(this, this.logger), this.expirer = new index_es_kt(this, this.logger), this.storage = null != l && l.storage ? l.storage : new tM.ZP(index_es_qt(index_es_qt({}, rW), l ? .storageOptions)), this.relayer = new index_es_zt({
                        core: this,
                        logger: this.logger,
                        relayUrl: this.relayUrl,
                        projectId: this.projectId
                    }), this.pairing = new index_es_$t(this, this.logger), this.verify = new index_es_Kt(this.projectId || "", this.logger)
                }
                static async init(l) {
                    let c = new index_es_ee(l);
                    await c.initialize();
                    let p = await c.crypto.getClientId();
                    return await c.storage.setItem("WALLETCONNECT_CLIENT_ID", p), c
                }
                get context() {
                    return (0, tB.getLoggerContext)(this.logger)
                }
                async start() {
                    this.initialized || await this.initialize()
                }
                async initialize() {
                    this.logger.trace("Initialized");
                    try {
                        await this.crypto.init(), await this.history.init(), await this.expirer.init(), await this.relayer.init(), await this.heartbeat.init(), await this.pairing.init(), this.initialized = !0, this.logger.info("Core Initialization Success")
                    } catch (l) {
                        throw this.logger.warn(`Core Initialization Failure at epoch ${Date.now()}`, l), this.logger.error(l.message), l
                    }
                }
            };
            let nE = "client",
                nA = `wc@2:${nE}:`,
                nC = {
                    name: nE,
                    logger: "error"
                },
                nS = "WALLETCONNECT_DEEPLINK_CHOICE",
                nN = "Proposal expired",
                nP = tp.SEVEN_DAYS,
                nD = {
                    wc_sessionPropose: {
                        req: {
                            ttl: tp.FIVE_MINUTES,
                            prompt: !0,
                            tag: 1100
                        },
                        res: {
                            ttl: tp.FIVE_MINUTES,
                            prompt: !1,
                            tag: 1101
                        }
                    },
                    wc_sessionSettle: {
                        req: {
                            ttl: tp.FIVE_MINUTES,
                            prompt: !1,
                            tag: 1102
                        },
                        res: {
                            ttl: tp.FIVE_MINUTES,
                            prompt: !1,
                            tag: 1103
                        }
                    },
                    wc_sessionUpdate: {
                        req: {
                            ttl: tp.ONE_DAY,
                            prompt: !1,
                            tag: 1104
                        },
                        res: {
                            ttl: tp.ONE_DAY,
                            prompt: !1,
                            tag: 1105
                        }
                    },
                    wc_sessionExtend: {
                        req: {
                            ttl: tp.ONE_DAY,
                            prompt: !1,
                            tag: 1106
                        },
                        res: {
                            ttl: tp.ONE_DAY,
                            prompt: !1,
                            tag: 1107
                        }
                    },
                    wc_sessionRequest: {
                        req: {
                            ttl: tp.FIVE_MINUTES,
                            prompt: !0,
                            tag: 1108
                        },
                        res: {
                            ttl: tp.FIVE_MINUTES,
                            prompt: !1,
                            tag: 1109
                        }
                    },
                    wc_sessionEvent: {
                        req: {
                            ttl: tp.FIVE_MINUTES,
                            prompt: !0,
                            tag: 1110
                        },
                        res: {
                            ttl: tp.FIVE_MINUTES,
                            prompt: !1,
                            tag: 1111
                        }
                    },
                    wc_sessionDelete: {
                        req: {
                            ttl: tp.ONE_DAY,
                            prompt: !1,
                            tag: 1112
                        },
                        res: {
                            ttl: tp.ONE_DAY,
                            prompt: !1,
                            tag: 1113
                        }
                    },
                    wc_sessionPing: {
                        req: {
                            ttl: tp.THIRTY_SECONDS,
                            prompt: !1,
                            tag: 1114
                        },
                        res: {
                            ttl: tp.THIRTY_SECONDS,
                            prompt: !1,
                            tag: 1115
                        }
                    }
                },
                nk = {
                    min: tp.FIVE_MINUTES,
                    max: tp.SEVEN_DAYS
                },
                nI = {
                    idle: "IDLE",
                    active: "ACTIVE"
                },
                nO = ["wc_sessionPropose", "wc_sessionRequest", "wc_authRequest"];
            var nj = Object.defineProperty,
                nT = Object.defineProperties,
                nR = Object.getOwnPropertyDescriptors,
                nL = Object.getOwnPropertySymbols,
                nM = Object.prototype.hasOwnProperty,
                nU = Object.prototype.propertyIsEnumerable,
                index_es_de = (l, c, p) => c in l ? nj(l, c, {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: p
                }) : l[c] = p,
                dist_index_es_g = (l, c) => {
                    for (var p in c || (c = {})) nM.call(c, p) && index_es_de(l, p, c[p]);
                    if (nL)
                        for (var p of nL(c)) nU.call(c, p) && index_es_de(l, p, c[p]);
                    return l
                },
                index_es_b = (l, c) => nT(l, nR(c));
            let index_es_ps = class index_es_ps extends index_es_S {
                constructor(l) {
                    super(l), this.name = "engine", this.events = new(ep()), this.initialized = !1, this.ignoredPayloadTypes = [1], this.requestQueue = {
                        state: nI.idle,
                        queue: []
                    }, this.sessionRequestQueue = {
                        state: nI.idle,
                        queue: []
                    }, this.requestQueueDelay = tp.ONE_SECOND, this.init = async () => {
                        this.initialized || (await this.cleanup(), this.registerRelayerEvents(), this.registerExpirerEvents(), this.registerPairingEvents(), this.client.core.pairing.register({
                            methods: Object.keys(nD)
                        }), this.initialized = !0, setTimeout(() => {
                            this.sessionRequestQueue.queue = this.getPendingSessionRequests(), this.processSessionRequestQueue()
                        }, (0, tp.toMiliseconds)(this.requestQueueDelay)))
                    }, this.connect = async l => {
                        await this.isInitialized();
                        let c = index_es_b(dist_index_es_g({}, l), {
                            requiredNamespaces: l.requiredNamespaces || {},
                            optionalNamespaces: l.optionalNamespaces || {}
                        });
                        await this.isValidConnect(c);
                        let {
                            pairingTopic: p,
                            requiredNamespaces: v,
                            optionalNamespaces: _,
                            sessionProperties: C,
                            relays: P
                        } = c, T = p, M, z = !1;
                        if (T && (z = this.client.core.pairing.pairings.get(T).active), !T || !z) {
                            let {
                                topic: l,
                                uri: c
                            } = await this.client.core.pairing.create();
                            T = l, M = c
                        }
                        let J = await this.client.core.crypto.generateKeyPair(),
                            Q = dist_index_es_g({
                                requiredNamespaces: v,
                                optionalNamespaces: _,
                                relays: P ? ? [{
                                    protocol: "irn"
                                }],
                                proposer: {
                                    publicKey: J,
                                    metadata: this.client.metadata
                                }
                            }, C && {
                                sessionProperties: C
                            }),
                            {
                                reject: X,
                                resolve: es,
                                done: eo
                            } = st(tp.FIVE_MINUTES, nN);
                        if (this.events.once(ft("session_connect"), async ({
                                error: l,
                                session: c
                            }) => {
                                if (l) X(l);
                                else if (c) {
                                    c.self.publicKey = J;
                                    let l = index_es_b(dist_index_es_g({}, c), {
                                        requiredNamespaces: c.requiredNamespaces,
                                        optionalNamespaces: c.optionalNamespaces
                                    });
                                    await this.client.session.set(c.topic, l), await this.setExpiry(c.topic, c.expiry), T && await this.client.core.pairing.updateMetadata({
                                        topic: T,
                                        metadata: c.peer.metadata
                                    }), es(l)
                                }
                            }), !T) {
                            let {
                                message: l
                            } = N("NO_MATCHING_KEY", `connect() pairing topic: ${T}`);
                            throw Error(l)
                        }
                        let el = await this.sendRequest({
                                topic: T,
                                method: "wc_sessionPropose",
                                params: Q
                            }),
                            ec = lt(tp.FIVE_MINUTES);
                        return await this.setProposal(el, dist_index_es_g({
                            id: el,
                            expiry: ec
                        }, Q)), {
                            uri: M,
                            approval: eo
                        }
                    }, this.pair = async l => (await this.isInitialized(), await this.client.core.pairing.pair(l)), this.approve = async l => {
                        await this.isInitialized(), await this.isValidApprove(l);
                        let {
                            id: c,
                            relayProtocol: p,
                            namespaces: v,
                            sessionProperties: _
                        } = l, C = this.client.proposal.get(c), {
                            pairingTopic: P,
                            proposer: T,
                            requiredNamespaces: M,
                            optionalNamespaces: z
                        } = C;
                        P = P || "", B(M) || (M = function(l, c) {
                            let p = cn(l, c);
                            if (p) throw Error(p.message);
                            let v = {};
                            for (let [c, p] of Object.entries(l)) v[c] = {
                                methods: p.methods,
                                events: p.events,
                                chains: p.accounts.map(l => `${l.split(":")[0]}:${l.split(":")[1]}`)
                            };
                            return v
                        }(v, "approve()"));
                        let J = await this.client.core.crypto.generateKeyPair(),
                            Q = T.publicKey,
                            X = await this.client.core.crypto.generateSharedKey(J, Q);
                        P && c && (await this.client.core.pairing.updateMetadata({
                            topic: P,
                            metadata: T.metadata
                        }), await this.sendResult({
                            id: c,
                            topic: P,
                            result: {
                                relay: {
                                    protocol: p ? ? "irn"
                                },
                                responderPublicKey: J
                            }
                        }), await this.client.proposal.delete(c, U("USER_DISCONNECTED")), await this.client.core.pairing.activate({
                            topic: P
                        }));
                        let es = dist_index_es_g({
                            relay: {
                                protocol: p ? ? "irn"
                            },
                            namespaces: v,
                            requiredNamespaces: M,
                            optionalNamespaces: z,
                            pairingTopic: P,
                            controller: {
                                publicKey: J,
                                metadata: this.client.metadata
                            },
                            expiry: lt(nP)
                        }, _ && {
                            sessionProperties: _
                        });
                        await this.client.core.relayer.subscribe(X), await this.sendRequest({
                            topic: X,
                            method: "wc_sessionSettle",
                            params: es,
                            throwOnFailedPublish: !0
                        });
                        let eo = index_es_b(dist_index_es_g({}, es), {
                            topic: X,
                            pairingTopic: P,
                            acknowledged: !1,
                            self: es.controller,
                            peer: {
                                publicKey: T.publicKey,
                                metadata: T.metadata
                            },
                            controller: J
                        });
                        return await this.client.session.set(X, eo), await this.setExpiry(X, lt(nP)), {
                            topic: X,
                            acknowledged: () => new Promise(l => setTimeout(() => l(this.client.session.get(X)), 500))
                        }
                    }, this.reject = async l => {
                        await this.isInitialized(), await this.isValidReject(l);
                        let {
                            id: c,
                            reason: p
                        } = l, {
                            pairingTopic: v
                        } = this.client.proposal.get(c);
                        v && (await this.sendError(c, v, p), await this.client.proposal.delete(c, U("USER_DISCONNECTED")))
                    }, this.update = async l => {
                        await this.isInitialized(), await this.isValidUpdate(l);
                        let {
                            topic: c,
                            namespaces: p
                        } = l, v = await this.sendRequest({
                            topic: c,
                            method: "wc_sessionUpdate",
                            params: {
                                namespaces: p
                            }
                        }), {
                            done: _,
                            resolve: C,
                            reject: P
                        } = st();
                        return this.events.once(ft("session_update", v), ({
                            error: l
                        }) => {
                            l ? P(l) : C()
                        }), await this.client.session.update(c, {
                            namespaces: p
                        }), {
                            acknowledged: _
                        }
                    }, this.extend = async l => {
                        await this.isInitialized(), await this.isValidExtend(l);
                        let {
                            topic: c
                        } = l, p = await this.sendRequest({
                            topic: c,
                            method: "wc_sessionExtend",
                            params: {}
                        }), {
                            done: v,
                            resolve: _,
                            reject: C
                        } = st();
                        return this.events.once(ft("session_extend", p), ({
                            error: l
                        }) => {
                            l ? C(l) : _()
                        }), await this.setExpiry(c, lt(nP)), {
                            acknowledged: v
                        }
                    }, this.request = async l => {
                        await this.isInitialized(), await this.isValidRequest(l);
                        let {
                            chainId: c,
                            request: p,
                            topic: v,
                            expiry: _
                        } = l, C = payloadId(), {
                            done: P,
                            resolve: T,
                            reject: M
                        } = st(_, "Request expired. Please try again.");
                        return this.events.once(ft("session_request", C), ({
                            error: l,
                            result: c
                        }) => {
                            l ? M(l) : T(c)
                        }), await Promise.all([new Promise(async l => {
                            await this.sendRequest({
                                clientRpcId: C,
                                topic: v,
                                method: "wc_sessionRequest",
                                params: {
                                    request: p,
                                    chainId: c
                                },
                                expiry: _,
                                throwOnFailedPublish: !0
                            }).catch(l => M(l)), this.client.events.emit("session_request_sent", {
                                topic: v,
                                request: p,
                                chainId: c,
                                id: C
                            }), l()
                        }), new Promise(async l => {
                            let c = await this.client.core.storage.getItem(nS);
                            pt({
                                id: C,
                                topic: v,
                                wcDeepLink: c
                            }), l()
                        }), P()]).then(l => l[2])
                    }, this.respond = async l => {
                        await this.isInitialized(), await this.isValidRespond(l);
                        let {
                            topic: c,
                            response: p
                        } = l, {
                            id: v
                        } = p;
                        isJsonRpcResult(p) ? await this.sendResult({
                            id: v,
                            topic: c,
                            result: p.result,
                            throwOnFailedPublish: !0
                        }) : isJsonRpcError(p) && await this.sendError(v, c, p.error), this.cleanupAfterResponse(l)
                    }, this.ping = async l => {
                        await this.isInitialized(), await this.isValidPing(l);
                        let {
                            topic: c
                        } = l;
                        if (this.client.session.keys.includes(c)) {
                            let l = await this.sendRequest({
                                    topic: c,
                                    method: "wc_sessionPing",
                                    params: {}
                                }),
                                {
                                    done: p,
                                    resolve: v,
                                    reject: _
                                } = st();
                            this.events.once(ft("session_ping", l), ({
                                error: l
                            }) => {
                                l ? _(l) : v()
                            }), await p()
                        } else this.client.core.pairing.pairings.keys.includes(c) && await this.client.core.pairing.ping({
                            topic: c
                        })
                    }, this.emit = async l => {
                        await this.isInitialized(), await this.isValidEmit(l);
                        let {
                            topic: c,
                            event: p,
                            chainId: v
                        } = l;
                        await this.sendRequest({
                            topic: c,
                            method: "wc_sessionEvent",
                            params: {
                                event: p,
                                chainId: v
                            }
                        })
                    }, this.disconnect = async l => {
                        await this.isInitialized(), await this.isValidDisconnect(l);
                        let {
                            topic: c
                        } = l;
                        this.client.session.keys.includes(c) ? (await this.sendRequest({
                            topic: c,
                            method: "wc_sessionDelete",
                            params: U("USER_DISCONNECTED"),
                            throwOnFailedPublish: !0
                        }), await this.deleteSession(c)) : await this.client.core.pairing.disconnect({
                            topic: c
                        })
                    }, this.find = l => (this.isInitialized(), this.client.session.getAll().filter(c => (function(l, c) {
                        let {
                            requiredNamespaces: p
                        } = c, v = Object.keys(l.namespaces), _ = Object.keys(p), C = !0;
                        return !!O(_, v) && (v.forEach(c => {
                            let {
                                accounts: v,
                                methods: _,
                                events: P
                            } = l.namespaces[c], T = A(v), M = p[c];
                            O(K(c, M), T) && O(M.methods, _) && O(M.events, P) || (C = !1)
                        }), C)
                    })(c, l))), this.getPendingSessionRequests = () => (this.isInitialized(), this.client.pendingRequest.getAll()), this.cleanupDuplicatePairings = async l => {
                        if (l.pairingTopic) try {
                            let c = this.client.core.pairing.pairings.get(l.pairingTopic),
                                p = this.client.core.pairing.pairings.getAll().filter(p => {
                                    var v, _;
                                    return (null == (v = p.peerMetadata) ? void 0 : v.url) && (null == (_ = p.peerMetadata) ? void 0 : _.url) === l.peer.metadata.url && p.topic && p.topic !== c.topic
                                });
                            if (0 === p.length) return;
                            this.client.logger.info(`Cleaning up ${p.length} duplicate pairing(s)`), await Promise.all(p.map(l => this.client.core.pairing.disconnect({
                                topic: l.topic
                            }))), this.client.logger.info("Duplicate pairings clean up finished")
                        } catch (l) {
                            this.client.logger.error(l)
                        }
                    }, this.deleteSession = async (l, c) => {
                        let {
                            self: p
                        } = this.client.session.get(l);
                        await this.client.core.relayer.unsubscribe(l), this.client.session.delete(l, U("USER_DISCONNECTED")), this.client.core.crypto.keychain.has(p.publicKey) && await this.client.core.crypto.deleteKeyPair(p.publicKey), this.client.core.crypto.keychain.has(l) && await this.client.core.crypto.deleteSymKey(l), c || this.client.core.expirer.del(l), this.client.core.storage.removeItem(nS).catch(l => this.client.logger.warn(l))
                    }, this.deleteProposal = async (l, c) => {
                        await Promise.all([this.client.proposal.delete(l, U("USER_DISCONNECTED")), c ? Promise.resolve() : this.client.core.expirer.del(l)])
                    }, this.deletePendingSessionRequest = async (l, c, p = !1) => {
                        await Promise.all([this.client.pendingRequest.delete(l, c), p ? Promise.resolve() : this.client.core.expirer.del(l)]), this.sessionRequestQueue.queue = this.sessionRequestQueue.queue.filter(c => c.id !== l), p && (this.sessionRequestQueue.state = nI.idle)
                    }, this.setExpiry = async (l, c) => {
                        this.client.session.keys.includes(l) && await this.client.session.update(l, {
                            expiry: c
                        }), this.client.core.expirer.set(l, c)
                    }, this.setProposal = async (l, c) => {
                        await this.client.proposal.set(l, c), this.client.core.expirer.set(l, c.expiry)
                    }, this.setPendingSessionRequest = async l => {
                        let c = nD.wc_sessionRequest.req.ttl,
                            {
                                id: p,
                                topic: v,
                                params: _,
                                verifyContext: C
                            } = l;
                        await this.client.pendingRequest.set(p, {
                            id: p,
                            topic: v,
                            params: _,
                            verifyContext: C
                        }), c && this.client.core.expirer.set(p, lt(c))
                    }, this.sendRequest = async l => {
                        let {
                            topic: c,
                            method: p,
                            params: v,
                            expiry: _,
                            relayRpcId: C,
                            clientRpcId: P,
                            throwOnFailedPublish: T
                        } = l, M = formatJsonRpcRequest(p, v, P);
                        if (q() && nO.includes(p)) {
                            let l = Mn(JSON.stringify(M));
                            this.client.core.verify.register({
                                attestationId: l
                            })
                        }
                        let z = await this.client.core.crypto.encode(c, M),
                            J = nD[p].req;
                        return _ && (J.ttl = _), C && (J.id = C), this.client.core.history.set(c, M), T ? (J.internal = index_es_b(dist_index_es_g({}, J.internal), {
                            throwOnFailedPublish: !0
                        }), await this.client.core.relayer.publish(c, z, J)) : this.client.core.relayer.publish(c, z, J).catch(l => this.client.logger.error(l)), M.id
                    }, this.sendResult = async l => {
                        let {
                            id: c,
                            topic: p,
                            result: v,
                            throwOnFailedPublish: _
                        } = l, C = formatJsonRpcResult(c, v), P = await this.client.core.crypto.encode(p, C), T = await this.client.core.history.get(p, c), M = nD[T.request.method].res;
                        _ ? (M.internal = index_es_b(dist_index_es_g({}, M.internal), {
                            throwOnFailedPublish: !0
                        }), await this.client.core.relayer.publish(p, P, M)) : this.client.core.relayer.publish(p, P, M).catch(l => this.client.logger.error(l)), await this.client.core.history.resolve(C)
                    }, this.sendError = async (l, c, p) => {
                        let v = formatJsonRpcError(l, p),
                            _ = await this.client.core.crypto.encode(c, v),
                            C = await this.client.core.history.get(c, l),
                            P = nD[C.request.method].res;
                        this.client.core.relayer.publish(c, _, P), await this.client.core.history.resolve(v)
                    }, this.cleanup = async () => {
                        let l = [],
                            c = [];
                        this.client.session.getAll().forEach(c => {
                            dt(c.expiry) && l.push(c.topic)
                        }), this.client.proposal.getAll().forEach(l => {
                            dt(l.expiry) && c.push(l.id)
                        }), await Promise.all([...l.map(l => this.deleteSession(l)), ...c.map(l => this.deleteProposal(l))])
                    }, this.onRelayEventRequest = async l => {
                        this.requestQueue.queue.push(l), await this.processRequestsQueue()
                    }, this.processRequestsQueue = async () => {
                        if (this.requestQueue.state === nI.active) {
                            this.client.logger.info("Request queue already active, skipping...");
                            return
                        }
                        for (this.client.logger.info(`Request queue starting with ${this.requestQueue.queue.length} requests`); this.requestQueue.queue.length > 0;) {
                            this.requestQueue.state = nI.active;
                            let l = this.requestQueue.queue.shift();
                            if (l) try {
                                this.processRequest(l), await new Promise(l => setTimeout(l, 300))
                            } catch (l) {
                                this.client.logger.warn(l)
                            }
                        }
                        this.requestQueue.state = nI.idle
                    }, this.processRequest = l => {
                        let {
                            topic: c,
                            payload: p
                        } = l, v = p.method;
                        switch (v) {
                            case "wc_sessionPropose":
                                return this.onSessionProposeRequest(c, p);
                            case "wc_sessionSettle":
                                return this.onSessionSettleRequest(c, p);
                            case "wc_sessionUpdate":
                                return this.onSessionUpdateRequest(c, p);
                            case "wc_sessionExtend":
                                return this.onSessionExtendRequest(c, p);
                            case "wc_sessionPing":
                                return this.onSessionPingRequest(c, p);
                            case "wc_sessionDelete":
                                return this.onSessionDeleteRequest(c, p);
                            case "wc_sessionRequest":
                                return this.onSessionRequest(c, p);
                            case "wc_sessionEvent":
                                return this.onSessionEventRequest(c, p);
                            default:
                                return this.client.logger.info(`Unsupported request method ${v}`)
                        }
                    }, this.onRelayEventResponse = async l => {
                        let {
                            topic: c,
                            payload: p
                        } = l, v = (await this.client.core.history.get(c, p.id)).request.method;
                        switch (v) {
                            case "wc_sessionPropose":
                                return this.onSessionProposeResponse(c, p);
                            case "wc_sessionSettle":
                                return this.onSessionSettleResponse(c, p);
                            case "wc_sessionUpdate":
                                return this.onSessionUpdateResponse(c, p);
                            case "wc_sessionExtend":
                                return this.onSessionExtendResponse(c, p);
                            case "wc_sessionPing":
                                return this.onSessionPingResponse(c, p);
                            case "wc_sessionRequest":
                                return this.onSessionRequestResponse(c, p);
                            default:
                                return this.client.logger.info(`Unsupported response method ${v}`)
                        }
                    }, this.onRelayEventUnknownPayload = l => {
                        let {
                            topic: c
                        } = l, {
                            message: p
                        } = N("MISSING_OR_INVALID", `Decoded payload on topic ${c} is not identifiable as a JSON-RPC request or a response.`);
                        throw Error(p)
                    }, this.onSessionProposeRequest = async (l, c) => {
                        let {
                            params: p,
                            id: v
                        } = c;
                        try {
                            this.isValidConnect(dist_index_es_g({}, c.params));
                            let _ = lt(tp.FIVE_MINUTES),
                                C = dist_index_es_g({
                                    id: v,
                                    pairingTopic: l,
                                    expiry: _
                                }, p);
                            await this.setProposal(v, C);
                            let P = Mn(JSON.stringify(c)),
                                T = await this.getVerifyContext(P, C.proposer.metadata);
                            this.client.events.emit("session_proposal", {
                                id: v,
                                params: C,
                                verifyContext: T
                            })
                        } catch (c) {
                            await this.sendError(v, l, c), this.client.logger.error(c)
                        }
                    }, this.onSessionProposeResponse = async (l, c) => {
                        let {
                            id: p
                        } = c;
                        if (isJsonRpcResult(c)) {
                            let {
                                result: v
                            } = c;
                            this.client.logger.trace({
                                type: "method",
                                method: "onSessionProposeResponse",
                                result: v
                            });
                            let _ = this.client.proposal.get(p);
                            this.client.logger.trace({
                                type: "method",
                                method: "onSessionProposeResponse",
                                proposal: _
                            });
                            let C = _.proposer.publicKey;
                            this.client.logger.trace({
                                type: "method",
                                method: "onSessionProposeResponse",
                                selfPublicKey: C
                            });
                            let P = v.responderPublicKey;
                            this.client.logger.trace({
                                type: "method",
                                method: "onSessionProposeResponse",
                                peerPublicKey: P
                            });
                            let T = await this.client.core.crypto.generateSharedKey(C, P);
                            this.client.logger.trace({
                                type: "method",
                                method: "onSessionProposeResponse",
                                sessionTopic: T
                            });
                            let M = await this.client.core.relayer.subscribe(T);
                            this.client.logger.trace({
                                type: "method",
                                method: "onSessionProposeResponse",
                                subscriptionId: M
                            }), await this.client.core.pairing.activate({
                                topic: l
                            })
                        } else isJsonRpcError(c) && (await this.client.proposal.delete(p, U("USER_DISCONNECTED")), this.events.emit(ft("session_connect"), {
                            error: c.error
                        }))
                    }, this.onSessionSettleRequest = async (l, c) => {
                        let {
                            id: p,
                            params: v
                        } = c;
                        try {
                            this.isValidSessionSettleRequest(v);
                            let {
                                relay: p,
                                controller: _,
                                expiry: C,
                                namespaces: P,
                                requiredNamespaces: T,
                                optionalNamespaces: M,
                                sessionProperties: z,
                                pairingTopic: J
                            } = c.params, Q = dist_index_es_g({
                                topic: l,
                                relay: p,
                                expiry: C,
                                namespaces: P,
                                acknowledged: !0,
                                pairingTopic: J,
                                requiredNamespaces: T,
                                optionalNamespaces: M,
                                controller: _.publicKey,
                                self: {
                                    publicKey: "",
                                    metadata: this.client.metadata
                                },
                                peer: {
                                    publicKey: _.publicKey,
                                    metadata: _.metadata
                                }
                            }, z && {
                                sessionProperties: z
                            });
                            await this.sendResult({
                                id: c.id,
                                topic: l,
                                result: !0
                            }), this.events.emit(ft("session_connect"), {
                                session: Q
                            }), this.cleanupDuplicatePairings(Q)
                        } catch (c) {
                            await this.sendError(p, l, c), this.client.logger.error(c)
                        }
                    }, this.onSessionSettleResponse = async (l, c) => {
                        let {
                            id: p
                        } = c;
                        isJsonRpcResult(c) ? (await this.client.session.update(l, {
                            acknowledged: !0
                        }), this.events.emit(ft("session_approve", p), {})) : isJsonRpcError(c) && (await this.client.session.delete(l, U("USER_DISCONNECTED")), this.events.emit(ft("session_approve", p), {
                            error: c.error
                        }))
                    }, this.onSessionUpdateRequest = async (l, c) => {
                        let {
                            params: p,
                            id: v
                        } = c;
                        try {
                            let c = `${l}_session_update`,
                                _ = er.get(c);
                            if (_ && this.isRequestOutOfSync(_, v)) {
                                this.client.logger.info(`Discarding out of sync request - ${v}`);
                                return
                            }
                            this.isValidUpdate(dist_index_es_g({
                                topic: l
                            }, p)), await this.client.session.update(l, {
                                namespaces: p.namespaces
                            }), await this.sendResult({
                                id: v,
                                topic: l,
                                result: !0
                            }), this.client.events.emit("session_update", {
                                id: v,
                                topic: l,
                                params: p
                            }), er.set(c, v)
                        } catch (c) {
                            await this.sendError(v, l, c), this.client.logger.error(c)
                        }
                    }, this.isRequestOutOfSync = (l, c) => parseInt(c.toString().slice(0, -3)) <= parseInt(l.toString().slice(0, -3)), this.onSessionUpdateResponse = (l, c) => {
                        let {
                            id: p
                        } = c;
                        isJsonRpcResult(c) ? this.events.emit(ft("session_update", p), {}) : isJsonRpcError(c) && this.events.emit(ft("session_update", p), {
                            error: c.error
                        })
                    }, this.onSessionExtendRequest = async (l, c) => {
                        let {
                            id: p
                        } = c;
                        try {
                            this.isValidExtend({
                                topic: l
                            }), await this.setExpiry(l, lt(nP)), await this.sendResult({
                                id: p,
                                topic: l,
                                result: !0
                            }), this.client.events.emit("session_extend", {
                                id: p,
                                topic: l
                            })
                        } catch (c) {
                            await this.sendError(p, l, c), this.client.logger.error(c)
                        }
                    }, this.onSessionExtendResponse = (l, c) => {
                        let {
                            id: p
                        } = c;
                        isJsonRpcResult(c) ? this.events.emit(ft("session_extend", p), {}) : isJsonRpcError(c) && this.events.emit(ft("session_extend", p), {
                            error: c.error
                        })
                    }, this.onSessionPingRequest = async (l, c) => {
                        let {
                            id: p
                        } = c;
                        try {
                            this.isValidPing({
                                topic: l
                            }), await this.sendResult({
                                id: p,
                                topic: l,
                                result: !0
                            }), this.client.events.emit("session_ping", {
                                id: p,
                                topic: l
                            })
                        } catch (c) {
                            await this.sendError(p, l, c), this.client.logger.error(c)
                        }
                    }, this.onSessionPingResponse = (l, c) => {
                        let {
                            id: p
                        } = c;
                        setTimeout(() => {
                            isJsonRpcResult(c) ? this.events.emit(ft("session_ping", p), {}) : isJsonRpcError(c) && this.events.emit(ft("session_ping", p), {
                                error: c.error
                            })
                        }, 500)
                    }, this.onSessionDeleteRequest = async (l, c) => {
                        let {
                            id: p
                        } = c;
                        try {
                            this.isValidDisconnect({
                                topic: l,
                                reason: c.params
                            }), await Promise.all([new Promise(c => {
                                this.client.core.relayer.once(r$.publish, async () => {
                                    c(await this.deleteSession(l))
                                })
                            }), this.sendResult({
                                id: p,
                                topic: l,
                                result: !0
                            })]), this.client.events.emit("session_delete", {
                                id: p,
                                topic: l
                            })
                        } catch (l) {
                            this.client.logger.error(l)
                        }
                    }, this.onSessionRequest = async (l, c) => {
                        let {
                            id: p,
                            params: v
                        } = c;
                        try {
                            this.isValidRequest(dist_index_es_g({
                                topic: l
                            }, v));
                            let c = Mn(JSON.stringify(formatJsonRpcRequest("wc_sessionRequest", v, p))),
                                _ = this.client.session.get(l),
                                C = await this.getVerifyContext(c, _.peer.metadata),
                                P = {
                                    id: p,
                                    topic: l,
                                    params: v,
                                    verifyContext: C
                                };
                            await this.setPendingSessionRequest(P), this.addSessionRequestToSessionRequestQueue(P), this.processSessionRequestQueue()
                        } catch (c) {
                            await this.sendError(p, l, c), this.client.logger.error(c)
                        }
                    }, this.onSessionRequestResponse = (l, c) => {
                        let {
                            id: p
                        } = c;
                        isJsonRpcResult(c) ? this.events.emit(ft("session_request", p), {
                            result: c.result
                        }) : isJsonRpcError(c) && this.events.emit(ft("session_request", p), {
                            error: c.error
                        })
                    }, this.onSessionEventRequest = async (l, c) => {
                        let {
                            id: p,
                            params: v
                        } = c;
                        try {
                            let c = `${l}_session_event_${v.event.name}`,
                                _ = er.get(c);
                            if (_ && this.isRequestOutOfSync(_, p)) {
                                this.client.logger.info(`Discarding out of sync request - ${p}`);
                                return
                            }
                            this.isValidEmit(dist_index_es_g({
                                topic: l
                            }, v)), this.client.events.emit("session_event", {
                                id: p,
                                topic: l,
                                params: v
                            }), er.set(c, p)
                        } catch (c) {
                            await this.sendError(p, l, c), this.client.logger.error(c)
                        }
                    }, this.addSessionRequestToSessionRequestQueue = l => {
                        this.sessionRequestQueue.queue.push(l)
                    }, this.cleanupAfterResponse = l => {
                        this.deletePendingSessionRequest(l.response.id, {
                            message: "fulfilled",
                            code: 0
                        }), setTimeout(() => {
                            this.sessionRequestQueue.state = nI.idle, this.processSessionRequestQueue()
                        }, (0, tp.toMiliseconds)(this.requestQueueDelay))
                    }, this.processSessionRequestQueue = () => {
                        if (this.sessionRequestQueue.state === nI.active) {
                            this.client.logger.info("session request queue is already active.");
                            return
                        }
                        let l = this.sessionRequestQueue.queue[0];
                        if (!l) {
                            this.client.logger.info("session request queue is empty.");
                            return
                        }
                        try {
                            this.sessionRequestQueue.state = nI.active, this.client.events.emit("session_request", l)
                        } catch (l) {
                            this.client.logger.error(l)
                        }
                    }, this.onPairingCreated = l => {
                        if (l.active) return;
                        let c = this.client.proposal.getAll().find(c => c.pairingTopic === l.topic);
                        c && this.onSessionProposeRequest(l.topic, formatJsonRpcRequest("wc_sessionPropose", {
                            requiredNamespaces: c.requiredNamespaces,
                            optionalNamespaces: c.optionalNamespaces,
                            relays: c.relays,
                            proposer: c.proposer
                        }, c.id))
                    }, this.isValidConnect = async l => {
                        let c;
                        if (!xt(l)) {
                            let {
                                message: c
                            } = N("MISSING_OR_INVALID", `connect() params: ${JSON.stringify(l)}`);
                            throw Error(c)
                        }
                        let {
                            pairingTopic: p,
                            requiredNamespaces: v,
                            optionalNamespaces: _,
                            sessionProperties: C,
                            relays: P
                        } = l;
                        if (w(p) || await this.isValidPairingTopic(p), c = !1, P ? P && D(P) && P.length && P.forEach(l => {
                                c = an(l)
                            }) : c = !0, !c) {
                            let {
                                message: l
                            } = N("MISSING_OR_INVALID", `connect() relays: ${P}`);
                            throw Error(l)
                        }
                        w(v) || 0 === B(v) || this.validateNamespaces(v, "requiredNamespaces"), w(_) || 0 === B(_) || this.validateNamespaces(_, "optionalNamespaces"), w(C) || this.validateSessionProps(C, "sessionProperties")
                    }, this.validateNamespaces = (l, c) => {
                        let p = function(l, c, p) {
                            let v = null;
                            if (l && B(l)) {
                                let _;
                                let C = ce(l, c);
                                C && (v = C);
                                let P = (_ = null, Object.entries(l).forEach(([l, v]) => {
                                    var C, P;
                                    let T;
                                    if (_) return;
                                    let M = (C = K(l, v), P = `${c} ${p}`, T = null, D(C) && C.length ? C.forEach(l => {
                                        T || k(l) || (T = U("UNSUPPORTED_CHAINS", `${P}, chain ${l} should be a string and conform to "namespace:chainId" format`))
                                    }) : k(l) || (T = U("UNSUPPORTED_CHAINS", `${P}, chains must be defined as "namespace:chainId" e.g. "eip155:1": {...} in the namespace key OR as an array of CAIP-2 chainIds e.g. eip155: { chains: ["eip155:1", "eip155:5"] }`)), T);
                                    M && (_ = M)
                                }), _);
                                P && (v = P)
                            } else v = N("MISSING_OR_INVALID", `${c}, ${p} should be an object with data`);
                            return v
                        }(l, "connect()", c);
                        if (p) throw Error(p.message)
                    }, this.isValidApprove = async l => {
                        if (!xt(l)) throw Error(N("MISSING_OR_INVALID", `approve() params: ${l}`).message);
                        let {
                            id: c,
                            namespaces: p,
                            relayProtocol: v,
                            sessionProperties: _
                        } = l;
                        await this.isValidProposalId(c);
                        let C = this.client.proposal.get(c),
                            P = cn(p, "approve()");
                        if (P) throw Error(P.message);
                        let T = un(C.requiredNamespaces, p, "approve()");
                        if (T) throw Error(T.message);
                        if (!h(v, !0)) {
                            let {
                                message: l
                            } = N("MISSING_OR_INVALID", `approve() relayProtocol: ${v}`);
                            throw Error(l)
                        }
                        w(_) || this.validateSessionProps(_, "sessionProperties")
                    }, this.isValidReject = async l => {
                        if (!xt(l)) {
                            let {
                                message: c
                            } = N("MISSING_OR_INVALID", `reject() params: ${l}`);
                            throw Error(c)
                        }
                        let {
                            id: c,
                            reason: p
                        } = l;
                        if (await this.isValidProposalId(c), !p || "object" != typeof p || !p.code || !G(p.code, !1) || !p.message || !h(p.message, !1)) {
                            let {
                                message: l
                            } = N("MISSING_OR_INVALID", `reject() reason: ${JSON.stringify(p)}`);
                            throw Error(l)
                        }
                    }, this.isValidSessionSettleRequest = l => {
                        let c;
                        if (!xt(l)) {
                            let {
                                message: c
                            } = N("MISSING_OR_INVALID", `onSessionSettleRequest() params: ${l}`);
                            throw Error(c)
                        }
                        let {
                            relay: p,
                            controller: v,
                            namespaces: _,
                            expiry: C
                        } = l;
                        if (!an(p)) {
                            let {
                                message: l
                            } = N("MISSING_OR_INVALID", "onSessionSettleRequest() relay protocol should be a string");
                            throw Error(l)
                        }
                        let P = (c = null, h(v ? .publicKey, !1) || (c = N("MISSING_OR_INVALID", "onSessionSettleRequest() controller public key should be a string")), c);
                        if (P) throw Error(P.message);
                        let T = cn(_, "onSessionSettleRequest()");
                        if (T) throw Error(T.message);
                        if (dt(C)) {
                            let {
                                message: l
                            } = N("EXPIRED", "onSessionSettleRequest()");
                            throw Error(l)
                        }
                    }, this.isValidUpdate = async l => {
                        if (!xt(l)) {
                            let {
                                message: c
                            } = N("MISSING_OR_INVALID", `update() params: ${l}`);
                            throw Error(c)
                        }
                        let {
                            topic: c,
                            namespaces: p
                        } = l;
                        await this.isValidSessionTopic(c);
                        let v = this.client.session.get(c),
                            _ = cn(p, "update()");
                        if (_) throw Error(_.message);
                        let C = un(v.requiredNamespaces, p, "update()");
                        if (C) throw Error(C.message)
                    }, this.isValidExtend = async l => {
                        if (!xt(l)) {
                            let {
                                message: c
                            } = N("MISSING_OR_INVALID", `extend() params: ${l}`);
                            throw Error(c)
                        }
                        let {
                            topic: c
                        } = l;
                        await this.isValidSessionTopic(c)
                    }, this.isValidRequest = async l => {
                        var c;
                        if (!xt(l)) {
                            let {
                                message: c
                            } = N("MISSING_OR_INVALID", `request() params: ${l}`);
                            throw Error(c)
                        }
                        let {
                            topic: p,
                            request: v,
                            chainId: _,
                            expiry: C
                        } = l;
                        await this.isValidSessionTopic(p);
                        let {
                            namespaces: P
                        } = this.client.session.get(p);
                        if (!Gt(P, _)) {
                            let {
                                message: l
                            } = N("MISSING_OR_INVALID", `request() chainId: ${_}`);
                            throw Error(l)
                        }
                        if (w(v) || !h(v.method, !1)) {
                            let {
                                message: l
                            } = N("MISSING_OR_INVALID", `request() ${JSON.stringify(v)}`);
                            throw Error(l)
                        }
                        if (!(h(c = v.method, !1) && (function(l, c) {
                                let p = [];
                                return Object.values(l).forEach(l => {
                                    A(l.accounts).includes(c) && p.push(...l.methods)
                                }), p
                            })(P, _).includes(c))) {
                            let {
                                message: l
                            } = N("MISSING_OR_INVALID", `request() method: ${v.method}`);
                            throw Error(l)
                        }
                        if (C && (!G(C, !1) || !(C <= nk.max) || !(C >= nk.min))) {
                            let {
                                message: l
                            } = N("MISSING_OR_INVALID", `request() expiry: ${C}. Expiry must be a number (in seconds) between ${nk.min} and ${nk.max}`);
                            throw Error(l)
                        }
                    }, this.isValidRespond = async l => {
                        if (!xt(l)) {
                            let {
                                message: c
                            } = N("MISSING_OR_INVALID", `respond() params: ${l}`);
                            throw Error(c)
                        }
                        let {
                            topic: c,
                            response: p
                        } = l;
                        if (await this.isValidSessionTopic(c), w(p) || w(p.result) && w(p.error) || !G(p.id, !1) || !h(p.jsonrpc, !1)) {
                            let {
                                message: l
                            } = N("MISSING_OR_INVALID", `respond() response: ${JSON.stringify(p)}`);
                            throw Error(l)
                        }
                    }, this.isValidPing = async l => {
                        if (!xt(l)) {
                            let {
                                message: c
                            } = N("MISSING_OR_INVALID", `ping() params: ${l}`);
                            throw Error(c)
                        }
                        let {
                            topic: c
                        } = l;
                        await this.isValidSessionOrPairingTopic(c)
                    }, this.isValidEmit = async l => {
                        var c;
                        if (!xt(l)) {
                            let {
                                message: c
                            } = N("MISSING_OR_INVALID", `emit() params: ${l}`);
                            throw Error(c)
                        }
                        let {
                            topic: p,
                            event: v,
                            chainId: _
                        } = l;
                        await this.isValidSessionTopic(p);
                        let {
                            namespaces: C
                        } = this.client.session.get(p);
                        if (!Gt(C, _)) {
                            let {
                                message: l
                            } = N("MISSING_OR_INVALID", `emit() chainId: ${_}`);
                            throw Error(l)
                        }
                        if (w(v) || !h(v.name, !1)) {
                            let {
                                message: l
                            } = N("MISSING_OR_INVALID", `emit() event: ${JSON.stringify(v)}`);
                            throw Error(l)
                        }
                        if (!(h(c = v.name, !1) && (function(l, c) {
                                let p = [];
                                return Object.values(l).forEach(l => {
                                    A(l.accounts).includes(c) && p.push(...l.events)
                                }), p
                            })(C, _).includes(c))) {
                            let {
                                message: l
                            } = N("MISSING_OR_INVALID", `emit() event: ${JSON.stringify(v)}`);
                            throw Error(l)
                        }
                    }, this.isValidDisconnect = async l => {
                        if (!xt(l)) {
                            let {
                                message: c
                            } = N("MISSING_OR_INVALID", `disconnect() params: ${l}`);
                            throw Error(c)
                        }
                        let {
                            topic: c
                        } = l;
                        await this.isValidSessionOrPairingTopic(c)
                    }, this.getVerifyContext = async (l, c) => {
                        let p = {
                            verified: {
                                verifyUrl: c.verifyUrl || r8,
                                validation: "UNKNOWN",
                                origin: c.url || ""
                            }
                        };
                        try {
                            let v = await this.client.core.verify.resolve({
                                attestationId: l,
                                verifyUrl: c.verifyUrl
                            });
                            v && (p.verified.origin = v.origin, p.verified.isScam = v.isScam, p.verified.validation = v.origin === new URL(c.url).origin ? "VALID" : "INVALID")
                        } catch (l) {
                            this.client.logger.info(l)
                        }
                        return this.client.logger.info(`Verify context: ${JSON.stringify(p)}`), p
                    }, this.validateSessionProps = (l, c) => {
                        Object.values(l).forEach(l => {
                            if (!h(l, !1)) {
                                let {
                                    message: p
                                } = N("MISSING_OR_INVALID", `${c} must be in Record<string, string> format. Received: ${JSON.stringify(l)}`);
                                throw Error(p)
                            }
                        })
                    }
                }
                async isInitialized() {
                    if (!this.initialized) {
                        let {
                            message: l
                        } = N("NOT_INITIALIZED", this.name);
                        throw Error(l)
                    }
                    await this.client.core.relayer.confirmOnlineStateOrThrow()
                }
                registerRelayerEvents() {
                    this.client.core.relayer.on(r$.message, async l => {
                        let {
                            topic: c,
                            message: p
                        } = l;
                        if (this.ignoredPayloadTypes.includes(this.client.core.crypto.getPayloadType(p))) return;
                        let v = await this.client.core.crypto.decode(c, p);
                        try {
                            isJsonRpcRequest(v) ? (this.client.core.history.set(c, v), this.onRelayEventRequest({
                                topic: c,
                                payload: v
                            })) : isJsonRpcResponse(v) ? (await this.client.core.history.resolve(v), await this.onRelayEventResponse({
                                topic: c,
                                payload: v
                            }), this.client.core.history.delete(c, v.id)) : this.onRelayEventUnknownPayload({
                                topic: c,
                                payload: v
                            })
                        } catch (l) {
                            this.client.logger.error(l)
                        }
                    })
                }
                registerExpirerEvents() {
                    this.client.core.expirer.on(r6.expired, async l => {
                        let {
                            topic: c,
                            id: p
                        } = ut(l.target);
                        if (p && this.client.pendingRequest.keys.includes(p)) return await this.deletePendingSessionRequest(p, N("EXPIRED"), !0);
                        c ? this.client.session.keys.includes(c) && (await this.deleteSession(c, !0), this.client.events.emit("session_expire", {
                            topic: c
                        })) : p && (await this.deleteProposal(p, !0), this.client.events.emit("proposal_expire", {
                            id: p
                        }))
                    })
                }
                registerPairingEvents() {
                    this.client.core.pairing.events.on(r5.create, l => this.onPairingCreated(l))
                }
                isValidPairingTopic(l) {
                    if (!h(l, !1)) {
                        let {
                            message: c
                        } = N("MISSING_OR_INVALID", `pairing topic should be a string: ${l}`);
                        throw Error(c)
                    }
                    if (!this.client.core.pairing.pairings.keys.includes(l)) {
                        let {
                            message: c
                        } = N("NO_MATCHING_KEY", `pairing topic doesn't exist: ${l}`);
                        throw Error(c)
                    }
                    if (dt(this.client.core.pairing.pairings.get(l).expiry)) {
                        let {
                            message: c
                        } = N("EXPIRED", `pairing topic: ${l}`);
                        throw Error(c)
                    }
                }
                async isValidSessionTopic(l) {
                    if (!h(l, !1)) {
                        let {
                            message: c
                        } = N("MISSING_OR_INVALID", `session topic should be a string: ${l}`);
                        throw Error(c)
                    }
                    if (!this.client.session.keys.includes(l)) {
                        let {
                            message: c
                        } = N("NO_MATCHING_KEY", `session topic doesn't exist: ${l}`);
                        throw Error(c)
                    }
                    if (dt(this.client.session.get(l).expiry)) {
                        await this.deleteSession(l);
                        let {
                            message: c
                        } = N("EXPIRED", `session topic: ${l}`);
                        throw Error(c)
                    }
                }
                async isValidSessionOrPairingTopic(l) {
                    if (this.client.session.keys.includes(l)) await this.isValidSessionTopic(l);
                    else if (this.client.core.pairing.pairings.keys.includes(l)) this.isValidPairingTopic(l);
                    else if (h(l, !1)) {
                        let {
                            message: c
                        } = N("NO_MATCHING_KEY", `session or pairing topic doesn't exist: ${l}`);
                        throw Error(c)
                    } else {
                        let {
                            message: c
                        } = N("MISSING_OR_INVALID", `session or pairing topic should be a string: ${l}`);
                        throw Error(c)
                    }
                }
                async isValidProposalId(l) {
                    if ("number" != typeof l) {
                        let {
                            message: c
                        } = N("MISSING_OR_INVALID", `proposal id should be a number: ${l}`);
                        throw Error(c)
                    }
                    if (!this.client.proposal.keys.includes(l)) {
                        let {
                            message: c
                        } = N("NO_MATCHING_KEY", `proposal id doesn't exist: ${l}`);
                        throw Error(c)
                    }
                    if (dt(this.client.proposal.get(l).expiry)) {
                        await this.deleteProposal(l);
                        let {
                            message: c
                        } = N("EXPIRED", `proposal id: ${l}`);
                        throw Error(c)
                    }
                }
            };
            let index_es_hs = class index_es_hs extends index_es_Ft {
                constructor(l, c) {
                    super(l, c, "proposal", nA), this.core = l, this.logger = c
                }
            };
            let index_es_ds = class index_es_ds extends index_es_Ft {
                constructor(l, c) {
                    super(l, c, "session", nA), this.core = l, this.logger = c
                }
            };
            let index_es_us = class index_es_us extends index_es_Ft {
                constructor(l, c) {
                    super(l, c, "request", nA, l => l.id), this.core = l, this.logger = c
                }
            };
            let dist_index_es_Q = class dist_index_es_Q extends b {
                constructor(l) {
                    super(l), this.protocol = "wc", this.version = 2, this.name = nC.name, this.events = new ef.EventEmitter, this.on = (l, c) => this.events.on(l, c), this.once = (l, c) => this.events.once(l, c), this.off = (l, c) => this.events.off(l, c), this.removeListener = (l, c) => this.events.removeListener(l, c), this.removeAllListeners = l => this.events.removeAllListeners(l), this.connect = async l => {
                        try {
                            return await this.engine.connect(l)
                        } catch (l) {
                            throw this.logger.error(l.message), l
                        }
                    }, this.pair = async l => {
                        try {
                            return await this.engine.pair(l)
                        } catch (l) {
                            throw this.logger.error(l.message), l
                        }
                    }, this.approve = async l => {
                        try {
                            return await this.engine.approve(l)
                        } catch (l) {
                            throw this.logger.error(l.message), l
                        }
                    }, this.reject = async l => {
                        try {
                            return await this.engine.reject(l)
                        } catch (l) {
                            throw this.logger.error(l.message), l
                        }
                    }, this.update = async l => {
                        try {
                            return await this.engine.update(l)
                        } catch (l) {
                            throw this.logger.error(l.message), l
                        }
                    }, this.extend = async l => {
                        try {
                            return await this.engine.extend(l)
                        } catch (l) {
                            throw this.logger.error(l.message), l
                        }
                    }, this.request = async l => {
                        try {
                            return await this.engine.request(l)
                        } catch (l) {
                            throw this.logger.error(l.message), l
                        }
                    }, this.respond = async l => {
                        try {
                            return await this.engine.respond(l)
                        } catch (l) {
                            throw this.logger.error(l.message), l
                        }
                    }, this.ping = async l => {
                        try {
                            return await this.engine.ping(l)
                        } catch (l) {
                            throw this.logger.error(l.message), l
                        }
                    }, this.emit = async l => {
                        try {
                            return await this.engine.emit(l)
                        } catch (l) {
                            throw this.logger.error(l.message), l
                        }
                    }, this.disconnect = async l => {
                        try {
                            return await this.engine.disconnect(l)
                        } catch (l) {
                            throw this.logger.error(l.message), l
                        }
                    }, this.find = l => {
                        try {
                            return this.engine.find(l)
                        } catch (l) {
                            throw this.logger.error(l.message), l
                        }
                    }, this.getPendingSessionRequests = () => {
                        try {
                            return this.engine.getPendingSessionRequests()
                        } catch (l) {
                            throw this.logger.error(l.message), l
                        }
                    }, this.name = l ? .name || nC.name, this.metadata = l ? .metadata || (0, tm.D)() || {
                        name: "",
                        description: "",
                        url: "",
                        icons: [""]
                    };
                    let c = "u" > typeof l ? .logger && "string" != typeof l ? .logger ? l.logger : (0, tB.pino)((0, tB.getDefaultLoggerOptions)({
                        level: l ? .logger || nC.logger
                    }));
                    this.core = l ? .core || new index_es_ee(l), this.logger = (0, tB.generateChildLogger)(c, this.name), this.session = new index_es_ds(this.core, this.logger), this.proposal = new index_es_hs(this.core, this.logger), this.pendingRequest = new index_es_us(this.core, this.logger), this.engine = new index_es_ps(this)
                }
                static async init(l) {
                    let c = new dist_index_es_Q(l);
                    return await c.initialize(), c
                }
                get context() {
                    return (0, tB.getLoggerContext)(this.logger)
                }
                get pairing() {
                    return this.core.pairing.pairings
                }
                async initialize() {
                    this.logger.trace("Initialized");
                    try {
                        await this.core.start(), await this.session.init(), await this.proposal.init(), await this.pendingRequest.init(), await this.engine.init(), this.core.verify.init({
                            verifyUrl: this.metadata.verifyUrl
                        }), this.logger.info("SignClient Initialization Success")
                    } catch (l) {
                        throw this.logger.info("SignClient Initialization Failure"), this.logger.error(l.message), l
                    }
                }
            };
            var nB = p(6862),
                nF = p.n(nB);
            let nH = {
                headers: {
                    Accept: "application/json",
                    "Content-Type": "application/json"
                },
                method: "POST"
            };
            let HttpConnection = class HttpConnection {
                constructor(l, c = !1) {
                    if (this.url = l, this.disableProviderPing = c, this.events = new ef.EventEmitter, this.isAvailable = !1, this.registering = !1, !isHttpUrl(l)) throw Error(`Provided URL is not compatible with HTTP connection: ${l}`);
                    this.url = l, this.disableProviderPing = c
                }
                get connected() {
                    return this.isAvailable
                }
                get connecting() {
                    return this.registering
                }
                on(l, c) {
                    this.events.on(l, c)
                }
                once(l, c) {
                    this.events.once(l, c)
                }
                off(l, c) {
                    this.events.off(l, c)
                }
                removeListener(l, c) {
                    this.events.removeListener(l, c)
                }
                async open(l = this.url) {
                    await this.register(l)
                }
                async close() {
                    if (!this.isAvailable) throw Error("Connection already closed");
                    this.onClose()
                }
                async send(l, c) {
                    this.isAvailable || await this.register();
                    try {
                        let c = safeJsonStringify(l),
                            p = await nF()(this.url, Object.assign(Object.assign({}, nH), {
                                body: c
                            })),
                            v = await p.json();
                        this.onPayload({
                            data: v
                        })
                    } catch (c) {
                        this.onError(l.id, c)
                    }
                }
                async register(l = this.url) {
                    if (!isHttpUrl(l)) throw Error(`Provided URL is not compatible with HTTP connection: ${l}`);
                    if (this.registering) {
                        let l = this.events.getMaxListeners();
                        return (this.events.listenerCount("register_error") >= l || this.events.listenerCount("open") >= l) && this.events.setMaxListeners(l + 1), new Promise((l, c) => {
                            this.events.once("register_error", l => {
                                this.resetMaxListeners(), c(l)
                            }), this.events.once("open", () => {
                                if (this.resetMaxListeners(), void 0 === this.isAvailable) return c(Error("HTTP connection is missing or invalid"));
                                l()
                            })
                        })
                    }
                    this.url = l, this.registering = !0;
                    try {
                        if (!this.disableProviderPing) {
                            let c = safeJsonStringify({
                                id: 1,
                                jsonrpc: "2.0",
                                method: "test",
                                params: []
                            });
                            await nF()(l, Object.assign(Object.assign({}, nH), {
                                body: c
                            }))
                        }
                        this.onOpen()
                    } catch (c) {
                        let l = this.parseError(c);
                        throw this.events.emit("register_error", l), this.onClose(), l
                    }
                }
                onOpen() {
                    this.isAvailable = !0, this.registering = !1, this.events.emit("open")
                }
                onClose() {
                    this.isAvailable = !1, this.registering = !1, this.events.emit("close")
                }
                onPayload(l) {
                    if (void 0 === l.data) return;
                    let c = "string" == typeof l.data ? esm_safeJsonParse(l.data) : l.data;
                    this.events.emit("payload", c)
                }
                onError(l, c) {
                    let p = this.parseError(c),
                        v = p.message || p.toString(),
                        _ = formatJsonRpcError(l, v);
                    this.events.emit("payload", _)
                }
                parseError(l, c = this.url) {
                    return parseConnectionError(l, c, "HTTP")
                }
                resetMaxListeners() {
                    this.events.getMaxListeners() > 10 && this.events.setMaxListeners(10)
                }
            };
            let nV = "error",
                nz = "wc@2:universal_provider:",
                nq = {
                    DEFAULT_CHAIN_CHANGED: "default_chain_changed"
                };
            var nW = "u" > typeof globalThis ? globalThis : "u" > typeof window ? window : "u" > typeof p.g ? p.g : "u" > typeof self ? self : {},
                nG = {
                    exports: {}
                };
            /**
             * @license
             * Lodash <https://lodash.com/>
             * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
             * Released under MIT license <https://lodash.com/license>
             * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
             * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
             */
            ! function(l, c) {
                (function() {
                    var p, v = "Expected a function",
                        _ = "__lodash_hash_undefined__",
                        C = "__lodash_placeholder__",
                        P = 1 / 0,
                        T = 0 / 0,
                        M = [
                            ["ary", 128],
                            ["bind", 1],
                            ["bindKey", 2],
                            ["curry", 8],
                            ["curryRight", 16],
                            ["flip", 512],
                            ["partial", 32],
                            ["partialRight", 64],
                            ["rearg", 256]
                        ],
                        z = "[object Arguments]",
                        J = "[object Array]",
                        Q = "[object Boolean]",
                        X = "[object Date]",
                        es = "[object Error]",
                        eo = "[object Function]",
                        el = "[object GeneratorFunction]",
                        ec = "[object Map]",
                        eh = "[object Number]",
                        ed = "[object Object]",
                        ef = "[object Promise]",
                        ep = "[object RegExp]",
                        eg = "[object Set]",
                        em = "[object String]",
                        ey = "[object Symbol]",
                        eb = "[object WeakMap]",
                        ew = "[object ArrayBuffer]",
                        ex = "[object DataView]",
                        e_ = "[object Float32Array]",
                        eE = "[object Float64Array]",
                        eA = "[object Int8Array]",
                        eC = "[object Int16Array]",
                        eS = "[object Int32Array]",
                        eN = "[object Uint8Array]",
                        eP = "[object Uint8ClampedArray]",
                        eD = "[object Uint16Array]",
                        ek = "[object Uint32Array]",
                        eI = /\b__p \+= '';/g,
                        eO = /\b(__p \+=) '' \+/g,
                        ej = /(__e\(.*?\)|\b__t\)) \+\n'';/g,
                        eT = /&(?:amp|lt|gt|quot|#39);/g,
                        eR = /[&<>"']/g,
                        eL = RegExp(eT.source),
                        eM = RegExp(eR.source),
                        eU = /<%-([\s\S]+?)%>/g,
                        eB = /<%([\s\S]+?)%>/g,
                        eF = /<%=([\s\S]+?)%>/g,
                        eH = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
                        eV = /^\w*$/,
                        ez = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,
                        eW = /[\\^$.*+?()[\]{}|]/g,
                        eG = RegExp(eW.source),
                        eK = /^\s+/,
                        eZ = /\s/,
                        eJ = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/,
                        eQ = /\{\n\/\* \[wrapped with (.+)\] \*/,
                        e$ = /,? & /,
                        eY = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g,
                        eX = /[()=,{}\[\]\/\s]/,
                        e0 = /\\(\\)?/g,
                        e1 = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g,
                        e2 = /\w*$/,
                        e5 = /^[-+]0x[0-9a-f]+$/i,
                        e3 = /^0b[01]+$/i,
                        e6 = /^\[object .+?Constructor\]$/,
                        e4 = /^0o[0-7]+$/i,
                        e8 = /^(?:0|[1-9]\d*)$/,
                        e9 = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g,
                        e7 = /($^)/,
                        tn = /['\n\r\u2028\u2029\\]/g,
                        ts = "\ud800-\udfff",
                        ta = "\\u0300-\\u036f\\ufe20-\\ufe2f\\u20d0-\\u20ff",
                        to = "\\u2700-\\u27bf",
                        tl = "a-z\\xdf-\\xf6\\xf8-\\xff",
                        tc = "A-Z\\xc0-\\xd6\\xd8-\\xde",
                        th = "\\ufe0e\\ufe0f",
                        td = "\\xac\\xb1\\xd7\\xf7\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf\\u2000-\\u206f \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000",
                        tf = "['’]",
                        tp = "[" + td + "]",
                        tg = "[" + ta + "]",
                        tm = "[" + tl + "]",
                        ty = "[^" + ts + td + "\\d+" + to + tl + tc + "]",
                        tb = "\ud83c[\udffb-\udfff]",
                        tw = "[^" + ts + "]",
                        tx = "(?:\ud83c[\udde6-\uddff]){2}",
                        t_ = "[\ud800-\udbff][\udc00-\udfff]",
                        tE = "[" + tc + "]",
                        tA = "\\u200d",
                        tC = "(?:" + tm + "|" + ty + ")",
                        tS = "(?:" + tf + "(?:d|ll|m|re|s|t|ve))?",
                        tN = "(?:" + tf + "(?:D|LL|M|RE|S|T|VE))?",
                        tP = "(?:" + tg + "|" + tb + ")?",
                        tD = "[" + th + "]?",
                        tk = "(?:" + tA + "(?:" + [tw, tx, t_].join("|") + ")" + tD + tP + ")*",
                        tI = tD + tP + tk,
                        tO = "(?:" + ["[" + to + "]", tx, t_].join("|") + ")" + tI,
                        tj = "(?:" + [tw + tg + "?", tg, tx, t_, "[" + ts + "]"].join("|") + ")",
                        tT = RegExp(tf, "g"),
                        tR = RegExp(tg, "g"),
                        tL = RegExp(tb + "(?=" + tb + ")|" + tj + tI, "g"),
                        tM = RegExp([tE + "?" + tm + "+" + tS + "(?=" + [tp, tE, "$"].join("|") + ")", "(?:" + tE + "|" + ty + ")+" + tN + "(?=" + [tp, tE + tC, "$"].join("|") + ")", tE + "?" + tC + "+" + tS, tE + "+" + tN, "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", "\\d+", tO].join("|"), "g"),
                        tU = RegExp("[" + tA + ts + ta + th + "]"),
                        tB = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/,
                        tF = ["Array", "Buffer", "DataView", "Date", "Error", "Float32Array", "Float64Array", "Function", "Int8Array", "Int16Array", "Int32Array", "Map", "Math", "Object", "Promise", "RegExp", "Set", "String", "Symbol", "TypeError", "Uint8Array", "Uint8ClampedArray", "Uint16Array", "Uint32Array", "WeakMap", "_", "clearTimeout", "isFinite", "parseInt", "setTimeout"],
                        tH = -1,
                        tV = {};
                    tV[e_] = tV[eE] = tV[eA] = tV[eC] = tV[eS] = tV[eN] = tV[eP] = tV[eD] = tV[ek] = !0, tV[z] = tV[J] = tV[ew] = tV[Q] = tV[ex] = tV[X] = tV[es] = tV[eo] = tV[ec] = tV[eh] = tV[ed] = tV[ep] = tV[eg] = tV[em] = tV[eb] = !1;
                    var tz = {};
                    tz[z] = tz[J] = tz[ew] = tz[ex] = tz[Q] = tz[X] = tz[e_] = tz[eE] = tz[eA] = tz[eC] = tz[eS] = tz[ec] = tz[eh] = tz[ed] = tz[ep] = tz[eg] = tz[em] = tz[ey] = tz[eN] = tz[eP] = tz[eD] = tz[ek] = !0, tz[es] = tz[eo] = tz[eb] = !1;
                    var tq = {
                            "\\": "\\",
                            "'": "'",
                            "\n": "n",
                            "\r": "r",
                            "\u2028": "u2028",
                            "\u2029": "u2029"
                        },
                        tW = parseFloat,
                        tG = parseInt,
                        tK = "object" == typeof nW && nW && nW.Object === Object && nW,
                        tZ = "object" == typeof self && self && self.Object === Object && self,
                        tJ = tK || tZ || Function("return this")(),
                        tQ = c && !c.nodeType && c,
                        t$ = tQ && l && !l.nodeType && l,
                        tY = t$ && t$.exports === tQ,
                        tX = tY && tK.process,
                        t0 = function() {
                            try {
                                return t$ && t$.require && t$.require("util").types || tX && tX.binding && tX.binding("util")
                            } catch {}
                        }(),
                        t1 = t0 && t0.isArrayBuffer,
                        t2 = t0 && t0.isDate,
                        t5 = t0 && t0.isMap,
                        t3 = t0 && t0.isRegExp,
                        t6 = t0 && t0.isSet,
                        t4 = t0 && t0.isTypedArray;

                    function cn(l, c, p) {
                        switch (p.length) {
                            case 0:
                                return l.call(c);
                            case 1:
                                return l.call(c, p[0]);
                            case 2:
                                return l.call(c, p[0], p[1]);
                            case 3:
                                return l.call(c, p[0], p[1], p[2])
                        }
                        return l.apply(c, p)
                    }

                    function Vo(l, c, p, v) {
                        for (var _ = -1, C = null == l ? 0 : l.length; ++_ < C;) {
                            var P = l[_];
                            c(v, P, p(P), l)
                        }
                        return v
                    }

                    function mn(l, c) {
                        for (var p = -1, v = null == l ? 0 : l.length; ++p < v && !1 !== c(l[p], p, l););
                        return l
                    }

                    function As(l, c) {
                        for (var p = -1, v = null == l ? 0 : l.length; ++p < v;)
                            if (!c(l[p], p, l)) return !1;
                        return !0
                    }

                    function jn(l, c) {
                        for (var p = -1, v = null == l ? 0 : l.length, _ = 0, C = []; ++p < v;) {
                            var P = l[p];
                            c(P, p, l) && (C[_++] = P)
                        }
                        return C
                    }

                    function Ee(l, c) {
                        return !!(null == l ? 0 : l.length) && Tt(l, c, 0) > -1
                    }

                    function Dr(l, c, p) {
                        for (var v = -1, _ = null == l ? 0 : l.length; ++v < _;)
                            if (p(c, l[v])) return !0;
                        return !1
                    }

                    function G(l, c) {
                        for (var p = -1, v = null == l ? 0 : l.length, _ = Array(v); ++p < v;) _[p] = c(l[p], p, l);
                        return _
                    }

                    function nt(l, c) {
                        for (var p = -1, v = c.length, _ = l.length; ++p < v;) l[_ + p] = c[p];
                        return l
                    }

                    function Hr(l, c, p, v) {
                        var _ = -1,
                            C = null == l ? 0 : l.length;
                        for (v && C && (p = l[++_]); ++_ < C;) p = c(p, l[_], _, l);
                        return p
                    }

                    function jo(l, c, p, v) {
                        var _ = null == l ? 0 : l.length;
                        for (v && _ && (p = l[--_]); _--;) p = c(p, l[_], _, l);
                        return p
                    }

                    function Nr(l, c) {
                        for (var p = -1, v = null == l ? 0 : l.length; ++p < v;)
                            if (c(l[p], p, l)) return !0;
                        return !1
                    }
                    var t8 = $r("length");

                    function Cs(l, c, p) {
                        var v;
                        return p(l, function(l, p, _) {
                            if (c(l, p, _)) return v = p, !1
                        }), v
                    }

                    function ye(l, c, p, v) {
                        for (var _ = l.length, C = p + (v ? 1 : -1); v ? C-- : ++C < _;)
                            if (c(l[C], C, l)) return C;
                        return -1
                    }

                    function Tt(l, c, p) {
                        return c == c ? function(l, c, p) {
                            for (var v = p - 1, _ = l.length; ++v < _;)
                                if (l[v] === c) return v;
                            return -1
                        }(l, c, p) : ye(l, Is, p)
                    }

                    function rf(l, c, p, v) {
                        for (var _ = p - 1, C = l.length; ++_ < C;)
                            if (v(l[_], c)) return _;
                        return -1
                    }

                    function Is(l) {
                        return l != l
                    }

                    function xs(l, c) {
                        var p = null == l ? 0 : l.length;
                        return p ? Wr(l, c) / p : T
                    }

                    function $r(l) {
                        return function(c) {
                            return null == c ? p : c[l]
                        }
                    }

                    function Ur(l) {
                        return function(c) {
                            return null == l ? p : l[c]
                        }
                    }

                    function Es(l, c, p, v, _) {
                        return _(l, function(l, _, C) {
                            p = v ? (v = !1, l) : c(p, l, _, C)
                        }), p
                    }

                    function Wr(l, c) {
                        for (var v, _ = -1, C = l.length; ++_ < C;) {
                            var P = c(l[_]);
                            P !== p && (v = v === p ? P : v + P)
                        }
                        return v
                    }

                    function Fr(l, c) {
                        for (var p = -1, v = Array(l); ++p < l;) v[p] = c(p);
                        return v
                    }

                    function ys(l) {
                        return l && l.slice(0, bs(l) + 1).replace(eK, "")
                    }

                    function hn(l) {
                        return function(c) {
                            return l(c)
                        }
                    }

                    function Mr(l, c) {
                        return G(c, function(c) {
                            return l[c]
                        })
                    }

                    function jt(l, c) {
                        return l.has(c)
                    }

                    function Ss(l, c) {
                        for (var p = -1, v = l.length; ++p < v && Tt(c, l[p], 0) > -1;);
                        return p
                    }

                    function Os(l, c) {
                        for (var p = l.length; p-- && Tt(c, l[p], 0) > -1;);
                        return p
                    }
                    var t9 = Ur({
                            À: "A",
                            Á: "A",
                            Â: "A",
                            Ã: "A",
                            Ä: "A",
                            Å: "A",
                            à: "a",
                            á: "a",
                            â: "a",
                            ã: "a",
                            ä: "a",
                            å: "a",
                            Ç: "C",
                            ç: "c",
                            Ð: "D",
                            ð: "d",
                            È: "E",
                            É: "E",
                            Ê: "E",
                            Ë: "E",
                            è: "e",
                            é: "e",
                            ê: "e",
                            ë: "e",
                            Ì: "I",
                            Í: "I",
                            Î: "I",
                            Ï: "I",
                            ì: "i",
                            í: "i",
                            î: "i",
                            ï: "i",
                            Ñ: "N",
                            ñ: "n",
                            Ò: "O",
                            Ó: "O",
                            Ô: "O",
                            Õ: "O",
                            Ö: "O",
                            Ø: "O",
                            ò: "o",
                            ó: "o",
                            ô: "o",
                            õ: "o",
                            ö: "o",
                            ø: "o",
                            Ù: "U",
                            Ú: "U",
                            Û: "U",
                            Ü: "U",
                            ù: "u",
                            ú: "u",
                            û: "u",
                            ü: "u",
                            Ý: "Y",
                            ý: "y",
                            ÿ: "y",
                            Æ: "Ae",
                            æ: "ae",
                            Þ: "Th",
                            þ: "th",
                            ß: "ss",
                            Ā: "A",
                            Ă: "A",
                            Ą: "A",
                            ā: "a",
                            ă: "a",
                            ą: "a",
                            Ć: "C",
                            Ĉ: "C",
                            Ċ: "C",
                            Č: "C",
                            ć: "c",
                            ĉ: "c",
                            ċ: "c",
                            č: "c",
                            Ď: "D",
                            Đ: "D",
                            ď: "d",
                            đ: "d",
                            Ē: "E",
                            Ĕ: "E",
                            Ė: "E",
                            Ę: "E",
                            Ě: "E",
                            ē: "e",
                            ĕ: "e",
                            ė: "e",
                            ę: "e",
                            ě: "e",
                            Ĝ: "G",
                            Ğ: "G",
                            Ġ: "G",
                            Ģ: "G",
                            ĝ: "g",
                            ğ: "g",
                            ġ: "g",
                            ģ: "g",
                            Ĥ: "H",
                            Ħ: "H",
                            ĥ: "h",
                            ħ: "h",
                            Ĩ: "I",
                            Ī: "I",
                            Ĭ: "I",
                            Į: "I",
                            İ: "I",
                            ĩ: "i",
                            ī: "i",
                            ĭ: "i",
                            į: "i",
                            ı: "i",
                            Ĵ: "J",
                            ĵ: "j",
                            Ķ: "K",
                            ķ: "k",
                            ĸ: "k",
                            Ĺ: "L",
                            Ļ: "L",
                            Ľ: "L",
                            Ŀ: "L",
                            Ł: "L",
                            ĺ: "l",
                            ļ: "l",
                            ľ: "l",
                            ŀ: "l",
                            ł: "l",
                            Ń: "N",
                            Ņ: "N",
                            Ň: "N",
                            Ŋ: "N",
                            ń: "n",
                            ņ: "n",
                            ň: "n",
                            ŋ: "n",
                            Ō: "O",
                            Ŏ: "O",
                            Ő: "O",
                            ō: "o",
                            ŏ: "o",
                            ő: "o",
                            Ŕ: "R",
                            Ŗ: "R",
                            Ř: "R",
                            ŕ: "r",
                            ŗ: "r",
                            ř: "r",
                            Ś: "S",
                            Ŝ: "S",
                            Ş: "S",
                            Š: "S",
                            ś: "s",
                            ŝ: "s",
                            ş: "s",
                            š: "s",
                            Ţ: "T",
                            Ť: "T",
                            Ŧ: "T",
                            ţ: "t",
                            ť: "t",
                            ŧ: "t",
                            Ũ: "U",
                            Ū: "U",
                            Ŭ: "U",
                            Ů: "U",
                            Ű: "U",
                            Ų: "U",
                            ũ: "u",
                            ū: "u",
                            ŭ: "u",
                            ů: "u",
                            ű: "u",
                            ų: "u",
                            Ŵ: "W",
                            ŵ: "w",
                            Ŷ: "Y",
                            ŷ: "y",
                            Ÿ: "Y",
                            Ź: "Z",
                            Ż: "Z",
                            Ž: "Z",
                            ź: "z",
                            ż: "z",
                            ž: "z",
                            Ĳ: "IJ",
                            ĳ: "ij",
                            Œ: "Oe",
                            œ: "oe",
                            ŉ: "'n",
                            ſ: "s"
                        }),
                        t7 = Ur({
                            "&": "&amp;",
                            "<": "&lt;",
                            ">": "&gt;",
                            '"': "&quot;",
                            "'": "&#39;"
                        });

                    function cf(l) {
                        return "\\" + tq[l]
                    }

                    function Lt(l) {
                        return tU.test(l)
                    }

                    function qr(l) {
                        var c = -1,
                            p = Array(l.size);
                        return l.forEach(function(l, v) {
                            p[++c] = [v, l]
                        }), p
                    }

                    function Rs(l, c) {
                        return function(p) {
                            return l(c(p))
                        }
                    }

                    function tt(l, c) {
                        for (var p = -1, v = l.length, _ = 0, P = []; ++p < v;) {
                            var T = l[p];
                            (T === c || T === C) && (l[p] = C, P[_++] = p)
                        }
                        return P
                    }

                    function Se(l) {
                        var c = -1,
                            p = Array(l.size);
                        return l.forEach(function(l) {
                            p[++c] = l
                        }), p
                    }

                    function Dt(l) {
                        return Lt(l) ? function(l) {
                            for (var c = tL.lastIndex = 0; tL.test(l);) ++c;
                            return c
                        }(l) : t8(l)
                    }

                    function On(l) {
                        return Lt(l) ? l.match(tL) || [] : l.split("")
                    }

                    function bs(l) {
                        for (var c = l.length; c-- && eZ.test(l.charAt(c)););
                        return c
                    }
                    var rt = Ur({
                            "&amp;": "&",
                            "&lt;": "<",
                            "&gt;": ">",
                            "&quot;": '"',
                            "&#39;": "'"
                        }),
                        rs = function h(l) {
                            var c, eZ, ts, ta, to = (l = null == l ? tJ : rs.defaults(tJ.Object(), l, rs.pick(tJ, tF))).Array,
                                tl = l.Date,
                                tc = l.Error,
                                th = l.Function,
                                td = l.Math,
                                tf = l.Object,
                                tp = l.RegExp,
                                tg = l.String,
                                tm = l.TypeError,
                                ty = to.prototype,
                                tb = th.prototype,
                                tw = tf.prototype,
                                tx = l["__core-js_shared__"],
                                t_ = tb.toString,
                                tE = tw.hasOwnProperty,
                                tA = 0,
                                tC = (c = /[^.]+$/.exec(tx && tx.keys && tx.keys.IE_PROTO || "")) ? "Symbol(src)_1." + c : "",
                                tS = tw.toString,
                                tN = t_.call(tf),
                                tP = tJ._,
                                tD = tp("^" + t_.call(tE).replace(eW, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"),
                                tk = tY ? l.Buffer : p,
                                tI = l.Symbol,
                                tO = l.Uint8Array,
                                tj = tk ? tk.allocUnsafe : p,
                                tL = Rs(tf.getPrototypeOf, tf),
                                tU = tf.create,
                                tq = tw.propertyIsEnumerable,
                                tK = ty.splice,
                                tZ = tI ? tI.isConcatSpreadable : p,
                                tQ = tI ? tI.iterator : p,
                                t$ = tI ? tI.toStringTag : p,
                                tX = function() {
                                    try {
                                        var l = mt(tf, "defineProperty");
                                        return l({}, "", {}), l
                                    } catch {}
                                }(),
                                t0 = l.clearTimeout !== tJ.clearTimeout && l.clearTimeout,
                                t8 = tl && tl.now !== tJ.Date.now && tl.now,
                                ra = l.setTimeout !== tJ.setTimeout && l.setTimeout,
                                ro = td.ceil,
                                rl = td.floor,
                                rc = tf.getOwnPropertySymbols,
                                rh = tk ? tk.isBuffer : p,
                                rd = l.isFinite,
                                rp = ty.join,
                                rg = Rs(tf.keys, tf),
                                rm = td.max,
                                ry = td.min,
                                rb = tl.now,
                                rw = l.parseInt,
                                rx = td.random,
                                r_ = ty.reverse,
                                rE = mt(l, "DataView"),
                                rA = mt(l, "Map"),
                                rC = mt(l, "Promise"),
                                rS = mt(l, "Set"),
                                rN = mt(l, "WeakMap"),
                                rP = mt(tf, "create"),
                                rD = rN && new rN,
                                rk = {},
                                rI = wt(rE),
                                rO = wt(rA),
                                rj = wt(rC),
                                rT = wt(rS),
                                rR = wt(rN),
                                rL = tI ? tI.prototype : p,
                                rM = rL ? rL.valueOf : p,
                                rU = rL ? rL.toString : p;

                            function a(l) {
                                if (Y(l) && !nM(l) && !(l instanceof H)) {
                                    if (l instanceof Pn) return l;
                                    if (tE.call(l, "__wrapped__")) return Fu(l)
                                }
                                return new Pn(l)
                            }
                            var rB = function() {
                                function n() {}
                                return function(l) {
                                    if (!K(l)) return {};
                                    if (tU) return tU(l);
                                    n.prototype = l;
                                    var c = new n;
                                    return n.prototype = p, c
                                }
                            }();

                            function qe() {}

                            function Pn(l, c) {
                                this.__wrapped__ = l, this.__actions__ = [], this.__chain__ = !!c, this.__index__ = 0, this.__values__ = p
                            }

                            function H(l) {
                                this.__wrapped__ = l, this.__actions__ = [], this.__dir__ = 1, this.__filtered__ = !1, this.__iteratees__ = [], this.__takeCount__ = 4294967295, this.__views__ = []
                            }

                            function dt(l) {
                                var c = -1,
                                    p = null == l ? 0 : l.length;
                                for (this.clear(); ++c < p;) {
                                    var v = l[c];
                                    this.set(v[0], v[1])
                                }
                            }

                            function Bn(l) {
                                var c = -1,
                                    p = null == l ? 0 : l.length;
                                for (this.clear(); ++c < p;) {
                                    var v = l[c];
                                    this.set(v[0], v[1])
                                }
                            }

                            function Gn(l) {
                                var c = -1,
                                    p = null == l ? 0 : l.length;
                                for (this.clear(); ++c < p;) {
                                    var v = l[c];
                                    this.set(v[0], v[1])
                                }
                            }

                            function gt(l) {
                                var c = -1,
                                    p = null == l ? 0 : l.length;
                                for (this.__data__ = new Gn; ++c < p;) this.add(l[c])
                            }

                            function Rn(l) {
                                var c = this.__data__ = new Bn(l);
                                this.size = c.size
                            }

                            function Fs(l, c) {
                                var p = nM(l),
                                    v = !p && nL(l),
                                    _ = !p && !v && nB(l),
                                    C = !p && !v && !_ && nq(l),
                                    P = p || v || _ || C,
                                    T = P ? Fr(l.length, tg) : [],
                                    M = T.length;
                                for (var z in l)(c || tE.call(l, z)) && !(P && ("length" == z || _ && ("offset" == z || "parent" == z) || C && ("buffer" == z || "byteLength" == z || "byteOffset" == z) || Zn(z, M))) && T.push(z);
                                return T
                            }

                            function Ms(l) {
                                var c = l.length;
                                return c ? l[ei(0, c - 1)] : p
                            }

                            function Yr(l, c, v) {
                                (v === p || bn(l[c], v)) && (v !== p || c in l) || zn(l, c, v)
                            }

                            function se(l, c, v) {
                                var _ = l[c];
                                tE.call(l, c) && bn(_, v) && (v !== p || c in l) || zn(l, c, v)
                            }

                            function Be(l, c) {
                                for (var p = l.length; p--;)
                                    if (bn(l[p][0], c)) return p;
                                return -1
                            }

                            function gc(l, c, p, v) {
                                return rF(l, function(l, _, C) {
                                    c(v, l, p(l), C)
                                }), v
                            }

                            function qs(l, c) {
                                return l && Un(c, V(c), l)
                            }

                            function zn(l, c, p) {
                                "__proto__" == c && tX ? tX(l, c, {
                                    configurable: !0,
                                    enumerable: !0,
                                    value: p,
                                    writable: !0
                                }) : l[c] = p
                            }

                            function Zr(l, c) {
                                for (var v = -1, _ = c.length, C = to(_), P = null == l; ++v < _;) C[v] = P ? p : Si(l, c[v]);
                                return C
                            }

                            function vt(l, c, v) {
                                return l == l && (v !== p && (l = l <= v ? l : v), c !== p && (l = l >= c ? l : c)), l
                            }

                            function An(l, c, v, _, C, P) {
                                var T, M = 1 & c,
                                    J = 2 & c,
                                    es = 4 & c;
                                if (v && (T = C ? v(l, _, C, P) : v(l)), T !== p) return T;
                                if (!K(l)) return l;
                                var ef = nM(l);
                                if (ef) {
                                    if (eb = l.length, eI = new l.constructor(eb), eb && "string" == typeof l[0] && tE.call(l, "index") && (eI.index = l.index, eI.input = l.input), T = eI, !M) return un(l, T)
                                } else {
                                    var eb, eI, eO, ej, eT, eR = r$(l),
                                        eL = eR == eo || eR == el;
                                    if (nB(l)) return hu(l, M);
                                    if (eR == ed || eR == z || eL && !C) {
                                        if (T = J || eL ? {} : bu(l), !M) return J ? (eO = (eT = T) && Un(l, on(l), eT), Un(l, rQ(l), eO)) : (ej = qs(T, l), Un(l, rJ(l), ej))
                                    } else {
                                        if (!tz[eR]) return C ? l : {};
                                        T = function(l, c, p) {
                                            var v, _, C = l.constructor;
                                            switch (c) {
                                                case ew:
                                                    return fi(l);
                                                case Q:
                                                case X:
                                                    return new C(+l);
                                                case ex:
                                                    return v = p ? fi(l.buffer) : l.buffer, new l.constructor(v, l.byteOffset, l.byteLength);
                                                case e_:
                                                case eE:
                                                case eA:
                                                case eC:
                                                case eS:
                                                case eN:
                                                case eP:
                                                case eD:
                                                case ek:
                                                    return lu(l, p);
                                                case ec:
                                                    return new C;
                                                case eh:
                                                case em:
                                                    return new C(l);
                                                case ep:
                                                    return (_ = new l.constructor(l.source, e2.exec(l))).lastIndex = l.lastIndex, _;
                                                case eg:
                                                    return new C;
                                                case ey:
                                                    return rM ? tf(rM.call(l)) : {}
                                            }
                                        }(l, eR, M)
                                    }
                                }
                                P || (P = new Rn);
                                var eM = P.get(l);
                                if (eM) return eM;
                                P.set(l, T), nz(l) ? l.forEach(function(p) {
                                    T.add(An(p, c, v, p, l, P))
                                }) : nH(l) && l.forEach(function(p, _) {
                                    T.set(_, An(p, c, v, _, l, P))
                                });
                                var eU = es ? J ? pi : li : J ? on : V,
                                    eB = ef ? p : eU(l);
                                return mn(eB || l, function(p, _) {
                                    eB && (p = l[_ = p]), se(T, _, An(p, c, v, _, l, P))
                                }), T
                            }

                            function Bs(l, c, v) {
                                var _ = v.length;
                                if (null == l) return !_;
                                for (l = tf(l); _--;) {
                                    var C = v[_],
                                        P = c[C],
                                        T = l[C];
                                    if (T === p && !(C in l) || !P(T)) return !1
                                }
                                return !0
                            }

                            function Gs(l, c, _) {
                                if ("function" != typeof l) throw new tm(v);
                                return r0(function() {
                                    l.apply(p, _)
                                }, c)
                            }

                            function ue(l, c, p, v) {
                                var _ = -1,
                                    C = Ee,
                                    P = !0,
                                    T = l.length,
                                    M = [],
                                    z = c.length;
                                if (!T) return M;
                                p && (c = G(c, hn(p))), v ? (C = Dr, P = !1) : c.length >= 200 && (C = jt, P = !1, c = new gt(c));
                                e: for (; ++_ < T;) {
                                    var J = l[_],
                                        Q = null == p ? J : p(J);
                                    if (J = v || 0 !== J ? J : 0, P && Q == Q) {
                                        for (var X = z; X--;)
                                            if (c[X] === Q) continue e;
                                        M.push(J)
                                    } else C(c, Q, v) || M.push(J)
                                }
                                return M
                            }
                            a.templateSettings = {
                                escape: eU,
                                evaluate: eB,
                                interpolate: eF,
                                variable: "",
                                imports: {
                                    _: a
                                }
                            }, a.prototype = qe.prototype, a.prototype.constructor = a, Pn.prototype = rB(qe.prototype), Pn.prototype.constructor = Pn, H.prototype = rB(qe.prototype), H.prototype.constructor = H, dt.prototype.clear = function() {
                                this.__data__ = rP ? rP(null) : {}, this.size = 0
                            }, dt.prototype.delete = function(l) {
                                var c = this.has(l) && delete this.__data__[l];
                                return this.size -= c ? 1 : 0, c
                            }, dt.prototype.get = function(l) {
                                var c = this.__data__;
                                if (rP) {
                                    var v = c[l];
                                    return v === _ ? p : v
                                }
                                return tE.call(c, l) ? c[l] : p
                            }, dt.prototype.has = function(l) {
                                var c = this.__data__;
                                return rP ? c[l] !== p : tE.call(c, l)
                            }, dt.prototype.set = function(l, c) {
                                var v = this.__data__;
                                return this.size += this.has(l) ? 0 : 1, v[l] = rP && c === p ? _ : c, this
                            }, Bn.prototype.clear = function() {
                                this.__data__ = [], this.size = 0
                            }, Bn.prototype.delete = function(l) {
                                var c = this.__data__,
                                    p = Be(c, l);
                                return !(p < 0) && (p == c.length - 1 ? c.pop() : tK.call(c, p, 1), --this.size, !0)
                            }, Bn.prototype.get = function(l) {
                                var c = this.__data__,
                                    v = Be(c, l);
                                return v < 0 ? p : c[v][1]
                            }, Bn.prototype.has = function(l) {
                                return Be(this.__data__, l) > -1
                            }, Bn.prototype.set = function(l, c) {
                                var p = this.__data__,
                                    v = Be(p, l);
                                return v < 0 ? (++this.size, p.push([l, c])) : p[v][1] = c, this
                            }, Gn.prototype.clear = function() {
                                this.size = 0, this.__data__ = {
                                    hash: new dt,
                                    map: new(rA || Bn),
                                    string: new dt
                                }
                            }, Gn.prototype.delete = function(l) {
                                var c = nr(this, l).delete(l);
                                return this.size -= c ? 1 : 0, c
                            }, Gn.prototype.get = function(l) {
                                return nr(this, l).get(l)
                            }, Gn.prototype.has = function(l) {
                                return nr(this, l).has(l)
                            }, Gn.prototype.set = function(l, c) {
                                var p = nr(this, l),
                                    v = p.size;
                                return p.set(l, c), this.size += p.size == v ? 0 : 1, this
                            }, gt.prototype.add = gt.prototype.push = function(l) {
                                return this.__data__.set(l, _), this
                            }, gt.prototype.has = function(l) {
                                return this.__data__.has(l)
                            }, Rn.prototype.clear = function() {
                                this.__data__ = new Bn, this.size = 0
                            }, Rn.prototype.delete = function(l) {
                                var c = this.__data__,
                                    p = c.delete(l);
                                return this.size = c.size, p
                            }, Rn.prototype.get = function(l) {
                                return this.__data__.get(l)
                            }, Rn.prototype.has = function(l) {
                                return this.__data__.has(l)
                            }, Rn.prototype.set = function(l, c) {
                                var p = this.__data__;
                                if (p instanceof Bn) {
                                    var v = p.__data__;
                                    if (!rA || v.length < 199) return v.push([l, c]), this.size = ++p.size, this;
                                    p = this.__data__ = new Gn(v)
                                }
                                return p.set(l, c), this.size = p.size, this
                            };
                            var rF = vu($n),
                                rH = vu(Xr, !0);

                            function mc(l, c) {
                                var p = !0;
                                return rF(l, function(l, v, _) {
                                    return p = !!c(l, v, _)
                                }), p
                            }

                            function Ge(l, c, v) {
                                for (var _ = -1, C = l.length; ++_ < C;) {
                                    var P = l[_],
                                        T = c(P);
                                    if (null != T && (M === p ? T == T && !pn(T) : v(T, M))) var M = T,
                                        z = P
                                }
                                return z
                            }

                            function Ks(l, c) {
                                var p = [];
                                return rF(l, function(l, v, _) {
                                    c(l, v, _) && p.push(l)
                                }), p
                            }

                            function j(l, c, p, v, _) {
                                var C = -1,
                                    P = l.length;
                                for (p || (p = ah), _ || (_ = []); ++C < P;) {
                                    var T = l[C];
                                    c > 0 && p(T) ? c > 1 ? j(T, c - 1, p, v, _) : nt(_, T) : v || (_[_.length] = T)
                                }
                                return _
                            }
                            var rV = _u(),
                                rz = _u(!0);

                            function $n(l, c) {
                                return l && rV(l, c, V)
                            }

                            function Xr(l, c) {
                                return l && rz(l, c, V)
                            }

                            function ze(l, c) {
                                return jn(c, function(c) {
                                    return Jn(l[c])
                                })
                            }

                            function _t(l, c) {
                                c = st(c, l);
                                for (var v = 0, _ = c.length; null != l && v < _;) l = l[Wn(c[v++])];
                                return v && v == _ ? l : p
                            }

                            function Zs(l, c, p) {
                                var v = c(l);
                                return nM(l) ? v : nt(v, p(l))
                            }

                            function en(l) {
                                return null == l ? l === p ? "[object Undefined]" : "[object Null]" : t$ && t$ in tf(l) ? function(l) {
                                    var c = tE.call(l, t$),
                                        v = l[t$];
                                    try {
                                        l[t$] = p;
                                        var _ = !0
                                    } catch {}
                                    var C = tS.call(l);
                                    return _ && (c ? l[t$] = v : delete l[t$]), C
                                }(l) : tS.call(l)
                            }

                            function Qr(l, c) {
                                return l > c
                            }

                            function Pc(l, c) {
                                return null != l && tE.call(l, c)
                            }

                            function Ac(l, c) {
                                return null != l && c in tf(l)
                            }

                            function Vr(l, c, v) {
                                for (var _ = v ? Dr : Ee, C = l[0].length, P = l.length, T = P, M = to(P), z = 1 / 0, J = []; T--;) {
                                    var Q = l[T];
                                    T && c && (Q = G(Q, hn(c))), z = ry(Q.length, z), M[T] = !v && (c || C >= 120 && Q.length >= 120) ? new gt(T && Q) : p
                                }
                                Q = l[0];
                                var X = -1,
                                    es = M[0];
                                e: for (; ++X < C && J.length < z;) {
                                    var eo = Q[X],
                                        el = c ? c(eo) : eo;
                                    if (eo = v || 0 !== eo ? eo : 0, !(es ? jt(es, el) : _(J, el, v))) {
                                        for (T = P; --T;) {
                                            var ec = M[T];
                                            if (!(ec ? jt(ec, el) : _(l[T], el, v))) continue e
                                        }
                                        es && es.push(el), J.push(eo)
                                    }
                                }
                                return J
                            }

                            function ae(l, c, v) {
                                c = st(c, l);
                                var _ = null == (l = Hu(l, c)) ? l : l[Wn(In(c))];
                                return null == _ ? p : cn(_, l, v)
                            }

                            function Js(l) {
                                return Y(l) && en(l) == z
                            }

                            function oe(l, c, v, _, C) {
                                return l === c || (null != l && null != c && (Y(l) || Y(c)) ? function(l, c, v, _, C, P) {
                                    var T = nM(l),
                                        M = nM(c),
                                        eo = T ? J : r$(l),
                                        el = M ? J : r$(c);
                                    eo = eo == z ? ed : eo, el = el == z ? ed : el;
                                    var ef = eo == ed,
                                        eb = el == ed,
                                        e_ = eo == el;
                                    if (e_ && nB(l)) {
                                        if (!nB(c)) return !1;
                                        T = !0, ef = !1
                                    }
                                    if (e_ && !ef) return P || (P = new Rn), T || nq(l) ? Su(l, c, v, _, C, P) : function(l, c, p, v, _, C, P) {
                                        switch (p) {
                                            case ex:
                                                if (l.byteLength != c.byteLength || l.byteOffset != c.byteOffset) break;
                                                l = l.buffer, c = c.buffer;
                                            case ew:
                                                return !(l.byteLength != c.byteLength || !C(new tO(l), new tO(c)));
                                            case Q:
                                            case X:
                                            case eh:
                                                return bn(+l, +c);
                                            case es:
                                                return l.name == c.name && l.message == c.message;
                                            case ep:
                                            case em:
                                                return l == c + "";
                                            case ec:
                                                var T = qr;
                                            case eg:
                                                var M = 1 & v;
                                                if (T || (T = Se), l.size != c.size && !M) break;
                                                var z = P.get(l);
                                                if (z) return z == c;
                                                v |= 2, P.set(l, c);
                                                var J = Su(T(l), T(c), v, _, C, P);
                                                return P.delete(l), J;
                                            case ey:
                                                if (rM) return rM.call(l) == rM.call(c)
                                        }
                                        return !1
                                    }(l, c, eo, v, _, C, P);
                                    if (!(1 & v)) {
                                        var eE = ef && tE.call(l, "__wrapped__"),
                                            eA = eb && tE.call(c, "__wrapped__");
                                        if (eE || eA) {
                                            var eC = eE ? l.value() : l,
                                                eS = eA ? c.value() : c;
                                            return P || (P = new Rn), C(eC, eS, v, _, P)
                                        }
                                    }
                                    return !!e_ && (P || (P = new Rn), function(l, c, v, _, C, P) {
                                        var T = 1 & v,
                                            M = li(l),
                                            z = M.length;
                                        if (z != li(c).length && !T) return !1;
                                        for (var J = z; J--;) {
                                            var Q = M[J];
                                            if (!(T ? Q in c : tE.call(c, Q))) return !1
                                        }
                                        var X = P.get(l),
                                            es = P.get(c);
                                        if (X && es) return X == c && es == l;
                                        var eo = !0;
                                        P.set(l, c), P.set(c, l);
                                        for (var el = T; ++J < z;) {
                                            var ec = l[Q = M[J]],
                                                eh = c[Q];
                                            if (_) var ed = T ? _(eh, ec, Q, c, l, P) : _(ec, eh, Q, l, c, P);
                                            if (!(ed === p ? ec === eh || C(ec, eh, v, _, P) : ed)) {
                                                eo = !1;
                                                break
                                            }
                                            el || (el = "constructor" == Q)
                                        }
                                        if (eo && !el) {
                                            var ef = l.constructor,
                                                ep = c.constructor;
                                            ef != ep && "constructor" in l && "constructor" in c && !("function" == typeof ef && ef instanceof ef && "function" == typeof ep && ep instanceof ep) && (eo = !1)
                                        }
                                        return P.delete(l), P.delete(c), eo
                                    }(l, c, v, _, C, P))
                                }(l, c, v, _, oe, C) : l != l && c != c)
                            }

                            function kr(l, c, v, _) {
                                var C = v.length,
                                    P = C,
                                    T = !_;
                                if (null == l) return !P;
                                for (l = tf(l); C--;) {
                                    var M = v[C];
                                    if (T && M[2] ? M[1] !== l[M[0]] : !(M[0] in l)) return !1
                                }
                                for (; ++C < P;) {
                                    var z = (M = v[C])[0],
                                        J = l[z],
                                        Q = M[1];
                                    if (T && M[2]) {
                                        if (J === p && !(z in l)) return !1
                                    } else {
                                        var X = new Rn;
                                        if (_) var es = _(J, Q, z, l, c, X);
                                        if (!(es === p ? oe(Q, J, 3, _, X) : es)) return !1
                                    }
                                }
                                return !0
                            }

                            function Xs(l) {
                                return !(!K(l) || tC && tC in l) && (Jn(l) ? tD : e6).test(wt(l))
                            }

                            function Qs(l) {
                                return "function" == typeof l ? l : null == l ? fn : "object" == typeof l ? nM(l) ? js(l[0], l[1]) : ks(l) : ma(l)
                            }

                            function jr(l) {
                                if (!he(l)) return rg(l);
                                var c = [];
                                for (var p in tf(l)) tE.call(l, p) && "constructor" != p && c.push(p);
                                return c
                            }

                            function ni(l, c) {
                                return l < c
                            }

                            function Vs(l, c) {
                                var p = -1,
                                    v = an(l) ? to(l.length) : [];
                                return rF(l, function(l, _, C) {
                                    v[++p] = c(l, _, C)
                                }), v
                            }

                            function ks(l) {
                                var c = gi(l);
                                return 1 == c.length && c[0][2] ? Lu(c[0][0], c[0][1]) : function(p) {
                                    return p === l || kr(p, l, c)
                                }
                            }

                            function js(l, c) {
                                var v;
                                return _i(l) && (v = c) == v && !K(v) ? Lu(Wn(l), c) : function(v) {
                                    var _ = Si(v, l);
                                    return _ === p && _ === c ? Oi(v, l) : oe(c, _, 3)
                                }
                            }

                            function Ke(l, c, v, _, C) {
                                l !== c && rV(c, function(P, T) {
                                    if (C || (C = new Rn), K(P)) ! function(l, c, v, _, C, P, T) {
                                        var M = wi(l, v),
                                            z = wi(c, v),
                                            J = T.get(z);
                                        if (J) {
                                            Yr(l, v, J);
                                            return
                                        }
                                        var Q = P ? P(M, z, v + "", l, c, T) : p,
                                            X = Q === p;
                                        if (X) {
                                            var es = nM(z),
                                                eo = !es && nB(z),
                                                el = !es && !eo && nq(z);
                                            Q = z, es || eo || el ? nM(M) ? Q = M : Z(M) ? Q = un(M) : eo ? (X = !1, Q = hu(z, !0)) : el ? (X = !1, Q = lu(z, !0)) : Q = [] : pe(z) || nL(z) ? (Q = M, nL(M) ? Q = oa(M) : (!K(M) || Jn(M)) && (Q = bu(z))) : X = !1
                                        }
                                        X && (T.set(z, Q), C(Q, z, _, P, T), T.delete(z)), Yr(l, v, Q)
                                    }(l, c, T, v, Ke, _, C);
                                    else {
                                        var M = _ ? _(wi(l, T), P, T + "", l, c, C) : p;
                                        M === p && (M = P), Yr(l, T, M)
                                    }
                                }, on)
                            }

                            function nu(l, c) {
                                var v = l.length;
                                if (v) return Zn(c += c < 0 ? v : 0, v) ? l[c] : p
                            }

                            function tu(l, c, p) {
                                c = c.length ? G(c, function(l) {
                                    return nM(l) ? function(c) {
                                        return _t(c, 1 === l.length ? l[0] : l)
                                    } : l
                                }) : [fn];
                                var v = -1;
                                return c = G(c, hn(x())),
                                    function(l, c) {
                                        var p = l.length;
                                        for (l.sort(c); p--;) l[p] = l[p].value;
                                        return l
                                    }(Vs(l, function(l, p, _) {
                                        return {
                                            criteria: G(c, function(c) {
                                                return c(l)
                                            }),
                                            index: ++v,
                                            value: l
                                        }
                                    }), function(l, c) {
                                        return function(l, c, p) {
                                            for (var v = -1, _ = l.criteria, C = c.criteria, P = _.length, T = p.length; ++v < P;) {
                                                var M = pu(_[v], C[v]);
                                                if (M) {
                                                    if (v >= T) return M;
                                                    return M * ("desc" == p[v] ? -1 : 1)
                                                }
                                            }
                                            return l.index - c.index
                                        }(l, c, p)
                                    })
                            }

                            function eu(l, c, p) {
                                for (var v = -1, _ = c.length, C = {}; ++v < _;) {
                                    var P = c[v],
                                        T = _t(l, P);
                                    p(T, P) && fe(C, st(P, l), T)
                                }
                                return C
                            }

                            function ti(l, c, p, v) {
                                var _ = v ? rf : Tt,
                                    C = -1,
                                    P = c.length,
                                    T = l;
                                for (l === c && (c = un(c)), p && (T = G(l, hn(p))); ++C < P;)
                                    for (var M = 0, z = c[C], J = p ? p(z) : z;
                                        (M = _(T, J, M, v)) > -1;) T !== l && tK.call(T, M, 1), tK.call(l, M, 1);
                                return l
                            }

                            function ru(l, c) {
                                for (var p = l ? c.length : 0, v = p - 1; p--;) {
                                    var _ = c[p];
                                    if (p == v || _ !== C) {
                                        var C = _;
                                        Zn(_) ? tK.call(l, _, 1) : si(l, _)
                                    }
                                }
                                return l
                            }

                            function ei(l, c) {
                                return l + rl(rx() * (c - l + 1))
                            }

                            function ri(l, c) {
                                var p = "";
                                if (!l || c < 1 || c > 9007199254740991) return p;
                                do c % 2 && (p += l), (c = rl(c / 2)) && (l += l); while (c);
                                return p
                            }

                            function L(l, c) {
                                return r1(Du(l, c, fn), l + "")
                            }

                            function fe(l, c, v, _) {
                                if (!K(l)) return l;
                                c = st(c, l);
                                for (var C = -1, P = c.length, T = P - 1, M = l; null != M && ++C < P;) {
                                    var z = Wn(c[C]),
                                        J = v;
                                    if ("__proto__" === z || "constructor" === z || "prototype" === z) break;
                                    if (C != T) {
                                        var Q = M[z];
                                        (J = _ ? _(Q, z, M) : p) === p && (J = K(Q) ? Q : Zn(c[C + 1]) ? [] : {})
                                    }
                                    se(M, z, J), M = M[z]
                                }
                                return l
                            }
                            var rq = rD ? function(l, c) {
                                    return rD.set(l, c), l
                                } : fn,
                                rW = tX ? function(l, c) {
                                    return tX(l, "toString", {
                                        configurable: !0,
                                        enumerable: !1,
                                        value: bi(c),
                                        writable: !0
                                    })
                                } : fn;

                            function Cn(l, c, p) {
                                var v = -1,
                                    _ = l.length;
                                c < 0 && (c = -c > _ ? 0 : _ + c), (p = p > _ ? _ : p) < 0 && (p += _), _ = c > p ? 0 : p - c >>> 0, c >>>= 0;
                                for (var C = to(_); ++v < _;) C[v] = l[v + c];
                                return C
                            }

                            function Mc(l, c) {
                                var p;
                                return rF(l, function(l, v, _) {
                                    return !(p = c(l, v, _))
                                }), !!p
                            }

                            function Ye(l, c, p) {
                                var v = 0,
                                    _ = null == l ? v : l.length;
                                if ("number" == typeof c && c == c && _ <= 2147483647) {
                                    for (; v < _;) {
                                        var C = v + _ >>> 1,
                                            P = l[C];
                                        null !== P && !pn(P) && (p ? P <= c : P < c) ? v = C + 1 : _ = C
                                    }
                                    return _
                                }
                                return ii(l, c, fn, p)
                            }

                            function ii(l, c, v, _) {
                                var C = 0,
                                    P = null == l ? 0 : l.length;
                                if (0 === P) return 0;
                                c = v(c);
                                for (var T = c != c, M = null === c, z = pn(c), J = c === p; C < P;) {
                                    var Q = rl((C + P) / 2),
                                        X = v(l[Q]),
                                        es = X !== p,
                                        eo = null === X,
                                        el = X == X,
                                        ec = pn(X);
                                    if (T) var eh = _ || el;
                                    else eh = J ? el && (_ || es) : M ? el && es && (_ || !eo) : z ? el && es && !eo && (_ || !ec) : !eo && !ec && (_ ? X <= c : X < c);
                                    eh ? C = Q + 1 : P = Q
                                }
                                return ry(P, 4294967294)
                            }

                            function su(l, c) {
                                for (var p = -1, v = l.length, _ = 0, C = []; ++p < v;) {
                                    var P = l[p],
                                        T = c ? c(P) : P;
                                    if (!p || !bn(T, M)) {
                                        var M = T;
                                        C[_++] = 0 === P ? 0 : P
                                    }
                                }
                                return C
                            }

                            function uu(l) {
                                return "number" == typeof l ? l : pn(l) ? T : +l
                            }

                            function ln(l) {
                                if ("string" == typeof l) return l;
                                if (nM(l)) return G(l, ln) + "";
                                if (pn(l)) return rU ? rU.call(l) : "";
                                var c = l + "";
                                return "0" == c && 1 / l == -P ? "-0" : c
                            }

                            function it(l, c, p) {
                                var v = -1,
                                    _ = Ee,
                                    C = l.length,
                                    P = !0,
                                    T = [],
                                    M = T;
                                if (p) P = !1, _ = Dr;
                                else if (C >= 200) {
                                    var z = c ? null : rK(l);
                                    if (z) return Se(z);
                                    P = !1, _ = jt, M = new gt
                                } else M = c ? [] : T;
                                e: for (; ++v < C;) {
                                    var J = l[v],
                                        Q = c ? c(J) : J;
                                    if (J = p || 0 !== J ? J : 0, P && Q == Q) {
                                        for (var X = M.length; X--;)
                                            if (M[X] === Q) continue e;
                                        c && M.push(Q), T.push(J)
                                    } else _(M, Q, p) || (M !== T && M.push(Q), T.push(J))
                                }
                                return T
                            }

                            function si(l, c) {
                                return c = st(c, l), null == (l = Hu(l, c)) || delete l[Wn(In(c))]
                            }

                            function au(l, c, p, v) {
                                return fe(l, c, p(_t(l, c)), v)
                            }

                            function Ze(l, c, p, v) {
                                for (var _ = l.length, C = v ? _ : -1;
                                    (v ? C-- : ++C < _) && c(l[C], C, l););
                                return p ? Cn(l, v ? 0 : C, v ? C + 1 : _) : Cn(l, v ? C + 1 : 0, v ? _ : C)
                            }

                            function ou(l, c) {
                                var p = l;
                                return p instanceof H && (p = p.value()), Hr(c, function(l, c) {
                                    return c.func.apply(c.thisArg, nt([l], c.args))
                                }, p)
                            }

                            function ui(l, c, p) {
                                var v = l.length;
                                if (v < 2) return v ? it(l[0]) : [];
                                for (var _ = -1, C = to(v); ++_ < v;)
                                    for (var P = l[_], T = -1; ++T < v;) T != _ && (C[_] = ue(C[_] || P, l[T], c, p));
                                return it(j(C, 1), c, p)
                            }

                            function fu(l, c, v) {
                                for (var _ = -1, C = l.length, P = c.length, T = {}; ++_ < C;) {
                                    var M = _ < P ? c[_] : p;
                                    v(T, l[_], M)
                                }
                                return T
                            }

                            function ai(l) {
                                return Z(l) ? l : []
                            }

                            function oi(l) {
                                return "function" == typeof l ? l : fn
                            }

                            function st(l, c) {
                                return nM(l) ? l : _i(l, c) ? [l] : r2(W(l))
                            }

                            function ut(l, c, v) {
                                var _ = l.length;
                                return v = v === p ? _ : v, !c && v >= _ ? l : Cn(l, c, v)
                            }
                            var rG = t0 || function(l) {
                                return tJ.clearTimeout(l)
                            };

                            function hu(l, c) {
                                if (c) return l.slice();
                                var p = l.length,
                                    v = tj ? tj(p) : new l.constructor(p);
                                return l.copy(v), v
                            }

                            function fi(l) {
                                var c = new l.constructor(l.byteLength);
                                return new tO(c).set(new tO(l)), c
                            }

                            function lu(l, c) {
                                var p = c ? fi(l.buffer) : l.buffer;
                                return new l.constructor(p, l.byteOffset, l.length)
                            }

                            function pu(l, c) {
                                if (l !== c) {
                                    var v = l !== p,
                                        _ = null === l,
                                        C = l == l,
                                        P = pn(l),
                                        T = c !== p,
                                        M = null === c,
                                        z = c == c,
                                        J = pn(c);
                                    if (!M && !J && !P && l > c || P && T && z && !M && !J || _ && T && z || !v && z || !C) return 1;
                                    if (!_ && !P && !J && l < c || J && v && C && !_ && !P || M && v && C || !T && C || !z) return -1
                                }
                                return 0
                            }

                            function du(l, c, p, v) {
                                for (var _ = -1, C = l.length, P = p.length, T = -1, M = c.length, z = rm(C - P, 0), J = to(M + z), Q = !v; ++T < M;) J[T] = c[T];
                                for (; ++_ < P;)(Q || _ < C) && (J[p[_]] = l[_]);
                                for (; z--;) J[T++] = l[_++];
                                return J
                            }

                            function gu(l, c, p, v) {
                                for (var _ = -1, C = l.length, P = -1, T = p.length, M = -1, z = c.length, J = rm(C - T, 0), Q = to(J + z), X = !v; ++_ < J;) Q[_] = l[_];
                                for (var es = _; ++M < z;) Q[es + M] = c[M];
                                for (; ++P < T;)(X || _ < C) && (Q[es + p[P]] = l[_++]);
                                return Q
                            }

                            function un(l, c) {
                                var p = -1,
                                    v = l.length;
                                for (c || (c = to(v)); ++p < v;) c[p] = l[p];
                                return c
                            }

                            function Un(l, c, v, _) {
                                var C = !v;
                                v || (v = {});
                                for (var P = -1, T = c.length; ++P < T;) {
                                    var M = c[P],
                                        z = _ ? _(v[M], l[M], M, v, l) : p;
                                    z === p && (z = l[M]), C ? zn(v, M, z) : se(v, M, z)
                                }
                                return v
                            }

                            function Je(l, c) {
                                return function(p, v) {
                                    var _ = nM(p) ? Vo : gc,
                                        C = c ? c() : {};
                                    return _(p, l, x(v, 2), C)
                                }
                            }

                            function Ft(l) {
                                return L(function(c, v) {
                                    var _ = -1,
                                        C = v.length,
                                        P = C > 1 ? v[C - 1] : p,
                                        T = C > 2 ? v[2] : p;
                                    for (P = l.length > 3 && "function" == typeof P ? (C--, P) : p, T && rn(v[0], v[1], T) && (P = C < 3 ? p : P, C = 1), c = tf(c); ++_ < C;) {
                                        var M = v[_];
                                        M && l(c, M, _, P)
                                    }
                                    return c
                                })
                            }

                            function vu(l, c) {
                                return function(p, v) {
                                    if (null == p) return p;
                                    if (!an(p)) return l(p, v);
                                    for (var _ = p.length, C = c ? _ : -1, P = tf(p);
                                        (c ? C-- : ++C < _) && !1 !== v(P[C], C, P););
                                    return p
                                }
                            }

                            function _u(l) {
                                return function(c, p, v) {
                                    for (var _ = -1, C = tf(c), P = v(c), T = P.length; T--;) {
                                        var M = P[l ? T : ++_];
                                        if (!1 === p(C[M], M, C)) break
                                    }
                                    return c
                                }
                            }

                            function mu(l) {
                                return function(c) {
                                    var v = Lt(c = W(c)) ? On(c) : p,
                                        _ = v ? v[0] : c.charAt(0),
                                        C = v ? ut(v, 1).join("") : c.slice(1);
                                    return _[l]() + C
                                }
                            }

                            function Mt(l) {
                                return function(c) {
                                    return Hr(va(ga(c).replace(tT, "")), l, "")
                                }
                            }

                            function ce(l) {
                                return function() {
                                    var c = arguments;
                                    switch (c.length) {
                                        case 0:
                                            return new l;
                                        case 1:
                                            return new l(c[0]);
                                        case 2:
                                            return new l(c[0], c[1]);
                                        case 3:
                                            return new l(c[0], c[1], c[2]);
                                        case 4:
                                            return new l(c[0], c[1], c[2], c[3]);
                                        case 5:
                                            return new l(c[0], c[1], c[2], c[3], c[4]);
                                        case 6:
                                            return new l(c[0], c[1], c[2], c[3], c[4], c[5]);
                                        case 7:
                                            return new l(c[0], c[1], c[2], c[3], c[4], c[5], c[6])
                                    }
                                    var p = rB(l.prototype),
                                        v = l.apply(p, c);
                                    return K(v) ? v : p
                                }
                            }

                            function wu(l) {
                                return function(c, v, _) {
                                    var C = tf(c);
                                    if (!an(c)) {
                                        var P = x(v, 3);
                                        c = V(c), v = function(l) {
                                            return P(C[l], l, C)
                                        }
                                    }
                                    var T = l(c, v, _);
                                    return T > -1 ? C[P ? c[T] : T] : p
                                }
                            }

                            function Pu(l) {
                                return Yn(function(c) {
                                    var _ = c.length,
                                        C = _,
                                        P = Pn.prototype.thru;
                                    for (l && c.reverse(); C--;) {
                                        var T = c[C];
                                        if ("function" != typeof T) throw new tm(v);
                                        if (P && !M && "wrapper" == je(T)) var M = new Pn([], !0)
                                    }
                                    for (C = M ? C : _; ++C < _;) {
                                        var z = je(T = c[C]),
                                            J = "wrapper" == z ? rZ(T) : p;
                                        M = J && mi(J[0]) && 424 == J[1] && !J[4].length && 1 == J[9] ? M[je(J[0])].apply(M, J[3]) : 1 == T.length && mi(T) ? M[z]() : M.thru(T)
                                    }
                                    return function() {
                                        var l = arguments,
                                            p = l[0];
                                        if (M && 1 == l.length && nM(p)) return M.plant(p).value();
                                        for (var v = 0, C = _ ? c[v].apply(this, l) : p; ++v < _;) C = c[v].call(this, C);
                                        return C
                                    }
                                })
                            }

                            function Xe(l, c, v, _, C, P, T, M, z, J) {
                                var Q = 128 & c,
                                    X = 1 & c,
                                    es = 2 & c,
                                    eo = 24 & c,
                                    el = 512 & c,
                                    ec = es ? p : ce(l);
                                return function y() {
                                    for (var eh = arguments.length, ed = to(eh), ef = eh; ef--;) ed[ef] = arguments[ef];
                                    if (eo) var ep = qt(y),
                                        eg = function(l, c) {
                                            for (var p = l.length, v = 0; p--;) l[p] === c && ++v;
                                            return v
                                        }(ed, ep);
                                    if (_ && (ed = du(ed, _, C, eo)), P && (ed = gu(ed, P, T, eo)), eh -= eg, eo && eh < J) {
                                        var em = tt(ed, ep);
                                        return Iu(l, c, Xe, y.placeholder, v, ed, em, M, z, J - eh)
                                    }
                                    var ey = X ? v : this,
                                        eb = es ? ey[l] : l;
                                    return eh = ed.length, M ? ed = function(l, c) {
                                        for (var v = l.length, _ = ry(c.length, v), C = un(l); _--;) {
                                            var P = c[_];
                                            l[_] = Zn(P, v) ? C[P] : p
                                        }
                                        return l
                                    }(ed, M) : el && eh > 1 && ed.reverse(), Q && z < eh && (ed.length = z), this && this !== tJ && this instanceof y && (eb = ec || ce(eb)), eb.apply(ey, ed)
                                }
                            }

                            function Au(l, c) {
                                return function(p, v) {
                                    var _, C;
                                    return _ = c(v), C = {}, $n(p, function(c, p, v) {
                                        l(C, _(c), p, v)
                                    }), C
                                }
                            }

                            function Qe(l, c) {
                                return function(v, _) {
                                    var C;
                                    if (v === p && _ === p) return c;
                                    if (v !== p && (C = v), _ !== p) {
                                        if (C === p) return _;
                                        "string" == typeof v || "string" == typeof _ ? (v = ln(v), _ = ln(_)) : (v = uu(v), _ = uu(_)), C = l(v, _)
                                    }
                                    return C
                                }
                            }

                            function ci(l) {
                                return Yn(function(c) {
                                    return c = G(c, hn(x())), L(function(p) {
                                        var v = this;
                                        return l(c, function(l) {
                                            return cn(l, v, p)
                                        })
                                    })
                                })
                            }

                            function Ve(l, c) {
                                var v = (c = c === p ? " " : ln(c)).length;
                                if (v < 2) return v ? ri(c, l) : c;
                                var _ = ri(c, ro(l / Dt(c)));
                                return Lt(c) ? ut(On(_), 0, l).join("") : _.slice(0, l)
                            }

                            function Cu(l) {
                                return function(c, v, _) {
                                    return _ && "number" != typeof _ && rn(c, v, _) && (v = _ = p), c = Xn(c), v === p ? (v = c, c = 0) : v = Xn(v), _ = _ === p ? c < v ? 1 : -1 : Xn(_),
                                        function(l, c, p, v) {
                                            for (var _ = -1, C = rm(ro((c - l) / (p || 1)), 0), P = to(C); C--;) P[v ? C : ++_] = l, l += p;
                                            return P
                                        }(c, v, _, l)
                                }
                            }

                            function ke(l) {
                                return function(c, p) {
                                    return "string" == typeof c && "string" == typeof p || (c = xn(c), p = xn(p)), l(c, p)
                                }
                            }

                            function Iu(l, c, v, _, C, P, T, M, z, J) {
                                var Q = 8 & c,
                                    X = Q ? T : p,
                                    es = Q ? p : T,
                                    eo = Q ? P : p,
                                    el = Q ? p : P;
                                c |= Q ? 32 : 64, 4 & (c &= ~(Q ? 64 : 32)) || (c &= -4);
                                var ec = [l, c, C, eo, X, el, es, M, z, J],
                                    eh = v.apply(p, ec);
                                return mi(l) && rX(eh, ec), eh.placeholder = _, $u(eh, l, c)
                            }

                            function hi(l) {
                                var c = td[l];
                                return function(l, p) {
                                    if (l = xn(l), (p = null == p ? 0 : ry(R(p), 292)) && rd(l)) {
                                        var v = (W(l) + "e").split("e");
                                        return +((v = (W(c(v[0] + "e" + (+v[1] + p))) + "e").split("e"))[0] + "e" + (+v[1] - p))
                                    }
                                    return c(l)
                                }
                            }
                            var rK = rS && 1 / Se(new rS([, -0]))[1] == P ? function(l) {
                                return new rS(l)
                            } : Di;

                            function xu(l) {
                                return function(c) {
                                    var p, v, _ = r$(c);
                                    return _ == ec ? qr(c) : _ == eg ? (p = -1, v = Array(c.size), c.forEach(function(l) {
                                        v[++p] = [l, l]
                                    }), v) : G(l(c), function(l) {
                                        return [l, c[l]]
                                    })
                                }
                            }

                            function Kn(l, c, _, P, T, M, z, J) {
                                var Q = 2 & c;
                                if (!Q && "function" != typeof l) throw new tm(v);
                                var X = P ? P.length : 0;
                                if (X || (c &= -97, P = T = p), z = z === p ? z : rm(R(z), 0), J = J === p ? J : R(J), X -= T ? T.length : 0, 64 & c) {
                                    var es = P,
                                        eo = T;
                                    P = T = p
                                }
                                var el = Q ? p : rZ(l),
                                    ec = [l, c, _, P, T, es, eo, M, z, J];
                                if (el && function(l, c) {
                                        var p = l[1],
                                            v = c[1],
                                            _ = p | v,
                                            P = _ < 131,
                                            T = 128 == v && 8 == p || 128 == v && 256 == p && l[7].length <= c[8] || 384 == v && c[7].length <= c[8] && 8 == p;
                                        if (P || T) {
                                            1 & v && (l[2] = c[2], _ |= 1 & p ? 0 : 4);
                                            var M = c[3];
                                            if (M) {
                                                var z = l[3];
                                                l[3] = z ? du(z, M, c[4]) : M, l[4] = z ? tt(l[3], C) : c[4]
                                            }(M = c[5]) && (z = l[5], l[5] = z ? gu(z, M, c[6]) : M, l[6] = z ? tt(l[5], C) : c[6]), (M = c[7]) && (l[7] = M), 128 & v && (l[8] = null == l[8] ? c[8] : ry(l[8], c[8])), null == l[9] && (l[9] = c[9]), l[0] = c[0], l[1] = _
                                        }
                                    }(ec, el), l = ec[0], c = ec[1], _ = ec[2], P = ec[3], T = ec[4], (J = ec[9] = ec[9] === p ? Q ? 0 : l.length : rm(ec[9] - X, 0)) || !(24 & c) || (c &= -25), c && 1 != c) 8 == c || 16 == c ? (eh = l, ed = c, ef = J, ep = ce(eh), eN = function s() {
                                    for (var l = arguments.length, c = to(l), v = l, _ = qt(s); v--;) c[v] = arguments[v];
                                    var C = l < 3 && c[0] !== _ && c[l - 1] !== _ ? [] : tt(c, _);
                                    return (l -= C.length) < ef ? Iu(eh, ed, Xe, s.placeholder, p, c, C, p, p, ef - l) : cn(this && this !== tJ && this instanceof s ? ep : eh, this, c)
                                }) : 32 != c && 33 != c || T.length ? eN = Xe.apply(p, ec) : (eg = l, em = c, ey = _, eb = P, ew = 1 & em, ex = ce(eg), eN = function f() {
                                    for (var l = -1, c = arguments.length, p = -1, v = eb.length, _ = to(v + c), C = this && this !== tJ && this instanceof f ? ex : eg; ++p < v;) _[p] = eb[p];
                                    for (; c--;) _[p++] = arguments[++l];
                                    return cn(C, ew ? ey : this, _)
                                });
                                else var eh, ed, ef, ep, eg, em, ey, eb, ew, ex, e_, eE, eA, eC, eS, eN = (e_ = l, eE = c, eA = _, eC = 1 & eE, eS = ce(e_), function o() {
                                    return (this && this !== tJ && this instanceof o ? eS : e_).apply(eC ? eA : this, arguments)
                                });
                                return $u((el ? rq : rX)(eN, ec), l, c)
                            }

                            function Eu(l, c, v, _) {
                                return l === p || bn(l, tw[v]) && !tE.call(_, v) ? c : l
                            }

                            function yu(l, c, v, _, C, P) {
                                return K(l) && K(c) && (P.set(c, l), Ke(l, c, p, yu, P), P.delete(c)), l
                            }

                            function kc(l) {
                                return pe(l) ? p : l
                            }

                            function Su(l, c, v, _, C, P) {
                                var T = 1 & v,
                                    M = l.length,
                                    z = c.length;
                                if (M != z && !(T && z > M)) return !1;
                                var J = P.get(l),
                                    Q = P.get(c);
                                if (J && Q) return J == c && Q == l;
                                var X = -1,
                                    es = !0,
                                    eo = 2 & v ? new gt : p;
                                for (P.set(l, c), P.set(c, l); ++X < M;) {
                                    var el = l[X],
                                        ec = c[X];
                                    if (_) var eh = T ? _(ec, el, X, c, l, P) : _(el, ec, X, l, c, P);
                                    if (eh !== p) {
                                        if (eh) continue;
                                        es = !1;
                                        break
                                    }
                                    if (eo) {
                                        if (!Nr(c, function(l, c) {
                                                if (!jt(eo, c) && (el === l || C(el, l, v, _, P))) return eo.push(c)
                                            })) {
                                            es = !1;
                                            break
                                        }
                                    } else if (!(el === ec || C(el, ec, v, _, P))) {
                                        es = !1;
                                        break
                                    }
                                }
                                return P.delete(l), P.delete(c), es
                            }

                            function Yn(l) {
                                return r1(Du(l, p, Bu), l + "")
                            }

                            function li(l) {
                                return Zs(l, V, rJ)
                            }

                            function pi(l) {
                                return Zs(l, on, rQ)
                            }
                            var rZ = rD ? function(l) {
                                return rD.get(l)
                            } : Di;

                            function je(l) {
                                for (var c = l.name + "", p = rk[c], v = tE.call(rk, c) ? p.length : 0; v--;) {
                                    var _ = p[v],
                                        C = _.func;
                                    if (null == C || C == l) return _.name
                                }
                                return c
                            }

                            function qt(l) {
                                return (tE.call(a, "placeholder") ? a : l).placeholder
                            }

                            function x() {
                                var l = a.iteratee || Ti;
                                return l = l === Ti ? Qs : l, arguments.length ? l(arguments[0], arguments[1]) : l
                            }

                            function nr(l, c) {
                                var p, v = l.__data__;
                                return ("string" == (p = typeof c) || "number" == p || "symbol" == p || "boolean" == p ? "__proto__" !== c : null === c) ? v["string" == typeof c ? "string" : "hash"] : v.map
                            }

                            function gi(l) {
                                for (var c = V(l), p = c.length; p--;) {
                                    var v = c[p],
                                        _ = l[v];
                                    c[p] = [v, _, _ == _ && !K(_)]
                                }
                                return c
                            }

                            function mt(l, c) {
                                var v = null == l ? p : l[c];
                                return Xs(v) ? v : p
                            }
                            var rJ = rc ? function(l) {
                                    return null == l ? [] : jn(rc(l = tf(l)), function(c) {
                                        return tq.call(l, c)
                                    })
                                } : Hi,
                                rQ = rc ? function(l) {
                                    for (var c = []; l;) nt(c, rJ(l)), l = tL(l);
                                    return c
                                } : Hi,
                                r$ = en;

                            function Ru(l, c, p) {
                                c = st(c, l);
                                for (var v = -1, _ = c.length, C = !1; ++v < _;) {
                                    var P = Wn(c[v]);
                                    if (!(C = null != l && p(l, P))) break;
                                    l = l[P]
                                }
                                return C || ++v != _ ? C : !!(_ = null == l ? 0 : l.length) && ar(_) && Zn(P, _) && (nM(l) || nL(l))
                            }

                            function bu(l) {
                                return "function" != typeof l.constructor || he(l) ? {} : rB(tL(l))
                            }

                            function ah(l) {
                                return nM(l) || nL(l) || !!(tZ && l && l[tZ])
                            }

                            function Zn(l, c) {
                                var p = typeof l;
                                return !!(c = c ? ? 9007199254740991) && ("number" == p || "symbol" != p && e8.test(l)) && l > -1 && l % 1 == 0 && l < c
                            }

                            function rn(l, c, p) {
                                if (!K(p)) return !1;
                                var v = typeof c;
                                return ("number" == v ? !!(an(p) && Zn(c, p.length)) : "string" == v && c in p) && bn(p[c], l)
                            }

                            function _i(l, c) {
                                if (nM(l)) return !1;
                                var p = typeof l;
                                return !!("number" == p || "symbol" == p || "boolean" == p || null == l || pn(l)) || eV.test(l) || !eH.test(l) || null != c && l in tf(c)
                            }

                            function mi(l) {
                                var c = je(l),
                                    p = a[c];
                                if ("function" != typeof p || !(c in H.prototype)) return !1;
                                if (l === p) return !0;
                                var v = rZ(p);
                                return !!v && l === v[0]
                            }(rE && r$(new rE(new ArrayBuffer(1))) != ex || rA && r$(new rA) != ec || rC && r$(rC.resolve()) != ef || rS && r$(new rS) != eg || rN && r$(new rN) != eb) && (r$ = function(l) {
                                var c = en(l),
                                    v = c == ed ? l.constructor : p,
                                    _ = v ? wt(v) : "";
                                if (_) switch (_) {
                                    case rI:
                                        return ex;
                                    case rO:
                                        return ec;
                                    case rj:
                                        return ef;
                                    case rT:
                                        return eg;
                                    case rR:
                                        return eb
                                }
                                return c
                            });
                            var rY = tx ? Jn : Ni;

                            function he(l) {
                                var c = l && l.constructor;
                                return l === ("function" == typeof c && c.prototype || tw)
                            }

                            function Lu(l, c) {
                                return function(v) {
                                    return null != v && v[l] === c && (c !== p || l in tf(v))
                                }
                            }

                            function Du(l, c, v) {
                                return c = rm(c === p ? l.length - 1 : c, 0),
                                    function() {
                                        for (var p = arguments, _ = -1, C = rm(p.length - c, 0), P = to(C); ++_ < C;) P[_] = p[c + _];
                                        _ = -1;
                                        for (var T = to(c + 1); ++_ < c;) T[_] = p[_];
                                        return T[c] = v(P), cn(l, this, T)
                                    }
                            }

                            function Hu(l, c) {
                                return c.length < 2 ? l : _t(l, Cn(c, 0, -1))
                            }

                            function wi(l, c) {
                                if (!("constructor" === c && "function" == typeof l[c]) && "__proto__" != c) return l[c]
                            }
                            var rX = Uu(rq),
                                r0 = ra || function(l, c) {
                                    return tJ.setTimeout(l, c)
                                },
                                r1 = Uu(rW);

                            function $u(l, c, p) {
                                var v, _, C = c + "";
                                return r1(l, function(l, c) {
                                    var p = c.length;
                                    if (!p) return l;
                                    var v = p - 1;
                                    return c[v] = (p > 1 ? "& " : "") + c[v], c = c.join(p > 2 ? ", " : " "), l.replace(eJ, `{
/* [wrapped with ` + c + `] */
`)
                                }(C, (v = (_ = C.match(eQ)) ? _[1].split(e$) : [], mn(M, function(l) {
                                    var c = "_." + l[0];
                                    p & l[1] && !Ee(v, c) && v.push(c)
                                }), v.sort())))
                            }

                            function Uu(l) {
                                var c = 0,
                                    v = 0;
                                return function() {
                                    var _ = rb(),
                                        C = 16 - (_ - v);
                                    if (v = _, C > 0) {
                                        if (++c >= 800) return arguments[0]
                                    } else c = 0;
                                    return l.apply(p, arguments)
                                }
                            }

                            function tr(l, c) {
                                var v = -1,
                                    _ = l.length,
                                    C = _ - 1;
                                for (c = c === p ? _ : c; ++v < c;) {
                                    var P = ei(v, C),
                                        T = l[P];
                                    l[P] = l[v], l[v] = T
                                }
                                return l.length = c, l
                            }
                            var r2 = (ts = (eZ = sr(function(l) {
                                var c = [];
                                return 46 === l.charCodeAt(0) && c.push(""), l.replace(ez, function(l, p, v, _) {
                                    c.push(v ? _.replace(e0, "$1") : p || l)
                                }), c
                            }, function(l) {
                                return 500 === ts.size && ts.clear(), l
                            })).cache, eZ);

                            function Wn(l) {
                                if ("string" == typeof l || pn(l)) return l;
                                var c = l + "";
                                return "0" == c && 1 / l == -P ? "-0" : c
                            }

                            function wt(l) {
                                if (null != l) {
                                    try {
                                        return t_.call(l)
                                    } catch {}
                                    try {
                                        return l + ""
                                    } catch {}
                                }
                                return ""
                            }

                            function Fu(l) {
                                if (l instanceof H) return l.clone();
                                var c = new Pn(l.__wrapped__, l.__chain__);
                                return c.__actions__ = un(l.__actions__), c.__index__ = l.__index__, c.__values__ = l.__values__, c
                            }
                            var r5 = L(function(l, c) {
                                    return Z(l) ? ue(l, j(c, 1, Z, !0)) : []
                                }),
                                r3 = L(function(l, c) {
                                    var v = In(c);
                                    return Z(v) && (v = p), Z(l) ? ue(l, j(c, 1, Z, !0), x(v, 2)) : []
                                }),
                                r6 = L(function(l, c) {
                                    var v = In(c);
                                    return Z(v) && (v = p), Z(l) ? ue(l, j(c, 1, Z, !0), p, v) : []
                                });

                            function Mu(l, c, p) {
                                var v = null == l ? 0 : l.length;
                                if (!v) return -1;
                                var _ = null == p ? 0 : R(p);
                                return _ < 0 && (_ = rm(v + _, 0)), ye(l, x(c, 3), _)
                            }

                            function qu(l, c, v) {
                                var _ = null == l ? 0 : l.length;
                                if (!_) return -1;
                                var C = _ - 1;
                                return v !== p && (C = R(v), C = v < 0 ? rm(_ + C, 0) : ry(C, _ - 1)), ye(l, x(c, 3), C, !0)
                            }

                            function Bu(l) {
                                return (null == l ? 0 : l.length) ? j(l, 1) : []
                            }

                            function Gu(l) {
                                return l && l.length ? l[0] : p
                            }
                            var r4 = L(function(l) {
                                    var c = G(l, ai);
                                    return c.length && c[0] === l[0] ? Vr(c) : []
                                }),
                                r8 = L(function(l) {
                                    var c = In(l),
                                        v = G(l, ai);
                                    return c === In(v) ? c = p : v.pop(), v.length && v[0] === l[0] ? Vr(v, x(c, 2)) : []
                                }),
                                r9 = L(function(l) {
                                    var c = In(l),
                                        v = G(l, ai);
                                    return (c = "function" == typeof c ? c : p) && v.pop(), v.length && v[0] === l[0] ? Vr(v, p, c) : []
                                });

                            function In(l) {
                                var c = null == l ? 0 : l.length;
                                return c ? l[c - 1] : p
                            }
                            var r7 = L(zu);

                            function zu(l, c) {
                                return l && l.length && c && c.length ? ti(l, c) : l
                            }
                            var ne = Yn(function(l, c) {
                                var p = null == l ? 0 : l.length,
                                    v = Zr(l, c);
                                return ru(l, G(c, function(l) {
                                    return Zn(l, p) ? +l : l
                                }).sort(pu)), v
                            });

                            function Ai(l) {
                                return null == l ? l : r_.call(l)
                            }
                            var nn = L(function(l) {
                                    return it(j(l, 1, Z, !0))
                                }),
                                ns = L(function(l) {
                                    var c = In(l);
                                    return Z(c) && (c = p), it(j(l, 1, Z, !0), x(c, 2))
                                }),
                                no = L(function(l) {
                                    var c = In(l);
                                    return c = "function" == typeof c ? c : p, it(j(l, 1, Z, !0), p, c)
                                });

                            function Ci(l) {
                                if (!(l && l.length)) return [];
                                var c = 0;
                                return l = jn(l, function(l) {
                                    if (Z(l)) return c = rm(l.length, c), !0
                                }), Fr(c, function(c) {
                                    return G(l, $r(c))
                                })
                            }

                            function Ku(l, c) {
                                if (!(l && l.length)) return [];
                                var v = Ci(l);
                                return null == c ? v : G(v, function(l) {
                                    return cn(c, p, l)
                                })
                            }
                            var nl = L(function(l, c) {
                                    return Z(l) ? ue(l, c) : []
                                }),
                                nc = L(function(l) {
                                    return ui(jn(l, Z))
                                }),
                                nh = L(function(l) {
                                    var c = In(l);
                                    return Z(c) && (c = p), ui(jn(l, Z), x(c, 2))
                                }),
                                nd = L(function(l) {
                                    var c = In(l);
                                    return c = "function" == typeof c ? c : p, ui(jn(l, Z), p, c)
                                }),
                                nf = L(Ci),
                                np = L(function(l) {
                                    var c = l.length,
                                        v = c > 1 ? l[c - 1] : p;
                                    return v = "function" == typeof v ? (l.pop(), v) : p, Ku(l, v)
                                });

                            function Yu(l) {
                                var c = a(l);
                                return c.__chain__ = !0, c
                            }

                            function er(l, c) {
                                return c(l)
                            }
                            var ng = Yn(function(l) {
                                    var c = l.length,
                                        v = c ? l[0] : 0,
                                        _ = this.__wrapped__,
                                        s = function(c) {
                                            return Zr(c, l)
                                        };
                                    return !(c > 1) && !this.__actions__.length && _ instanceof H && Zn(v) ? ((_ = _.slice(v, +v + (c ? 1 : 0))).__actions__.push({
                                        func: er,
                                        args: [s],
                                        thisArg: p
                                    }), new Pn(_, this.__chain__).thru(function(l) {
                                        return c && !l.length && l.push(p), l
                                    })) : this.thru(s)
                                }),
                                nm = Je(function(l, c, p) {
                                    tE.call(l, p) ? ++l[p] : zn(l, p, 1)
                                }),
                                ny = wu(Mu),
                                nb = wu(qu);

                            function Zu(l, c) {
                                return (nM(l) ? mn : rF)(l, x(c, 3))
                            }

                            function Ju(l, c) {
                                return (nM(l) ? function(l, c) {
                                    for (var p = null == l ? 0 : l.length; p-- && !1 !== c(l[p], p, l););
                                    return l
                                } : rH)(l, x(c, 3))
                            }
                            var nw = Je(function(l, c, p) {
                                    tE.call(l, p) ? l[p].push(c) : zn(l, p, [c])
                                }),
                                nx = L(function(l, c, p) {
                                    var v = -1,
                                        _ = "function" == typeof c,
                                        C = an(l) ? to(l.length) : [];
                                    return rF(l, function(l) {
                                        C[++v] = _ ? cn(c, l, p) : ae(l, c, p)
                                    }), C
                                }),
                                n_ = Je(function(l, c, p) {
                                    zn(l, p, c)
                                });

                            function rr(l, c) {
                                return (nM(l) ? G : Vs)(l, x(c, 3))
                            }
                            var nE = Je(function(l, c, p) {
                                    l[p ? 0 : 1].push(c)
                                }, function() {
                                    return [
                                        [],
                                        []
                                    ]
                                }),
                                nA = L(function(l, c) {
                                    if (null == l) return [];
                                    var p = c.length;
                                    return p > 1 && rn(l, c[0], c[1]) ? c = [] : p > 2 && rn(c[0], c[1], c[2]) && (c = [c[0]]), tu(l, j(c, 1), [])
                                }),
                                nC = t8 || function() {
                                    return tJ.Date.now()
                                };

                            function Xu(l, c, v) {
                                return c = v ? p : c, c = l && null == c ? l.length : c, Kn(l, 128, p, p, p, p, c)
                            }

                            function Qu(l, c) {
                                var _;
                                if ("function" != typeof c) throw new tm(v);
                                return l = R(l),
                                    function() {
                                        return --l > 0 && (_ = c.apply(this, arguments)), l <= 1 && (c = p), _
                                    }
                            }
                            var nS = L(function(l, c, p) {
                                    var v = 1;
                                    if (p.length) {
                                        var _ = tt(p, qt(nS));
                                        v |= 32
                                    }
                                    return Kn(l, v, c, p, _)
                                }),
                                nN = L(function(l, c, p) {
                                    var v = 3;
                                    if (p.length) {
                                        var _ = tt(p, qt(nN));
                                        v |= 32
                                    }
                                    return Kn(c, v, l, p, _)
                                });

                            function na(l, c, _) {
                                var C, P, T, M, z, J, Q = 0,
                                    X = !1,
                                    es = !1,
                                    eo = !0;
                                if ("function" != typeof l) throw new tm(v);

                                function I(c) {
                                    var v = C,
                                        _ = P;
                                    return C = P = p, Q = c, M = l.apply(_, v)
                                }

                                function y(l) {
                                    var v = l - J,
                                        _ = l - Q;
                                    return J === p || v >= c || v < 0 || es && _ >= T
                                }

                                function D() {
                                    var l, p, v, _ = nC();
                                    if (y(_)) return N(_);
                                    z = r0(D, (l = _ - J, p = _ - Q, v = c - l, es ? ry(v, T - p) : v))
                                }

                                function N(l) {
                                    return z = p, eo && C ? I(l) : (C = P = p, M)
                                }

                                function gn() {
                                    var l, v = nC(),
                                        _ = y(v);
                                    if (C = arguments, P = this, J = v, _) {
                                        if (z === p) return Q = l = J, z = r0(D, c), X ? I(l) : M;
                                        if (es) return rG(z), z = r0(D, c), I(J)
                                    }
                                    return z === p && (z = r0(D, c)), M
                                }
                                return c = xn(c) || 0, K(_) && (X = !!_.leading, T = (es = "maxWait" in _) ? rm(xn(_.maxWait) || 0, c) : T, eo = "trailing" in _ ? !!_.trailing : eo), gn.cancel = function() {
                                    z !== p && rG(z), Q = 0, C = J = P = z = p
                                }, gn.flush = function() {
                                    return z === p ? M : N(nC())
                                }, gn
                            }
                            var nP = L(function(l, c) {
                                    return Gs(l, 1, c)
                                }),
                                nD = L(function(l, c, p) {
                                    return Gs(l, xn(c) || 0, p)
                                });

                            function sr(l, c) {
                                if ("function" != typeof l || null != c && "function" != typeof c) throw new tm(v);
                                var e = function() {
                                    var p = arguments,
                                        v = c ? c.apply(this, p) : p[0],
                                        _ = e.cache;
                                    if (_.has(v)) return _.get(v);
                                    var C = l.apply(this, p);
                                    return e.cache = _.set(v, C) || _, C
                                };
                                return e.cache = new(sr.Cache || Gn), e
                            }

                            function ur(l) {
                                if ("function" != typeof l) throw new tm(v);
                                return function() {
                                    var c = arguments;
                                    switch (c.length) {
                                        case 0:
                                            return !l.call(this);
                                        case 1:
                                            return !l.call(this, c[0]);
                                        case 2:
                                            return !l.call(this, c[0], c[1]);
                                        case 3:
                                            return !l.call(this, c[0], c[1], c[2])
                                    }
                                    return !l.apply(this, c)
                                }
                            }
                            sr.Cache = Gn;
                            var nk = L(function(l, c) {
                                    var p = (c = 1 == c.length && nM(c[0]) ? G(c[0], hn(x())) : G(j(c, 1), hn(x()))).length;
                                    return L(function(v) {
                                        for (var _ = -1, C = ry(v.length, p); ++_ < C;) v[_] = c[_].call(this, v[_]);
                                        return cn(l, this, v)
                                    })
                                }),
                                nI = L(function(l, c) {
                                    var v = tt(c, qt(nI));
                                    return Kn(l, 32, p, c, v)
                                }),
                                nO = L(function(l, c) {
                                    var v = tt(c, qt(nO));
                                    return Kn(l, 64, p, c, v)
                                }),
                                nj = Yn(function(l, c) {
                                    return Kn(l, 256, p, p, p, c)
                                });

                            function bn(l, c) {
                                return l === c || l != l && c != c
                            }
                            var nT = ke(Qr),
                                nR = ke(function(l, c) {
                                    return l >= c
                                }),
                                nL = Js(function() {
                                    return arguments
                                }()) ? Js : function(l) {
                                    return Y(l) && tE.call(l, "callee") && !tq.call(l, "callee")
                                },
                                nM = to.isArray,
                                nU = t1 ? hn(t1) : function(l) {
                                    return Y(l) && en(l) == ew
                                };

                            function an(l) {
                                return null != l && ar(l.length) && !Jn(l)
                            }

                            function Z(l) {
                                return Y(l) && an(l)
                            }
                            var nB = rh || Ni,
                                nF = t2 ? hn(t2) : function(l) {
                                    return Y(l) && en(l) == X
                                };

                            function Ei(l) {
                                if (!Y(l)) return !1;
                                var c = en(l);
                                return c == es || "[object DOMException]" == c || "string" == typeof l.message && "string" == typeof l.name && !pe(l)
                            }

                            function Jn(l) {
                                if (!K(l)) return !1;
                                var c = en(l);
                                return c == eo || c == el || "[object AsyncFunction]" == c || "[object Proxy]" == c
                            }

                            function ea(l) {
                                return "number" == typeof l && l == R(l)
                            }

                            function ar(l) {
                                return "number" == typeof l && l > -1 && l % 1 == 0 && l <= 9007199254740991
                            }

                            function K(l) {
                                var c = typeof l;
                                return null != l && ("object" == c || "function" == c)
                            }

                            function Y(l) {
                                return null != l && "object" == typeof l
                            }
                            var nH = t5 ? hn(t5) : function(l) {
                                return Y(l) && r$(l) == ec
                            };

                            function ia(l) {
                                return "number" == typeof l || Y(l) && en(l) == eh
                            }

                            function pe(l) {
                                if (!Y(l) || en(l) != ed) return !1;
                                var c = tL(l);
                                if (null === c) return !0;
                                var p = tE.call(c, "constructor") && c.constructor;
                                return "function" == typeof p && p instanceof p && t_.call(p) == tN
                            }
                            var nV = t3 ? hn(t3) : function(l) {
                                    return Y(l) && en(l) == ep
                                },
                                nz = t6 ? hn(t6) : function(l) {
                                    return Y(l) && r$(l) == eg
                                };

                            function or(l) {
                                return "string" == typeof l || !nM(l) && Y(l) && en(l) == em
                            }

                            function pn(l) {
                                return "symbol" == typeof l || Y(l) && en(l) == ey
                            }
                            var nq = t4 ? hn(t4) : function(l) {
                                    return Y(l) && ar(l.length) && !!tV[en(l)]
                                },
                                nW = ke(ni),
                                nG = ke(function(l, c) {
                                    return l <= c
                                });

                            function ua(l) {
                                if (!l) return [];
                                if (an(l)) return or(l) ? On(l) : un(l);
                                if (tQ && l[tQ]) return function(l) {
                                    for (var c, p = []; !(c = l.next()).done;) p.push(c.value);
                                    return p
                                }(l[tQ]());
                                var c = r$(l);
                                return (c == ec ? qr : c == eg ? Se : Gt)(l)
                            }

                            function Xn(l) {
                                return l ? (l = xn(l)) === P || l === -P ? (l < 0 ? -1 : 1) * 17976931348623157e292 : l == l ? l : 0 : 0 === l ? l : 0
                            }

                            function R(l) {
                                var c = Xn(l),
                                    p = c % 1;
                                return c == c ? p ? c - p : c : 0
                            }

                            function aa(l) {
                                return l ? vt(R(l), 0, 4294967295) : 0
                            }

                            function xn(l) {
                                if ("number" == typeof l) return l;
                                if (pn(l)) return T;
                                if (K(l)) {
                                    var c = "function" == typeof l.valueOf ? l.valueOf() : l;
                                    l = K(c) ? c + "" : c
                                }
                                if ("string" != typeof l) return 0 === l ? l : +l;
                                l = ys(l);
                                var p = e3.test(l);
                                return p || e4.test(l) ? tG(l.slice(2), p ? 2 : 8) : e5.test(l) ? T : +l
                            }

                            function oa(l) {
                                return Un(l, on(l))
                            }

                            function W(l) {
                                return null == l ? "" : ln(l)
                            }
                            var nK = Ft(function(l, c) {
                                    if (he(c) || an(c)) {
                                        Un(c, V(c), l);
                                        return
                                    }
                                    for (var p in c) tE.call(c, p) && se(l, p, c[p])
                                }),
                                nZ = Ft(function(l, c) {
                                    Un(c, on(c), l)
                                }),
                                nJ = Ft(function(l, c, p, v) {
                                    Un(c, on(c), l, v)
                                }),
                                nQ = Ft(function(l, c, p, v) {
                                    Un(c, V(c), l, v)
                                }),
                                n$ = Yn(Zr),
                                nY = L(function(l, c) {
                                    l = tf(l);
                                    var v = -1,
                                        _ = c.length,
                                        C = _ > 2 ? c[2] : p;
                                    for (C && rn(c[0], c[1], C) && (_ = 1); ++v < _;)
                                        for (var P = c[v], T = on(P), M = -1, z = T.length; ++M < z;) {
                                            var J = T[M],
                                                Q = l[J];
                                            (Q === p || bn(Q, tw[J]) && !tE.call(l, J)) && (l[J] = P[J])
                                        }
                                    return l
                                }),
                                nX = L(function(l) {
                                    return l.push(p, yu), cn(n3, p, l)
                                });

                            function Si(l, c, v) {
                                var _ = null == l ? p : _t(l, c);
                                return _ === p ? v : _
                            }

                            function Oi(l, c) {
                                return null != l && Ru(l, c, Ac)
                            }
                            var n0 = Au(function(l, c, p) {
                                    null != c && "function" != typeof c.toString && (c = tS.call(c)), l[c] = p
                                }, bi(fn)),
                                n1 = Au(function(l, c, p) {
                                    null != c && "function" != typeof c.toString && (c = tS.call(c)), tE.call(l, c) ? l[c].push(p) : l[c] = [p]
                                }, x),
                                n2 = L(ae);

                            function V(l) {
                                return an(l) ? Fs(l) : jr(l)
                            }

                            function on(l) {
                                return an(l) ? Fs(l, !0) : function(l) {
                                    if (!K(l)) return function(l) {
                                        var c = [];
                                        if (null != l)
                                            for (var p in tf(l)) c.push(p);
                                        return c
                                    }(l);
                                    var c = he(l),
                                        p = [];
                                    for (var v in l) "constructor" == v && (c || !tE.call(l, v)) || p.push(v);
                                    return p
                                }(l)
                            }
                            var n5 = Ft(function(l, c, p) {
                                    Ke(l, c, p)
                                }),
                                n3 = Ft(function(l, c, p, v) {
                                    Ke(l, c, p, v)
                                }),
                                n6 = Yn(function(l, c) {
                                    var p = {};
                                    if (null == l) return p;
                                    var v = !1;
                                    c = G(c, function(c) {
                                        return c = st(c, l), v || (v = c.length > 1), c
                                    }), Un(l, pi(l), p), v && (p = An(p, 7, kc));
                                    for (var _ = c.length; _--;) si(p, c[_]);
                                    return p
                                }),
                                n4 = Yn(function(l, c) {
                                    return null == l ? {} : eu(l, c, function(c, p) {
                                        return Oi(l, p)
                                    })
                                });

                            function ha(l, c) {
                                if (null == l) return {};
                                var p = G(pi(l), function(l) {
                                    return [l]
                                });
                                return c = x(c), eu(l, p, function(l, p) {
                                    return c(l, p[0])
                                })
                            }
                            var n8 = xu(V),
                                n9 = xu(on);

                            function Gt(l) {
                                return null == l ? [] : Mr(l, V(l))
                            }
                            var n7 = Mt(function(l, c, p) {
                                return c = c.toLowerCase(), l + (p ? da(c) : c)
                            });

                            function da(l) {
                                return ih(W(l).toLowerCase())
                            }

                            function ga(l) {
                                return (l = W(l)) && l.replace(e9, t9).replace(tR, "")
                            }
                            var ir = Mt(function(l, c, p) {
                                    return l + (p ? "-" : "") + c.toLowerCase()
                                }),
                                is = Mt(function(l, c, p) {
                                    return l + (p ? " " : "") + c.toLowerCase()
                                }),
                                io = mu("toLowerCase"),
                                il = Mt(function(l, c, p) {
                                    return l + (p ? "_" : "") + c.toLowerCase()
                                }),
                                ic = Mt(function(l, c, p) {
                                    return l + (p ? " " : "") + ih(c)
                                }),
                                iu = Mt(function(l, c, p) {
                                    return l + (p ? " " : "") + c.toUpperCase()
                                }),
                                ih = mu("toUpperCase");

                            function va(l, c, v) {
                                var _;
                                return l = W(l), (c = v ? p : c) === p ? (_ = l, tB.test(_)) ? l.match(tM) || [] : l.match(eY) || [] : l.match(c) || []
                            }
                            var ip = L(function(l, c) {
                                    try {
                                        return cn(l, p, c)
                                    } catch (l) {
                                        return Ei(l) ? l : new tc(l)
                                    }
                                }),
                                ig = Yn(function(l, c) {
                                    return mn(c, function(c) {
                                        zn(l, c = Wn(c), nS(l[c], l))
                                    }), l
                                });

                            function bi(l) {
                                return function() {
                                    return l
                                }
                            }
                            var im = Pu(),
                                iy = Pu(!0);

                            function fn(l) {
                                return l
                            }

                            function Ti(l) {
                                return Qs("function" == typeof l ? l : An(l, 1))
                            }
                            var ib = L(function(l, c) {
                                    return function(p) {
                                        return ae(p, l, c)
                                    }
                                }),
                                iw = L(function(l, c) {
                                    return function(p) {
                                        return ae(l, p, c)
                                    }
                                });

                            function Li(l, c, p) {
                                var v = V(c),
                                    _ = ze(c, v);
                                null != p || K(c) && (_.length || !v.length) || (p = c, c = l, l = this, _ = ze(c, V(c)));
                                var C = !(K(p) && "chain" in p) || !!p.chain,
                                    P = Jn(l);
                                return mn(_, function(p) {
                                    var v = c[p];
                                    l[p] = v, P && (l.prototype[p] = function() {
                                        var c = this.__chain__;
                                        if (C || c) {
                                            var p = l(this.__wrapped__);
                                            return (p.__actions__ = un(this.__actions__)).push({
                                                func: v,
                                                args: arguments,
                                                thisArg: l
                                            }), p.__chain__ = c, p
                                        }
                                        return v.apply(l, nt([this.value()], arguments))
                                    })
                                }), l
                            }

                            function Di() {}
                            var ix = ci(G),
                                i_ = ci(As),
                                iE = ci(Nr);

                            function ma(l) {
                                return _i(l) ? $r(Wn(l)) : function(c) {
                                    return _t(c, l)
                                }
                            }
                            var iA = Cu(),
                                iC = Cu(!0);

                            function Hi() {
                                return []
                            }

                            function Ni() {
                                return !1
                            }
                            var iS = Qe(function(l, c) {
                                    return l + c
                                }, 0),
                                iN = hi("ceil"),
                                iP = Qe(function(l, c) {
                                    return l / c
                                }, 1),
                                iD = hi("floor"),
                                ik = Qe(function(l, c) {
                                    return l * c
                                }, 1),
                                iI = hi("round"),
                                iO = Qe(function(l, c) {
                                    return l - c
                                }, 0);
                            return a.after = function(l, c) {
                                if ("function" != typeof c) throw new tm(v);
                                return l = R(l),
                                    function() {
                                        if (--l < 1) return c.apply(this, arguments)
                                    }
                            }, a.ary = Xu, a.assign = nK, a.assignIn = nZ, a.assignInWith = nJ, a.assignWith = nQ, a.at = n$, a.before = Qu, a.bind = nS, a.bindAll = ig, a.bindKey = nN, a.castArray = function() {
                                if (!arguments.length) return [];
                                var l = arguments[0];
                                return nM(l) ? l : [l]
                            }, a.chain = Yu, a.chunk = function(l, c, v) {
                                c = (v ? rn(l, c, v) : c === p) ? 1 : rm(R(c), 0);
                                var _ = null == l ? 0 : l.length;
                                if (!_ || c < 1) return [];
                                for (var C = 0, P = 0, T = to(ro(_ / c)); C < _;) T[P++] = Cn(l, C, C += c);
                                return T
                            }, a.compact = function(l) {
                                for (var c = -1, p = null == l ? 0 : l.length, v = 0, _ = []; ++c < p;) {
                                    var C = l[c];
                                    C && (_[v++] = C)
                                }
                                return _
                            }, a.concat = function() {
                                var l = arguments.length;
                                if (!l) return [];
                                for (var c = to(l - 1), p = arguments[0], v = l; v--;) c[v - 1] = arguments[v];
                                return nt(nM(p) ? un(p) : [p], j(c, 1))
                            }, a.cond = function(l) {
                                var c = null == l ? 0 : l.length,
                                    p = x();
                                return l = c ? G(l, function(l) {
                                    if ("function" != typeof l[1]) throw new tm(v);
                                    return [p(l[0]), l[1]]
                                }) : [], L(function(p) {
                                    for (var v = -1; ++v < c;) {
                                        var _ = l[v];
                                        if (cn(_[0], this, p)) return cn(_[1], this, p)
                                    }
                                })
                            }, a.conforms = function(l) {
                                var c, p;
                                return p = V(c = An(l, 1)),
                                    function(l) {
                                        return Bs(l, c, p)
                                    }
                            }, a.constant = bi, a.countBy = nm, a.create = function(l, c) {
                                var p = rB(l);
                                return null == c ? p : qs(p, c)
                            }, a.curry = function ku(l, c, v) {
                                c = v ? p : c;
                                var _ = Kn(l, 8, p, p, p, p, p, c);
                                return _.placeholder = ku.placeholder, _
                            }, a.curryRight = function ju(l, c, v) {
                                c = v ? p : c;
                                var _ = Kn(l, 16, p, p, p, p, p, c);
                                return _.placeholder = ju.placeholder, _
                            }, a.debounce = na, a.defaults = nY, a.defaultsDeep = nX, a.defer = nP, a.delay = nD, a.difference = r5, a.differenceBy = r3, a.differenceWith = r6, a.drop = function(l, c, v) {
                                var _ = null == l ? 0 : l.length;
                                return _ ? Cn(l, (c = v || c === p ? 1 : R(c)) < 0 ? 0 : c, _) : []
                            }, a.dropRight = function(l, c, v) {
                                var _ = null == l ? 0 : l.length;
                                return _ ? Cn(l, 0, (c = _ - (c = v || c === p ? 1 : R(c))) < 0 ? 0 : c) : []
                            }, a.dropRightWhile = function(l, c) {
                                return l && l.length ? Ze(l, x(c, 3), !0, !0) : []
                            }, a.dropWhile = function(l, c) {
                                return l && l.length ? Ze(l, x(c, 3), !0) : []
                            }, a.fill = function(l, c, v, _) {
                                var C = null == l ? 0 : l.length;
                                return C ? (v && "number" != typeof v && rn(l, c, v) && (v = 0, _ = C), function(l, c, v, _) {
                                    var C = l.length;
                                    for ((v = R(v)) < 0 && (v = -v > C ? 0 : C + v), (_ = _ === p || _ > C ? C : R(_)) < 0 && (_ += C), _ = v > _ ? 0 : aa(_); v < _;) l[v++] = c;
                                    return l
                                }(l, c, v, _)) : []
                            }, a.filter = function(l, c) {
                                return (nM(l) ? jn : Ks)(l, x(c, 3))
                            }, a.flatMap = function(l, c) {
                                return j(rr(l, c), 1)
                            }, a.flatMapDeep = function(l, c) {
                                return j(rr(l, c), P)
                            }, a.flatMapDepth = function(l, c, v) {
                                return v = v === p ? 1 : R(v), j(rr(l, c), v)
                            }, a.flatten = Bu, a.flattenDeep = function(l) {
                                return (null == l ? 0 : l.length) ? j(l, P) : []
                            }, a.flattenDepth = function(l, c) {
                                return (null == l ? 0 : l.length) ? j(l, c = c === p ? 1 : R(c)) : []
                            }, a.flip = function(l) {
                                return Kn(l, 512)
                            }, a.flow = im, a.flowRight = iy, a.fromPairs = function(l) {
                                for (var c = -1, p = null == l ? 0 : l.length, v = {}; ++c < p;) {
                                    var _ = l[c];
                                    v[_[0]] = _[1]
                                }
                                return v
                            }, a.functions = function(l) {
                                return null == l ? [] : ze(l, V(l))
                            }, a.functionsIn = function(l) {
                                return null == l ? [] : ze(l, on(l))
                            }, a.groupBy = nw, a.initial = function(l) {
                                return (null == l ? 0 : l.length) ? Cn(l, 0, -1) : []
                            }, a.intersection = r4, a.intersectionBy = r8, a.intersectionWith = r9, a.invert = n0, a.invertBy = n1, a.invokeMap = nx, a.iteratee = Ti, a.keyBy = n_, a.keys = V, a.keysIn = on, a.map = rr, a.mapKeys = function(l, c) {
                                var p = {};
                                return c = x(c, 3), $n(l, function(l, v, _) {
                                    zn(p, c(l, v, _), l)
                                }), p
                            }, a.mapValues = function(l, c) {
                                var p = {};
                                return c = x(c, 3), $n(l, function(l, v, _) {
                                    zn(p, v, c(l, v, _))
                                }), p
                            }, a.matches = function(l) {
                                return ks(An(l, 1))
                            }, a.matchesProperty = function(l, c) {
                                return js(l, An(c, 1))
                            }, a.memoize = sr, a.merge = n5, a.mergeWith = n3, a.method = ib, a.methodOf = iw, a.mixin = Li, a.negate = ur, a.nthArg = function(l) {
                                return l = R(l), L(function(c) {
                                    return nu(c, l)
                                })
                            }, a.omit = n6, a.omitBy = function(l, c) {
                                return ha(l, ur(x(c)))
                            }, a.once = function(l) {
                                return Qu(2, l)
                            }, a.orderBy = function(l, c, v, _) {
                                return null == l ? [] : (nM(c) || (c = null == c ? [] : [c]), nM(v = _ ? p : v) || (v = null == v ? [] : [v]), tu(l, c, v))
                            }, a.over = ix, a.overArgs = nk, a.overEvery = i_, a.overSome = iE, a.partial = nI, a.partialRight = nO, a.partition = nE, a.pick = n4, a.pickBy = ha, a.property = ma, a.propertyOf = function(l) {
                                return function(c) {
                                    return null == l ? p : _t(l, c)
                                }
                            }, a.pull = r7, a.pullAll = zu, a.pullAllBy = function(l, c, p) {
                                return l && l.length && c && c.length ? ti(l, c, x(p, 2)) : l
                            }, a.pullAllWith = function(l, c, v) {
                                return l && l.length && c && c.length ? ti(l, c, p, v) : l
                            }, a.pullAt = ne, a.range = iA, a.rangeRight = iC, a.rearg = nj, a.reject = function(l, c) {
                                return (nM(l) ? jn : Ks)(l, ur(x(c, 3)))
                            }, a.remove = function(l, c) {
                                var p = [];
                                if (!(l && l.length)) return p;
                                var v = -1,
                                    _ = [],
                                    C = l.length;
                                for (c = x(c, 3); ++v < C;) {
                                    var P = l[v];
                                    c(P, v, l) && (p.push(P), _.push(v))
                                }
                                return ru(l, _), p
                            }, a.rest = function(l, c) {
                                if ("function" != typeof l) throw new tm(v);
                                return L(l, c = c === p ? c : R(c))
                            }, a.reverse = Ai, a.sampleSize = function(l, c, v) {
                                return c = (v ? rn(l, c, v) : c === p) ? 1 : R(c), (nM(l) ? function(l, c) {
                                    return tr(un(l), vt(c, 0, l.length))
                                } : function(l, c) {
                                    var p = Gt(l);
                                    return tr(p, vt(c, 0, p.length))
                                })(l, c)
                            }, a.set = function(l, c, p) {
                                return null == l ? l : fe(l, c, p)
                            }, a.setWith = function(l, c, v, _) {
                                return _ = "function" == typeof _ ? _ : p, null == l ? l : fe(l, c, v, _)
                            }, a.shuffle = function(l) {
                                return (nM(l) ? function(l) {
                                    return tr(un(l))
                                } : function(l) {
                                    return tr(Gt(l))
                                })(l)
                            }, a.slice = function(l, c, v) {
                                var _ = null == l ? 0 : l.length;
                                return _ ? (v && "number" != typeof v && rn(l, c, v) ? (c = 0, v = _) : (c = null == c ? 0 : R(c), v = v === p ? _ : R(v)), Cn(l, c, v)) : []
                            }, a.sortBy = nA, a.sortedUniq = function(l) {
                                return l && l.length ? su(l) : []
                            }, a.sortedUniqBy = function(l, c) {
                                return l && l.length ? su(l, x(c, 2)) : []
                            }, a.split = function(l, c, v) {
                                return v && "number" != typeof v && rn(l, c, v) && (c = v = p), (v = v === p ? 4294967295 : v >>> 0) ? (l = W(l)) && ("string" == typeof c || null != c && !nV(c)) && !(c = ln(c)) && Lt(l) ? ut(On(l), 0, v) : l.split(c, v) : []
                            }, a.spread = function(l, c) {
                                if ("function" != typeof l) throw new tm(v);
                                return c = null == c ? 0 : rm(R(c), 0), L(function(p) {
                                    var v = p[c],
                                        _ = ut(p, 0, c);
                                    return v && nt(_, v), cn(l, this, _)
                                })
                            }, a.tail = function(l) {
                                var c = null == l ? 0 : l.length;
                                return c ? Cn(l, 1, c) : []
                            }, a.take = function(l, c, v) {
                                return l && l.length ? Cn(l, 0, (c = v || c === p ? 1 : R(c)) < 0 ? 0 : c) : []
                            }, a.takeRight = function(l, c, v) {
                                var _ = null == l ? 0 : l.length;
                                return _ ? Cn(l, (c = _ - (c = v || c === p ? 1 : R(c))) < 0 ? 0 : c, _) : []
                            }, a.takeRightWhile = function(l, c) {
                                return l && l.length ? Ze(l, x(c, 3), !1, !0) : []
                            }, a.takeWhile = function(l, c) {
                                return l && l.length ? Ze(l, x(c, 3)) : []
                            }, a.tap = function(l, c) {
                                return c(l), l
                            }, a.throttle = function(l, c, p) {
                                var _ = !0,
                                    C = !0;
                                if ("function" != typeof l) throw new tm(v);
                                return K(p) && (_ = "leading" in p ? !!p.leading : _, C = "trailing" in p ? !!p.trailing : C), na(l, c, {
                                    leading: _,
                                    maxWait: c,
                                    trailing: C
                                })
                            }, a.thru = er, a.toArray = ua, a.toPairs = n8, a.toPairsIn = n9, a.toPath = function(l) {
                                return nM(l) ? G(l, Wn) : pn(l) ? [l] : un(r2(W(l)))
                            }, a.toPlainObject = oa, a.transform = function(l, c, p) {
                                var v = nM(l),
                                    _ = v || nB(l) || nq(l);
                                if (c = x(c, 4), null == p) {
                                    var C = l && l.constructor;
                                    p = _ ? v ? new C : [] : K(l) && Jn(C) ? rB(tL(l)) : {}
                                }
                                return (_ ? mn : $n)(l, function(l, v, _) {
                                    return c(p, l, v, _)
                                }), p
                            }, a.unary = function(l) {
                                return Xu(l, 1)
                            }, a.union = nn, a.unionBy = ns, a.unionWith = no, a.uniq = function(l) {
                                return l && l.length ? it(l) : []
                            }, a.uniqBy = function(l, c) {
                                return l && l.length ? it(l, x(c, 2)) : []
                            }, a.uniqWith = function(l, c) {
                                return c = "function" == typeof c ? c : p, l && l.length ? it(l, p, c) : []
                            }, a.unset = function(l, c) {
                                return null == l || si(l, c)
                            }, a.unzip = Ci, a.unzipWith = Ku, a.update = function(l, c, p) {
                                return null == l ? l : au(l, c, oi(p))
                            }, a.updateWith = function(l, c, v, _) {
                                return _ = "function" == typeof _ ? _ : p, null == l ? l : au(l, c, oi(v), _)
                            }, a.values = Gt, a.valuesIn = function(l) {
                                return null == l ? [] : Mr(l, on(l))
                            }, a.without = nl, a.words = va, a.wrap = function(l, c) {
                                return nI(oi(c), l)
                            }, a.xor = nc, a.xorBy = nh, a.xorWith = nd, a.zip = nf, a.zipObject = function(l, c) {
                                return fu(l || [], c || [], se)
                            }, a.zipObjectDeep = function(l, c) {
                                return fu(l || [], c || [], fe)
                            }, a.zipWith = np, a.entries = n8, a.entriesIn = n9, a.extend = nZ, a.extendWith = nJ, Li(a, a), a.add = iS, a.attempt = ip, a.camelCase = n7, a.capitalize = da, a.ceil = iN, a.clamp = function(l, c, v) {
                                return v === p && (v = c, c = p), v !== p && (v = (v = xn(v)) == v ? v : 0), c !== p && (c = (c = xn(c)) == c ? c : 0), vt(xn(l), c, v)
                            }, a.clone = function(l) {
                                return An(l, 4)
                            }, a.cloneDeep = function(l) {
                                return An(l, 5)
                            }, a.cloneDeepWith = function(l, c) {
                                return An(l, 5, c = "function" == typeof c ? c : p)
                            }, a.cloneWith = function(l, c) {
                                return An(l, 4, c = "function" == typeof c ? c : p)
                            }, a.conformsTo = function(l, c) {
                                return null == c || Bs(l, c, V(c))
                            }, a.deburr = ga, a.defaultTo = function(l, c) {
                                return null == l || l != l ? c : l
                            }, a.divide = iP, a.endsWith = function(l, c, v) {
                                l = W(l), c = ln(c);
                                var _ = l.length,
                                    C = v = v === p ? _ : vt(R(v), 0, _);
                                return (v -= c.length) >= 0 && l.slice(v, C) == c
                            }, a.eq = bn, a.escape = function(l) {
                                return (l = W(l)) && eM.test(l) ? l.replace(eR, t7) : l
                            }, a.escapeRegExp = function(l) {
                                return (l = W(l)) && eG.test(l) ? l.replace(eW, "\\$&") : l
                            }, a.every = function(l, c, v) {
                                var _ = nM(l) ? As : mc;
                                return v && rn(l, c, v) && (c = p), _(l, x(c, 3))
                            }, a.find = ny, a.findIndex = Mu, a.findKey = function(l, c) {
                                return Cs(l, x(c, 3), $n)
                            }, a.findLast = nb, a.findLastIndex = qu, a.findLastKey = function(l, c) {
                                return Cs(l, x(c, 3), Xr)
                            }, a.floor = iD, a.forEach = Zu, a.forEachRight = Ju, a.forIn = function(l, c) {
                                return null == l ? l : rV(l, x(c, 3), on)
                            }, a.forInRight = function(l, c) {
                                return null == l ? l : rz(l, x(c, 3), on)
                            }, a.forOwn = function(l, c) {
                                return l && $n(l, x(c, 3))
                            }, a.forOwnRight = function(l, c) {
                                return l && Xr(l, x(c, 3))
                            }, a.get = Si, a.gt = nT, a.gte = nR, a.has = function(l, c) {
                                return null != l && Ru(l, c, Pc)
                            }, a.hasIn = Oi, a.head = Gu, a.identity = fn, a.includes = function(l, c, p, v) {
                                l = an(l) ? l : Gt(l), p = p && !v ? R(p) : 0;
                                var _ = l.length;
                                return p < 0 && (p = rm(_ + p, 0)), or(l) ? p <= _ && l.indexOf(c, p) > -1 : !!_ && Tt(l, c, p) > -1
                            }, a.indexOf = function(l, c, p) {
                                var v = null == l ? 0 : l.length;
                                if (!v) return -1;
                                var _ = null == p ? 0 : R(p);
                                return _ < 0 && (_ = rm(v + _, 0)), Tt(l, c, _)
                            }, a.inRange = function(l, c, v) {
                                var _, C, P;
                                return c = Xn(c), v === p ? (v = c, c = 0) : v = Xn(v), (_ = l = xn(l)) >= ry(C = c, P = v) && _ < rm(C, P)
                            }, a.invoke = n2, a.isArguments = nL, a.isArray = nM, a.isArrayBuffer = nU, a.isArrayLike = an, a.isArrayLikeObject = Z, a.isBoolean = function(l) {
                                return !0 === l || !1 === l || Y(l) && en(l) == Q
                            }, a.isBuffer = nB, a.isDate = nF, a.isElement = function(l) {
                                return Y(l) && 1 === l.nodeType && !pe(l)
                            }, a.isEmpty = function(l) {
                                if (null == l) return !0;
                                if (an(l) && (nM(l) || "string" == typeof l || "function" == typeof l.splice || nB(l) || nq(l) || nL(l))) return !l.length;
                                var c = r$(l);
                                if (c == ec || c == eg) return !l.size;
                                if (he(l)) return !jr(l).length;
                                for (var p in l)
                                    if (tE.call(l, p)) return !1;
                                return !0
                            }, a.isEqual = function(l, c) {
                                return oe(l, c)
                            }, a.isEqualWith = function(l, c, v) {
                                var _ = (v = "function" == typeof v ? v : p) ? v(l, c) : p;
                                return _ === p ? oe(l, c, p, v) : !!_
                            }, a.isError = Ei, a.isFinite = function(l) {
                                return "number" == typeof l && rd(l)
                            }, a.isFunction = Jn, a.isInteger = ea, a.isLength = ar, a.isMap = nH, a.isMatch = function(l, c) {
                                return l === c || kr(l, c, gi(c))
                            }, a.isMatchWith = function(l, c, v) {
                                return v = "function" == typeof v ? v : p, kr(l, c, gi(c), v)
                            }, a.isNaN = function(l) {
                                return ia(l) && l != +l
                            }, a.isNative = function(l) {
                                if (rY(l)) throw new tc("Unsupported core-js use. Try https://npms.io/search?q=ponyfill.");
                                return Xs(l)
                            }, a.isNil = function(l) {
                                return null == l
                            }, a.isNull = function(l) {
                                return null === l
                            }, a.isNumber = ia, a.isObject = K, a.isObjectLike = Y, a.isPlainObject = pe, a.isRegExp = nV, a.isSafeInteger = function(l) {
                                return ea(l) && l >= -9007199254740991 && l <= 9007199254740991
                            }, a.isSet = nz, a.isString = or, a.isSymbol = pn, a.isTypedArray = nq, a.isUndefined = function(l) {
                                return l === p
                            }, a.isWeakMap = function(l) {
                                return Y(l) && r$(l) == eb
                            }, a.isWeakSet = function(l) {
                                return Y(l) && "[object WeakSet]" == en(l)
                            }, a.join = function(l, c) {
                                return null == l ? "" : rp.call(l, c)
                            }, a.kebabCase = ir, a.last = In, a.lastIndexOf = function(l, c, v) {
                                var _ = null == l ? 0 : l.length;
                                if (!_) return -1;
                                var C = _;
                                return v !== p && (C = (C = R(v)) < 0 ? rm(_ + C, 0) : ry(C, _ - 1)), c == c ? function(l, c, p) {
                                    for (var v = p + 1; v-- && l[v] !== c;);
                                    return v
                                }(l, c, C) : ye(l, Is, C, !0)
                            }, a.lowerCase = is, a.lowerFirst = io, a.lt = nW, a.lte = nG, a.max = function(l) {
                                return l && l.length ? Ge(l, fn, Qr) : p
                            }, a.maxBy = function(l, c) {
                                return l && l.length ? Ge(l, x(c, 2), Qr) : p
                            }, a.mean = function(l) {
                                return xs(l, fn)
                            }, a.meanBy = function(l, c) {
                                return xs(l, x(c, 2))
                            }, a.min = function(l) {
                                return l && l.length ? Ge(l, fn, ni) : p
                            }, a.minBy = function(l, c) {
                                return l && l.length ? Ge(l, x(c, 2), ni) : p
                            }, a.stubArray = Hi, a.stubFalse = Ni, a.stubObject = function() {
                                return {}
                            }, a.stubString = function() {
                                return ""
                            }, a.stubTrue = function() {
                                return !0
                            }, a.multiply = ik, a.nth = function(l, c) {
                                return l && l.length ? nu(l, R(c)) : p
                            }, a.noConflict = function() {
                                return tJ._ === this && (tJ._ = tP), this
                            }, a.noop = Di, a.now = nC, a.pad = function(l, c, p) {
                                l = W(l);
                                var v = (c = R(c)) ? Dt(l) : 0;
                                if (!c || v >= c) return l;
                                var _ = (c - v) / 2;
                                return Ve(rl(_), p) + l + Ve(ro(_), p)
                            }, a.padEnd = function(l, c, p) {
                                l = W(l);
                                var v = (c = R(c)) ? Dt(l) : 0;
                                return c && v < c ? l + Ve(c - v, p) : l
                            }, a.padStart = function(l, c, p) {
                                l = W(l);
                                var v = (c = R(c)) ? Dt(l) : 0;
                                return c && v < c ? Ve(c - v, p) + l : l
                            }, a.parseInt = function(l, c, p) {
                                return p || null == c ? c = 0 : c && (c = +c), rw(W(l).replace(eK, ""), c || 0)
                            }, a.random = function(l, c, v) {
                                if (v && "boolean" != typeof v && rn(l, c, v) && (c = v = p), v === p && ("boolean" == typeof c ? (v = c, c = p) : "boolean" == typeof l && (v = l, l = p)), l === p && c === p ? (l = 0, c = 1) : (l = Xn(l), c === p ? (c = l, l = 0) : c = Xn(c)), l > c) {
                                    var _ = l;
                                    l = c, c = _
                                }
                                if (v || l % 1 || c % 1) {
                                    var C = rx();
                                    return ry(l + C * (c - l + tW("1e-" + ((C + "").length - 1))), c)
                                }
                                return ei(l, c)
                            }, a.reduce = function(l, c, p) {
                                var v = nM(l) ? Hr : Es,
                                    _ = arguments.length < 3;
                                return v(l, x(c, 4), p, _, rF)
                            }, a.reduceRight = function(l, c, p) {
                                var v = nM(l) ? jo : Es,
                                    _ = arguments.length < 3;
                                return v(l, x(c, 4), p, _, rH)
                            }, a.repeat = function(l, c, v) {
                                return c = (v ? rn(l, c, v) : c === p) ? 1 : R(c), ri(W(l), c)
                            }, a.replace = function() {
                                var l = arguments,
                                    c = W(l[0]);
                                return l.length < 3 ? c : c.replace(l[1], l[2])
                            }, a.result = function(l, c, v) {
                                c = st(c, l);
                                var _ = -1,
                                    C = c.length;
                                for (C || (C = 1, l = p); ++_ < C;) {
                                    var P = null == l ? p : l[Wn(c[_])];
                                    P === p && (_ = C, P = v), l = Jn(P) ? P.call(l) : P
                                }
                                return l
                            }, a.round = iI, a.runInContext = h, a.sample = function(l) {
                                return (nM(l) ? Ms : function(l) {
                                    return Ms(Gt(l))
                                })(l)
                            }, a.size = function(l) {
                                if (null == l) return 0;
                                if (an(l)) return or(l) ? Dt(l) : l.length;
                                var c = r$(l);
                                return c == ec || c == eg ? l.size : jr(l).length
                            }, a.snakeCase = il, a.some = function(l, c, v) {
                                var _ = nM(l) ? Nr : Mc;
                                return v && rn(l, c, v) && (c = p), _(l, x(c, 3))
                            }, a.sortedIndex = function(l, c) {
                                return Ye(l, c)
                            }, a.sortedIndexBy = function(l, c, p) {
                                return ii(l, c, x(p, 2))
                            }, a.sortedIndexOf = function(l, c) {
                                var p = null == l ? 0 : l.length;
                                if (p) {
                                    var v = Ye(l, c);
                                    if (v < p && bn(l[v], c)) return v
                                }
                                return -1
                            }, a.sortedLastIndex = function(l, c) {
                                return Ye(l, c, !0)
                            }, a.sortedLastIndexBy = function(l, c, p) {
                                return ii(l, c, x(p, 2), !0)
                            }, a.sortedLastIndexOf = function(l, c) {
                                if (null == l ? 0 : l.length) {
                                    var p = Ye(l, c, !0) - 1;
                                    if (bn(l[p], c)) return p
                                }
                                return -1
                            }, a.startCase = ic, a.startsWith = function(l, c, p) {
                                return l = W(l), p = null == p ? 0 : vt(R(p), 0, l.length), c = ln(c), l.slice(p, p + c.length) == c
                            }, a.subtract = iO, a.sum = function(l) {
                                return l && l.length ? Wr(l, fn) : 0
                            }, a.sumBy = function(l, c) {
                                return l && l.length ? Wr(l, x(c, 2)) : 0
                            }, a.template = function(l, c, v) {
                                var _ = a.templateSettings;
                                v && rn(l, c, v) && (c = p), l = W(l), c = nJ({}, c, _, Eu);
                                var C, P, T = nJ({}, c.imports, _.imports, Eu),
                                    M = V(T),
                                    z = Mr(T, M),
                                    J = 0,
                                    Q = c.interpolate || e7,
                                    X = "__p += '",
                                    es = tp((c.escape || e7).source + "|" + Q.source + "|" + (Q === eF ? e1 : e7).source + "|" + (c.evaluate || e7).source + "|$", "g"),
                                    eo = "//# sourceURL=" + (tE.call(c, "sourceURL") ? (c.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++tH + "]") + `
`;
                                l.replace(es, function(c, p, v, _, T, M) {
                                    return v || (v = _), X += l.slice(J, M).replace(tn, cf), p && (C = !0, X += `' +
__e(` + p + `) +
'`), T && (P = !0, X += `';
` + T + `;
__p += '`), v && (X += `' +
((__t = (` + v + `)) == null ? '' : __t) +
'`), J = M + c.length, c
                                }), X += `';
`;
                                var el = tE.call(c, "variable") && c.variable;
                                if (el) {
                                    if (eX.test(el)) throw new tc("Invalid `variable` option passed into `_.template`")
                                } else X = `with (obj) {
` + X + `
}
`;
                                X = (P ? X.replace(eI, "") : X).replace(eO, "$1").replace(ej, "$1;"), X = "function(" + (el || "obj") + `) {
` + (el ? "" : `obj || (obj = {});
`) + "var __t, __p = ''" + (C ? ", __e = _.escape" : "") + (P ? `, __j = Array.prototype.join;
function print() { __p += __j.call(arguments, '') }
` : `;
`) + X + `return __p
}`;
                                var ec = ip(function() {
                                    return th(M, eo + "return " + X).apply(p, z)
                                });
                                if (ec.source = X, Ei(ec)) throw ec;
                                return ec
                            }, a.times = function(l, c) {
                                if ((l = R(l)) < 1 || l > 9007199254740991) return [];
                                var p = 4294967295,
                                    v = ry(l, 4294967295);
                                c = x(c), l -= 4294967295;
                                for (var _ = Fr(v, c); ++p < l;) c(p);
                                return _
                            }, a.toFinite = Xn, a.toInteger = R, a.toLength = aa, a.toLower = function(l) {
                                return W(l).toLowerCase()
                            }, a.toNumber = xn, a.toSafeInteger = function(l) {
                                return l ? vt(R(l), -9007199254740991, 9007199254740991) : 0 === l ? l : 0
                            }, a.toString = W, a.toUpper = function(l) {
                                return W(l).toUpperCase()
                            }, a.trim = function(l, c, v) {
                                if ((l = W(l)) && (v || c === p)) return ys(l);
                                if (!l || !(c = ln(c))) return l;
                                var _ = On(l),
                                    C = On(c),
                                    P = Ss(_, C),
                                    T = Os(_, C) + 1;
                                return ut(_, P, T).join("")
                            }, a.trimEnd = function(l, c, v) {
                                if ((l = W(l)) && (v || c === p)) return l.slice(0, bs(l) + 1);
                                if (!l || !(c = ln(c))) return l;
                                var _ = On(l),
                                    C = Os(_, On(c)) + 1;
                                return ut(_, 0, C).join("")
                            }, a.trimStart = function(l, c, v) {
                                if ((l = W(l)) && (v || c === p)) return l.replace(eK, "");
                                if (!l || !(c = ln(c))) return l;
                                var _ = On(l),
                                    C = Ss(_, On(c));
                                return ut(_, C).join("")
                            }, a.truncate = function(l, c) {
                                var v = 30,
                                    _ = "...";
                                if (K(c)) {
                                    var C = "separator" in c ? c.separator : C;
                                    v = "length" in c ? R(c.length) : v, _ = "omission" in c ? ln(c.omission) : _
                                }
                                var P = (l = W(l)).length;
                                if (Lt(l)) {
                                    var T = On(l);
                                    P = T.length
                                }
                                if (v >= P) return l;
                                var M = v - Dt(_);
                                if (M < 1) return _;
                                var z = T ? ut(T, 0, M).join("") : l.slice(0, M);
                                if (C === p) return z + _;
                                if (T && (M += z.length - M), nV(C)) {
                                    if (l.slice(M).search(C)) {
                                        var J, Q = z;
                                        for (C.global || (C = tp(C.source, W(e2.exec(C)) + "g")), C.lastIndex = 0; J = C.exec(Q);) var X = J.index;
                                        z = z.slice(0, X === p ? M : X)
                                    }
                                } else if (l.indexOf(ln(C), M) != M) {
                                    var es = z.lastIndexOf(C);
                                    es > -1 && (z = z.slice(0, es))
                                }
                                return z + _
                            }, a.unescape = function(l) {
                                return (l = W(l)) && eL.test(l) ? l.replace(eT, rt) : l
                            }, a.uniqueId = function(l) {
                                var c = ++tA;
                                return W(l) + c
                            }, a.upperCase = iu, a.upperFirst = ih, a.each = Zu, a.eachRight = Ju, a.first = Gu, Li(a, (ta = {}, $n(a, function(l, c) {
                                tE.call(a.prototype, c) || (ta[c] = l)
                            }), ta), {
                                chain: !1
                            }), a.VERSION = "4.17.21", mn(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function(l) {
                                a[l].placeholder = a
                            }), mn(["drop", "take"], function(l, c) {
                                H.prototype[l] = function(v) {
                                    v = v === p ? 1 : rm(R(v), 0);
                                    var _ = this.__filtered__ && !c ? new H(this) : this.clone();
                                    return _.__filtered__ ? _.__takeCount__ = ry(v, _.__takeCount__) : _.__views__.push({
                                        size: ry(v, 4294967295),
                                        type: l + (_.__dir__ < 0 ? "Right" : "")
                                    }), _
                                }, H.prototype[l + "Right"] = function(c) {
                                    return this.reverse()[l](c).reverse()
                                }
                            }), mn(["filter", "map", "takeWhile"], function(l, c) {
                                var p = c + 1,
                                    v = 1 == p || 3 == p;
                                H.prototype[l] = function(l) {
                                    var c = this.clone();
                                    return c.__iteratees__.push({
                                        iteratee: x(l, 3),
                                        type: p
                                    }), c.__filtered__ = c.__filtered__ || v, c
                                }
                            }), mn(["head", "last"], function(l, c) {
                                var p = "take" + (c ? "Right" : "");
                                H.prototype[l] = function() {
                                    return this[p](1).value()[0]
                                }
                            }), mn(["initial", "tail"], function(l, c) {
                                var p = "drop" + (c ? "" : "Right");
                                H.prototype[l] = function() {
                                    return this.__filtered__ ? new H(this) : this[p](1)
                                }
                            }), H.prototype.compact = function() {
                                return this.filter(fn)
                            }, H.prototype.find = function(l) {
                                return this.filter(l).head()
                            }, H.prototype.findLast = function(l) {
                                return this.reverse().find(l)
                            }, H.prototype.invokeMap = L(function(l, c) {
                                return "function" == typeof l ? new H(this) : this.map(function(p) {
                                    return ae(p, l, c)
                                })
                            }), H.prototype.reject = function(l) {
                                return this.filter(ur(x(l)))
                            }, H.prototype.slice = function(l, c) {
                                l = R(l);
                                var v = this;
                                return v.__filtered__ && (l > 0 || c < 0) ? new H(v) : (l < 0 ? v = v.takeRight(-l) : l && (v = v.drop(l)), c !== p && (v = (c = R(c)) < 0 ? v.dropRight(-c) : v.take(c - l)), v)
                            }, H.prototype.takeRightWhile = function(l) {
                                return this.reverse().takeWhile(l).reverse()
                            }, H.prototype.toArray = function() {
                                return this.take(4294967295)
                            }, $n(H.prototype, function(l, c) {
                                var v = /^(?:filter|find|map|reject)|While$/.test(c),
                                    _ = /^(?:head|last)$/.test(c),
                                    C = a[_ ? "take" + ("last" == c ? "Right" : "") : c],
                                    P = _ || /^find/.test(c);
                                C && (a.prototype[c] = function() {
                                    var c = this.__wrapped__,
                                        T = _ ? [1] : arguments,
                                        M = c instanceof H,
                                        z = T[0],
                                        J = M || nM(c),
                                        m = function(l) {
                                            var c = C.apply(a, nt([l], T));
                                            return _ && Q ? c[0] : c
                                        };
                                    J && v && "function" == typeof z && 1 != z.length && (M = J = !1);
                                    var Q = this.__chain__,
                                        X = !!this.__actions__.length,
                                        es = P && !Q,
                                        eo = M && !X;
                                    if (!P && J) {
                                        c = eo ? c : new H(this);
                                        var el = l.apply(c, T);
                                        return el.__actions__.push({
                                            func: er,
                                            args: [m],
                                            thisArg: p
                                        }), new Pn(el, Q)
                                    }
                                    return es && eo ? l.apply(this, T) : (el = this.thru(m), es ? _ ? el.value()[0] : el.value() : el)
                                })
                            }), mn(["pop", "push", "shift", "sort", "splice", "unshift"], function(l) {
                                var c = ty[l],
                                    p = /^(?:push|sort|unshift)$/.test(l) ? "tap" : "thru",
                                    v = /^(?:pop|shift)$/.test(l);
                                a.prototype[l] = function() {
                                    var l = arguments;
                                    if (v && !this.__chain__) {
                                        var _ = this.value();
                                        return c.apply(nM(_) ? _ : [], l)
                                    }
                                    return this[p](function(p) {
                                        return c.apply(nM(p) ? p : [], l)
                                    })
                                }
                            }), $n(H.prototype, function(l, c) {
                                var p = a[c];
                                if (p) {
                                    var v = p.name + "";
                                    tE.call(rk, v) || (rk[v] = []), rk[v].push({
                                        name: c,
                                        func: p
                                    })
                                }
                            }), rk[Xe(p, 2).name] = [{
                                name: "wrapper",
                                func: p
                            }], H.prototype.clone = function() {
                                var l = new H(this.__wrapped__);
                                return l.__actions__ = un(this.__actions__), l.__dir__ = this.__dir__, l.__filtered__ = this.__filtered__, l.__iteratees__ = un(this.__iteratees__), l.__takeCount__ = this.__takeCount__, l.__views__ = un(this.__views__), l
                            }, H.prototype.reverse = function() {
                                if (this.__filtered__) {
                                    var l = new H(this);
                                    l.__dir__ = -1, l.__filtered__ = !0
                                } else l = this.clone(), l.__dir__ *= -1;
                                return l
                            }, H.prototype.value = function() {
                                var l = this.__wrapped__.value(),
                                    c = this.__dir__,
                                    p = nM(l),
                                    v = c < 0,
                                    _ = p ? l.length : 0,
                                    C = function(l, c, p) {
                                        for (var v = -1, _ = p.length; ++v < _;) {
                                            var C = p[v],
                                                P = C.size;
                                            switch (C.type) {
                                                case "drop":
                                                    l += P;
                                                    break;
                                                case "dropRight":
                                                    c -= P;
                                                    break;
                                                case "take":
                                                    c = ry(c, l + P);
                                                    break;
                                                case "takeRight":
                                                    l = rm(l, c - P)
                                            }
                                        }
                                        return {
                                            start: l,
                                            end: c
                                        }
                                    }(0, _, this.__views__),
                                    P = C.start,
                                    T = C.end,
                                    M = T - P,
                                    z = v ? T : P - 1,
                                    J = this.__iteratees__,
                                    Q = J.length,
                                    X = 0,
                                    es = ry(M, this.__takeCount__);
                                if (!p || !v && _ == M && es == M) return ou(l, this.__actions__);
                                var eo = [];
                                e: for (; M-- && X < es;) {
                                    z += c;
                                    for (var el = -1, ec = l[z]; ++el < Q;) {
                                        var eh = J[el],
                                            ed = eh.iteratee,
                                            ef = eh.type,
                                            ep = ed(ec);
                                        if (2 == ef) ec = ep;
                                        else if (!ep) {
                                            if (1 == ef) continue e;
                                            break e
                                        }
                                    }
                                    eo[X++] = ec
                                }
                                return eo
                            }, a.prototype.at = ng, a.prototype.chain = function() {
                                return Yu(this)
                            }, a.prototype.commit = function() {
                                return new Pn(this.value(), this.__chain__)
                            }, a.prototype.next = function() {
                                this.__values__ === p && (this.__values__ = ua(this.value()));
                                var l = this.__index__ >= this.__values__.length,
                                    c = l ? p : this.__values__[this.__index__++];
                                return {
                                    done: l,
                                    value: c
                                }
                            }, a.prototype.plant = function(l) {
                                for (var c, v = this; v instanceof qe;) {
                                    var _ = Fu(v);
                                    _.__index__ = 0, _.__values__ = p, c ? C.__wrapped__ = _ : c = _;
                                    var C = _;
                                    v = v.__wrapped__
                                }
                                return C.__wrapped__ = l, c
                            }, a.prototype.reverse = function() {
                                var l = this.__wrapped__;
                                if (l instanceof H) {
                                    var c = l;
                                    return this.__actions__.length && (c = new H(this)), (c = c.reverse()).__actions__.push({
                                        func: er,
                                        args: [Ai],
                                        thisArg: p
                                    }), new Pn(c, this.__chain__)
                                }
                                return this.thru(Ai)
                            }, a.prototype.toJSON = a.prototype.valueOf = a.prototype.value = function() {
                                return ou(this.__wrapped__, this.__actions__)
                            }, a.prototype.first = a.prototype.head, tQ && (a.prototype[tQ] = function() {
                                return this
                            }), a
                        }();
                    t$ ? ((t$.exports = rs)._ = rs, tQ._ = rs) : tJ._ = rs
                }).call(nW)
            }(nG, nG.exports);
            var nK = Object.defineProperty,
                nZ = Object.defineProperties,
                nJ = Object.getOwnPropertyDescriptors,
                nQ = Object.getOwnPropertySymbols,
                n$ = Object.prototype.hasOwnProperty,
                nY = Object.prototype.propertyIsEnumerable,
                ya = (l, c, p) => c in l ? nK(l, c, {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: p
                }) : l[c] = p,
                index_es_cr = (l, c) => {
                    for (var p in c || (c = {})) n$.call(c, p) && ya(l, p, c[p]);
                    if (nQ)
                        for (var p of nQ(c)) nY.call(c, p) && ya(l, p, c[p]);
                    return l
                },
                Yg = (l, c) => nZ(l, nJ(c));

            function dist_index_es_ft(l, c, p) {
                var v;
                let _ = function(l) {
                    let [c, p] = l.split(":");
                    return {
                        namespace: c,
                        reference: p
                    }
                }(l);
                return (null == (v = c.rpcMap) ? void 0 : v[_.reference]) || `https://rpc.walletconnect.com/v1/?chainId=${_.namespace}:${_.reference}&projectId=${p}`
            }

            function dist_index_es_Ct(l) {
                return l.includes(":") ? l.split(":")[1] : l
            }

            function Sa(l) {
                return l.map(l => `${l.split(":")[0]}:${l.split(":")[1]}`)
            }

            function Oa(l) {
                var c, p, v, _;
                let C = {};
                if (!B(l)) return C;
                for (let [P, T] of Object.entries(l)) {
                    let l = oe(P) ? [P] : T.chains,
                        M = T.methods || [],
                        z = T.events || [],
                        J = T.rpcMap || {},
                        Q = Xe(P);
                    C[Q] = Yg(index_es_cr(index_es_cr({}, C[Q]), T), {
                        chains: S(l, null == (c = C[Q]) ? void 0 : c.chains),
                        methods: S(M, null == (p = C[Q]) ? void 0 : p.methods),
                        events: S(z, null == (v = C[Q]) ? void 0 : v.events),
                        rpcMap: index_es_cr(index_es_cr({}, J), null == (_ = C[Q]) ? void 0 : _.rpcMap)
                    })
                }
                return C
            }

            function Xg(l) {
                return l.includes(":") ? l.split(":")[2] : l
            }

            function index_es_Wi(l) {
                return "number" == typeof l ? l : l.includes("0x") ? parseInt(l, 16) : l.includes(":") ? Number(l.split(":")[1]) : Number(l)
            }
            let nX = {},
                index_es_z = l => nX[l],
                Fi = (l, c) => {
                    nX[l] = c
                };
            let Vg = class Vg {
                constructor(l) {
                    this.name = "polkadot", this.namespace = l.namespace, this.events = index_es_z("events"), this.client = index_es_z("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders()
                }
                updateNamespace(l) {
                    this.namespace = Object.assign(this.namespace, l)
                }
                requestAccounts() {
                    return this.getAccounts()
                }
                getDefaultChain() {
                    if (this.chainId) return this.chainId;
                    if (this.namespace.defaultChain) return this.namespace.defaultChain;
                    let l = this.namespace.chains[0];
                    if (!l) throw Error("ChainId not found");
                    return l.split(":")[1]
                }
                request(l) {
                    return this.namespace.methods.includes(l.request.method) ? this.client.request(l) : this.getHttpProvider().request(l.request)
                }
                setDefaultChain(l, c) {
                    this.httpProviders[l] || this.setHttpProvider(l, c), this.chainId = l, this.events.emit(nq.DEFAULT_CHAIN_CHANGED, `${this.name}:${l}`)
                }
                getAccounts() {
                    let l = this.namespace.accounts;
                    return l && l.filter(l => l.split(":")[1] === this.chainId.toString()).map(l => l.split(":")[2]) || []
                }
                createHttpProviders() {
                    let l = {};
                    return this.namespace.chains.forEach(c => {
                        var p;
                        let v = dist_index_es_Ct(c);
                        l[v] = this.createHttpProvider(v, null == (p = this.namespace.rpcMap) ? void 0 : p[c])
                    }), l
                }
                getHttpProvider() {
                    let l = `${this.name}:${this.chainId}`,
                        c = this.httpProviders[l];
                    if (typeof c > "u") throw Error(`JSON-RPC provider for ${l} not found`);
                    return c
                }
                setHttpProvider(l, c) {
                    let p = this.createHttpProvider(l, c);
                    p && (this.httpProviders[l] = p)
                }
                createHttpProvider(l, c) {
                    let p = c || dist_index_es_ft(l, this.namespace, this.client.core.projectId);
                    if (!p) throw Error(`No RPC url provided for chainId: ${l}`);
                    return new JsonRpcProvider(new HttpConnection(p, index_es_z("disableProviderPing")))
                }
            };
            let kg = class kg {
                constructor(l) {
                    this.name = "eip155", this.namespace = l.namespace, this.events = index_es_z("events"), this.client = index_es_z("client"), this.httpProviders = this.createHttpProviders(), this.chainId = parseInt(this.getDefaultChain())
                }
                async request(l) {
                    switch (l.request.method) {
                        case "eth_requestAccounts":
                        case "eth_accounts":
                            return this.getAccounts();
                        case "wallet_switchEthereumChain":
                            return await this.handleSwitchChain(l);
                        case "eth_chainId":
                            return parseInt(this.getDefaultChain())
                    }
                    return this.namespace.methods.includes(l.request.method) ? await this.client.request(l) : this.getHttpProvider().request(l.request)
                }
                updateNamespace(l) {
                    this.namespace = Object.assign(this.namespace, l)
                }
                setDefaultChain(l, c) {
                    this.httpProviders[l] || this.setHttpProvider(parseInt(l), c), this.chainId = parseInt(l), this.events.emit(nq.DEFAULT_CHAIN_CHANGED, `${this.name}:${l}`)
                }
                requestAccounts() {
                    return this.getAccounts()
                }
                getDefaultChain() {
                    if (this.chainId) return this.chainId.toString();
                    if (this.namespace.defaultChain) return this.namespace.defaultChain;
                    let l = this.namespace.chains[0];
                    if (!l) throw Error("ChainId not found");
                    return l.split(":")[1]
                }
                createHttpProvider(l, c) {
                    let p = c || dist_index_es_ft(`${this.name}:${l}`, this.namespace, this.client.core.projectId);
                    if (!p) throw Error(`No RPC url provided for chainId: ${l}`);
                    return new JsonRpcProvider(new HttpConnection(p, index_es_z("disableProviderPing")))
                }
                setHttpProvider(l, c) {
                    let p = this.createHttpProvider(l, c);
                    p && (this.httpProviders[l] = p)
                }
                createHttpProviders() {
                    let l = {};
                    return this.namespace.chains.forEach(c => {
                        var p;
                        let v = parseInt(dist_index_es_Ct(c));
                        l[v] = this.createHttpProvider(v, null == (p = this.namespace.rpcMap) ? void 0 : p[c])
                    }), l
                }
                getAccounts() {
                    let l = this.namespace.accounts;
                    return l ? [...new Set(l.filter(l => l.split(":")[1] === this.chainId.toString()).map(l => l.split(":")[2]))] : []
                }
                getHttpProvider() {
                    let l = this.chainId,
                        c = this.httpProviders[l];
                    if (typeof c > "u") throw Error(`JSON-RPC provider for ${l} not found`);
                    return c
                }
                async handleSwitchChain(l) {
                    var c, p;
                    let v = l.request.params ? null == (c = l.request.params[0]) ? void 0 : c.chainId : "0x0";
                    v = v.startsWith("0x") ? v : `0x${v}`;
                    let _ = parseInt(v, 16);
                    if (this.isChainApproved(_)) this.setDefaultChain(`${_}`);
                    else if (this.namespace.methods.includes("wallet_switchEthereumChain")) await this.client.request({
                        topic: l.topic,
                        request: {
                            method: l.request.method,
                            params: [{
                                chainId: v
                            }]
                        },
                        chainId: null == (p = this.namespace.chains) ? void 0 : p[0]
                    }), this.setDefaultChain(`${_}`);
                    else throw Error(`Failed to switch to chain 'eip155:${_}'. The chain is not approved or the wallet does not support 'wallet_switchEthereumChain' method.`);
                    return null
                }
                isChainApproved(l) {
                    return this.namespace.chains.includes(`${this.name}:${l}`)
                }
            };
            let jg = class jg {
                constructor(l) {
                    this.name = "solana", this.namespace = l.namespace, this.events = index_es_z("events"), this.client = index_es_z("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders()
                }
                updateNamespace(l) {
                    this.namespace = Object.assign(this.namespace, l)
                }
                requestAccounts() {
                    return this.getAccounts()
                }
                request(l) {
                    return this.namespace.methods.includes(l.request.method) ? this.client.request(l) : this.getHttpProvider().request(l.request)
                }
                setDefaultChain(l, c) {
                    this.httpProviders[l] || this.setHttpProvider(l, c), this.chainId = l, this.events.emit(nq.DEFAULT_CHAIN_CHANGED, `${this.name}:${l}`)
                }
                getDefaultChain() {
                    if (this.chainId) return this.chainId;
                    if (this.namespace.defaultChain) return this.namespace.defaultChain;
                    let l = this.namespace.chains[0];
                    if (!l) throw Error("ChainId not found");
                    return l.split(":")[1]
                }
                getAccounts() {
                    let l = this.namespace.accounts;
                    return l ? [...new Set(l.filter(l => l.split(":")[1] === this.chainId.toString()).map(l => l.split(":")[2]))] : []
                }
                createHttpProviders() {
                    let l = {};
                    return this.namespace.chains.forEach(c => {
                        var p;
                        let v = dist_index_es_Ct(c);
                        l[v] = this.createHttpProvider(v, null == (p = this.namespace.rpcMap) ? void 0 : p[c])
                    }), l
                }
                getHttpProvider() {
                    let l = `${this.name}:${this.chainId}`,
                        c = this.httpProviders[l];
                    if (typeof c > "u") throw Error(`JSON-RPC provider for ${l} not found`);
                    return c
                }
                setHttpProvider(l, c) {
                    let p = this.createHttpProvider(l, c);
                    p && (this.httpProviders[l] = p)
                }
                createHttpProvider(l, c) {
                    let p = c || dist_index_es_ft(l, this.namespace, this.client.core.projectId);
                    if (!p) throw Error(`No RPC url provided for chainId: ${l}`);
                    return new JsonRpcProvider(new HttpConnection(p, index_es_z("disableProviderPing")))
                }
            };
            let nv = class nv {
                constructor(l) {
                    this.name = "cosmos", this.namespace = l.namespace, this.events = index_es_z("events"), this.client = index_es_z("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders()
                }
                updateNamespace(l) {
                    this.namespace = Object.assign(this.namespace, l)
                }
                requestAccounts() {
                    return this.getAccounts()
                }
                getDefaultChain() {
                    if (this.chainId) return this.chainId;
                    if (this.namespace.defaultChain) return this.namespace.defaultChain;
                    let l = this.namespace.chains[0];
                    if (!l) throw Error("ChainId not found");
                    return l.split(":")[1]
                }
                request(l) {
                    return this.namespace.methods.includes(l.request.method) ? this.client.request(l) : this.getHttpProvider().request(l.request)
                }
                setDefaultChain(l, c) {
                    this.httpProviders[l] || this.setHttpProvider(l, c), this.chainId = l, this.events.emit(nq.DEFAULT_CHAIN_CHANGED, `${this.name}:${this.chainId}`)
                }
                getAccounts() {
                    let l = this.namespace.accounts;
                    return l ? [...new Set(l.filter(l => l.split(":")[1] === this.chainId.toString()).map(l => l.split(":")[2]))] : []
                }
                createHttpProviders() {
                    let l = {};
                    return this.namespace.chains.forEach(c => {
                        var p;
                        let v = dist_index_es_Ct(c);
                        l[v] = this.createHttpProvider(v, null == (p = this.namespace.rpcMap) ? void 0 : p[c])
                    }), l
                }
                getHttpProvider() {
                    let l = `${this.name}:${this.chainId}`,
                        c = this.httpProviders[l];
                    if (typeof c > "u") throw Error(`JSON-RPC provider for ${l} not found`);
                    return c
                }
                setHttpProvider(l, c) {
                    let p = this.createHttpProvider(l, c);
                    p && (this.httpProviders[l] = p)
                }
                createHttpProvider(l, c) {
                    let p = c || dist_index_es_ft(l, this.namespace, this.client.core.projectId);
                    if (!p) throw Error(`No RPC url provided for chainId: ${l}`);
                    return new JsonRpcProvider(new HttpConnection(p, index_es_z("disableProviderPing")))
                }
            };
            let tv = class tv {
                constructor(l) {
                    this.name = "cip34", this.namespace = l.namespace, this.events = index_es_z("events"), this.client = index_es_z("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders()
                }
                updateNamespace(l) {
                    this.namespace = Object.assign(this.namespace, l)
                }
                requestAccounts() {
                    return this.getAccounts()
                }
                getDefaultChain() {
                    if (this.chainId) return this.chainId;
                    if (this.namespace.defaultChain) return this.namespace.defaultChain;
                    let l = this.namespace.chains[0];
                    if (!l) throw Error("ChainId not found");
                    return l.split(":")[1]
                }
                request(l) {
                    return this.namespace.methods.includes(l.request.method) ? this.client.request(l) : this.getHttpProvider().request(l.request)
                }
                setDefaultChain(l, c) {
                    this.httpProviders[l] || this.setHttpProvider(l, c), this.chainId = l, this.events.emit(nq.DEFAULT_CHAIN_CHANGED, `${this.name}:${this.chainId}`)
                }
                getAccounts() {
                    let l = this.namespace.accounts;
                    return l ? [...new Set(l.filter(l => l.split(":")[1] === this.chainId.toString()).map(l => l.split(":")[2]))] : []
                }
                createHttpProviders() {
                    let l = {};
                    return this.namespace.chains.forEach(c => {
                        let p = this.getCardanoRPCUrl(c),
                            v = dist_index_es_Ct(c);
                        l[v] = this.createHttpProvider(v, p)
                    }), l
                }
                getHttpProvider() {
                    let l = `${this.name}:${this.chainId}`,
                        c = this.httpProviders[l];
                    if (typeof c > "u") throw Error(`JSON-RPC provider for ${l} not found`);
                    return c
                }
                getCardanoRPCUrl(l) {
                    let c = this.namespace.rpcMap;
                    if (c) return c[l]
                }
                setHttpProvider(l, c) {
                    let p = this.createHttpProvider(l, c);
                    p && (this.httpProviders[l] = p)
                }
                createHttpProvider(l, c) {
                    let p = c || this.getCardanoRPCUrl(l);
                    if (!p) throw Error(`No RPC url provided for chainId: ${l}`);
                    return new JsonRpcProvider(new HttpConnection(p, index_es_z("disableProviderPing")))
                }
            };
            let ev = class ev {
                constructor(l) {
                    this.name = "elrond", this.namespace = l.namespace, this.events = index_es_z("events"), this.client = index_es_z("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders()
                }
                updateNamespace(l) {
                    this.namespace = Object.assign(this.namespace, l)
                }
                requestAccounts() {
                    return this.getAccounts()
                }
                request(l) {
                    return this.namespace.methods.includes(l.request.method) ? this.client.request(l) : this.getHttpProvider().request(l.request)
                }
                setDefaultChain(l, c) {
                    this.httpProviders[l] || this.setHttpProvider(l, c), this.chainId = l, this.events.emit(nq.DEFAULT_CHAIN_CHANGED, `${this.name}:${l}`)
                }
                getDefaultChain() {
                    if (this.chainId) return this.chainId;
                    if (this.namespace.defaultChain) return this.namespace.defaultChain;
                    let l = this.namespace.chains[0];
                    if (!l) throw Error("ChainId not found");
                    return l.split(":")[1]
                }
                getAccounts() {
                    let l = this.namespace.accounts;
                    return l ? [...new Set(l.filter(l => l.split(":")[1] === this.chainId.toString()).map(l => l.split(":")[2]))] : []
                }
                createHttpProviders() {
                    let l = {};
                    return this.namespace.chains.forEach(c => {
                        var p;
                        let v = dist_index_es_Ct(c);
                        l[v] = this.createHttpProvider(v, null == (p = this.namespace.rpcMap) ? void 0 : p[c])
                    }), l
                }
                getHttpProvider() {
                    let l = `${this.name}:${this.chainId}`,
                        c = this.httpProviders[l];
                    if (typeof c > "u") throw Error(`JSON-RPC provider for ${l} not found`);
                    return c
                }
                setHttpProvider(l, c) {
                    let p = this.createHttpProvider(l, c);
                    p && (this.httpProviders[l] = p)
                }
                createHttpProvider(l, c) {
                    let p = c || dist_index_es_ft(l, this.namespace, this.client.core.projectId);
                    if (!p) throw Error(`No RPC url provided for chainId: ${l}`);
                    return new JsonRpcProvider(new HttpConnection(p, index_es_z("disableProviderPing")))
                }
            };
            let rv = class rv {
                constructor(l) {
                    this.name = "multiversx", this.namespace = l.namespace, this.events = index_es_z("events"), this.client = index_es_z("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders()
                }
                updateNamespace(l) {
                    this.namespace = Object.assign(this.namespace, l)
                }
                requestAccounts() {
                    return this.getAccounts()
                }
                request(l) {
                    return this.namespace.methods.includes(l.request.method) ? this.client.request(l) : this.getHttpProvider().request(l.request)
                }
                setDefaultChain(l, c) {
                    this.httpProviders[l] || this.setHttpProvider(l, c), this.chainId = l, this.events.emit(nq.DEFAULT_CHAIN_CHANGED, `${this.name}:${l}`)
                }
                getDefaultChain() {
                    if (this.chainId) return this.chainId;
                    if (this.namespace.defaultChain) return this.namespace.defaultChain;
                    let l = this.namespace.chains[0];
                    if (!l) throw Error("ChainId not found");
                    return l.split(":")[1]
                }
                getAccounts() {
                    let l = this.namespace.accounts;
                    return l ? [...new Set(l.filter(l => l.split(":")[1] === this.chainId.toString()).map(l => l.split(":")[2]))] : []
                }
                createHttpProviders() {
                    let l = {};
                    return this.namespace.chains.forEach(c => {
                        var p;
                        let v = dist_index_es_Ct(c);
                        l[v] = this.createHttpProvider(v, null == (p = this.namespace.rpcMap) ? void 0 : p[c])
                    }), l
                }
                getHttpProvider() {
                    let l = `${this.name}:${this.chainId}`,
                        c = this.httpProviders[l];
                    if (typeof c > "u") throw Error(`JSON-RPC provider for ${l} not found`);
                    return c
                }
                setHttpProvider(l, c) {
                    let p = this.createHttpProvider(l, c);
                    p && (this.httpProviders[l] = p)
                }
                createHttpProvider(l, c) {
                    let p = c || dist_index_es_ft(l, this.namespace, this.client.core.projectId);
                    if (!p) throw Error(`No RPC url provided for chainId: ${l}`);
                    return new JsonRpcProvider(new HttpConnection(p, index_es_z("disableProviderPing")))
                }
            };
            let iv = class iv {
                constructor(l) {
                    this.name = "near", this.namespace = l.namespace, this.events = index_es_z("events"), this.client = index_es_z("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders()
                }
                updateNamespace(l) {
                    this.namespace = Object.assign(this.namespace, l)
                }
                requestAccounts() {
                    return this.getAccounts()
                }
                getDefaultChain() {
                    if (this.chainId) return this.chainId;
                    if (this.namespace.defaultChain) return this.namespace.defaultChain;
                    let l = this.namespace.chains[0];
                    if (!l) throw Error("ChainId not found");
                    return l.split(":")[1]
                }
                request(l) {
                    return this.namespace.methods.includes(l.request.method) ? this.client.request(l) : this.getHttpProvider().request(l.request)
                }
                setDefaultChain(l, c) {
                    if (this.chainId = l, !this.httpProviders[l]) {
                        let p = c || dist_index_es_ft(`${this.name}:${l}`, this.namespace);
                        if (!p) throw Error(`No RPC url provided for chainId: ${l}`);
                        this.setHttpProvider(l, p)
                    }
                    this.events.emit(nq.DEFAULT_CHAIN_CHANGED, `${this.name}:${this.chainId}`)
                }
                getAccounts() {
                    let l = this.namespace.accounts;
                    return l && l.filter(l => l.split(":")[1] === this.chainId.toString()).map(l => l.split(":")[2]) || []
                }
                createHttpProviders() {
                    let l = {};
                    return this.namespace.chains.forEach(c => {
                        var p;
                        l[c] = this.createHttpProvider(c, null == (p = this.namespace.rpcMap) ? void 0 : p[c])
                    }), l
                }
                getHttpProvider() {
                    let l = `${this.name}:${this.chainId}`,
                        c = this.httpProviders[l];
                    if (typeof c > "u") throw Error(`JSON-RPC provider for ${l} not found`);
                    return c
                }
                setHttpProvider(l, c) {
                    let p = this.createHttpProvider(l, c);
                    p && (this.httpProviders[l] = p)
                }
                createHttpProvider(l, c) {
                    let p = c || dist_index_es_ft(l, this.namespace);
                    return typeof p > "u" ? void 0 : new JsonRpcProvider(new HttpConnection(p, index_es_z("disableProviderPing")))
                }
            };
            var n0 = Object.defineProperty,
                n1 = Object.defineProperties,
                n2 = Object.getOwnPropertyDescriptors,
                n5 = Object.getOwnPropertySymbols,
                n3 = Object.prototype.hasOwnProperty,
                n6 = Object.prototype.propertyIsEnumerable,
                Ta = (l, c, p) => c in l ? n0(l, c, {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: p
                }) : l[c] = p,
                index_es_hr = (l, c) => {
                    for (var p in c || (c = {})) n3.call(c, p) && Ta(l, p, c[p]);
                    if (n5)
                        for (var p of n5(c)) n6.call(c, p) && Ta(l, p, c[p]);
                    return l
                },
                Mi = (l, c) => n1(l, n2(c));
            let index_es_lr = class index_es_lr {
                constructor(l) {
                    this.events = new(ep()), this.rpcProviders = {}, this.shouldAbortPairingAttempt = !1, this.maxPairingAttempts = 10, this.disableProviderPing = !1, this.providerOpts = l, this.logger = "u" > typeof l ? .logger && "string" != typeof l ? .logger ? l.logger : (0, tB.pino)((0, tB.getDefaultLoggerOptions)({
                        level: l ? .logger || nV
                    })), this.disableProviderPing = l ? .disableProviderPing || !1
                }
                static async init(l) {
                    let c = new index_es_lr(l);
                    return await c.initialize(), c
                }
                async request(l, c) {
                    let [p, v] = this.validateChain(c);
                    if (!this.session) throw Error("Please call connect() before request()");
                    return await this.getProvider(p).request({
                        request: index_es_hr({}, l),
                        chainId: `${p}:${v}`,
                        topic: this.session.topic
                    })
                }
                sendAsync(l, c, p) {
                    this.request(l, p).then(l => c(null, l)).catch(l => c(l, void 0))
                }
                async enable() {
                    if (!this.client) throw Error("Sign Client not initialized");
                    return this.session || await this.connect({
                        namespaces: this.namespaces,
                        optionalNamespaces: this.optionalNamespaces,
                        sessionProperties: this.sessionProperties
                    }), await this.requestAccounts()
                }
                async disconnect() {
                    var l;
                    if (!this.session) throw Error("Please call connect() before enable()");
                    await this.client.disconnect({
                        topic: null == (l = this.session) ? void 0 : l.topic,
                        reason: U("USER_DISCONNECTED")
                    }), await this.cleanup()
                }
                async connect(l) {
                    if (!this.client) throw Error("Sign Client not initialized");
                    if (this.setNamespaces(l), await this.cleanupPendingPairings(), !l.skipPairing) return await this.pair(l.pairingTopic)
                }
                on(l, c) {
                    this.events.on(l, c)
                }
                once(l, c) {
                    this.events.once(l, c)
                }
                removeListener(l, c) {
                    this.events.removeListener(l, c)
                }
                off(l, c) {
                    this.events.off(l, c)
                }
                get isWalletConnect() {
                    return !0
                }
                async pair(l) {
                    this.shouldAbortPairingAttempt = !1;
                    let c = 0;
                    do {
                        if (this.shouldAbortPairingAttempt) throw Error("Pairing aborted");
                        if (c >= this.maxPairingAttempts) throw Error("Max auto pairing attempts reached");
                        let {
                            uri: p,
                            approval: v
                        } = await this.client.connect({
                            pairingTopic: l,
                            requiredNamespaces: this.namespaces,
                            optionalNamespaces: this.optionalNamespaces,
                            sessionProperties: this.sessionProperties
                        });
                        p && (this.uri = p, this.events.emit("display_uri", p)), await v().then(l => {
                            this.session = l, this.namespaces || (this.namespaces = function(l) {
                                let c = {};
                                for (let [p, v] of Object.entries(l)) {
                                    let l = v.methods || [],
                                        _ = v.events || [],
                                        C = v.accounts || [],
                                        P = oe(p) ? [p] : v.chains ? v.chains : Sa(v.accounts);
                                    c[p] = {
                                        chains: P,
                                        methods: l,
                                        events: _,
                                        accounts: C
                                    }
                                }
                                return c
                            }(l.namespaces), this.persist("namespaces", this.namespaces))
                        }).catch(l => {
                            if (l.message !== nN) throw l;
                            c++
                        })
                    } while (!this.session);
                    return this.onConnect(), this.session
                }
                setDefaultChain(l, c) {
                    try {
                        if (!this.session) return;
                        let [p, v] = this.validateChain(l);
                        this.getProvider(p).setDefaultChain(v, c)
                    } catch (l) {
                        if (!/Please call connect/.test(l.message)) throw l
                    }
                }
                async cleanupPendingPairings(l = {}) {
                    this.logger.info("Cleaning up inactive pairings...");
                    let c = this.client.pairing.getAll();
                    if (D(c)) {
                        for (let p of c) l.deletePairings ? this.client.core.expirer.set(p.topic, 0) : await this.client.core.relayer.subscriber.unsubscribe(p.topic);
                        this.logger.info(`Inactive pairings cleared: ${c.length}`)
                    }
                }
                abortPairingAttempt() {
                    this.shouldAbortPairingAttempt = !0
                }
                async checkStorage() {
                    if (this.namespaces = await this.getFromStore("namespaces"), this.optionalNamespaces = await this.getFromStore("optionalNamespaces") || {}, this.client.session.length) {
                        let l = this.client.session.keys.length - 1;
                        this.session = this.client.session.get(this.client.session.keys[l]), this.createProviders()
                    }
                }
                async initialize() {
                    this.logger.trace("Initialized"), await this.createClient(), await this.checkStorage(), this.registerEventListeners()
                }
                async createClient() {
                    this.client = this.providerOpts.client || await dist_index_es_Q.init({
                        logger: this.providerOpts.logger || nV,
                        relayUrl: this.providerOpts.relayUrl || "wss://relay.walletconnect.com",
                        projectId: this.providerOpts.projectId,
                        metadata: this.providerOpts.metadata,
                        storageOptions: this.providerOpts.storageOptions,
                        storage: this.providerOpts.storage,
                        name: this.providerOpts.name
                    }), this.logger.trace("SignClient Initialized")
                }
                createProviders() {
                    if (!this.client) throw Error("Sign Client not initialized");
                    if (!this.session) throw Error("Session not initialized. Please call connect() before enable()");
                    let l = [...new Set(Object.keys(this.session.namespaces).map(l => Xe(l)))];
                    Fi("client", this.client), Fi("events", this.events), Fi("disableProviderPing", this.disableProviderPing), l.forEach(l => {
                        if (!this.session) return;
                        let c = function(l, c) {
                                let p = Object.keys(c.namespaces).filter(c => c.includes(l));
                                if (!p.length) return [];
                                let v = [];
                                return p.forEach(l => {
                                    let p = c.namespaces[l].accounts;
                                    v.push(...p)
                                }), v
                            }(l, this.session),
                            p = Sa(c),
                            v = function(l = {}, c = {}) {
                                let p = Oa(l),
                                    v = Oa(c);
                                return nG.exports.merge(p, v)
                            }(this.namespaces, this.optionalNamespaces),
                            _ = Mi(index_es_hr({}, v[l]), {
                                accounts: c,
                                chains: p
                            });
                        switch (l) {
                            case "eip155":
                                this.rpcProviders[l] = new kg({
                                    namespace: _
                                });
                                break;
                            case "solana":
                                this.rpcProviders[l] = new jg({
                                    namespace: _
                                });
                                break;
                            case "cosmos":
                                this.rpcProviders[l] = new nv({
                                    namespace: _
                                });
                                break;
                            case "polkadot":
                                this.rpcProviders[l] = new Vg({
                                    namespace: _
                                });
                                break;
                            case "cip34":
                                this.rpcProviders[l] = new tv({
                                    namespace: _
                                });
                                break;
                            case "elrond":
                                this.rpcProviders[l] = new ev({
                                    namespace: _
                                });
                                break;
                            case "multiversx":
                                this.rpcProviders[l] = new rv({
                                    namespace: _
                                });
                                break;
                            case "near":
                                this.rpcProviders[l] = new iv({
                                    namespace: _
                                })
                        }
                    })
                }
                registerEventListeners() {
                    if (typeof this.client > "u") throw Error("Sign Client is not initialized");
                    this.client.on("session_ping", l => {
                        this.events.emit("session_ping", l)
                    }), this.client.on("session_event", l => {
                        let {
                            params: c
                        } = l, {
                            event: p
                        } = c;
                        if ("accountsChanged" === p.name) {
                            let l = p.data;
                            l && D(l) && this.events.emit("accountsChanged", l.map(Xg))
                        } else if ("chainChanged" === p.name) {
                            let l = c.chainId,
                                p = c.event.data,
                                v = Xe(l),
                                _ = index_es_Wi(l) !== index_es_Wi(p) ? `${v}:${index_es_Wi(p)}` : l;
                            this.onChainChanged(_)
                        } else this.events.emit(p.name, p.data);
                        this.events.emit("session_event", l)
                    }), this.client.on("session_update", ({
                        topic: l,
                        params: c
                    }) => {
                        var p;
                        let {
                            namespaces: v
                        } = c, _ = null == (p = this.client) ? void 0 : p.session.get(l);
                        this.session = Mi(index_es_hr({}, _), {
                            namespaces: v
                        }), this.onSessionUpdate(), this.events.emit("session_update", {
                            topic: l,
                            params: c
                        })
                    }), this.client.on("session_delete", async l => {
                        await this.cleanup(), this.events.emit("session_delete", l), this.events.emit("disconnect", Mi(index_es_hr({}, U("USER_DISCONNECTED")), {
                            data: l.topic
                        }))
                    }), this.on(nq.DEFAULT_CHAIN_CHANGED, l => {
                        this.onChainChanged(l, !0)
                    })
                }
                getProvider(l) {
                    if (!this.rpcProviders[l]) throw Error(`Provider not found: ${l}`);
                    return this.rpcProviders[l]
                }
                onSessionUpdate() {
                    Object.keys(this.rpcProviders).forEach(l => {
                        var c;
                        this.getProvider(l).updateNamespace(null == (c = this.session) ? void 0 : c.namespaces[l])
                    })
                }
                setNamespaces(l) {
                    let {
                        namespaces: c,
                        optionalNamespaces: p,
                        sessionProperties: v
                    } = l;
                    c && Object.keys(c).length && (this.namespaces = c), p && Object.keys(p).length && (this.optionalNamespaces = p), this.sessionProperties = v, this.persist("namespaces", c), this.persist("optionalNamespaces", p)
                }
                validateChain(l) {
                    let [c, p] = l ? .split(":") || ["", ""];
                    if (!this.namespaces || !Object.keys(this.namespaces).length) return [c, p];
                    if (c && !Object.keys(this.namespaces || {}).map(l => Xe(l)).includes(c)) throw Error(`Namespace '${c}' is not configured. Please call connect() first with namespace config.`);
                    if (c && p) return [c, p];
                    let v = Xe(Object.keys(this.namespaces)[0]),
                        _ = this.rpcProviders[v].getDefaultChain();
                    return [v, _]
                }
                async requestAccounts() {
                    let [l] = this.validateChain();
                    return await this.getProvider(l).requestAccounts()
                }
                onChainChanged(l, c = !1) {
                    var p;
                    if (!this.namespaces) return;
                    let [v, _] = this.validateChain(l);
                    c || this.getProvider(v).setDefaultChain(_), (null != (p = this.namespaces[v]) ? p : this.namespaces[`${v}:${_}`]).defaultChain = _, this.persist("namespaces", this.namespaces), this.events.emit("chainChanged", _)
                }
                onConnect() {
                    this.createProviders(), this.events.emit("connect", {
                        session: this.session
                    })
                }
                async cleanup() {
                    this.session = void 0, this.namespaces = void 0, this.optionalNamespaces = void 0, this.sessionProperties = void 0, this.persist("namespaces", void 0), this.persist("optionalNamespaces", void 0), this.persist("sessionProperties", void 0), await this.cleanupPendingPairings({
                        deletePairings: !0
                    })
                }
                persist(l, c) {
                    this.client.core.storage.setItem(`${nz}/${l}`, c)
                }
                async getFromStore(l) {
                    return await this.client.core.storage.getItem(`${nz}/${l}`)
                }
            };
            let n4 = ["eth_sendTransaction", "personal_sign"],
                n8 = ["eth_accounts", "eth_requestAccounts", "eth_sendRawTransaction", "eth_sign", "eth_signTransaction", "eth_signTypedData", "eth_signTypedData_v3", "eth_signTypedData_v4", "eth_sendTransaction", "personal_sign", "wallet_switchEthereumChain", "wallet_addEthereumChain", "wallet_getPermissions", "wallet_requestPermissions", "wallet_registerOnboarding", "wallet_watchAsset", "wallet_scanQRCode"],
                n9 = ["chainChanged", "accountsChanged"],
                n7 = ["chainChanged", "accountsChanged", "message", "disconnect", "connect"];
            var ir = Object.defineProperty,
                is = Object.defineProperties,
                io = Object.getOwnPropertyDescriptors,
                il = Object.getOwnPropertySymbols,
                ic = Object.prototype.hasOwnProperty,
                iu = Object.prototype.propertyIsEnumerable,
                dist_index_es_O = (l, c, p) => c in l ? ir(l, c, {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: p
                }) : l[c] = p,
                dist_index_es_p = (l, c) => {
                    for (var p in c || (c = {})) ic.call(c, p) && dist_index_es_O(l, p, c[p]);
                    if (il)
                        for (var p of il(c)) iu.call(c, p) && dist_index_es_O(l, p, c[p]);
                    return l
                },
                dist_index_es_M = (l, c) => is(l, io(c));

            function ethereum_provider_dist_index_es_g(l) {
                return Number(l[0].split(":")[1])
            }

            function f(l) {
                return `0x${l.toString(16)}`
            }
            let dist_index_es_v = class dist_index_es_v {
                constructor() {
                    this.events = new ef.EventEmitter, this.namespace = "eip155", this.accounts = [], this.chainId = 1, this.STORAGE_KEY = "wc@2:ethereum_provider:", this.on = (l, c) => (this.events.on(l, c), this), this.once = (l, c) => (this.events.once(l, c), this), this.removeListener = (l, c) => (this.events.removeListener(l, c), this), this.off = (l, c) => (this.events.off(l, c), this), this.parseAccount = l => this.isCompatibleChainId(l) ? this.parseAccountId(l).address : l, this.signer = {}, this.rpc = {}
                }
                static async init(l) {
                    let c = new dist_index_es_v;
                    return await c.initialize(l), c
                }
                async request(l) {
                    return await this.signer.request(l, this.formatChainId(this.chainId))
                }
                sendAsync(l, c) {
                    this.signer.sendAsync(l, c, this.formatChainId(this.chainId))
                }
                get connected() {
                    return !!this.signer.client && this.signer.client.core.relayer.connected
                }
                get connecting() {
                    return !!this.signer.client && this.signer.client.core.relayer.connecting
                }
                async enable() {
                    return this.session || await this.connect(), await this.request({
                        method: "eth_requestAccounts"
                    })
                }
                async connect(l) {
                    if (!this.signer.client) throw Error("Provider not initialized. Call init() first");
                    this.loadConnectOpts(l);
                    let {
                        required: c,
                        optional: p
                    } = function(l) {
                        let {
                            chains: c,
                            optionalChains: p,
                            methods: v,
                            optionalMethods: _,
                            events: C,
                            optionalEvents: P,
                            rpcMap: T
                        } = l;
                        if (!D(c)) throw Error("Invalid chains");
                        let M = {
                                chains: c,
                                methods: v || n4,
                                events: C || n9,
                                rpcMap: dist_index_es_p({}, c.length ? {
                                    [ethereum_provider_dist_index_es_g(c)]: T[ethereum_provider_dist_index_es_g(c)]
                                } : {})
                            },
                            z = C ? .filter(l => !n9.includes(l)),
                            J = v ? .filter(l => !n4.includes(l));
                        if (!p && !P && !_ && !(null != z && z.length) && !(null != J && J.length)) return {
                            required: c.length ? M : void 0
                        };
                        let Q = z ? .length && J ? .length || !p,
                            X = {
                                chains: [...new Set(Q ? M.chains.concat(p || []) : p)],
                                methods: [...new Set(M.methods.concat(null != _ && _.length ? _ : n8))],
                                events: [...new Set(M.events.concat(null != P && P.length ? P : n7))],
                                rpcMap: T
                            };
                        return {
                            required: c.length ? M : void 0,
                            optional: p.length ? X : void 0
                        }
                    }(this.rpc);
                    try {
                        let v = await new Promise(async (v, _) => {
                            var C;
                            this.rpc.showQrModal && (null == (C = this.modal) || C.subscribeModal(l => {
                                l.open || this.signer.session || (this.signer.abortPairingAttempt(), _(Error("Connection request reset. Please try again.")))
                            })), await this.signer.connect(dist_index_es_M(dist_index_es_p({
                                namespaces: dist_index_es_p({}, c && {
                                    [this.namespace]: c
                                })
                            }, p && {
                                optionalNamespaces: {
                                    [this.namespace]: p
                                }
                            }), {
                                pairingTopic: l ? .pairingTopic
                            })).then(l => {
                                v(l)
                            }).catch(l => {
                                _(Error(l.message))
                            })
                        });
                        if (!v) return;
                        let _ = function(l, c = []) {
                            let p = [];
                            return Object.keys(l).forEach(v => {
                                if (c.length && !c.includes(v)) return;
                                let _ = l[v];
                                p.push(..._.accounts)
                            }), p
                        }(v.namespaces, [this.namespace]);
                        this.setChainIds(this.rpc.chains.length ? this.rpc.chains : _), this.setAccounts(_), this.events.emit("connect", {
                            chainId: f(this.chainId)
                        })
                    } catch (l) {
                        throw this.signer.logger.error(l), l
                    } finally {
                        this.modal && this.modal.closeModal()
                    }
                }
                async disconnect() {
                    this.session && await this.signer.disconnect(), this.reset()
                }
                get isWalletConnect() {
                    return !0
                }
                get session() {
                    return this.signer.session
                }
                registerEventListeners() {
                    this.signer.on("session_event", l => {
                        let {
                            params: c
                        } = l, {
                            event: p
                        } = c;
                        "accountsChanged" === p.name ? (this.accounts = this.parseAccounts(p.data), this.events.emit("accountsChanged", this.accounts)) : "chainChanged" === p.name ? this.setChainId(this.formatChainId(p.data)) : this.events.emit(p.name, p.data), this.events.emit("session_event", l)
                    }), this.signer.on("chainChanged", l => {
                        let c = parseInt(l);
                        this.chainId = c, this.events.emit("chainChanged", f(this.chainId)), this.persist()
                    }), this.signer.on("session_update", l => {
                        this.events.emit("session_update", l)
                    }), this.signer.on("session_delete", l => {
                        this.reset(), this.events.emit("session_delete", l), this.events.emit("disconnect", dist_index_es_M(dist_index_es_p({}, U("USER_DISCONNECTED")), {
                            data: l.topic,
                            name: "USER_DISCONNECTED"
                        }))
                    }), this.signer.on("display_uri", l => {
                        var c, p;
                        this.rpc.showQrModal && (null == (c = this.modal) || c.closeModal(), null == (p = this.modal) || p.openModal({
                            uri: l
                        })), this.events.emit("display_uri", l)
                    })
                }
                switchEthereumChain(l) {
                    this.request({
                        method: "wallet_switchEthereumChain",
                        params: [{
                            chainId: l.toString(16)
                        }]
                    })
                }
                isCompatibleChainId(l) {
                    return "string" == typeof l && l.startsWith(`${this.namespace}:`)
                }
                formatChainId(l) {
                    return `${this.namespace}:${l}`
                }
                parseChainId(l) {
                    return Number(l.split(":")[1])
                }
                setChainIds(l) {
                    let c = l.filter(l => this.isCompatibleChainId(l)).map(l => this.parseChainId(l));
                    c.length && (this.chainId = c[0], this.events.emit("chainChanged", f(this.chainId)), this.persist())
                }
                setChainId(l) {
                    if (this.isCompatibleChainId(l)) {
                        let c = this.parseChainId(l);
                        this.chainId = c, this.switchEthereumChain(c)
                    }
                }
                parseAccountId(l) {
                    let [c, p, v] = l.split(":");
                    return {
                        chainId: `${c}:${p}`,
                        address: v
                    }
                }
                setAccounts(l) {
                    this.accounts = l.filter(l => this.parseChainId(this.parseAccountId(l).chainId) === this.chainId).map(l => this.parseAccountId(l).address), this.events.emit("accountsChanged", this.accounts)
                }
                getRpcConfig(l) {
                    var c, p;
                    let v = null != (c = l ? .chains) ? c : [],
                        _ = null != (p = l ? .optionalChains) ? p : [],
                        C = v.concat(_);
                    if (!C.length) throw Error("No chains specified in either `chains` or `optionalChains`");
                    let P = v.length ? l ? .methods || n4 : [],
                        T = v.length ? l ? .events || n9 : [],
                        M = l ? .optionalMethods || [],
                        z = l ? .optionalEvents || [],
                        J = l ? .rpcMap || this.buildRpcMap(C, l.projectId),
                        Q = l ? .qrModalOptions || void 0;
                    return {
                        chains: v ? .map(l => this.formatChainId(l)),
                        optionalChains: _.map(l => this.formatChainId(l)),
                        methods: P,
                        events: T,
                        optionalMethods: M,
                        optionalEvents: z,
                        rpcMap: J,
                        showQrModal: !!(null != l && l.showQrModal),
                        qrModalOptions: Q,
                        projectId: l.projectId,
                        metadata: l.metadata
                    }
                }
                buildRpcMap(l, c) {
                    let p = {};
                    return l.forEach(l => {
                        p[l] = this.getRpcUrl(l, c)
                    }), p
                }
                async initialize(l) {
                    if (this.rpc = this.getRpcConfig(l), this.chainId = this.rpc.chains.length ? ethereum_provider_dist_index_es_g(this.rpc.chains) : ethereum_provider_dist_index_es_g(this.rpc.optionalChains), this.signer = await index_es_lr.init({
                            projectId: this.rpc.projectId,
                            metadata: this.rpc.metadata,
                            disableProviderPing: l.disableProviderPing,
                            relayUrl: l.relayUrl,
                            storageOptions: l.storageOptions
                        }), this.registerEventListeners(), await this.loadPersistedSession(), this.rpc.showQrModal) {
                        let l;
                        try {
                            let {
                                WalletConnectModal: c
                            } = await p.e(1993).then(p.bind(p, 1993));
                            l = c
                        } catch {
                            throw Error("To use QR modal, please install @walletconnect/modal package")
                        }
                        if (l) try {
                            this.modal = new l(dist_index_es_p({
                                walletConnectVersion: 2,
                                projectId: this.rpc.projectId,
                                standaloneChains: this.rpc.chains
                            }, this.rpc.qrModalOptions))
                        } catch (l) {
                            throw this.signer.logger.error(l), Error("Could not generate WalletConnectModal Instance")
                        }
                    }
                }
                loadConnectOpts(l) {
                    if (!l) return;
                    let {
                        chains: c,
                        optionalChains: p,
                        rpcMap: v
                    } = l;
                    c && D(c) && (this.rpc.chains = c.map(l => this.formatChainId(l)), c.forEach(l => {
                        this.rpc.rpcMap[l] = v ? .[l] || this.getRpcUrl(l)
                    })), p && D(p) && (this.rpc.optionalChains = [], this.rpc.optionalChains = p ? .map(l => this.formatChainId(l)), p.forEach(l => {
                        this.rpc.rpcMap[l] = v ? .[l] || this.getRpcUrl(l)
                    }))
                }
                getRpcUrl(l, c) {
                    var p;
                    return (null == (p = this.rpc.rpcMap) ? void 0 : p[l]) || `https://rpc.walletconnect.com/v1/?chainId=eip155:${l}&projectId=${c||this.rpc.projectId}`
                }
                async loadPersistedSession() {
                    if (!this.session) return;
                    let l = await this.signer.client.core.storage.getItem(`${this.STORAGE_KEY}/chainId`),
                        c = this.session.namespaces[`${this.namespace}:${l}`] ? this.session.namespaces[`${this.namespace}:${l}`] : this.session.namespaces[this.namespace];
                    this.setChainIds(l ? [this.formatChainId(l)] : c ? .accounts), this.setAccounts(c ? .accounts)
                }
                reset() {
                    this.chainId = 1, this.accounts = []
                }
                persist() {
                    this.session && this.signer.client.core.storage.setItem(`${this.STORAGE_KEY}/chainId`, this.chainId)
                }
                parseAccounts(l) {
                    return "string" == typeof l || l instanceof String ? [this.parseAccount(l)] : l.map(l => this.parseAccount(l))
                }
            };
            var ih = p(3330);
            (v = _ || (_ = {})).METAMASK = "METAMASK", v.WALLETCONNECT = "WALLETCONNECT", v.COINBASE_WALLET = "COINBASE_WALLET", v.OKX_WALLET = "OKX_WALLET";
            let Connector = class Connector {
                get ethereum() {
                    window.location.href.includes("localhost") && console.warn("OKX injected provider collision on blacklisted domains: [localhost]. Whitelisted domains: []");
                    let {
                        ethereum: l
                    } = window;
                    return null != l ? l : null
                }
                async connect() {
                    let l = await this.getEip1193Provider();
                    return await l.request({
                        method: "eth_requestAccounts",
                        params: []
                    }), this.eip1193Provider = l, new ih.Qr(l)
                }
                is(l) {
                    return this.id === l.id
                }
                off(l, c) {
                    var p;
                    null === (p = this.eip1193Provider) || void 0 === p || p.removeListener(l, c)
                }
                on(l, c) {
                    var p;
                    null === (p = this.eip1193Provider) || void 0 === p || p.on(l, c)
                }
                static get storage() {
                    return {
                        clear: () => {
                            localStorage.removeItem(Connector.STORAGE_KEY)
                        },
                        get: () => {
                            let l = localStorage.getItem(Connector.STORAGE_KEY);
                            return "string" == typeof l && Array.from(ig.keys()).includes(l) && ig.get(l) || null
                        },
                        set: l => {
                            localStorage.setItem(Connector.STORAGE_KEY, l.id)
                        }
                    }
                }
                constructor(l, c, p) {
                    this.id = l, this.name = c, this.logo = p, this.isLoading = !1
                }
            };
            Connector.STORAGE_KEY = "blast.dapp.connector";
            var ip = new WeakSet;
            let WalletConnect = class WalletConnect extends Connector {
                cleanup() {
                    window.localStorage.setItem(WalletConnect.KILL_SESSION_TRIGGER, "true")
                }
                async connect() {
                    (function(l, c, p) {
                        if (!c.has(l)) throw TypeError("attempted to get private field on non-instance");
                        return p
                    })(this, ip, cleanup).call(this);
                    let l = await this.getEip1193Provider(),
                        c = l.isWalletConnect && "object" == typeof l.session;
                    return c || await l.connect(), this.provider = l, new ih.Qr(l)
                }
                async disconnect() {
                    try {
                        var l;
                        await (null === (l = this.provider) || void 0 === l ? void 0 : l.disconnect())
                    } catch (l) {} finally {
                        this.cleanup()
                    }
                }
                async getEip1193Provider() {
                    let l = await dist_index_es_v.init({
                        chains: [1],
                        projectId: WalletConnect.PROJECT_ID,
                        qrModalOptions: {
                            themeMode: "dark",
                            themeVariables: {
                                "--wcm-z-index": "9999"
                            }
                        },
                        rpcMap: {
                            1: "https://eth-mainnet.g.alchemy.com/v2/2Xovb_wTQmbdm9kkkHQjA_4Kdfz-p2pE"
                        },
                        showQrModal: !0
                    });
                    return l
                }
                off(l, c) {
                    var p;
                    null === (p = this.provider) || void 0 === p || p.removeListener(l, c)
                }
                on(l, c) {
                    var p;
                    null === (p = this.provider) || void 0 === p || p.on(l, c)
                }
                constructor(l = "WALLETCONNECT", c = "Walletconnect", p = "/walletconnect.png") {
                    super(l, c, p),
                        function(l, c) {
                            if (c.has(l)) throw TypeError("Cannot initialize the same private elements twice on an object")
                        }(this, ip), ip.add(this), this.id = l, this.name = c, this.logo = p, this.provider = null
                }
            };

            function cleanup() {
                let l = window.localStorage.getItem(WalletConnect.KILL_SESSION_TRIGGER);
                "true" === l && Object.keys(window.localStorage).forEach(l => {
                    let c = l.toLowerCase();
                    c.startsWith(WalletConnect.STORAGE_KEY_PREFIX) && window.localStorage.removeItem(l)
                })
            }
            WalletConnect.KILL_SESSION_TRIGGER = "wc@2:blast_kill_session", WalletConnect.PROJECT_ID = "d9185c7dd3ecac336da84173129d10f2", WalletConnect.STORAGE_KEY_PREFIX = "wc@2";
            let CoinbaseWallet = class CoinbaseWallet extends Connector {
                getEip1193Provider() {
                    var l;
                    let c = this.ethereum;
                    if (null === c) throw Error("Could not retrieve EIP1193 provider for ".concat(this.name, ": Missing window.ethereum"));
                    let p = c;
                    return (null === (l = c.providers) || void 0 === l ? void 0 : l.length) && c.providers.forEach(l => {
                        l.isCoinbaseWallet && (p = l)
                    }), p.reloadOnDisconnect = !1, p
                }
                constructor(l = "COINBASE_WALLET", c = "Coinbase Wallet", p = "/coinbase.png") {
                    super(l, c, p), this.id = l, this.name = c, this.logo = p
                }
            };
            let ig = new Map([
                ["METAMASK", new class extends Connector {
                    async getEip1193Provider() {
                        var l;
                        let c = this.ethereum;
                        if (!c) throw Error("Could not retrieve EIP1193 provider for ".concat(this.name, ": Missing window.ethereum"));
                        let p = c;
                        return (null === (l = c.providers) || void 0 === l ? void 0 : l.length) && c.providers.forEach(async l => {
                            l.isMetaMask && (p = l)
                        }), p
                    }
                    constructor(l = "METAMASK", c = "Metamask", p = "/metamask.png") {
                        super(l, c, p), this.id = l, this.name = c, this.logo = p
                    }
                }],
                ["WALLETCONNECT", new WalletConnect]
            ])
        },
        3096: function(l, c, p) {
            "use strict";
            p.d(c, {
                x: function() {
                    return DappProvider
                },
                O: function() {
                    return useDapp
                }
            });
            var v = p(4817),
                _ = p(9215),
                C = p(8101),
                P = p(1248),
                T = p(3515),
                M = p(8347),
                z = p(6597),
                J = p(3330);
            let Q = P.createContext(null),
                DappProvider = l => {
                    var c;
                    let [, p] = P.useTransition(), [X, es] = P.useState(null), [eo, el] = P.useState(null), [ec, eh] = P.useState(J.RR), [ed, ef] = P.useState(null), [ep, eg] = P.useState(null), [em, ey] = P.useState(!1), eb = ec.matches(J.RR), ew = !!(null == ep ? void 0 : ep.isLoading), ex = "string" == typeof(null == X ? void 0 : X.address) && !ew, e_ = P.useCallback(async l => {
                        l.isLoading = !0, eg(l);
                        try {
                            let c = await l.connect(),
                                [p] = await c.listAccounts(),
                                v = await c.getNetwork();
                            if (!(p instanceof _.C1)) throw Error("Expected signer to be an instance of: JsonRpcSigner, got: ".concat(typeof p));
                            es(p), eh(v), ef(c), ey(!1), eg(c => ((null == c ? void 0 : c.is(l)) && (c.isLoading = !1), c)), z.wR.storage.set(l)
                        } catch (_) {
                            var c;
                            eg(null);
                            let p = null == _ ? void 0 : null === (c = _.message) || void 0 === c ? void 0 : c.toLowerCase(),
                                v = z.wR.storage.get();
                            l instanceof z.be && v instanceof z.be && (null == p ? void 0 : p.includes("connection request reset")) ? z.wR.storage.clear() : l instanceof z.GU && v instanceof z.GU && (null == p ? void 0 : p.includes("user denied account authorization")) && z.wR.storage.clear()
                        }
                    }, []), eE = P.useCallback(() => {
                        es(null), eh(J.RR), ef(null), eg(null), z.wR.storage.clear(), window.location.reload()
                    }, []), eA = P.useCallback(async () => {
                        ey(!0)
                    }, []), eC = P.useCallback(() => {
                        try {
                            ep instanceof z.be && ep.disconnect()
                        } catch (l) {
                            console.warn("Could not disconnect from ".concat(null == ep ? void 0 : ep.name), l)
                        } finally {
                            eE()
                        }
                    }, [eE, ep]), eS = P.useCallback(async () => {
                        if (null !== ed) try {
                            await ed.request("wallet_requestPermissions", [{
                                eth_accounts: {}
                            }])
                        } catch (l) {
                            console.error(l)
                        }
                    }, [ed]), eN = P.useCallback(async function() {
                        let l = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : (0, C.B4)(J.RR.chainId);
                        if (null !== ed) try {
                            await ed.request("wallet_switchEthereumChain", [{
                                chainId: l
                            }])
                        } catch (l) {
                            console.warn("Connected wallet is missing chain: ".concat(J.RR.name, ". Add { chainId: ").concat(J.RR.chainId, ", chainName: ").concat(J.RR.name, " } with relevant RPC URLs"))
                        }
                    }, [ed]);
                    return P.useEffect(() => {
                        let l = z.wR.storage.get();
                        null !== l && e_(l)
                    }, [e_]), P.useEffect(() => {
                        if (null === ed || null === ep || ew) return;
                        let handleDisconnect = l => {
                                "string" == typeof(null == l ? void 0 : l.message) && l.message.toLowerCase().includes("user disconnected") && ep instanceof z.be && (ep.disconnect(), eE())
                            },
                            l = !1,
                            handleChainChanged = async c => {
                                l = !0, e_(ep)
                            },
                            handleAccountsChanged = async c => {
                                if (0 === c.length) eE();
                                else if (!l) {
                                    let [l] = c, p = await ed.getSigner(l);
                                    es(p)
                                }
                            };
                        return ep.on("disconnect", handleDisconnect), ep.on("chainChanged", handleChainChanged), ep.on("accountsChanged", handleAccountsChanged), () => {
                            ep.off("disconnect", handleDisconnect), ep.off("chainChanged", handleChainChanged), ep.off("accountsChanged", handleAccountsChanged), l = !1
                        }
                    }, [e_, eE, ed, ep, ew]), P.useEffect(() => {
                        var l;
                        if (!eb || null === X || null === ed) return;
                        let c = !0;
                        el(null);
                        let v = (l = async () => {
                            let l = await ed.lookupAddress(X.address),
                                v = "" === l || "string" != typeof l ? null : (0, T.w3)(l) === l ? l : null;
                            c && p(() => {
                                el(v)
                            })
                        }, "function" == typeof window.requestIdleCallback ? window.requestIdleCallback(l, void 0) : setTimeout(l, 0));
                        return () => {
                            c = !1, "function" == typeof window.cancelIdleCallback ? window.cancelIdleCallback(v) : clearTimeout(v)
                        }
                    }, [X, ed, eb]), (0, v.jsxs)(Q.Provider, {
                        value: {
                            connect: eA,
                            disconnect: eC,
                            ensName: eo,
                            isConnected: ex,
                            isConnecting: ew,
                            isEthereum: eb,
                            provider: ed,
                            requestPermissions: eS,
                            signer: X,
                            switchEthereumChain: eN,
                            connector: null !== (c = null == ep ? void 0 : ep.id) && void 0 !== c ? c : null
                        },
                        children: [l.children, (0, v.jsx)(M.y, {
                            loadingConnector: (null == ep ? void 0 : ep.isLoading) ? ep : null,
                            onConnector: l => e_(l),
                            open: em,
                            onClose: () => {
                                (null == ep ? void 0 : ep.isLoading) || (ey(!1), null === ed && eg(null))
                            }
                        })]
                    })
                };

            function useDapp() {
                let l = P.useContext(Q);
                if (null === l) throw Error("Missing expected DappContext");
                return l
            }
        },
        3330: function(l, c, p) {
            "use strict";
            p.d(c, {
                Qr: function() {
                    return BrowserProvider
                },
                RR: function() {
                    return T
                },
                Mn: function() {
                    return waitForTransaction
                }
            });
            var v = p(8004),
                _ = p(9644),
                C = p(9215);
            let provider_browser_BrowserProvider = class provider_browser_BrowserProvider extends C.JU {#
                e;
                constructor(l, c) {
                    super(c, {
                        batchMaxCount: 1
                    }), this.#e = async (c, p) => {
                        let v = {
                            method: c,
                            params: p
                        };
                        this.emit("debug", {
                            action: "sendEip1193Request",
                            payload: v
                        });
                        try {
                            let c = await l.request(v);
                            return this.emit("debug", {
                                action: "receiveEip1193Result",
                                result: c
                            }), c
                        } catch (c) {
                            let l = Error(c.message);
                            throw l.code = c.code, l.data = c.data, l.payload = v, this.emit("debug", {
                                action: "receiveEip1193Error",
                                error: l
                            }), l
                        }
                    }
                }
                async send(l, c) {
                    return await this._start(), await super.send(l, c)
                }
                async _send(l) {
                    (0, _.en)(!Array.isArray(l), "EIP-1193 does not support batch request", "payload", l);
                    try {
                        let c = await this.#e(l.method, l.params || []);
                        return [{
                            id: l.id,
                            result: c
                        }]
                    } catch (c) {
                        return [{
                            id: l.id,
                            error: {
                                code: c.code,
                                data: c.data,
                                message: c.message
                            }
                        }]
                    }
                }
                getRpcError(l, c) {
                    switch ((c = JSON.parse(JSON.stringify(c))).error.code || -1) {
                        case 4001:
                            c.error.message = `ethers-user-denied: ${c.error.message}`;
                            break;
                        case 4200:
                            c.error.message = `ethers-unsupported: ${c.error.message}`
                    }
                    return super.getRpcError(l, c)
                }
                async hasSigner(l) {
                    null == l && (l = 0);
                    let c = await this.send("eth_accounts", []);
                    return "number" == typeof l ? c.length > l : (l = l.toLowerCase(), 0 !== c.filter(c => c.toLowerCase() === l).length)
                }
                async getSigner(l) {
                    if (null == l && (l = 0), !await this.hasSigner(l)) try {
                        await this.#e("eth_requestAccounts", [])
                    } catch (c) {
                        let l = c.payload;
                        throw this.getRpcError(l, {
                            id: l.id,
                            error: c
                        })
                    }
                    return await super.getSigner(l)
                }
            };
            var P = p(795);
            let T = v.Z.from("mainnet");
            let BrowserProvider = class BrowserProvider extends provider_browser_BrowserProvider {
                constructor(l, c) {
                    super(l, c), this.request = async (c, p) => {
                        let v = {
                            method: c,
                            params: p
                        };
                        this.emit("debug", {
                            payload: v,
                            action: "sendEip1193Request"
                        });
                        try {
                            let c = await l.request(v);
                            return this.emit("debug", {
                                result: c,
                                action: "receiveEip1193Result"
                            }), c
                        } catch (c) {
                            let l = Error(c.message);
                            throw l.code = c.code, l.data = c.data, l.payload = v, this.emit("debug", {
                                error: l,
                                action: "receiveEip1193Error"
                            }), l
                        }
                    }
                }
            };

            function waitForTransaction(l) {
                return async c => {
                    let p = await l.waitForTransaction(c.hash);
                    return null === p ? new P.IX({ ...c.toJSON(),
                        status: 0
                    }, l) : p
                }
            }
        },
        2359: function(l, c, p) {
            "use strict";
            p.d(c, {
                V: function() {
                    return ProgressOrb
                }
            });
            var v = p(4817),
                _ = p(1248);
            let ProgressOrb = l => {
                let c = _.useRef(null),
                    p = {
                        0: {
                            enter: "/videos/orb-phase-0-enter.webm",
                            loop: "/videos/orb-phase-0-loop.webm"
                        },
                        1: {
                            enter: "/videos/orb-phase-1-enter.webm",
                            loop: "/videos/orb-phase-1-loop.webm"
                        },
                        2: {
                            enter: "/videos/orb-phase-2-enter.webm",
                            loop: "/videos/orb-phase-2-loop.webm"
                        },
                        3: {
                            enter: "/videos/orb-phase-3-enter.webm",
                            loop: "/videos/orb-phase-3-loop.webm"
                        }
                    };
                return (0, v.jsx)(_.Fragment, {
                    children: (0, v.jsxs)("div", {
                        className: "relative h-full w-full",
                        children: [(0, v.jsx)("video", {
                            ref: c,
                            loop: !0,
                            muted: !0,
                            className: "absolute inset-0",
                            controls: !1,
                            src: p[l.progress].loop,
                            style: {
                                opacity: "0"
                            }
                        }), (0, v.jsx)("video", {
                            autoPlay: !0,
                            muted: !0,
                            className: "absolute inset-0",
                            controls: !1,
                            src: p[l.progress].enter,
                            onEnded: l => {
                                window.requestAnimationFrame(() => {
                                    l.target instanceof HTMLVideoElement && c.current instanceof HTMLVideoElement && (c.current.play(), c.current.style.opacity = "1", l.target.style.opacity = "0")
                                })
                            }
                        })]
                    })
                })
            }
        },
        3125: function(l, c, p) {
            "use strict";
            p.d(c, {
                U: function() {
                    return GameProvider
                },
                G: function() {
                    return useGame
                }
            });
            var v, _, C = p(4817),
                P = p(1248),
                T = p(3742),
                M = p(7833),
                __generator = function(l, c) {
                    var p, v, _, C, P = {
                        label: 0,
                        sent: function() {
                            if (1 & _[0]) throw _[1];
                            return _[1]
                        },
                        trys: [],
                        ops: []
                    };
                    return C = {
                        next: verb(0),
                        throw: verb(1),
                        return: verb(2)
                    }, "function" == typeof Symbol && (C[Symbol.iterator] = function() {
                        return this
                    }), C;

                    function verb(T) {
                        return function(M) {
                            return function(T) {
                                if (p) throw TypeError("Generator is already executing.");
                                for (; C && (C = 0, T[0] && (P = 0)), P;) try {
                                    if (p = 1, v && (_ = 2 & T[0] ? v.return : T[0] ? v.throw || ((_ = v.return) && _.call(v), 0) : v.next) && !(_ = _.call(v, T[1])).done) return _;
                                    switch (v = 0, _ && (T = [2 & T[0], _.value]), T[0]) {
                                        case 0:
                                        case 1:
                                            _ = T;
                                            break;
                                        case 4:
                                            return P.label++, {
                                                value: T[1],
                                                done: !1
                                            };
                                        case 5:
                                            P.label++, v = T[1], T = [0];
                                            continue;
                                        case 7:
                                            T = P.ops.pop(), P.trys.pop();
                                            continue;
                                        default:
                                            if (!(_ = (_ = P.trys).length > 0 && _[_.length - 1]) && (6 === T[0] || 2 === T[0])) {
                                                P = 0;
                                                continue
                                            }
                                            if (3 === T[0] && (!_ || T[1] > _[0] && T[1] < _[3])) {
                                                P.label = T[1];
                                                break
                                            }
                                            if (6 === T[0] && P.label < _[1]) {
                                                P.label = _[1], _ = T;
                                                break
                                            }
                                            if (_ && P.label < _[2]) {
                                                P.label = _[2], P.ops.push(T);
                                                break
                                            }
                                            _[2] && P.ops.pop(), P.trys.pop();
                                            continue
                                    }
                                    T = c.call(l, P)
                                } catch (l) {
                                    T = [6, l], v = 0
                                } finally {
                                    p = _ = 0
                                }
                                if (5 & T[0]) throw T[1];
                                return {
                                    value: T[0] ? T[1] : void 0,
                                    done: !0
                                }
                            }([T, M])
                        }
                    }
                };

            function DynamicNamespaces(l) {
                var c = l.dynamic,
                    p = l.namespaces,
                    v = void 0 === p ? [] : p,
                    _ = l.fallback,
                    C = l.children,
                    z = (0, P.useContext)(T.Y).config,
                    J = (0, M.Z)().lang,
                    Q = (0, P.useState)(!1),
                    X = Q[0],
                    es = Q[1],
                    eo = (0, P.useState)([]),
                    el = eo[0],
                    ec = eo[1],
                    eh = c || z.loadLocaleFrom || function() {
                        return Promise.resolve({})
                    };
                return ((0, P.useEffect)(function() {
                    ! function() {
                        var l, c, p, _;
                        l = this, c = void 0, p = void 0, _ = function() {
                            return __generator(this, function(l) {
                                switch (l.label) {
                                    case 0:
                                        if ("function" != typeof eh) return [2];
                                        return [4, Promise.all(v.map(function(l) {
                                            return eh(J, l)
                                        }))];
                                    case 1:
                                        return ec(l.sent()), es(!0), [2]
                                }
                            })
                        }, new(p || (p = Promise))(function(v, C) {
                            function fulfilled(l) {
                                try {
                                    step(_.next(l))
                                } catch (l) {
                                    C(l)
                                }
                            }

                            function rejected(l) {
                                try {
                                    step(_.throw(l))
                                } catch (l) {
                                    C(l)
                                }
                            }

                            function step(l) {
                                var c;
                                l.done ? v(l.value) : ((c = l.value) instanceof p ? c : new p(function(l) {
                                    l(c)
                                })).then(fulfilled, rejected)
                            }
                            step((_ = _.apply(l, c || [])).next())
                        })
                    }()
                }, [v.join()]), X) ? P.createElement(T.Z, {
                    lang: J,
                    namespaces: v.reduce(function(l, c, p) {
                        return l[c] = el[p], l
                    }, {})
                }, C) : _ || null
            }
            var z = p(6497),
                J = p(7622),
                Q = p(6179),
                X = p(5834),
                es = p(1173),
                eo = p(3338),
                el = p(1389),
                ec = p(6359),
                eh = p(8299),
                ed = p(7657),
                ef = p(414);
            (v = _ || (_ = {}))[v.idle = 0] = "idle", v[v.entering = 1] = "entering", v[v.entered = 2] = "entered", v[v.ready = 3] = "ready", v[v.roll = 4] = "roll", v[v.spin = 5] = "spin", v[v.reveal = 6] = "reveal", v[v.claim = 7] = "claim", v[v.exiting = 8] = "exiting", v[v.exited = 9] = "exited";
            let ep = {
                    className: "max-h-[480px]",
                    px: 480
                },
                eg = {
                    className: "max-w-[1048px]",
                    px: 1048
                },
                em = {
                    "initial-spin": {
                        classNames: "py-8",
                        px: 32
                    },
                    "luck-spin": {
                        classNames: "py-5",
                        px: 20
                    },
                    "standard-spin": {
                        classNames: "py-8",
                        px: 32
                    },
                    "super-spin": {
                        classNames: "py-8",
                        px: 32
                    },
                    "tweet-spin": {
                        classNames: "py-8",
                        px: 32
                    }
                },
                ey = {
                    "initial-spin": {
                        classNames: "gap-8",
                        px: 32
                    },
                    "luck-spin": {
                        classNames: "gap-5",
                        px: 20
                    },
                    "standard-spin": {
                        classNames: "gap-8",
                        px: 32
                    },
                    "super-spin": {
                        classNames: "gap-8",
                        px: 32
                    },
                    "tweet-spin": {
                        classNames: "gap-8",
                        px: 32
                    }
                },
                getCardHeight = (l, c) => {
                    if ("luck-spin" === c) {
                        let p = 2 * em[c].px + ey[c].px;
                        return (l - p) / 2
                    } {
                        let p = 2 * em[c].px;
                        return l - p
                    }
                },
                getCardWidth = (l, c) => "luck-spin" === c ? .67 * l : 1 * l,
                useResultReducer = (l, c) => "reset" === c.type ? { ...l,
                    pool: null,
                    result: null,
                    touched: !1
                } : { ...c.payload,
                    touched: !0
                };
            var eb = p(8735),
                ew = p.n(eb),
                ex = p(34),
                e_ = p(3460);
            let LuckCardBack = l => {
                    let c = (0, el.m)("transition-colors", "common" === l.rarity && "fill-camo-200", "rare" === l.rarity && "fill-yellow-100", "skeleton" === l.rarity && "fill-camo-700", "super" === l.rarity && "fill-yellow-300", "uncommon" === l.rarity && "fill-yellow-600"),
                        p = (0, el.m)("transition-colors", "group-hover:fill-white", "common" === l.rarity && "fill-camo-400", "rare" === l.rarity && "fill-yellow-400", "skeleton" === l.rarity && "fill-camo-400", "super" === l.rarity && "fill-yellow-500", "uncommon" === l.rarity && "fill-yellow-400"),
                        v = (0, el.m)("transition-colors", "group-hover:stroke-white", "common" === l.rarity && "stroke-camo-400", "rare" === l.rarity && "stroke-yellow-400", "skeleton" === l.rarity && "stroke-camo-400", "super" === l.rarity && "stroke-yellow-500", "uncommon" === l.rarity && "stroke-yellow-400"),
                        _ = (0, el.m)("transition-colors", "group-hover:fill-white", "common" === l.rarity && "fill-camo-400", "rare" === l.rarity && "fill-yellow-400", "skeleton" === l.rarity && "fill-yellow-100", "super" === l.rarity && "fill-yellow-500", "uncommon" === l.rarity && "fill-yellow-400"),
                        P = (0, el.m)("transition-colors", "group-hover:stroke-white", "common" === l.rarity && "stroke-camo-400", "rare" === l.rarity && "stroke-yellow-400", "skeleton" === l.rarity && "stroke-yellow-100", "super" === l.rarity && "stroke-yellow-500", "uncommon" === l.rarity && "stroke-yellow-400");
                    return (0, C.jsxs)("svg", {
                        className: "h-full w-full",
                        fill: "none",
                        height: "212",
                        viewBox: "0 0 142 212",
                        width: "142",
                        xmlns: "http://www.w3.org/2000/svg",
                        children: [(0, C.jsx)("path", {
                            className: (0, el.m)(P, c),
                            d: "M134 1.25H8C4.13401 1.25 1 4.38401 1 8.25V204.25C1 208.116 4.13401 211.25 8 211.25H134C137.866 211.25 141 208.116 141 204.25V8.25C141 4.38401 137.866 1.25 134 1.25Z",
                            strokeMiterlimit: "10",
                            strokeWidth: "1.5"
                        }), (0, C.jsx)("path", {
                            className: v,
                            d: "M8.14453 28.7644V15.6284L16.6235 7.14844H28.9275",
                            strokeMiterlimit: "10"
                        }), (0, C.jsx)("path", {
                            className: v,
                            d: "M112.648 7.14844H125.783L134.263 15.6284V28.7644",
                            strokeMiterlimit: "10"
                        }), (0, C.jsx)("path", {
                            className: v,
                            d: "M134.263 184.158V196.462L125.783 204.942H112.648",
                            strokeMiterlimit: "10"
                        }), (0, C.jsx)("path", {
                            className: v,
                            d: "M28.9275 204.941H16.6235L8.14453 196.461V183.326",
                            strokeMiterlimit: "10"
                        }), (0, C.jsx)("path", {
                            className: v,
                            d: "M13.9648 17.957L37.3688 41.361V74.076",
                            strokeMiterlimit: "10"
                        }), (0, C.jsx)("path", {
                            className: v,
                            d: "M37.3711 55.5645V74.076",
                            strokeMiterlimit: "10",
                            strokeWidth: "4"
                        }), (0, C.jsx)("path", {
                            className: v,
                            d: "M129.023 76.1816V94.693",
                            strokeMiterlimit: "10",
                            strokeWidth: "4"
                        }), (0, C.jsx)("path", {
                            className: v,
                            d: "M96.5469 103.229V143.577",
                            strokeMiterlimit: "10",
                            strokeWidth: "4"
                        }), (0, C.jsx)("path", {
                            className: v,
                            d: "M18.5352 14.8848L43.0192 39.3688V74.0768L61.2462 92.3048V204.943",
                            strokeMiterlimit: "10"
                        }), (0, C.jsx)("path", {
                            className: P,
                            d: "M97.7116 73.8081C115.003 73.8081 129.021 59.7904 129.021 42.4988C129.021 25.2071 115.003 11.1895 97.7116 11.1895C80.42 11.1895 66.4023 25.2071 66.4023 42.4988C66.4023 59.7904 80.42 73.8081 97.7116 73.8081Z",
                            strokeMiterlimit: "10",
                            strokeWidth: "0.8847"
                        }), (0, C.jsx)("path", {
                            className: _,
                            d: "M88.4212 59.7652C88.2873 59.9692 88.1141 60.1444 87.9118 60.2809C87.7095 60.4173 87.4821 60.5124 87.2428 60.5602C87.0035 60.6079 86.7571 60.6075 86.5179 60.5592C86.2787 60.5109 86.0515 60.4158 85.8495 60.2789C85.6447 60.1461 85.4685 59.9735 85.3314 59.7716C85.1943 59.5697 85.099 59.3425 85.0511 59.1031C85.0033 58.8638 85.0038 58.6172 85.0527 58.378C85.1016 58.1389 85.1979 57.9124 85.3359 57.711L107.762 24.2555C107.898 24.054 108.073 23.882 108.277 23.7491C108.481 23.6162 108.709 23.5251 108.948 23.4815C109.187 23.438 109.433 23.4427 109.67 23.4952C109.907 23.5478 110.132 23.6472 110.33 23.7877C110.536 23.9204 110.712 24.0929 110.85 24.295C110.988 24.4971 111.083 24.7248 111.132 24.9645C111.18 25.2042 111.18 25.4509 111.131 25.6905C111.082 25.9301 110.986 26.1577 110.848 26.3595L88.4212 59.7652ZM92.857 38.2252H86.177C86.0319 38.2323 85.8869 38.2096 85.7508 38.1588C85.6147 38.108 85.4904 38.0302 85.3854 37.9298C85.2804 37.8294 85.197 37.709 85.1401 37.5753C85.0833 37.4416 85.0542 37.2977 85.0548 37.1524V24.4918C85.0528 24.3439 85.0805 24.1967 85.1361 24.0597C85.1918 23.9226 85.2745 23.7981 85.3791 23.6935C85.4837 23.5888 85.6082 23.5065 85.7452 23.4508C85.8823 23.3951 86.0291 23.3673 86.177 23.3692H92.857C93.1535 23.373 93.4367 23.4926 93.6464 23.7022C93.8561 23.9119 93.9755 24.1953 93.9793 24.4918V37.1524C93.9761 37.2966 93.9445 37.4385 93.8863 37.5704C93.8282 37.7023 93.7446 37.8219 93.6404 37.9215C93.5361 38.0211 93.4133 38.0989 93.2789 38.151C93.1445 38.2031 93.0011 38.2285 92.857 38.2252ZM92.4842 28.2276C92.4804 27.9312 92.3609 27.6477 92.1513 27.4381C91.9416 27.2284 91.6584 27.1089 91.3619 27.1051H87.6261C87.4816 27.1079 87.3392 27.1394 87.2068 27.1974C87.0745 27.2553 86.9549 27.3387 86.8549 27.443C86.7549 27.5472 86.6764 27.6702 86.624 27.8048C86.5716 27.9394 86.5463 28.0832 86.5495 28.2276V33.4127C86.5471 33.5547 86.5733 33.696 86.6266 33.8277C86.6798 33.9594 86.7591 34.0788 86.8595 34.1793C86.96 34.2797 87.0796 34.3589 87.2113 34.4122C87.343 34.4655 87.484 34.4917 87.6261 34.4894H91.3619C91.5064 34.4926 91.65 34.4675 91.7846 34.4151C91.9192 34.3627 92.0422 34.2842 92.1465 34.1842C92.2507 34.0842 92.3342 33.9645 92.3922 33.8321C92.4501 33.6998 92.4814 33.5571 92.4842 33.4127V28.2276ZM110.053 60.6061H103.323C103.178 60.6029 103.036 60.5714 102.904 60.5133C102.772 60.4551 102.653 60.3714 102.554 60.2672C102.454 60.163 102.376 60.0403 102.324 59.9059C102.272 59.7714 102.246 59.6281 102.25 59.484V46.8229C102.247 46.6813 102.273 46.541 102.326 46.4098C102.38 46.2785 102.459 46.1593 102.559 46.0592C102.659 45.9591 102.778 45.8798 102.909 45.8268C103.04 45.7737 103.181 45.7477 103.323 45.7501H110.053C110.194 45.7477 110.335 45.7737 110.466 45.8268C110.597 45.8798 110.716 45.9591 110.817 46.0592C110.917 46.1593 110.996 46.2785 111.049 46.4098C111.102 46.541 111.128 46.6813 111.125 46.8229V59.4835C111.129 59.6277 111.104 59.7709 111.051 59.9054C110.999 60.0398 110.921 60.163 110.822 60.2672C110.722 60.3714 110.603 60.4546 110.471 60.5128C110.339 60.5709 110.197 60.6029 110.053 60.6061ZM109.68 50.5626C109.674 50.271 109.552 49.994 109.342 49.7921C109.131 49.5902 108.849 49.48 108.557 49.4859H104.817C104.673 49.4831 104.53 49.509 104.396 49.5616C104.262 49.6142 104.139 49.6926 104.035 49.7926C103.931 49.8926 103.848 50.012 103.79 50.1441C103.733 50.2763 103.702 50.4184 103.699 50.5626V55.7481C103.703 56.0434 103.823 56.3255 104.031 56.5343C104.24 56.7431 104.522 56.862 104.817 56.8663H108.557C108.853 56.8621 109.136 56.743 109.345 56.5343C109.555 56.3255 109.675 56.0438 109.68 55.7481V50.5626Z"
                        }), (0, C.jsx)("path", {
                            className: v,
                            d: "M8.14453 48.1387V95.6927L25.1455 112.694H52.5385V117.308",
                            strokeMiterlimit: "10"
                        }), (0, C.jsx)("path", {
                            className: v,
                            d: "M8.14453 172.062V122.411C8.14453 121.733 8.41362 121.084 8.89246 120.605C9.37129 120.126 10.0207 119.857 10.6979 119.857H31.4178C31.7531 119.857 32.0851 119.923 32.3949 120.052C32.7047 120.18 32.9862 120.368 33.2233 120.605L38.9326 126.314C39.4115 126.793 40.061 127.062 40.7382 127.062H49.9854C50.3207 127.062 50.6527 127.129 50.9625 127.257C51.2723 127.385 51.5538 127.573 51.7909 127.81C52.028 128.047 52.2161 128.329 52.3444 128.639C52.4727 128.948 52.5388 129.28 52.5388 129.616V148.119C52.5388 148.796 52.2697 149.446 51.7909 149.925C51.312 150.404 50.6626 150.673 49.9854 150.673H43.8966C43.5613 150.673 43.2292 150.739 42.9194 150.867C42.6096 150.995 42.3282 151.183 42.0911 151.42C41.854 151.658 41.6658 151.939 41.5375 152.249C41.4092 152.559 41.3431 152.891 41.3431 153.226V154.548C41.3432 155.226 41.6122 155.875 42.0911 156.354C42.5699 156.833 43.2194 157.102 43.8966 157.102H49.9854C50.6625 157.102 51.312 157.371 51.7908 157.85C52.2697 158.328 52.5387 158.978 52.5388 159.655V172.062C52.5388 172.398 52.4727 172.73 52.3444 173.04C52.2161 173.349 52.028 173.631 51.7909 173.868C51.5538 174.105 51.2723 174.293 50.9625 174.421C50.6527 174.55 50.3207 174.616 49.9854 174.616H38.4254C37.7482 174.616 37.0987 174.346 36.6199 173.868L33.0089 170.257C32.7718 170.02 32.4903 169.831 32.1805 169.703C31.8708 169.575 31.5388 169.509 31.2035 169.509H28.2191C27.5419 169.509 26.8924 169.778 26.4136 170.257C25.9347 170.736 25.6656 171.385 25.6656 172.062C25.6656 172.74 25.3967 173.389 24.9178 173.868C24.439 174.347 23.7895 174.616 23.1123 174.616H10.6975C10.0204 174.616 9.37097 174.347 8.89221 173.868C8.41346 173.389 8.1445 172.74 8.14453 172.062Z",
                            strokeMiterlimit: "10"
                        }), (0, C.jsx)("path", {
                            className: v,
                            d: "M19.5374 136.706C22.7208 136.706 25.3014 134.125 25.3014 130.942C25.3014 127.758 22.7208 125.178 19.5374 125.178C16.3541 125.178 13.7734 127.758 13.7734 130.942C13.7734 134.125 16.3541 136.706 19.5374 136.706Z",
                            strokeMiterlimit: "10"
                        }), (0, C.jsx)("path", {
                            className: p,
                            d: "M36.8788 187.307H38.3984V183.327H36.8788V187.307Z"
                        }), (0, C.jsx)("path", {
                            className: p,
                            d: "M29.3744 184.989C29.8335 184.989 30.2058 184.617 30.2058 184.158C30.2058 183.698 29.8335 183.326 29.3744 183.326C28.9152 183.326 28.543 183.698 28.543 184.158C28.543 184.617 28.9152 184.989 29.3744 184.989Z"
                        }), (0, C.jsx)("path", {
                            className: p,
                            d: "M53.2053 183.326H49.2148V204.941H53.2053V183.326Z"
                        }), (0, C.jsx)("path", {
                            className: p,
                            d: "M43.2528 183.326H42.3984V204.941H43.2528V183.326Z"
                        }), (0, C.jsx)("path", {
                            className: p,
                            d: "M23.1669 183.326H22.3125V196.098H23.1669V183.326Z"
                        }), (0, C.jsx)("path", {
                            className: p,
                            d: "M19.7838 183.326H17.9453V196.098H19.7838V183.326Z"
                        }), (0, C.jsx)("path", {
                            className: p,
                            d: "M16.422 183.326H12.8672V196.098H16.422V183.326Z"
                        }), (0, C.jsx)("path", {
                            className: p,
                            d: "M41.4208 183.326H40.5664V204.941H41.4208V183.326Z"
                        }), (0, C.jsx)("path", {
                            className: p,
                            d: "M34.5888 183.326H33.7344V204.941H34.5888V183.326Z"
                        }), (0, C.jsx)("path", {
                            className: p,
                            d: "M36.8788 204.891H38.3984V193.342H36.8788V204.891Z"
                        }), (0, C.jsx)("path", {
                            className: p,
                            d: "M29.3744 188.969C29.8335 188.969 30.2058 188.597 30.2058 188.138C30.2058 187.679 29.8335 187.307 29.3744 187.307C28.9152 187.307 28.543 187.679 28.543 188.138C28.543 188.597 28.9152 188.969 29.3744 188.969Z"
                        }), (0, C.jsx)("path", {
                            className: p,
                            d: "M29.3744 192.95C29.8335 192.95 30.2058 192.578 30.2058 192.119C30.2058 191.659 29.8335 191.287 29.3744 191.287C28.9152 191.287 28.543 191.659 28.543 192.119C28.543 192.578 28.9152 192.95 29.3744 192.95Z"
                        }), (0, C.jsx)("path", {
                            className: p,
                            d: "M29.3744 196.93C29.8335 196.93 30.2058 196.558 30.2058 196.099C30.2058 195.64 29.8335 195.268 29.3744 195.268C28.9152 195.268 28.543 195.64 28.543 196.099C28.543 196.558 28.9152 196.93 29.3744 196.93Z"
                        }), (0, C.jsx)("path", {
                            className: p,
                            d: "M29.3744 200.909C29.8335 200.909 30.2058 200.537 30.2058 200.077C30.2058 199.618 29.8335 199.246 29.3744 199.246C28.9152 199.246 28.543 199.618 28.543 200.077C28.543 200.537 28.9152 200.909 29.3744 200.909Z"
                        }), (0, C.jsx)("path", {
                            className: p,
                            d: "M53.2044 204.941H56.0864V194.133L50.5664 188.613L53.2044 204.941Z"
                        }), (0, C.jsx)("path", {
                            className: v,
                            d: "M134.315 64.8203V149.839L112.645 171.51V199.246H76.1055",
                            strokeMiterlimit: "10"
                        }), (0, C.jsx)("path", {
                            className: v,
                            d: "M129.02 76.1836V147.237L96.3215 179.935V194.551H76.1055",
                            strokeMiterlimit: "10"
                        }), (0, C.jsx)("path", {
                            className: v,
                            d: "M76.1058 12.5566H23.7188L48.8808 37.7196V63.3246L87.7767 102.222V189.713H76.1058L70.0508 195.769V204.891",
                            strokeMiterlimit: "10"
                        }), (0, C.jsx)("path", {
                            className: v,
                            d: "M96.5469 115.09V172.065",
                            strokeMiterlimit: "10"
                        }), (0, C.jsx)("path", {
                            className: v,
                            d: "M13.7734 162.865H25.6663",
                            strokeMiterlimit: "10"
                        }), (0, C.jsx)("path", {
                            className: p,
                            d: "M35.3939 163.696C35.8531 163.696 36.2253 163.324 36.2253 162.865C36.2253 162.405 35.8531 162.033 35.3939 162.033C34.9347 162.033 34.5625 162.405 34.5625 162.865C34.5625 163.324 34.9347 163.696 35.3939 163.696Z"
                        }), (0, C.jsx)("path", {
                            className: p,
                            d: "M49.2142 172.251C49.6734 172.251 50.0456 171.878 50.0456 171.419C50.0456 170.96 49.6734 170.588 49.2142 170.588C48.755 170.588 48.3828 170.96 48.3828 171.419C48.3828 171.878 48.755 172.251 49.2142 172.251Z"
                        }), (0, C.jsx)("path", {
                            className: v,
                            d: "M28.2031 162.865H32.1615",
                            strokeMiterlimit: "10"
                        })]
                    })
                },
                LuckCardFront = l => {
                    let c = (0, el.m)("transition-colors", "common" === l.rarity && "fill-camo-200", "rare" === l.rarity && "fill-yellow-100", "skeleton" === l.rarity && "fill-camo-700", "super" === l.rarity && "fill-yellow-300", "uncommon" === l.rarity && "fill-yellow-600"),
                        p = (0, el.m)("transition-colors", "common" === l.rarity && "stroke-camo-400", "rare" === l.rarity && "stroke-yellow-400", "skeleton" === l.rarity && "stroke-yellow-100", "super" === l.rarity && "stroke-yellow-500", "uncommon" === l.rarity && "stroke-yellow-400");
                    return (0, C.jsxs)(P.Fragment, {
                        children: [(0, C.jsx)("svg", {
                            className: "h-full w-full",
                            viewBox: "0 0 104 104",
                            xmlns: "http://www.w3.org/2000/svg",
                            children: (0, C.jsx)("path", {
                                className: (0, el.m)(c, p),
                                d: "M102.961 18.9238C102.961 18.208 102.654 17.5266 102.118 17.0521L92.5184 8.55191C92.0612 8.14711 91.4717 7.92363 90.8611 7.92363H68.534C68.0038 7.92363 67.5739 8.35346 67.5739 8.88368C67.5739 9.96618 66.6964 10.8437 65.6139 10.8437H53.4727C52.3902 10.8437 51.5127 9.96619 51.5127 8.88368C51.5127 8.35346 51.0828 7.92363 50.5526 7.92363H29.5621C28.6121 7.92363 27.7029 7.53745 27.0432 6.85376L22.2817 1.91849C21.8106 1.43014 21.1611 1.1543 20.4826 1.1543H3.03125C1.65054 1.1543 0.53125 2.27358 0.53125 3.6543V95.6082C0.53125 96.3679 0.876663 97.0864 1.46999 97.5608L10.0515 104.423C10.4947 104.777 11.0453 104.97 11.6128 104.97H100.461C101.842 104.97 102.961 103.851 102.961 102.47V18.9238Z"
                            })
                        }), (0, C.jsx)("div", {
                            className: "typography-brand-body absolute z-[1] px-[12px] text-center text-[150%] font-bold uppercase leading-[110%] tracking-[1.2px]",
                            children: l.children
                        })]
                    })
                },
                Meter = () => (0, C.jsxs)("svg", {
                    className: "text-yellow-300",
                    fill: "none",
                    height: "185",
                    viewBox: "0 0 58 185",
                    width: "58",
                    xmlns: "http://www.w3.org/2000/svg",
                    children: [(0, C.jsx)("path", {
                        className: "text-yellow-100",
                        d: "M1.13281 28.4528V0.927734H27.464",
                        stroke: "currentColor",
                        strokeMiterlimit: "10",
                        strokeWidth: "1.5"
                    }), (0, C.jsx)("path", {
                        className: "text-yellow-100",
                        d: "M57.1359 156.402V183.927H30.8047",
                        stroke: "currentColor",
                        strokeMiterlimit: "10",
                        strokeWidth: "1.5"
                    }), (0, C.jsx)("path", {
                        d: "M9.29688 10.6406L46.8811 175.388V10.6406H9.29688Z",
                        stroke: "currentColor",
                        strokeMiterlimit: "10",
                        strokeWidth: "1.5"
                    }), (0, C.jsx)("path", {
                        d: "M12.5742 24.6406H46.8805",
                        stroke: "currentColor",
                        strokeMiterlimit: "10",
                        strokeWidth: "1.5"
                    }), (0, C.jsx)("path", {
                        d: "M15.8203 38.9121H46.8809",
                        stroke: "currentColor",
                        strokeMiterlimit: "10",
                        strokeWidth: "1.5"
                    }), (0, C.jsx)("path", {
                        d: "M19.0664 53.1797H46.8813",
                        stroke: "currentColor",
                        strokeMiterlimit: "10",
                        strokeWidth: "1.5"
                    }), (0, C.jsx)("path", {
                        d: "M22.3086 67.4473H46.8778",
                        stroke: "currentColor",
                        strokeMiterlimit: "10",
                        strokeWidth: "1.5"
                    }), (0, C.jsx)("path", {
                        d: "M25.5547 81.7168H46.8782",
                        stroke: "currentColor",
                        strokeMiterlimit: "10",
                        strokeWidth: "1.5"
                    }), (0, C.jsx)("path", {
                        d: "M28.8008 95.9844H46.8786",
                        stroke: "currentColor",
                        strokeMiterlimit: "10",
                        strokeWidth: "1.5"
                    }), (0, C.jsx)("path", {
                        d: "M32.0469 110.252H46.8789",
                        stroke: "currentColor",
                        strokeMiterlimit: "10",
                        strokeWidth: "1.5"
                    }), (0, C.jsx)("path", {
                        d: "M35.293 124.52H46.8793",
                        stroke: "currentColor",
                        strokeMiterlimit: "10",
                        strokeWidth: "1.5"
                    }), (0, C.jsx)("path", {
                        d: "M38.5391 138.787H46.8797",
                        stroke: "currentColor",
                        strokeMiterlimit: "10",
                        strokeWidth: "1.5"
                    }), (0, C.jsx)("path", {
                        d: "M41.7852 153.057H46.88",
                        stroke: "currentColor",
                        strokeMiterlimit: "10",
                        strokeWidth: "1.5"
                    })]
                });
            var eE = p(5199);
            let LuckCard = l => {
                    let {
                        onFlip: c,
                        prize: p,
                        rarity: v,
                        spinCount: P,
                        state: T
                    } = l, {
                        t: z
                    } = (0, M.Z)("game"), J = T < _.reveal || T >= _.exiting, Q = T < _.roll && P > 0, X = J || !v ? "skeleton" : v;
                    return (0, C.jsxs)("div", {
                        className: (0, el.m)("relative flex h-full w-full items-center justify-center", Q && "group cursor-pointer hover:scale-[1.05]"),
                        onClick: l => {
                            Q && c(l)
                        },
                        children: [(0, C.jsx)("div", {
                            className: "h-full w-full",
                            children: (0, C.jsx)(LuckCardBack, {
                                rarity: X
                            })
                        }), (0, C.jsx)("div", {
                            className: "absolute flex h-full w-full items-center justify-center px-[6px]",
                            style: {
                                opacity: T <= _.spin || T >= _.exiting ? 0 : 1,
                                transform: "rotateY(180deg)",
                                transition: T === _.reveal ? "opacity 750ms cubic-bezier(0.4, 0, 0.2, 1)" : void 0
                            },
                            children: (0, C.jsx)(LuckCardFront, {
                                rarity: X,
                                children: z("card.label_luck", {
                                    value: p
                                })
                            })
                        })]
                    })
                },
                LuckSpinLuck = l => {
                    var c, p, v, T;
                    let {
                        inDuration: z,
                        luck: J,
                        state: Q
                    } = l, {
                        t: X
                    } = (0, M.Z)("game"), es = (0, e_.D9)(J), eo = P.useRef(null), el = P.useRef(null);
                    if (Q === _.entering) {
                        let l = {
                            duration: z,
                            easing: "ease-in-out",
                            fill: "forwards"
                        };
                        null === (c = eo.current) || void 0 === c || c.animate([{
                            width: "0%"
                        }, {
                            width: "".concat(null != J ? J : 0, "%")
                        }], l), null === (p = el.current) || void 0 === p || p.animate([{
                            clipPath: "inset(0 100% 0 0)"
                        }, {
                            clipPath: "inset(0 ".concat(100 - (J || 0), "% 0 0)")
                        }], l)
                    } else if (Q === _.claim) {
                        let l = {
                            duration: 1500,
                            easing: "ease-out",
                            fill: "forwards"
                        };
                        null === (v = eo.current) || void 0 === v || v.animate([{
                            width: "".concat(null != es ? es : 0, "%")
                        }, {
                            width: "".concat(null != J ? J : 0, "%")
                        }], l), null === (T = el.current) || void 0 === T || T.animate([{
                            clipPath: "inset(0 ".concat(100 - (es || 0), "% 0 0)")
                        }, {
                            clipPath: "inset(0 ".concat(100 - (J || 0), "% 0 0)")
                        }], l)
                    }
                    return (0, C.jsx)("div", {
                        className: "flex h-[64px] w-[192px] bg-yellow-100 [clip-path:polygon(0_0,75%_0%,100%_50%,100%_100%,25%_100%,0%_50%)]",
                        children: (0, C.jsxs)("div", {
                            className: "relative m-[1px] flex h-[62px] w-[190px] flex-col bg-black [clip-path:polygon(0_0,75%_0%,100%_50%,100%_100%,25%_100%,0%_50%)]",
                            children: [(0, C.jsx)("div", {
                                ref: eo,
                                className: "absolute  h-full w-full bg-yellow-300 transition-all duration-1000",
                                style: {
                                    zIndex: -1
                                }
                            }), (0, C.jsxs)("div", {
                                ref: el,
                                className: "absolute left-0 top-0 h-full w-full transition-all duration-1000",
                                style: {
                                    zIndex: 1
                                },
                                children: [(0, C.jsx)("div", {
                                    className: "typography-brand-body-bold ml-[10%] mt-1 uppercase text-black",
                                    children: X("luck-spin.luck_label")
                                }), Q === _.claim ? (0, C.jsx)(eA, {
                                    className: "typography-brand-heading-2 ml-[25%] leading-none text-black",
                                    end: null != J ? J : 0
                                }) : (0, C.jsx)("div", {
                                    className: "typography-brand-heading-2 ml-[25%] leading-none text-black",
                                    children: X("luck-spin.luck_value", {
                                        value: J
                                    })
                                })]
                            }), (0, C.jsx)("div", {
                                className: "typography-brand-body-bold ml-[10%] mt-1 uppercase text-yellow-100",
                                children: X("luck-spin.luck_label")
                            }), Q === _.claim ? (0, C.jsx)(eA, {
                                className: "typography-brand-heading-2 ml-[25%] leading-none text-yellow-100",
                                end: null != J ? J : 0
                            }) : (0, C.jsx)("div", {
                                className: "typography-brand-heading-2 ml-[25%] leading-none text-yellow-100",
                                children: X("luck-spin.luck_value", {
                                    value: J
                                })
                            })]
                        })
                    })
                },
                eA = P.memo(l => {
                    let {
                        className: c,
                        end: p
                    } = l, {
                        t: v
                    } = (0, M.Z)("game"), _ = P.useRef(0);
                    return P.useEffect(() => {
                        _.current = p
                    }), (0, C.jsx)(ex.ZP, {
                        duration: 1,
                        end: p,
                        start: 0 === _.current ? p : _.current,
                        easingFn: P.useCallback((l, c, p, v) => -p * (l /= v) * (l - 2) + c, []),
                        formattingFn: P.useCallback(l => v("luck-spin.luck_value", {
                            value: l
                        }), [v]),
                        children: l => {
                            let {
                                countUpRef: p
                            } = l;
                            return (0, C.jsx)("span", {
                                ref: p,
                                className: c
                            })
                        }
                    })
                }, (l, c) => l.end === c.end && l.className === c.className);
            eA.displayName = "CountUpCurrentLuck";
            let LuckStrobeMeter = l => {
                    var c, p, v;
                    let {
                        left: T,
                        luck: z,
                        result: J,
                        right: Q,
                        state: X
                    } = l, {
                        t: es
                    } = (0, M.Z)("game"), eo = P.useRef(null);
                    return X >= _.reveal ? null === (c = eo.current) || void 0 === c || c.animate([{
                        clipPath: "inset(100% 0 0 0)"
                    }, {
                        clipPath: "inset(".concat(100 - (null != J ? J : 0), "% 0 0 0)")
                    }], {
                        duration: 1e3,
                        easing: "cubic-bezier(0.4, 0, 0.2, 1)",
                        fill: "forwards"
                    }) : X >= _.roll ? null === (p = eo.current) || void 0 === p || p.animate([{
                        clipPath: "inset(100% 0 0 0)"
                    }, {
                        clipPath: "inset(0 0 0 0)"
                    }], {
                        duration: 250,
                        easing: "cubic-bezier(0.4, 0, 0.2, 1)",
                        fill: "forwards",
                        iterations: 1 / 0
                    }) : X === _.entering && (null === (v = eo.current) || void 0 === v || v.animate([{
                        clipPath: "inset(100% 0 0 0)"
                    }, {
                        clipPath: "inset(".concat(100 - (z || 0), "% 0 0 0)")
                    }], {
                        duration: 1e3,
                        easing: "cubic-bezier(0.4, 0, 0.2, 1)",
                        fill: "forwards"
                    })), (0, C.jsxs)("div", {
                        className: "flex w-max flex-col items-center gap-4",
                        children: [(0, C.jsx)("div", {
                            className: (0, el.m)("typography-UI-heading-1 animate uppercase text-yellow-100 [writing-mode:vertical-rl]", T && "rotate-180", Q && "rotate-0"),
                            children: es("luck-spin.vertical-rl")
                        }), (0, C.jsxs)("div", {
                            className: (0, el.m)("relative flex w-full", T && "[transform:rotateY(0deg)]", Q && "[transform:rotateY(180deg)]"),
                            children: [(0, C.jsx)("div", {
                                className: "absolute inset-0 z-[-1] mb-[12px] ml-[10px] mr-[12px] mt-[10px] [clip-path:polygon(0_0,100%_100%,100%_0)]",
                                children: (0, C.jsx)("div", {
                                    ref: eo,
                                    className: "h-full w-full bg-yellow-300"
                                })
                            }), (0, C.jsx)(Meter, {})]
                        })]
                    })
                },
                SpinCard = l => {
                    let {
                        onSpin: c,
                        onSpinAll: p,
                        prize: v,
                        rarity: T,
                        showControls: z = !1,
                        spinCount: J,
                        state: Q
                    } = l, {
                        t: es
                    } = (0, M.Z)("game"), eo = P.useRef(null), ec = Q < _.reveal || Q >= _.exiting, eh = ec || !T ? "skeleton" : T, ep = Q >= _.spin && Q < _.exiting, eg = Q >= _.roll || J <= 0, em = "flex h-full w-full flex-col items-center justify-center";
                    return (0, C.jsxs)(eE.s, {
                        variant: eh,
                        children: [(0, C.jsx)(X.u, {
                            placement: "bottom-start",
                            referenceElement: eo.current,
                            children: (0, C.jsx)("div", {
                                className: "typography-brand-body max-w-[160px] text-camo-200",
                                children: es("card.tooltip_spin_all")
                            })
                        }), (0, C.jsxs)(eE.i, {
                            variant: eh,
                            children: [(0, C.jsx)(ed.rl, {
                                appear: !0,
                                duration: ep ? 1e3 : 500,
                                in: ep,
                                children: (0, C.jsxs)("div", {
                                    className: em,
                                    children: [(0, C.jsx)("div", {
                                        className: "relative my-6 aspect-square h-full flex-1",
                                        children: null !== T && (0, C.jsxs)(P.Fragment, {
                                            children: [(0, C.jsx)(ew(), {
                                                fill: !0,
                                                alt: "",
                                                src: {
                                                    common: "/images/orb-atomic-yellow-100.png",
                                                    rare: "/images/orb-concentric-yellow-100.png",
                                                    super: "/images/orb-kinetic-yellow-100.png",
                                                    uncommon: "/images/orb-burst-yellow-100.png"
                                                }[T]
                                            }), (0, C.jsx)(ef.zW, {
                                                duration: 1e3,
                                                in: Q >= _.reveal && Q <= _.claim,
                                                children: (0, C.jsx)(ew(), {
                                                    fill: !0,
                                                    alt: "",
                                                    className: "opacity-0",
                                                    src: {
                                                        common: "/images/orb-atomic-greyscale.png",
                                                        rare: "/images/orb-concentric-greyscale.png",
                                                        super: "/images/orb-kinetic-greyscale.png",
                                                        uncommon: "/images/orb-burst-yellow-100.png"
                                                    }[T]
                                                })
                                            })]
                                        })
                                    }), (0, C.jsx)("div", {
                                        className: "typography-brand-heading-3-caps font-semibold",
                                        children: es("card.label_points", {
                                            count: v
                                        })
                                    })]
                                })
                            }), (0, C.jsxs)("div", {
                                className: (0, el.m)(em, "absolute inset-0 transition-opacity duration-1000"),
                                style: {
                                    opacity: ep ? 0 : 1,
                                    pointerEvents: ep ? "none" : "all"
                                },
                                children: [(0, C.jsx)("div", {
                                    className: "typography-brand-body-l-caps",
                                    children: es("card.label_spin_ready")
                                }), (0, C.jsxs)("div", {
                                    className: "relative flex w-full flex-1 items-center justify-center",
                                    children: [(0, C.jsx)("div", {
                                        className: "absolute h-[1px] w-1/2 -rotate-45 bg-yellow-100"
                                    }), (0, C.jsx)("div", {
                                        className: "absolute h-[1px] w-1/2 rotate-45 bg-yellow-100"
                                    })]
                                }), z && (0, C.jsxs)("div", {
                                    className: "relative flex w-full flex-col items-center px-4",
                                    children: [(0, C.jsx)("div", {
                                        className: "w-full",
                                        children: (0, C.jsx)(X.zx, {
                                            stretch: !0,
                                            disabled: eg,
                                            onClick: c,
                                            variant: "primary",
                                            children: (0, C.jsxs)("div", {
                                                className: "pointer-events-none flex items-center justify-between",
                                                children: [es("card.button_spin"), (0, C.jsx)("span", {
                                                    className: "opacity-50",
                                                    children: es("card.button_spins", {
                                                        count: J
                                                    })
                                                })]
                                            })
                                        })
                                    }), (0, C.jsx)("div", {
                                        className: "absolute top-full",
                                        children: (0, C.jsx)("button", {
                                            ref: eo,
                                            className: "typography-brand-body-l-caps text-camo-300",
                                            disabled: !0,
                                            onClick: () => {},
                                            children: es("card.button_spin_all")
                                        })
                                    })]
                                })]
                            })]
                        })]
                    })
                },
                SuperSpinMultiplier = l => {
                    let {
                        t: c
                    } = (0, M.Z)("game"), [p, v] = P.useState("up");
                    return null === l.multiplier && "down" === p && v("up"), "up" === p && null !== l.multiplier && setTimeout(() => {
                        v("down")
                    }, 2750), (0, C.jsx)("div", {
                        className: "flex h-[56px] w-[144px] bg-yellow-300 [clip-path:polygon(0_0,75%_0%,100%_50%,100%_100%,25%_100%,0%_50%)]",
                        children: (0, C.jsxs)("div", {
                            className: "m-[1px] flex h-[54px] w-[142px] flex-col bg-black [clip-path:polygon(0_0,75%_0%,100%_50%,100%_100%,25%_100%,0%_50%)]",
                            children: [(0, C.jsx)("div", {
                                className: "typography-brand-heading-2 ml-[10%] leading-none text-yellow-100",
                                children: null === l.multiplier ? c("super-spin.multiplier_hidden") : (0, C.jsx)(eC, {
                                    end: l.multiplier,
                                    start: 0
                                })
                            }), (0, C.jsx)("div", {
                                className: "typography-brand-body-bold ml-[25%] uppercase leading-none text-yellow-100",
                                children: c("super-spin.multiplier_label")
                            })]
                        })
                    })
                },
                eC = P.memo(l => {
                    let {
                        end: c,
                        start: p
                    } = l, {
                        lang: v,
                        t: _
                    } = (0, M.Z)("game"), T = P.useRef(p);
                    return P.useEffect(() => {
                        T.current = c
                    }), (0, C.jsx)(ex.ZP, {
                        decimalPlaces: 1,
                        decimals: 1,
                        duration: .85,
                        end: c,
                        start: 0 === T.current && 0 !== p ? c : T.current,
                        easingFn: P.useCallback((l, c, p, v) => -p * (l /= v) * (l - 2) + c, []),
                        formattingFn: P.useCallback(l => _("super-spin.multiplier_revealed", {
                            value: l.toLocaleString(v, {
                                minimumFractionDigits: l === c || 10 === l ? 0 : 1
                            })
                        }), [c, v, _]),
                        children: l => {
                            let {
                                countUpRef: c
                            } = l;
                            return (0, C.jsx)("span", {
                                ref: c
                            })
                        }
                    })
                }, (l, c) => l.end === c.end && l.start === c.start);
            eC.displayName = "CountUpCurrentMultipler";
            let SuperStrobeLights = l => {
                    let {
                        left: c,
                        right: p,
                        state: v
                    } = l, {
                        t: P
                    } = (0, M.Z)("game"), T = {
                        animationDuration: v >= _.spin ? "150ms" : void 0
                    }, z = (0, el.m)("animate-linear-wipe w-full [background-size:auto_200%]", v >= _.reveal ? "bg-yellow-300" : "bg-gradient-to-b from-yellow-300 to-black");
                    return (0, C.jsxs)("div", {
                        className: "flex w-7 flex-col items-center gap-4",
                        children: [(0, C.jsx)("div", {
                            className: (0, el.m)("typography-UI-heading-1 animate uppercase text-yellow-300 [writing-mode:vertical-rl]", c && "rotate-180", p && "rotate-0"),
                            children: P("super-spin.vertical-rl")
                        }), (0, C.jsxs)("div", {
                            className: "flex w-full flex-col gap-2",
                            children: [(0, C.jsx)("div", {
                                className: (0, el.m)(z, "h-[144px]"),
                                style: T
                            }), (0, C.jsx)("div", {
                                className: (0, el.m)(z, "h-[24px]"),
                                style: T
                            }), (0, C.jsx)("div", {
                                className: (0, el.m)(z, "h-[18px]"),
                                style: T
                            }), (0, C.jsx)("div", {
                                className: (0, el.m)(z, "h-[12px]"),
                                style: T
                            }), (0, C.jsx)("div", {
                                className: (0, el.m)(z, "h-[6px]"),
                                style: T
                            }), (0, C.jsx)("div", {
                                className: (0, el.m)(z, "h-[4px]"),
                                style: T
                            }), (0, C.jsx)("div", {
                                className: (0, el.m)(z, "h-[2px]"),
                                style: T
                            })]
                        })]
                    })
                },
                eS = P.memo(l => {
                    let {
                        left: c,
                        mount: p,
                        right: v,
                        ..._
                    } = l, T = P.useRef(null), M = P.useRef(null), z = {
                        duration: _.duration,
                        easing: "cubic-bezier(0.4, 0, 0.2, 1)",
                        fill: "forwards"
                    };
                    if (!0 === _.in) setTimeout(() => {
                        var l, c;
                        null === (l = T.current) || void 0 === l || l.animate([{
                            strokeDashoffset: -112
                        }, {
                            strokeDashoffset: 0
                        }], z), null === (c = M.current) || void 0 === c || c.animate([{
                            strokeDashoffset: 112
                        }, {
                            strokeDashoffset: 0
                        }], z)
                    }, _.duration - 150);
                    else if (p) {
                        var J, Q;
                        null === (J = T.current) || void 0 === J || J.animate([{
                            strokeDashoffset: 0
                        }, {
                            strokeDashoffset: -112
                        }], z), null === (Q = M.current) || void 0 === Q || Q.animate([{
                            strokeDashoffset: 0
                        }, {
                            strokeDashoffset: 112
                        }], z)
                    }
                    let X = p ? ed.E6 : eh.S3;
                    return (0, C.jsxs)("div", {
                        className: (0, el.m)("flex h-full flex-col justify-between", c && "[transform:rotateY(0deg)]", v && "[transform:rotateY(180deg)]"),
                        children: [(0, C.jsx)("svg", {
                            className: "translate-x-[-1px] translate-y-[1px]",
                            fill: "none",
                            height: "16.706",
                            viewBox: "0 0 112 16.706",
                            width: "96",
                            xmlns: "http://www.w3.org/2000/svg",
                            children: (0, C.jsx)("path", {
                                ref: T,
                                d: "M111 1C36.113 8.65 1 16.706 1 16.706",
                                stroke: "currentColor",
                                strokeDasharray: "112",
                                strokeDashoffset: "112",
                                strokeMiterlimit: "10",
                                strokeWidth: "1.5"
                            })
                        }), (0, C.jsx)(X, { ..._,
                            appear: !0,
                            children: (0, C.jsx)("div", {
                                className: "flex-1",
                                children: (0, C.jsx)(ec.iz, {
                                    axis: "y",
                                    className: "bg-current"
                                })
                            })
                        }), (0, C.jsx)("svg", {
                            className: "translate-x-[-1px] translate-y-[-1px]",
                            fill: "none",
                            height: "16.706",
                            viewBox: "0 0 112 16.706",
                            width: "96",
                            xmlns: "http://www.w3.org/2000/svg",
                            children: (0, C.jsx)("path", {
                                ref: M,
                                d: "M1 0s35.08 8.057 110 15.706",
                                stroke: "currentColor",
                                strokeDasharray: "112",
                                strokeDashoffset: "112",
                                strokeMiterlimit: "10",
                                strokeWidth: "1.5"
                            })
                        })]
                    })
                }, (l, c) => l.duration === c.duration && l.in === c.in && l.mount === c.mount);
            eS.displayName = "ViewFinder";
            let WinningWave = l => {
                    let {
                        isFailedLuckSpin: c,
                        state: p
                    } = l;
                    return (0, C.jsx)("video", {
                        autoPlay: !0,
                        loop: !0,
                        muted: !0,
                        src: "/videos/winning-wave.webm",
                        style: {
                            transform: p >= _.reveal && p <= _.exiting && !c ? "scale(1)" : "scale(0)",
                            transformOrigin: "center",
                            transition: "transform 1000ms cubic-bezier(0.4, 0, 0.2, 1)"
                        }
                    })
                },
                Deck = l => {
                    let {
                        deck: c,
                        getAssignedPrize: p,
                        getPrizeRarity: v,
                        setState: P,
                        spinCount: T,
                        spinType: M,
                        state: z,
                        width: J
                    } = l;
                    return (0, C.jsx)("div", {
                        className: "flex h-full w-full justify-center",
                        style: {
                            overflow: "luck-spin" === M ? "visible" : "hidden",
                            width: "".concat(J, "px")
                        },
                        children: (0, C.jsx)("div", {
                            className: (0, el.m)("flex", ey[M].classNames),
                            style: c.getDeckStyle(),
                            children: c.rows.map((l, J) => (0, C.jsx)("div", {
                                className: (0, el.m)("flex", ey[M].classNames),
                                children: Array.from({
                                    length: l
                                }).map((l, Q) => {
                                    var X;
                                    let es = "game-card-".concat(J, "-").concat(Q),
                                        eo = p({
                                            index: Q,
                                            rowIndex: J
                                        }, c.prizeCard.index, "round-robin"),
                                        el = c.getCardStyle({
                                            index: Q,
                                            rowIndex: J
                                        }),
                                        ec = {
                                            spinCount: T,
                                            state: z,
                                            prize: eo,
                                            rarity: v(eo)
                                        };
                                    return "luck-spin" === M ? (0, C.jsx)("div", {
                                        style: el,
                                        children: (0, C.jsx)(LuckCard, { ...ec,
                                            onFlip: l => {
                                                let {
                                                    target: p
                                                } = l;
                                                c.mutatePrizeCardParts({
                                                    el: p,
                                                    index: {
                                                        index: Q,
                                                        rowIndex: J
                                                    }
                                                }), P(_.roll)
                                            }
                                        })
                                    }, es) : (0, C.jsx)("div", {
                                        style: el,
                                        children: (0, C.jsx)(SpinCard, { ...ec,
                                            onSpin: () => P(_.roll),
                                            showControls: Q === (null === (X = c.prizeCard.index) || void 0 === X ? void 0 : X.index),
                                            onSpinAll: () => {}
                                        })
                                    }, es)
                                })
                            }, "game-row-".concat(J)))
                        })
                    })
                },
                RevealStateControls = l => {
                    let {
                        isFailedLuckSpin: c,
                        setState: p,
                        spinCount: v,
                        spinType: T
                    } = l, {
                        t: z
                    } = (0, M.Z)("game");
                    return "luck-spin" === T ? (0, C.jsx)(X.zx, {
                        stretch: !0,
                        variant: "primary",
                        onClick: () => {
                            c ? p(_.ready) : p(_.claim)
                        },
                        children: (0, C.jsx)("div", {
                            className: "flex w-56 items-center justify-between",
                            children: c ? (0, C.jsxs)(P.Fragment, {
                                children: [z("luck-spin.button_try_again"), (0, C.jsx)("span", {
                                    className: "opacity-50",
                                    children: z("card.button_spins", {
                                        count: v
                                    })
                                })]
                            }) : (0, C.jsx)("span", {
                                className: "w-full",
                                children: z("luck-spin.button_claim")
                            })
                        })
                    }) : (0, C.jsx)(X.zx, {
                        stretch: !0,
                        onClick: () => p(_.claim),
                        variant: "primary",
                        children: (0, C.jsx)("div", {
                            className: "w-56",
                            children: z("".concat(T, ".button_claim"))
                        })
                    })
                };

            function Game(l) {
                let c = { ...l.options,
                        opening: "reduced"
                    },
                    {
                        data: p,
                        setState: v,
                        state: T
                    } = l,
                    {
                        luck: z,
                        spinCount: J,
                        spinsPerWeek: X,
                        spinType: es
                    } = p,
                    eo = function(l, c) {
                        var p, v, _;
                        let {
                            spinType: C
                        } = c, T = P.useRef(null), M = P.useRef(null), z = P.useRef(null), [J, Q] = P.useState(0), X = P.useCallback(() => {
                            Q(l => l + 1)
                        }, []);
                        P.useEffect(() => {
                            let l;
                            X();
                            let onResize = () => {
                                clearTimeout(l), l = setTimeout(X, 250)
                            };
                            return window.addEventListener("resize", onResize), () => {
                                clearTimeout(l), window.removeEventListener("resize", onResize)
                            }
                        }, [l, X]);
                        let es = T.current,
                            eo = M.current,
                            el = z.current,
                            ec = null == es ? void 0 : es.getBoundingClientRect(),
                            eh = null == eo ? void 0 : eo.getBoundingClientRect(),
                            ed = null == el ? void 0 : el.getBoundingClientRect(),
                            ef = null !== (p = null == ec ? void 0 : ec.height) && void 0 !== p ? p : 0,
                            em = null !== (v = null == eh ? void 0 : eh.height) && void 0 !== v ? v : 0,
                            ey = null !== (_ = null == ed ? void 0 : ed.height) && void 0 !== _ ? _ : 0,
                            eb = Math.min(ep.px, Math.floor(ef - em - ey)),
                            ew = Math.min(eg.px, Math.floor(2.2 * eb)),
                            ex = getCardHeight(eb, C),
                            e_ = getCardWidth(ex, C);
                        return {
                            card: {
                                height: ex,
                                width: e_
                            },
                            deck: {
                                height: eb,
                                width: ew
                            },
                            refs: {
                                contentArea: T,
                                footer: z,
                                header: M
                            }
                        }
                    }(T, p),
                    eb = function(l, c, p) {
                        let {
                            luck: v,
                            spinType: C
                        } = p, [T, M] = P.useState(null), [z, J] = P.useReducer(useResultReducer, {
                            isLuckImproved: null,
                            pool: null,
                            result: null,
                            touched: !1
                        });
                        return l === _.ready && null !== T && M(null), P.useEffect(() => {
                            if (l === _.roll) {
                                setTimeout(() => {
                                    c(_.spin)
                                }, 1250);
                                let executeSpin = async () => {
                                    let l = 1;
                                    "super-spin" === C && M(l = await fetch((0, Q.FP)("/spins/sample-superspin"), {
                                        credentials: "include",
                                        headers: {
                                            "Content-Type": "application/json"
                                        },
                                        method: "POST"
                                    }).then(l => l.json()).then(l => {
                                        let {
                                            spinMultiplier: c
                                        } = l;
                                        return null != c ? c : 1
                                    })), fetch((0, Q.FP)("/spins/execute"), {
                                        body: JSON.stringify({
                                            spinType: C,
                                            spinMultiplier: l
                                        }),
                                        credentials: "include",
                                        headers: {
                                            "Content-Type": "application/json"
                                        },
                                        method: "POST"
                                    }).then(l => l.json()).then(l => {
                                        let c = "luck-spin" === C ? l => {
                                                var c;
                                                return {
                                                    rarity: l.rarity,
                                                    value: Math.round((null !== (c = l.luck) && void 0 !== c ? c : 0) * 100)
                                                }
                                            } : l => ({
                                                rarity: l.rarity,
                                                value: l.numberPoints
                                            }),
                                            p = c(l.result).value;
                                        J({
                                            payload: {
                                                isLuckImproved: "luck-spin" === C ? p > v : null,
                                                pool: l.possibilities.map(c),
                                                result: p
                                            },
                                            type: "update"
                                        })
                                    })
                                };
                                executeSpin()
                            }
                        }, [l, v, C, c]), { ...z,
                            multiplier: T,
                            getAssignedPrize: (l, c, p) => {
                                var v, _, C, P;
                                let T = z.pool,
                                    M = z.result;
                                if (null === T || null === M || null === c) return null;
                                if (l.index === c.index && l.rowIndex === c.rowIndex) return M;
                                let J = l.index,
                                    Q = c.index;
                                switch (p) {
                                    case "round-robin":
                                        let X = J < Q ? (J + T.length - 1) % T.length : (J - 1) % T.length;
                                        return null !== (_ = null === (v = T[X]) || void 0 === v ? void 0 : v.value) && void 0 !== _ ? _ : null;
                                    case "sequential":
                                        return null !== (P = null === (C = T[(J > Q ? J - 1 : J) % T.length]) || void 0 === C ? void 0 : C.value) && void 0 !== P ? P : null
                                }
                            },
                            getPrizeRarity: l => {
                                var c;
                                if (null === l || null === z.pool) return null;
                                if ("super-spin" === C) return "super";
                                let p = z.pool.find(c => l === c.value),
                                    v = null !== (c = null == p ? void 0 : p.rarity) && void 0 !== c ? c : null;
                                return "extra-rare" !== v ? v : "luck-spin" === C ? "super" : "rare"
                            }
                        }
                    }(T, v, p),
                    ew = function(l, c, p, v, C) {
                        let {
                            spinType: T
                        } = p, M = v.card.height, z = v.card.width, J = z + ey[T].px, Q = "luck-spin" === T ? 5 : 11, X = "luck-spin" === T ? 2 : 5, es = "luck-spin" === T ? 1e3 : 6e3, eo = P.useRef({
                            el: null,
                            index: {
                                index: (Q - 1) / 2,
                                rowIndex: X - 1
                            },
                            style: null
                        }), mutatePrizeCardParts = l => {
                            eo.current = { ...eo.current,
                                ...l
                            }
                        }, el = Array(l >= _.spin ? X : "luck-spin" === T ? 2 : 1).fill(Q);
                        l === _.spin && setTimeout(() => {
                            c(_.reveal)
                        }, es + 250), l === _.claim && setTimeout(() => {
                            c(_.ready)
                        }, 2250);
                        let getSpinCardStyle = c => {
                                var p;
                                let {
                                    index: C
                                } = c, P = null === (p = eo.current.index) || void 0 === p ? void 0 : p.index;
                                if ("number" != typeof P) throw Error("engine: getSpinCardStyle: Expected non-null prize card");
                                let T = C - P,
                                    M = v.card.height,
                                    z = v.card.width,
                                    J = "0deg",
                                    Q = "1",
                                    X = "".concat(1e3, "ms"),
                                    es = "scale, translate",
                                    el = "0 0";
                                return l < _.roll || l >= _.exiting ? (el = "".concat(0 - 90 * T, "% ").concat(C === P ? -1 : 0, "px"), Q = "".concat(1 - .1 * Math.abs(T))) : l === _.claim ? (el = "".concat(100 * Math.sign(C - P) || 0, "% ").concat(0, "px"), Q = "".concat(C === P ? 1.085 : 1), J = "y ".concat(C === P ? 720 : 0, "deg"), X = "".concat(2e3, "ms"), es = "scale, translate, rotate") : l >= _.reveal && (el = "".concat(100 * Math.sign(C - P) || 0, "% ").concat(0, "px"), Q = "".concat(C === P ? 1.085 : 1)), {
                                    height: M,
                                    rotate: J,
                                    scale: Q,
                                    transitionDuration: X,
                                    transitionProperty: es,
                                    translate: el,
                                    width: z,
                                    zIndex: -Math.abs(T)
                                }
                            },
                            getLuckCardStyle = c => {
                                var p, P, J;
                                let Q = eo.current,
                                    X = Q.index;
                                if (null === X) throw Error("engine: getLuckCardStyle: Expected non-null prize card");
                                let es = c.index === X.index && c.rowIndex === X.rowIndex,
                                    el = v.card.height,
                                    ec = v.card.width,
                                    eh = "1",
                                    ed = "y 0deg",
                                    ef = "1",
                                    ep = "".concat(1e3, "ms"),
                                    eg = "opacity, scale, translate",
                                    eb = "0 0";
                                if (l === _.claim) {
                                    let l = es && (null === (p = Q.style) || void 0 === p ? void 0 : p.translate) || "0 0";
                                    eh = "".concat(es ? 1 : 0), ed = "y ".concat(es ? 900 : 0, "deg"), eb = "".concat(l), ef = "".concat(es ? 2 : 1), ep = "".concat(2e3, "ms"), eg = "opacity, scale, translate, rotate"
                                } else if (l === _.reveal) {
                                    let l = es && (null === (P = Q.style) || void 0 === P ? void 0 : P.translate) || "0 0";
                                    eb = "".concat(l), eh = "".concat(es ? 1 : 0), ed = "y ".concat(es ? 180 : 0, "deg"), ef = "".concat(es ? 2 : 1), eg = "opacity, scale, translate, rotate"
                                } else if (l === _.spin) {
                                    let l = null === (J = Q.el) || void 0 === J ? void 0 : J.getBoundingClientRect(),
                                        c = Number(null == l ? void 0 : l.left),
                                        p = Number(null == l ? void 0 : l.top),
                                        v = window.innerWidth / 2,
                                        _ = window.innerHeight / 2,
                                        C = _ - (p + M / 2) + ey[T].px + 2 * em[T].px;
                                    eh = "".concat(es ? 1 : 0), ef = "".concat(1), eb = "".concat(v - (c + z / 2), "px ").concat(C, "px"), es && mutatePrizeCardParts({
                                        style: {
                                            translate: eb
                                        }
                                    })
                                } else l === _.roll ? (eh = "".concat(es ? 1 : 0), ef = "".concat(es ? 1.05 : 1)) : l === _.ready && (eg = "opacity, scale, translate, rotate", C.isLuckImproved && (ed = "y ".concat(es ? 700 : 0, "deg")));
                                return {
                                    height: el,
                                    opacity: eh,
                                    rotate: ed,
                                    scale: ef,
                                    transitionDuration: ep,
                                    transitionProperty: eg,
                                    translate: eb,
                                    width: ec
                                }
                            },
                            getLuckDeckStyle = () => ({
                                flexDirection: "column"
                            }),
                            getSpinDeckStyle = () => {
                                if (!(l >= _.spin) || !(l < _.exiting)) return {
                                    flexDirection: "row"
                                }; {
                                    let l = Math.floor(el.length / 2),
                                        c = (el.length - l - 1) * Q * J,
                                        p = {
                                            x: Math.floor(50 * Math.random()) / 100,
                                            y: Math.floor(20 * Math.random()) / 100
                                        };
                                    return {
                                        flexDirection: "row",
                                        transform: "translate3D(-".concat(c, "px,0px,0px)"),
                                        transitionDuration: "".concat(es, "ms"),
                                        transitionProperty: "all",
                                        transitionTimingFunction: "cubic-bezier(0,".concat(p.x, ",").concat(p.y, ",1)")
                                    }
                                }
                            };
                        return {
                            mutatePrizeCardParts,
                            rows: el,
                            getCardStyle: l => "luck-spin" === T ? getLuckCardStyle(l) : getSpinCardStyle(l),
                            getDeckStyle: () => "luck-spin" === T ? getLuckDeckStyle() : getSpinDeckStyle(),
                            prizeCard: eo.current
                        }
                    }(T, v, p, eo, eb),
                    {
                        t: ex
                    } = (0, M.Z)("game"),
                    e_ = "luck-spin" === es && !eb.isLuckImproved,
                    eE = P.useRef(void 0);
                return P.useEffect(() => {
                    clearTimeout(eE.current)
                }, [T]), (0, C.jsx)(ed.WV, {
                    appear: !0,
                    duration: T === _.exiting ? 500 : 2e3,
                    in: T > _.idle && T < _.exiting,
                    children: (0, C.jsx)("div", {
                        className: "absolute inset-0 z-10 bg-black",
                        children: (0, C.jsx)(ec.M9, {
                            className: "h-full",
                            position: "center-x",
                            children: (0, C.jsxs)("div", {
                                className: "relative flex h-full w-full flex-col",
                                children: [(0, C.jsx)(ef.zW, {
                                    duration: 1e3,
                                    in: T < _.roll || T >= _.reveal,
                                    children: (0, C.jsx)("div", {
                                        className: "absolute left-0 top-6",
                                        children: (0, C.jsx)(ec.Hw, {
                                            appear: {
                                                duration: 1500,
                                                in: T > _.idle
                                            }
                                        })
                                    })
                                }), (0, C.jsx)(ef.zW, {
                                    duration: 1e3,
                                    in: T < _.roll || T >= _.reveal,
                                    children: (0, C.jsx)("div", {
                                        className: "absolute right-0 top-6",
                                        children: (0, C.jsx)(ec.Hw, {
                                            appear: {
                                                duration: 1500,
                                                in: T > _.idle
                                            }
                                        })
                                    })
                                }), (0, C.jsx)(ed.WV, {
                                    appear: !0,
                                    duration: 1e3,
                                    in: "super-spin" === es && T > _.idle,
                                    children: (0, C.jsx)("div", {
                                        className: "absolute right-4 top-11",
                                        children: (0, C.jsx)(SuperSpinMultiplier, {
                                            multiplier: eb.multiplier
                                        })
                                    })
                                }), (0, C.jsx)(ed.WV, {
                                    appear: !0,
                                    duration: 1e3,
                                    in: "luck-spin" === es && T > _.idle,
                                    children: (0, C.jsx)("div", {
                                        className: "absolute right-4 top-11",
                                        children: (0, C.jsx)(LuckSpinLuck, {
                                            inDuration: 1750,
                                            luck: z,
                                            state: T
                                        })
                                    })
                                }), (0, C.jsx)("div", {
                                    ref: eo.refs.contentArea,
                                    className: "w-full flex-1",
                                    children: (0, C.jsxs)("div", {
                                        className: "flex h-full w-full flex-col items-center justify-center px-12",
                                        children: [(0, C.jsx)(eh.ug, {
                                            duration: 1500,
                                            in: T > _.idle,
                                            children: (0, C.jsx)("div", {
                                                ref: eo.refs.header,
                                                children: (0, C.jsx)(ef.zW, {
                                                    duration: 1e3,
                                                    in: T < _.roll,
                                                    children: (0, C.jsxs)("div", {
                                                        className: "flex flex-col items-center gap-2 px-28 pb-8",
                                                        children: [(0, C.jsx)("div", {
                                                            className: "typography-brand-heading-3-caps text-yellow-100",
                                                            children: ex("".concat(es, ".h1"), {
                                                                count: J
                                                            })
                                                        }), (0, C.jsx)("div", {
                                                            className: "typography-brand-body-l text-yellow-100",
                                                            children: ex("".concat(es, ".h2"))
                                                        })]
                                                    })
                                                })
                                            })
                                        }), (0, C.jsxs)("div", {
                                            className: "relative flex flex-col items-center justify-center",
                                            style: {
                                                height: "".concat(eo.deck.height, "px"),
                                                width: "".concat(eo.deck.width, "px")
                                            },
                                            children: [(0, C.jsx)("div", {
                                                className: "pointer-events-none absolute z-[-10] scale-[1.75]",
                                                children: (0, C.jsx)(WinningWave, {
                                                    isFailedLuckSpin: e_,
                                                    state: T
                                                })
                                            }), (0, C.jsx)(ed.WV, {
                                                appear: !0,
                                                duration: 1e3,
                                                in: T >= _.reveal,
                                                children: (0, C.jsx)("div", {
                                                    className: "absolute -bottom-14 z-10",
                                                    children: (0, C.jsx)(RevealStateControls, {
                                                        isFailedLuckSpin: e_,
                                                        setState: v,
                                                        spinCount: J,
                                                        spinType: es
                                                    })
                                                })
                                            }), (0, C.jsx)("div", {
                                                className: "absolute bottom-0 left-0 top-0 z-[1] text-camo-400",
                                                children: (0, C.jsx)(eS, {
                                                    left: !0,
                                                    duration: 750,
                                                    in: T > _.idle
                                                })
                                            }), (0, C.jsx)("div", {
                                                className: "absolute bottom-0 right-0 top-0 z-[1] text-camo-400",
                                                children: (0, C.jsx)(eS, {
                                                    right: !0,
                                                    duration: 750,
                                                    in: T > _.idle
                                                })
                                            }), (0, C.jsx)("div", {
                                                className: "absolute bottom-0 left-0 top-0 z-[1] text-yellow-300",
                                                children: (0, C.jsx)(eS, {
                                                    left: !0,
                                                    mount: !0,
                                                    duration: 750,
                                                    in: T >= _.reveal
                                                })
                                            }), (0, C.jsx)("div", {
                                                className: "absolute bottom-0 right-0 top-0 z-[1] text-yellow-300",
                                                children: (0, C.jsx)(eS, {
                                                    mount: !0,
                                                    right: !0,
                                                    duration: 750,
                                                    in: T >= _.reveal
                                                })
                                            }), "super-spin" === es && (0, C.jsxs)(P.Fragment, {
                                                children: [(0, C.jsx)("div", {
                                                    className: "absolute right-full mr-4 h-max w-max",
                                                    children: (0, C.jsx)(SuperStrobeLights, {
                                                        left: !0,
                                                        state: T
                                                    })
                                                }), (0, C.jsx)("div", {
                                                    className: "absolute left-full ml-4 h-max w-max",
                                                    children: (0, C.jsx)(SuperStrobeLights, {
                                                        right: !0,
                                                        state: T
                                                    })
                                                })]
                                            }), "luck-spin" === es && (0, C.jsxs)(P.Fragment, {
                                                children: [(0, C.jsx)("div", {
                                                    className: "absolute right-full mr-4 h-max w-max",
                                                    children: (0, C.jsx)(LuckStrobeMeter, {
                                                        left: !0,
                                                        luck: z,
                                                        result: eb.result,
                                                        state: T
                                                    })
                                                }), (0, C.jsx)("div", {
                                                    className: "absolute left-full ml-4 h-max w-max",
                                                    children: (0, C.jsx)(LuckStrobeMeter, {
                                                        right: !0,
                                                        luck: z,
                                                        result: eb.result,
                                                        state: T
                                                    })
                                                })]
                                            }), (0, C.jsx)(DeckMaxHeight, {
                                                delay: "reduced" === c.opening ? 0 : 2e3,
                                                duration: "reduced" === c.opening ? 0 : 2e3,
                                                in: T > _.idle,
                                                children: (0, C.jsx)("div", {
                                                    style: {
                                                        height: "".concat(eo.deck.height, "px")
                                                    },
                                                    className: (0, el.m)("relative flex", em[es].classNames),
                                                    children: (0, C.jsx)(DeckMaxWidth, {
                                                        delay: "reduced" === c.opening ? 0 : 4e3,
                                                        duration: "reduced" === c.opening ? 0 : 1e3,
                                                        in: T > _.idle,
                                                        onComplete: () => {
                                                            v(_.entered), eE.current = setTimeout(() => v(_.ready), 1e3)
                                                        },
                                                        children: (0, C.jsx)(Deck, {
                                                            deck: ew,
                                                            getAssignedPrize: eb.getAssignedPrize,
                                                            getPrizeRarity: eb.getPrizeRarity,
                                                            setState: v,
                                                            spinCount: J,
                                                            spinType: es,
                                                            state: T,
                                                            width: eo.deck.width
                                                        })
                                                    })
                                                })
                                            })]
                                        })]
                                    })
                                }), (0, C.jsxs)("div", {
                                    ref: eo.refs.footer,
                                    className: "mt-3 flex flex-col",
                                    children: [(0, C.jsx)(ef.zW, {
                                        duration: 1e3,
                                        in: T < _.roll,
                                        children: (0, C.jsxs)("aside", {
                                            className: "flex justify-center gap-6",
                                            children: [(0, C.jsx)(eh.ug, {
                                                duration: 1500,
                                                in: T > _.idle,
                                                children: (0, C.jsx)("div", {
                                                    className: "typography-brand-body-l-caps text-yellow-100",
                                                    children: ex("".concat(es, ".aside_left"))
                                                })
                                            }), (0, C.jsx)(ec.iz, {
                                                axis: "y"
                                            }), (0, C.jsx)(eh.ug, {
                                                duration: 1500,
                                                in: T > _.idle,
                                                children: (0, C.jsx)("div", {
                                                    className: "typography-brand-body-l text-yellow-100",
                                                    children: ex("".concat(es, ".aside_right"), {
                                                        count: X
                                                    })
                                                })
                                            })]
                                        })
                                    }), (0, C.jsx)(ef.zW, {
                                        duration: 1e3,
                                        in: T < _.roll || T >= _.reveal,
                                        children: (0, C.jsxs)("div", {
                                            className: "flex items-center gap-4",
                                            children: [(0, C.jsx)(ec.Hw, {
                                                appear: {
                                                    duration: 1500,
                                                    in: T > _.idle
                                                }
                                            }), (0, C.jsx)(eh.IR, {
                                                duration: 1500,
                                                in: T > _.idle,
                                                children: (0, C.jsx)(ec.iz, {
                                                    axis: "x",
                                                    className: "flex-1"
                                                })
                                            }), (0, C.jsx)(ec.Hw, {
                                                appear: {
                                                    duration: 1500,
                                                    in: T > _.idle
                                                }
                                            })]
                                        })
                                    })]
                                })]
                            })
                        })
                    })
                })
            }
            let DeckMaxHeight = l => (0, C.jsx)(eh.gT, { ...l,
                    classNames: {
                        appear: "max-h-[0px]",
                        appearDone: (0, el.m)(ep.className, "transition-all"),
                        exit: ep.className,
                        exitDone: "max-h-[0px] transition-all"
                    },
                    children: l.children
                }),
                DeckMaxWidth = l => (0, C.jsx)(eh.gT, { ...l,
                    classNames: {
                        appear: "scale-x-0 max-w-[0px]",
                        appearDone: (0, el.m)(eg.className, "scale-x-1 transition-all"),
                        exit: (0, el.m)(eg.className, "scale-x-1"),
                        exitDone: "scale-x-0 max-w-[0px] transition-all"
                    },
                    children: l.children
                }),
                eN = P.createContext(null),
                GameProvider = l => {
                    var c;
                    let p = (0, z.useRouter)(),
                        {
                            mutate: v
                        } = (0, J.kY)(),
                        {
                            me: T,
                            refreshMe: M
                        } = (0, eo.Hi)(),
                        {
                            toggleBackground: el
                        } = (0, es.$)(),
                        [ec, eh] = P.useState(null),
                        [ed, ef] = P.useState(_.idle),
                        [ep, eg] = P.useState(),
                        em = null == ec ? void 0 : ec.spinCount,
                        ey = null == ec ? void 0 : ec.spinType,
                        {
                            replace: eb
                        } = p,
                        ew = P.useCallback((l, c) => {
                            eh(l), eg(c)
                        }, []),
                        ex = P.useCallback(() => {
                            ef(l => l > _.idle && l <= _.ready ? _.exiting : l)
                        }, []),
                        e_ = P.useCallback(() => {
                            null !== ec ? ef(l => l === _.idle ? (el("black", 500), _.entering) : l) : console.warn("GameContext: Could not start uninitialized Game. Suggest leaving the target element.")
                        }, [ec, el]),
                        eE = P.useCallback(() => {
                            eh(null), ef(_.idle), eg(void 0)
                        }, []);
                    P.useEffect(() => {
                        let onKeyDown = l => {
                            "Escape" === l.key && ex()
                        };
                        return document.addEventListener("keydown", onKeyDown), () => document.removeEventListener("keydown", onKeyDown)
                    }, [ex]), P.useEffect(() => {
                        ed === _.ready && 0 === em && setTimeout(() => {
                            ex(), eb("/airdrop", void 0, {
                                shallow: !0
                            })
                        }, 1500)
                    }, [ex, eb, ed, ey, em]), P.useEffect(() => {
                        ed === _.entering && M(), ed === _.reveal && eh(l => null === l ? l : { ...l,
                            spinCount: l.spinCount - 1
                        }), ed === _.claim && (M(), v((0, Q.FP)("/user/dashboard"))), ed === _.exiting && (el("default", 1e3), setTimeout(() => ef(_.exited), 750)), ed === _.exited && eE()
                    }, [ed, v, ex, M, eE, el]);
                    let eA = Array.from(document.getElementsByTagName("main")),
                        eC = null == eA ? void 0 : eA[0];
                    return (0, C.jsxs)(eN.Provider, {
                        value: {
                            init: ew,
                            quit: ex,
                            start: e_,
                            isOpen: ed > _.idle && ed < _.exiting
                        },
                        children: [l.children, (0, C.jsx)(X.h_, {
                            container: eC,
                            children: null !== ec && "string" != typeof T && (0, C.jsx)(DynamicNamespaces, {
                                namespaces: ["game"],
                                children: (0, C.jsx)(Game, {
                                    options: ep,
                                    setState: ef,
                                    state: ed,
                                    data: { ...ec,
                                        luck: Math.round((null !== (c = T.luck) && void 0 !== c ? c : 0) * 100)
                                    }
                                })
                            })
                        })]
                    })
                };

            function useGame() {
                let l = P.useContext(eN);
                if (null === l) throw Error("Missing expected GameContext");
                return l
            }
        },
        5199: function(l, c, p) {
            "use strict";
            p.d(c, {
                i: function() {
                    return SpinCardCurrentColor
                },
                s: function() {
                    return SpinCardFrontBack
                }
            });
            var v = p(4817),
                _ = p(1389);
            let SpinCardFrontBack = l => {
                    let {
                        children: c,
                        variant: p
                    } = l;
                    return (0, v.jsxs)("div", {
                        className: "relative aspect-square h-full w-full",
                        children: [(0, v.jsx)("svg", {
                            className: "h-full w-full",
                            fill: "none",
                            viewBox: "0 0 432 398",
                            xmlns: "http://www.w3.org/2000/svg",
                            children: (0, v.jsx)("path", {
                                d: "M386.198 11.9007H374.291V1.65039H347.29V22.1338H186.161L164.692 1.65039H10.752C5.22911 1.65039 0.751953 6.12754 0.751953 11.6504V361.347L58.5143 397.001H421.23C426.753 397.001 431.23 392.524 431.23 387.001V40.7039L386.198 11.9007Z",
                                strokeMiterlimit: "10",
                                strokeWidth: "1.5",
                                className: (0, _.m)("transition-colors duration-1000", "skeleton" === p && "fill-black stroke-yellow-100", "common" === p && "fill-camo-200 stroke-camo-200", "uncommon" === p && "fill-yellow-600 stroke-yellow-600", "rare" === p && "fill-yellow-100 stroke-yellow-100", "super" === p && "fill-yellow-300 stroke-yellow-300")
                            })
                        }), (0, v.jsx)("div", {
                            className: "absolute inset-0 px-[24px] py-[15%]",
                            children: c
                        })]
                    })
                },
                SpinCardCurrentColor = l => {
                    let {
                        children: c,
                        variant: p
                    } = l;
                    return (0, v.jsx)("div", {
                        className: (0, _.m)("relative flex h-full w-full flex-col items-center justify-between transition-colors duration-1000", "skeleton" === p && "text-yellow-100", "common" === p && "text-black", "uncommon" === p && "text-yellow-100", "rare" === p && "text-black", "super" === p && "text-black"),
                        children: c
                    })
                }
        },
        6359: function(l, c, p) {
            "use strict";
            p.d(c, {
                Hw: function() {
                    return FineCrosshair
                },
                Jp: function() {
                    return ScrollHeader
                },
                M9: function() {
                    return MainContent
                },
                RQ: function() {
                    return Frame
                },
                h4: function() {
                    return Header
                },
                i4: function() {
                    return TrackDivider
                },
                iz: function() {
                    return Divider
                },
                oT: function() {
                    return ScanCodeD
                },
                or: function() {
                    return Main
                }
            });
            var v = p(4817),
                _ = p(8821),
                C = p.n(_),
                P = p(8735),
                T = p.n(P),
                M = p(1248),
                z = p(1389),
                J = p(5834),
                Q = p(8299),
                X = p(6227),
                es = p(9651),
                eo = p(1173);
            let Frame = l => {
                    let {
                        bottomEdgeContent: c = (0, v.jsx)(es.B, {}),
                        children: p,
                        height: _ = "screen",
                        showBars: C = !1
                    } = l, P = (0, eo.$)(), [Q, eh] = M.useState(!1), ed = M.useRef(null), ef = M.useRef(null), ep = M.useRef(null), eg = M.useRef(null), em = M.useRef(null);
                    return M.useEffect(() => {
                        if ("hero" !== P.defaultBackground) return;
                        let l = new Image;
                        l.srcset = "/images/hero-0.5x.jpg 0.5x, /images/hero-1x.jpg 1x, /images/hero-2x.jpg 2x", l.onload = () => eh(!0)
                    }, [P.defaultBackground]), M.useEffect(() => {
                        let apply = (l, c) => {
                                null !== l && c(l)
                            },
                            setPositions = () => {
                                let l = document.body.getBoundingClientRect(),
                                    c = 0 === l.top ? "absolute" : "fixed";
                                apply(ed.current, l => l.style.position = c), apply(ef.current, l => l.style.position = c), apply(ep.current, l => l.style.position = c), apply(eg.current, l => l.style.position = c), apply(em.current, l => l.style.position = c)
                            };
                        return setPositions(), window.addEventListener("scroll", setPositions), () => {
                            window.removeEventListener("scroll", setPositions)
                        }
                    }, []), (0, v.jsxs)("div", {
                        className: (0, z.m)("relative flex min-h-screen w-screen px-[11px] py-[12px] sm:py-[11px]", "screen" === _ && "h-screen overflow-hidden", "auto" === _ && "h-auto", "responsive" === _ && "h-auto sm:h-screen"),
                        children: [(0, v.jsxs)("div", {
                            className: (0, z.m)("relative flex min-h-full w-full flex-1 flex-col rounded-md border-2 border-camo-500 transition-colors", "screen" === _ && "overflow-hidden", "bg-gradient-to-b from-[#11140C] from-[27.54%] to-[#252B1B]", "hero" === P.defaultBackground && "xs:bg-[image-set('/images/hero-0.5x.jpg'_0.5x,'/images/hero-1x.jpg'_1x,'/images/hero-2x.jpg'_2x)] bg-cover bg-center bg-no-repeat"),
                            children: [(0, v.jsx)("div", {
                                className: (0, z.m)("relative z-10 flex flex-1 flex-col pb-16", "screen" === _ && "h-screen overflow-hidden", "responsive" === _ && "h-auto sm:h-full", "hero" === P.defaultBackground && "xs:[background:linear-gradient(180deg,_rgba(17,_20,_12,_0.24)_27.54%,_rgba(17,_20,_12,_0.37)_58.11%,_rgba(17,_20,_12,_0.63)_100%)]"),
                                children: p
                            }), "hero" === P.defaultBackground && (0, v.jsx)("div", {
                                className: (0, z.m)(Q ? "opacity-0" : "opacity-100", "pointer-events-none absolute inset-0 z-0 hidden h-full w-full bg-[url('/images/hero-0.5x.jpg')] bg-cover bg-center bg-no-repeat transition-opacity duration-1000 xs:block")
                            }), (0, v.jsx)("div", {
                                className: (0, z.m)("bg-black", X.L[P.duration], "black" === P.background ? "opacity-100" : "opacity-0", "pointer-events-none absolute inset-0 z-0 h-full w-full transition-opacity")
                            })]
                        }), (0, v.jsx)("div", {
                            ref: ed,
                            className: "absolute left-0 right-0 top-0 z-20 h-[14px] border-b-2 border-camo-500 bg-black sm:h-[13px]"
                        }), (0, v.jsx)("div", {
                            className: "absolute bottom-0 left-0 right-0 z-20 h-[14px] border-t-2 border-camo-500 bg-black sm:h-[13px]"
                        }), (0, v.jsx)(T(), {
                            ref: eg,
                            alt: "",
                            className: "pointer-events-none absolute left-0 top-0 z-20 hidden sm:block",
                            height: 0,
                            src: "/images/frame-corner-sm-top-left.svg",
                            width: 597
                        }), (0, v.jsx)(T(), {
                            ref: em,
                            alt: "",
                            className: "pointer-events-none absolute right-0 top-0 z-20 hidden sm:block",
                            height: 0,
                            src: "/images/frame-corner-sm-top-right.svg",
                            width: 465
                        }), (0, v.jsx)(T(), {
                            ref: ef,
                            alt: "",
                            className: "pointer-events-none absolute left-0 top-0 z-20 block sm:hidden",
                            height: 0,
                            src: "/images/frame-corner-top-left.svg",
                            width: 150
                        }), (0, v.jsx)(T(), {
                            ref: ep,
                            alt: "",
                            className: "pointer-events-none absolute right-0 top-0 z-20 block sm:hidden",
                            height: 0,
                            src: "/images/frame-corner-top-right.svg",
                            width: 211
                        }), (0, v.jsx)(T(), {
                            alt: "",
                            className: "pointer-events-none absolute bottom-0 right-0 z-20 hidden sm:block",
                            height: 0,
                            src: "/images/frame-corner-sm-bottom-right.svg",
                            width: 465
                        }), (0, v.jsx)(T(), {
                            alt: "",
                            className: "pointer-events-none absolute bottom-0 right-0 z-20 block sm:hidden",
                            height: 0,
                            src: "/images/frame-corner-bottom-right.svg",
                            width: 211
                        }), c && (0, v.jsx)("div", {
                            className: "absolute bottom-5 z-20 hidden animate-appear-expand-right items-center xs:left-[150px] xs:right-[180px] xs:flex sm:left-[600px] sm:right-60",
                            children: c
                        }), (0, v.jsx)(T(), {
                            alt: "",
                            className: "pointer-events-none absolute bottom-0 left-0 z-20 hidden sm:block",
                            height: 0,
                            src: "/images/frame-corner-sm-bottom-left.svg",
                            width: 597
                        }), (0, v.jsx)(T(), {
                            alt: "",
                            className: "pointer-events-none absolute bottom-0 left-0 z-20 block sm:hidden",
                            height: 0,
                            src: "/images/frame-corner-bottom-left.svg",
                            width: 150
                        }), C && (0, v.jsxs)(M.Fragment, {
                            children: [(0, v.jsx)(ec, {}), (0, v.jsx)(el, {})]
                        }), (0, v.jsxs)("div", {
                            className: "absolute z-20 hidden items-center gap-6 text-camo-400 xs:bottom-1 xs:right-10 xs:flex xs:max-sm:scale-75 sm:bottom-5 sm:right-20",
                            children: [(0, v.jsx)("a", {
                                href: "https://twitter.com/Blast_L2",
                                rel: "noreferrer",
                                target: "_blank",
                                children: (0, v.jsx)(J.hU, {
                                    "aria-label": "Twitter",
                                    name: "twitter-filled",
                                    variant: "tertiary"
                                })
                            }), (0, v.jsx)("a", {
                                href: "https://discord.gg/blast-l2",
                                rel: "noreferrer",
                                target: "_blank",
                                children: (0, v.jsx)(J.hU, {
                                    "aria-label": "Discord",
                                    name: "discord",
                                    variant: "tertiary"
                                })
                            })]
                        })]
                    })
                },
                FineCrosshair = l => (0, v.jsxs)("div", {
                    className: "relative flex h-8 items-center justify-center",
                    children: [(0, v.jsx)("div", {
                        className: "absolute h-full w-[1px] bg-camo-400"
                    }), void 0 !== l.appear ? (0, v.jsx)(Q.LB, { ...l.appear,
                        children: (0, v.jsx)("div", {
                            className: "h-[1px] w-8 bg-camo-400"
                        })
                    }) : (0, v.jsx)("div", {
                        className: "h-[1px] w-8 bg-camo-400"
                    })]
                }),
                Divider = l => (0, v.jsx)("div", {
                    className: (0, z.m)("bg-camo-400", "x" === l.axis && "h-[1px] w-full", "y" === l.axis && "h-full w-[1px]", l.className)
                }),
                Main = l => {
                    let {
                        children: c,
                        className: p,
                        unsafeOverflow: _ = !1
                    } = l;
                    return (0, v.jsx)("main", {
                        className: (0, z.m)("relative flex h-full flex-1 overflow-hidden px-6 pt-6 sm:ml-16 sm:pl-14 sm:pr-14 lg:pt-14", _ ? "overflow-visible" : "overflow-hidden", p),
                        children: c
                    })
                },
                MainContent = l => (0, v.jsx)("div", {
                    ref: l.innerRef,
                    className: (0, z.m)("flex flex-1 flex-col", {
                        "center-x": "items-center sm:mr-16",
                        "center-xy": "justify-center items-center mb-6 sm:mr-16 lg:mb-14",
                        "center-y": "justify-center mb-6 lg:mb-14",
                        top: "mt-8 lg:mt-0"
                    }[l.position], l.className),
                    children: l.children
                }),
                Header = l => (0, v.jsx)("header", {
                    className: (0, z.m)("z-[11] flex h-max justify-between px-6 pb-3 pt-9 sm:ml-16 sm:mr-14 sm:pl-14 sm:pr-0 sm:pt-10 lg:pt-14", l.underlined && "border-b border-camo-400", l.className),
                    children: l.children
                }),
                ScrollHeader = l => {
                    let {
                        bgImage: c = "gradient",
                        children: p,
                        threshold: _ = -32
                    } = l, [C, P] = M.useState(!1);
                    return M.useEffect(() => {
                        {
                            let onScroll = () => {
                                let l = document.body.getBoundingClientRect();
                                P(l.top < _)
                            };
                            return window.addEventListener("scroll", onScroll), () => {
                                window.removeEventListener("scroll", onScroll)
                            }
                        }
                    }, [_]), (0, v.jsx)("div", {
                        className: "sticky top-[14px] z-10 sm:top-[13px]",
                        children: (0, v.jsxs)("div", {
                            className: "relative",
                            children: [p, (0, v.jsx)("div", {
                                className: (0, z.m)("absolute bottom-0 left-0 right-0 transition-opacity duration-300", C ? "opacity-100" : "opacity-0"),
                                children: (0, v.jsx)(Divider, {
                                    axis: "x",
                                    className: "h-[2px] bg-camo-500"
                                })
                            }), (0, v.jsx)("div", {
                                className: (0, z.m)("absolute inset-0 top-[-12px] -z-10 transition-opacity duration-300", C ? "opacity-100" : "opacity-0", "blur" === c && "backdrop-blur-[12px]", "gradient" === c && "bg-gradient-to-b from-[rgba(17,20,12,0.95)] from-[27.54%] to-[rgba(37,43,27,0.85)] backdrop-blur-[6px]")
                            })]
                        })
                    })
                },
                TrackDivider = () => (0, v.jsxs)("svg", {
                    className: "w-full",
                    fill: "none",
                    height: "15",
                    width: "1177",
                    xmlns: "http://www.w3.org/2000/svg",
                    children: [(0, v.jsx)("path", {
                        d: "M653.476 7.969h29.202v6.489h-29.202zM.918 7.969H30.12v6.489H.918zM701.334 7.969h29.202v6.489h-29.202zM48.776 7.969h29.202v6.489H48.776zM511 7.965h138.691v6.489H511zM1077.49 7.965h64v6.489h-64zM944.612 7.969h29.202v6.489h-29.202zM690.465 7.969h3.082v6.489h-3.082zM37.907 7.969h3.082v6.489h-3.082zM751.303 7.969h3.082v6.489h-3.082zM98.745 7.969h3.082v6.489h-3.082zM756.333 7.969h3.082v6.489h-3.082zM103.774 7.969h3.082v6.489h-3.082zM868.686 7.969h3.082v6.489h-3.082zM873.715 7.965h3.082v6.489h-3.082zM1145.94 7.965h3.082v6.489h-3.082zM1159.67 7.965h3.082v6.489h-3.082zM1173.41 7.965h3.082v6.489h-3.082zM937.744 7.969h3.082v6.489h-3.082zM821.226 7.969h3.082v6.489h-3.082zM168.668 7.969h3.082v6.489h-3.082z",
                        fill: "currentColor"
                    }), (0, v.jsx)("circle", {
                        cx: "843.128",
                        cy: "11.374",
                        fill: "currentColor",
                        r: "1.46"
                    }), (0, v.jsx)("circle", {
                        cx: "916.059",
                        cy: "11.374",
                        fill: "currentColor",
                        r: "1.46"
                    }), (0, v.jsx)("circle", {
                        cx: "979.06",
                        cy: "11.374",
                        fill: "currentColor",
                        r: "1.46"
                    }), (0, v.jsx)("circle", {
                        cx: "847.995",
                        cy: "11.374",
                        fill: "currentColor",
                        r: "1.46"
                    }), (0, v.jsx)("circle", {
                        cx: "920.926",
                        cy: "11.374",
                        fill: "currentColor",
                        r: "1.46"
                    }), (0, v.jsx)("circle", {
                        cx: "983.927",
                        cy: "11.374",
                        fill: "currentColor",
                        r: "1.46"
                    }), (0, v.jsx)("circle", {
                        cx: "852.862",
                        cy: "11.37",
                        fill: "currentColor",
                        r: "1.46"
                    }), (0, v.jsx)("circle", {
                        cx: "925.794",
                        cy: "11.37",
                        fill: "currentColor",
                        r: "1.46"
                    }), (0, v.jsx)("circle", {
                        cx: "988.794",
                        cy: "11.37",
                        fill: "currentColor",
                        r: "1.46"
                    }), (0, v.jsx)("path", {
                        d: "M1176 1 0 1.01M458.489 1l-12.5 12.5h-230.5",
                        stroke: "currentColor",
                        strokeWidth: "1.5"
                    })]
                });

            function ScanCodeD(l) {
                return (0, v.jsxs)("svg", {
                    className: l.className,
                    fill: "none",
                    viewBox: "0 0 524 8",
                    children: [(0, v.jsx)("path", {
                        d: "M.195.99h29.202v6.489H.195zM48.054.99h29.202v6.489H48.054zM324.254.989h138.691v6.489H324.254zM37.185.99h3.082v6.489h-3.082zM98.022.99h3.082v6.489h-3.082zM103.052.99h3.082v6.489h-3.082zM215.405.99h3.082v6.489h-3.082zM220.435.989h3.082v6.489h-3.082zM492.654.989h3.082v6.489h-3.082zM506.39.989h3.082v6.489h-3.082zM520.125.989h3.082v6.489h-3.082zM284.464.99h3.082v6.489h-3.082zM167.946.99h3.082v6.489h-3.082z",
                        fill: "currentColor"
                    }), (0, v.jsx)("circle", {
                        cx: "189.847",
                        cy: "4.397",
                        fill: "currentColor",
                        r: "1.46"
                    }), (0, v.jsx)("circle", {
                        cx: "194.714",
                        cy: "4.397",
                        fill: "currentColor",
                        r: "1.46"
                    }), (0, v.jsx)("circle", {
                        cx: "199.581",
                        cy: "4.396",
                        fill: "currentColor",
                        r: "1.46"
                    }), (0, v.jsx)("circle", {
                        cx: "279.219",
                        cy: "4.396",
                        fill: "currentColor",
                        r: "1.46"
                    })]
                })
            }

            function LongShortLong() {
                return (0, v.jsxs)("div", {
                    className: "flex w-full flex-col gap-1",
                    children: [(0, v.jsx)("div", {
                        className: "h-8 bg-current"
                    }), (0, v.jsx)("div", {
                        className: "h-1 bg-current"
                    }), (0, v.jsx)("div", {
                        className: "h-8 bg-current"
                    })]
                })
            }

            function TwoShort() {
                return (0, v.jsxs)("div", {
                    className: "flex w-full flex-col gap-1",
                    children: [(0, v.jsx)("div", {
                        className: "h-1 bg-current"
                    }), (0, v.jsx)("div", {
                        className: "h-1 bg-current"
                    })]
                })
            }

            function AnimatedBarsRightInner() {
                return (0, v.jsxs)("div", {
                    className: "absolute bottom-20 right-6 top-6 hidden w-1.5 animate-enter-fade flex-col text-camo-400 [animation-delay:0.5s] [animation-fill-mode:both] xs:flex [&>*]:opacity-50",
                    children: [(0, v.jsxs)("div", {
                        className: "absolute inset-0 bottom-40 flex flex-col justify-end",
                        children: [(0, v.jsx)("div", {
                            className: "flex w-full flex-col gap-4",
                            children: (0, v.jsx)("div", {
                                className: "h-1 bg-current"
                            })
                        }), (0, v.jsx)("div", {
                            className: "flex-0 animate-[flex-grow_20s_ease-in-out_alternate_infinite] [animation-delay:2s]"
                        })]
                    }), (0, v.jsxs)("div", {
                        className: "absolute inset-0 bottom-24 top-1/2 flex flex-col justify-end",
                        children: [(0, v.jsx)(TwoShort, {}), (0, v.jsx)("div", {
                            className: "flex-0 animate-[flex-grow_10s_ease-in-out_alternate_infinite] [animation-delay:3s]"
                        })]
                    }), (0, v.jsxs)("div", {
                        className: "absolute inset-0 top-1/2 flex flex-col justify-end",
                        children: [(0, v.jsx)(LongShortLong, {}), (0, v.jsx)("div", {
                            className: "flex-0 animate-[flex-grow_16s_ease-in-out_alternate_infinite]"
                        })]
                    })]
                })
            }
            let el = C()(() => Promise.resolve(AnimatedBarsRightInner), {
                ssr: !1
            });

            function AnimatedBarsLeftInner() {
                return (0, v.jsxs)("div", {
                    className: "absolute bottom-6 left-6 top-20 hidden w-1.5 animate-enter-fade flex-col text-camo-400 [animation-delay:0.5s] [animation-fill-mode:both] xs:flex [&>*]:opacity-50",
                    children: [(0, v.jsxs)("div", {
                        className: "absolute inset-0 bottom-1/4 flex flex-col",
                        children: [(0, v.jsx)("div", {
                            className: "flex-0 animate-[flex-grow_20s_ease-in-out_alternate_infinite] [animation-delay:2s]"
                        }), (0, v.jsxs)("div", {
                            className: "flex w-full flex-col gap-4",
                            children: [(0, v.jsx)("div", {
                                className: "h-1 bg-current"
                            }), (0, v.jsx)("div", {
                                className: "h-1 bg-current"
                            }), (0, v.jsx)("div", {
                                className: "h-1 bg-current"
                            })]
                        })]
                    }), (0, v.jsxs)("div", {
                        className: "absolute inset-0 top-16 flex flex-col",
                        children: [(0, v.jsx)("div", {
                            className: "flex-0 animate-[flex-grow_14s_ease-in-out_alternate_infinite]"
                        }), (0, v.jsxs)("div", {
                            className: "flex w-full flex-col gap-1",
                            children: [(0, v.jsx)("div", {
                                className: "h-32 bg-current"
                            }), (0, v.jsx)("div", {
                                className: "h-8 bg-current"
                            }), (0, v.jsx)("div", {
                                className: "h-1 bg-current"
                            }), (0, v.jsx)("div", {
                                className: "h-1 w-1 self-center rounded-full bg-current"
                            })]
                        })]
                    }), (0, v.jsxs)("div", {
                        className: "absolute inset-x-0 inset-y-1/4 flex flex-col",
                        children: [(0, v.jsx)("div", {
                            className: "flex-0 animate-[flex-grow_10s_ease-in-out_alternate_infinite]"
                        }), (0, v.jsxs)("div", {
                            className: "flex w-full flex-col gap-1",
                            children: [(0, v.jsx)("div", {
                                className: "h-1 bg-current"
                            }), (0, v.jsx)("div", {
                                className: "h-1 bg-current"
                            }), (0, v.jsx)("div", {
                                className: "h-4"
                            }), (0, v.jsx)("div", {
                                className: "h-1 w-1 self-center rounded-full bg-current"
                            }), (0, v.jsx)("div", {
                                className: "h-1 w-1 self-center rounded-full bg-current"
                            }), (0, v.jsx)("div", {
                                className: "h-1 w-1 self-center rounded-full bg-current"
                            }), (0, v.jsx)("div", {
                                className: "h-4"
                            }), (0, v.jsx)("div", {
                                className: "h-1 bg-current"
                            })]
                        })]
                    }), (0, v.jsxs)("div", {
                        className: "absolute inset-0 top-1/3 flex flex-col",
                        children: [(0, v.jsx)("div", {
                            className: "flex-0 animate-[flex-grow_10s_ease-in-out_alternate_infinite] [animation-delay:3s]"
                        }), (0, v.jsx)(TwoShort, {})]
                    }), (0, v.jsxs)("div", {
                        className: "absolute inset-0 top-1/2 flex flex-col",
                        children: [(0, v.jsx)("div", {
                            className: "flex-0 animate-[flex-grow_16s_ease-in-out_alternate_infinite]"
                        }), (0, v.jsx)(LongShortLong, {})]
                    })]
                })
            }
            let ec = C()(() => Promise.resolve(AnimatedBarsLeftInner), {
                ssr: !1
            })
        },
        1173: function(l, c, p) {
            "use strict";
            p.d(c, {
                $: function() {
                    return useLayout
                },
                a: function() {
                    return LayoutProvider
                }
            });
            var v = p(4817),
                _ = p(6497),
                C = p(1248);
            let P = C.createContext(null),
                LayoutProvider = l => {
                    let c = (0, _.useRouter)(),
                        [p, T] = C.useState({
                            background: "default",
                            duration: 0
                        }),
                        M = C.useCallback((l, c) => {
                            T({
                                background: l,
                                duration: c
                            })
                        }, []);
                    return (0, v.jsx)(P.Provider, {
                        value: {
                            toggleBackground: M,
                            background: p.background,
                            defaultBackground: "/" === c.pathname ? "hero" : "gradient",
                            duration: p.duration
                        },
                        children: l.children
                    })
                };

            function useLayout() {
                let l = C.useContext(P);
                if (null === l) throw Error("Missing expected LayoutContext");
                return l
            }
        },
        5644: function(l, c, p) {
            "use strict";
            p.d(c, {
                a: function() {
                    return ProfileProvider
                },
                U: function() {
                    return useProfile
                }
            });
            var v, _, C = p(4817),
                P = p(8851),
                T = p(7833),
                M = p(8735),
                z = p.n(M),
                J = p(1248),
                Q = p(1266),
                X = p(2843);
            let es = J.use || (l => {
                    if ("pending" === l.status) throw l;
                    if ("fulfilled" === l.status) return l.value;
                    if ("rejected" === l.status) throw l.reason;
                    throw l.status = "pending", l.then(c => {
                        l.status = "fulfilled", l.value = c
                    }, c => {
                        l.status = "rejected", l.reason = c
                    }), l
                }),
                eo = {
                    dedupe: !0
                };
            X.$l.defineProperty(X.J$, "defaultValue", {
                value: X.u_
            });
            let el = (0, X.s6)((l, c, p) => {
                    let {
                        cache: v,
                        compare: _,
                        suspense: C,
                        fallbackData: P,
                        revalidateOnMount: T,
                        revalidateIfStale: M,
                        refreshInterval: z,
                        refreshWhenHidden: el,
                        refreshWhenOffline: ec,
                        keepPreviousData: eh
                    } = p, [ed, ef, ep, eg] = X.DY.get(v), [em, ey] = (0, X.qC)(l), eb = (0, J.useRef)(!1), ew = (0, J.useRef)(!1), ex = (0, J.useRef)(em), e_ = (0, J.useRef)(c), eE = (0, J.useRef)(p), getConfig = () => eE.current, isActive = () => getConfig().isVisible() && getConfig().isOnline(), [eA, eC, eS, eN] = (0, X.JN)(v, em), eP = (0, J.useRef)({}).current, eD = (0, X.o8)(P) ? p.fallback[em] : P, isEqual = (l, c) => {
                        for (let p in eP)
                            if ("data" === p) {
                                if (!_(l[p], c[p]) && (!(0, X.o8)(l[p]) || !_(eU, c[p]))) return !1
                            } else if (c[p] !== l[p]) return !1;
                        return !0
                    }, ek = (0, J.useMemo)(() => {
                        let l = !!em && !!c && ((0, X.o8)(T) ? !getConfig().isPaused() && !C && (!!(0, X.o8)(M) || M) : T),
                            getSelectedCache = c => {
                                let p = (0, X.PM)(c);
                                return (delete p._k, l) ? {
                                    isValidating: !0,
                                    isLoading: !0,
                                    ...p
                                } : p
                            },
                            p = eA(),
                            v = eN(),
                            _ = getSelectedCache(p),
                            P = p === v ? _ : getSelectedCache(v),
                            z = _;
                        return [() => {
                            let l = getSelectedCache(eA()),
                                c = isEqual(l, z);
                            return c ? (z.data = l.data, z.isLoading = l.isLoading, z.isValidating = l.isValidating, z.error = l.error, z) : (z = l, l)
                        }, () => P]
                    }, [v, em]), eI = (0, Q.useSyncExternalStore)((0, J.useCallback)(l => eS(em, (c, p) => {
                        isEqual(p, c) || l()
                    }), [v, em]), ek[0], ek[1]), eO = !eb.current, ej = ed[em] && ed[em].length > 0, eT = eI.data, eR = (0, X.o8)(eT) ? eD : eT, eL = eI.error, eM = (0, J.useRef)(eR), eU = eh ? (0, X.o8)(eT) ? eM.current : eT : eR, eB = (!ej || !!(0, X.o8)(eL)) && (eO && !(0, X.o8)(T) ? T : !getConfig().isPaused() && (C ? !(0, X.o8)(eR) && M : (0, X.o8)(eR) || M)), eF = !!(em && c && eO && eB), eH = (0, X.o8)(eI.isValidating) ? eF : eI.isValidating, eV = (0, X.o8)(eI.isLoading) ? eF : eI.isLoading, ez = (0, J.useCallback)(async l => {
                        let c, v;
                        let C = e_.current;
                        if (!em || !C || ew.current || getConfig().isPaused()) return !1;
                        let P = !0,
                            T = l || {},
                            M = !ep[em] || !T.dedupe,
                            callbackSafeguard = () => X.w6 ? !ew.current && em === ex.current && eb.current : em === ex.current,
                            z = {
                                isValidating: !1,
                                isLoading: !1
                            },
                            finishRequestAndUpdateState = () => {
                                eC(z)
                            },
                            cleanupState = () => {
                                let l = ep[em];
                                l && l[1] === v && delete ep[em]
                            },
                            J = {
                                isValidating: !0
                            };
                        (0, X.o8)(eA().data) && (J.isLoading = !0);
                        try {
                            if (M && (eC(J), p.loadingTimeout && (0, X.o8)(eA().data) && setTimeout(() => {
                                    P && callbackSafeguard() && getConfig().onLoadingSlow(em, p)
                                }, p.loadingTimeout), ep[em] = [C(ey), (0, X.u3)()]), [c, v] = ep[em], c = await c, M && setTimeout(cleanupState, p.dedupingInterval), !ep[em] || ep[em][1] !== v) return M && callbackSafeguard() && getConfig().onDiscarded(em), !1;
                            z.error = X.i_;
                            let l = ef[em];
                            if (!(0, X.o8)(l) && (v <= l[0] || v <= l[1] || 0 === l[1])) return finishRequestAndUpdateState(), M && callbackSafeguard() && getConfig().onDiscarded(em), !1;
                            let T = eA().data;
                            z.data = _(T, c) ? T : c, M && callbackSafeguard() && getConfig().onSuccess(c, em, p)
                        } catch (p) {
                            cleanupState();
                            let l = getConfig(),
                                {
                                    shouldRetryOnError: c
                                } = l;
                            !l.isPaused() && (z.error = p, M && callbackSafeguard() && (l.onError(p, em, l), (!0 === c || (0, X.mf)(c) && c(p)) && isActive() && l.onErrorRetry(p, em, l, l => {
                                let c = ed[em];
                                c && c[0] && c[0](X.sj.ERROR_REVALIDATE_EVENT, l)
                            }, {
                                retryCount: (T.retryCount || 0) + 1,
                                dedupe: !0
                            })))
                        }
                        return P = !1, finishRequestAndUpdateState(), !0
                    }, [em, v]), eW = (0, J.useCallback)((...l) => (0, X.BN)(v, ex.current, ...l), []);
                    if ((0, X.LI)(() => {
                            e_.current = c, eE.current = p, (0, X.o8)(eT) || (eM.current = eT)
                        }), (0, X.LI)(() => {
                            if (!em) return;
                            let l = ez.bind(X.i_, eo),
                                c = 0,
                                p = (0, X.ko)(em, ed, (p, v = {}) => {
                                    if (p == X.sj.FOCUS_EVENT) {
                                        let p = Date.now();
                                        getConfig().revalidateOnFocus && p > c && isActive() && (c = p + getConfig().focusThrottleInterval, l())
                                    } else if (p == X.sj.RECONNECT_EVENT) getConfig().revalidateOnReconnect && isActive() && l();
                                    else if (p == X.sj.MUTATE_EVENT) return ez();
                                    else if (p == X.sj.ERROR_REVALIDATE_EVENT) return ez(v)
                                });
                            return ew.current = !1, ex.current = em, eb.current = !0, eC({
                                _k: ey
                            }), eB && ((0, X.o8)(eR) || X.W6 ? l() : (0, X.kw)(l)), () => {
                                ew.current = !0, p()
                            }
                        }, [em]), (0, X.LI)(() => {
                            let l;

                            function next() {
                                let c = (0, X.mf)(z) ? z(eA().data) : z;
                                c && -1 !== l && (l = setTimeout(execute, c))
                            }

                            function execute() {
                                !eA().error && (el || getConfig().isVisible()) && (ec || getConfig().isOnline()) ? ez(eo).then(next) : next()
                            }
                            return next(), () => {
                                l && (clearTimeout(l), l = -1)
                            }
                        }, [z, el, ec, em]), (0, J.useDebugValue)(eU), C && (0, X.o8)(eR) && em) {
                        if (!X.w6 && X.W6) throw Error("Fallback data is required when using suspense in SSR.");
                        e_.current = c, eE.current = p, ew.current = !1;
                        let l = eg[em];
                        if (!(0, X.o8)(l)) {
                            let c = eW(l);
                            es(c)
                        }
                        if ((0, X.o8)(eL)) {
                            let l = ez(eo);
                            (0, X.o8)(eU) || (l.status = "fulfilled", l.value = !0), es(l)
                        } else throw eL
                    }
                    return {
                        mutate: eW,
                        get data() {
                            return eP.data = !0, eU
                        },
                        get error() {
                            return eP.error = !0, eL
                        },
                        get isValidating() {
                            return eP.isValidating = !0, eH
                        },
                        get isLoading() {
                            return eP.isLoading = !0, eV
                        }
                    }
                }),
                ec = X.w6 ? l => {
                    l()
                } : J.startTransition,
                useStateWithDeps = l => {
                    let [, c] = (0, J.useState)({}), p = (0, J.useRef)(!1), v = (0, J.useRef)(l), _ = (0, J.useRef)({
                        data: !1,
                        error: !1,
                        isValidating: !1
                    }), C = (0, J.useCallback)(l => {
                        let C = !1,
                            P = v.current;
                        for (let c in l) P[c] !== l[c] && (P[c] = l[c], _.current[c] && (C = !0));
                        C && !p.current && c({})
                    }, []);
                    return (0, X.LI)(() => (p.current = !1, () => {
                        p.current = !0
                    })), [v, _.current, C]
                },
                eh = (0, X.xD)(el, () => (l, c, p = {}) => {
                    let {
                        mutate: v
                    } = (0, X.kY)(), _ = (0, J.useRef)(l), C = (0, J.useRef)(c), P = (0, J.useRef)(p), T = (0, J.useRef)(0), [M, z, Q] = useStateWithDeps({
                        data: X.i_,
                        error: X.i_,
                        isMutating: !1
                    }), es = M.current, eo = (0, J.useCallback)(async (l, c) => {
                        var p, M;
                        let [z, J] = (0, X.qC)(_.current);
                        if (!C.current) throw Error("Can’t trigger the mutation: missing fetcher.");
                        if (!z) throw Error("Can’t trigger the mutation: missing key.");
                        let es = (0, X.PM)((0, X.PM)({
                                populateCache: !1,
                                throwOnError: !0
                            }, P.current), c),
                            eo = (0, X.u3)();
                        T.current = eo, Q({
                            isMutating: !0
                        });
                        try {
                            let c = await v(z, C.current(J, {
                                arg: l
                            }), (0, X.PM)(es, {
                                throwOnError: !0
                            }));
                            return T.current <= eo && (ec(() => Q({
                                data: c,
                                isMutating: !1,
                                error: void 0
                            })), null == (p = es.onSuccess) || p.call(es, c, z, es)), c
                        } catch (l) {
                            if (T.current <= eo && (ec(() => Q({
                                    error: l,
                                    isMutating: !1
                                })), null == (M = es.onError) || M.call(es, l, z, es), es.throwOnError)) throw l
                        }
                    }, []), el = (0, J.useCallback)(() => {
                        T.current = (0, X.u3)(), Q({
                            data: X.i_,
                            error: X.i_,
                            isMutating: !1
                        })
                    }, []);
                    return (0, X.LI)(() => {
                        _.current = l, C.current = c, P.current = p
                    }), {
                        trigger: eo,
                        reset: el,
                        get data() {
                            return z.data = !0, es.data
                        },
                        get error() {
                            return z.error = !0, es.error
                        },
                        get isMutating() {
                            return z.isMutating = !0, es.isMutating
                        }
                    }
                });
            var ed = p(1389),
                ef = p(6179),
                ep = p(5834),
                eg = p(4656),
                em = p(3096),
                ey = p(350),
                eb = p(3338);
            (v = _ || (_ = {})).DISPLAY_NAME_BAD_LENGTH = "-3010", v.DISPLAY_NAME_BAD_CHARS = "-3011", v.DISPLAY_NAME_TAKEN = "-3012", v.DISPLAY_NAME_NOT_OWN_HANDLE = "-3013";
            let updateMe = async (l, c) => {
                    let {
                        arg: p
                    } = c;
                    return fetch(l, {
                        body: JSON.stringify({
                            displayName: p.displayName
                        }),
                        credentials: "include",
                        headers: {
                            "Content-Type": "application/json"
                        },
                        method: "POST"
                    }).then(l => l.json())
                },
                ew = J.createContext(null),
                ProfileProvider = l => {
                    var c, p, v, _;
                    let {
                        t: M
                    } = (0, T.Z)("common"), Q = (0, em.O)(), {
                        me: X,
                        refreshMe: es
                    } = (0, eb.Hi)(), eo = (0, ey.A)(), {
                        trigger: el
                    } = eh((0, ef.FP)("/user/display-name"), updateMe), ec = "string" != typeof X && (null === (c = X.twitter) || void 0 === c ? void 0 : c.profileImageUrl), ex = "string" != typeof X && X.displayName, e_ = null === (p = Q.signer) || void 0 === p ? void 0 : p.address, eE = eo.address, eA = null != eE ? eE : e_, eC = "string" != typeof X && (null === (v = X.twitter) || void 0 === v ? void 0 : v.handle), [eS, eN] = J.useState(""), [eP, eD] = J.useState(!1), [ek, eI] = J.useState(!1), [eO, ej] = J.useState(!1), [eT, eR] = J.useState(null), eL = !"".concat(ex).startsWith("@") || !eS.startsWith("@");
                    "string" == typeof X || eO || "" !== eS || eN("".concat(X.displayName));
                    let close = () => eD(!1),
                        onSubmit = async () => {
                            eI(!0);
                            let l = await el({
                                displayName: eS
                            });
                            if ("message" in l) eR(l.message);
                            else {
                                eD(!1);
                                let l = await es();
                                "string" != typeof l && eN("".concat(l.displayName))
                            }
                            eI(!1)
                        },
                        randomHandle = () => {
                            let l = 15 - "".concat(eC).length,
                                c = Math.round(Math.random() * parseInt("1".concat("0".repeat(l))));
                            return "".concat(eC).concat(c)
                        };
                    return (0, C.jsxs)(ew.Provider, {
                        value: {
                            close,
                            open: () => eD(!0)
                        },
                        children: [l.children, (0, C.jsxs)(eg.u_, {
                            ariaLabel: M("profile.modal.aria-label"),
                            onClose: close,
                            open: eP,
                            children: [(0, C.jsx)(eg.Io, {
                                children: (0, C.jsx)("h2", {
                                    className: "typography-brand-body-l-caps text-yellow-100",
                                    children: M("profile.modal.h2")
                                })
                            }), (0, C.jsxs)("form", {
                                onSubmit: l => {
                                    l.preventDefault(), onSubmit()
                                },
                                children: [(0, C.jsxs)("div", {
                                    className: "flex flex-col",
                                    children: [(0, C.jsx)("input", {
                                        disabled: ek,
                                        placeholder: M("input"),
                                        value: eS,
                                        className: (0, ed.m)("typography-brand-body-l h-10 w-72 rounded-lg border border-camo-400 bg-camo-700 px-4 py-2 text-yellow-100 transition-colors placeholder:text-camo-500 disabled:bg-camo-600 disabled:text-camo-300", "string" == typeof eT && "border-mars-400"),
                                        onChange: l => {
                                            ej(!0), eN(l.target.value)
                                        }
                                    }), (0, C.jsx)("div", {
                                        className: "flex h-6 w-full justify-end",
                                        children: "string" == typeof eT && (0, C.jsx)("strong", {
                                            className: "typography-UI-body mb-4 ml-auto text-mars-300",
                                            children: M("profile.modal.strong_".concat(eT))
                                        })
                                    })]
                                }), "string" == typeof ec && (0, C.jsxs)("div", {
                                    className: "flex items-center gap-4",
                                    children: [(0, C.jsx)(z(), {
                                        alt: M("profile.img.alt_avatar"),
                                        height: 80,
                                        src: ec,
                                        width: 80,
                                        className: (0, ed.m)("rounded-full", eL ? "opacity-50" : "opacity-100")
                                    }), (0, C.jsx)(ep.zx, {
                                        stretch: !0,
                                        type: "button",
                                        variant: "secondary",
                                        onClick: () => {
                                            eL ? eN("@".concat(eC)) : eN(randomHandle())
                                        },
                                        children: M(eL ? "profile.modal.button_show_avatar" : "profile.modal.button_hide_avatar")
                                    })]
                                }), (0, C.jsxs)("aside", {
                                    className: "mb-8 mt-12 w-full bg-camo-600 p-4",
                                    children: [(0, C.jsx)("div", {
                                        className: "typography-brand-body font-semibold uppercase text-yellow-100",
                                        children: (0, C.jsx)(P.Z, {
                                            i18nKey: "common:profile.modal.aside",
                                            components: {
                                                0: (0, C.jsx)("span", {
                                                    className: "text-camo-400"
                                                })
                                            }
                                        })
                                    }), (0, C.jsx)("div", {
                                        className: "typography-brand-body-l mt-2 text-camo-400",
                                        children: null !== (_ = null == eA ? void 0 : eA.slice(0, 18)) && void 0 !== _ ? _ : "-"
                                    })]
                                }), (0, C.jsx)(ep.zx, {
                                    stretch: !0,
                                    disabled: ek || eS === ex,
                                    onClick: onSubmit,
                                    type: "submit",
                                    variant: "primary",
                                    children: M("profile.modal.button_submit")
                                })]
                            })]
                        })]
                    })
                };

            function useProfile() {
                let l = J.useContext(ew);
                if (null === l) throw Error("Missing expected ProfileContext");
                return l
            }
        },
        6388: function(l, c, p) {
            "use strict";
            p.d(c, {
                ar: function() {
                    return ProgressSplashProvider
                },
                EW: function() {
                    return P
                },
                WO: function() {
                    return UnlockSplashProvider
                },
                $l: function() {
                    return useProgressSplash
                },
                Rw: function() {
                    return useUnlockSplash
                }
            });
            var v, _, C, P, T = p(4817),
                M = p(1248),
                z = p(5834),
                J = p(1173),
                Q = p(7833),
                X = p(1389),
                es = p(2359),
                eo = p(7657),
                el = p(3460);
            let ProgressSplashScreen = l => {
                    let c = M.useRef(null),
                        p = M.useRef(null),
                        [v, _] = M.useState(null);
                    if (null !== l.mimicOrb && null === v) {
                        let c = l.mimicOrb.getBoundingClientRect();
                        _({
                            height: c.height,
                            left: c.left,
                            position: "fixed",
                            top: c.top,
                            width: c.width
                        })
                    }
                    return M.useEffect(() => {
                        l.in && setTimeout(() => {
                            let l = c.current,
                                v = p.current;
                            if (!l || !v) return;
                            let _ = l.getBoundingClientRect(),
                                C = v.getBoundingClientRect(),
                                P = _.left + _.width / 2,
                                T = _.top + _.height / 2,
                                M = C.left + C.width / 2,
                                z = C.top + C.height / 2,
                                J = _.height,
                                Q = 1 * window.innerHeight,
                                X = (Q / J).toFixed(2),
                                es = J * Number(X);
                            l.style.transitionTimingFunction = "cubic-bezier(0.4, 0, 0.2, 1)", l.style.transitionProperty = "all", l.style.transitionDuration = "1000ms", l.style.transformOrigin = "center", l.style.scale = "".concat(X), l.style.translate = "".concat(M - P, "px ").concat(z - T + es / 2, "px")
                        }, 1e3)
                    }, [l.in]), (0, T.jsx)(z.h_, {
                        container: l.anchorEl,
                        children: (0, T.jsx)(eo.WV, {
                            appear: !1,
                            in: l.in,
                            children: (0, T.jsxs)("div", {
                                className: "pointer-events-none absolute inset-0 z-10 mt-8 flex flex-col items-center gap-11",
                                children: [(0, T.jsx)(TypewriterTitle, {
                                    innerRef: p
                                }), (0, T.jsx)("div", {
                                    ref: c,
                                    style: null != v ? v : {},
                                    children: (0, T.jsx)(es.V, {
                                        progress: 3
                                    })
                                })]
                            })
                        })
                    })
                },
                TypewriterTitle = l => {
                    let {
                        innerRef: c
                    } = l, {
                        t: p
                    } = (0, Q.Z)("early-access"), v = p("title_experience"), [_, C, P] = useTypewriter(v, {
                        delayMs: 1e3,
                        keystrokeMs: 100
                    }), M = _ === v, z = C || M || !P;
                    return (0, T.jsxs)("div", {
                        ref: c,
                        className: "typography-brand-body-l-caps text-camo-200",
                        children: [_, (0, T.jsx)("span", {
                            className: (0, X.m)("inline-block h-[18px] w-[2px] translate-y-[3px] bg-current", z && "animate-blink")
                        })]
                    })
                },
                ec = {
                    commaMs: 0,
                    delayMs: 0,
                    keystrokeMs: 50,
                    periodMs: 0
                },
                useTypewriter = (l, c) => {
                    let p = { ...ec,
                            ...c
                        },
                        v = M.useRef(l),
                        [_, C] = M.useState(""),
                        [P, T] = M.useState(!1),
                        [z, J] = M.useState(!1);
                    return M.useEffect(() => {
                        setTimeout(() => {
                            J(!0)
                        }, p.delayMs)
                    }, [p.delayMs]), (0, el.Yz)(() => {
                        C(l => {
                            let c = v.current.charAt(l.length);
                            return "." === c && (T(!0), setTimeout(() => {
                                T(!1)
                            }, p.periodMs)), "," === c && (T(!0), setTimeout(() => {
                                T(!1)
                            }, p.commaMs)), l + c
                        })
                    }, z && !P ? p.keystrokeMs : null), [_, P, z]
                };
            var eh = p(34),
                ed = p(6359),
                ef = p(3338);
            (v = C || (C = {}))[v.idle = -1] = "idle", v[v.entering = 0] = "entering", v[v.countDown = 1] = "countDown", v[v.unlock = 2] = "unlock", v[v.countUp = 3] = "countUp", v[v.exiting = 4] = "exiting";
            let UnlockSplash = l => {
                    var c;
                    let {
                        anchorEl: p,
                        onCountup: v,
                        onEnd: _,
                        onUnlock: C,
                        ...P
                    } = l, {
                        t: z
                    } = (0, Q.Z)("common"), {
                        me: J
                    } = (0, ef.Hi)(), es = M.useRef(null), eo = M.useRef(null), el = M.useRef(null), ec = "string" != typeof J && null !== (c = J.pointsForBridging) && void 0 !== c ? c : 0, [eh, em] = M.useState(-1);
                    M.useEffect(() => {
                        if (P.in && -1 === eh && em(0), 0 === eh) {
                            var l, c, p;
                            let v = el.current,
                                _ = es.current,
                                C = eo.current,
                                P = null !== (l = null == v ? void 0 : v.getBoundingClientRect()) && void 0 !== l ? l : null,
                                T = null !== (c = null == _ ? void 0 : _.getBoundingClientRect()) && void 0 !== c ? c : null,
                                M = null !== (p = null == C ? void 0 : C.getBoundingClientRect()) && void 0 !== p ? p : null;
                            if (null !== P && null !== M && null !== _ && null !== T) {
                                let l = T.top + T.height / 2,
                                    c = M.top + M.height / 2,
                                    p = P.top + P.height / 2;
                                _.style.transform = "translateY(".concat((c + p) / 2 - l, "px)"), setTimeout(() => {
                                    em(1)
                                }, 2500)
                            }
                        }
                        1 === eh && (setTimeout(() => C(), 1750), setTimeout(() => em(2), 2750)), 2 === eh && setTimeout(() => em(3), 1e3), 3 === eh && (v(), setTimeout(() => {
                            _(), em(4)
                        }, 2750))
                    }, [p, v, _, C, eh, P.in]);
                    let ey = eh < 1,
                        eb = eh >= 1 && eh < 3,
                        ew = eh >= 3;
                    return (0, T.jsx)("div", {
                        className: "absolute inset-0 h-full w-full",
                        style: {
                            opacity: eh >= 0 && eh < 4 ? "1" : "0",
                            transitionDuration: "2000ms",
                            transitionProperty: "opacity",
                            transitionTimingFunction: "ease-in-out"
                        },
                        children: (0, T.jsxs)(ed.M9, {
                            className: "flex h-full w-full justify-center",
                            position: "center-x",
                            children: [(0, T.jsxs)("div", {
                                ref: es,
                                className: "absolute top-0 flex items-center",
                                style: {
                                    opacity: eh >= 0 ? "1" : "0",
                                    transitionDuration: "1500ms",
                                    transitionProperty: "all"
                                },
                                children: [(0, T.jsxs)("div", {
                                    className: (0, X.m)("typography-brand-heading-1 text-[56px] uppercase transition-colors duration-[750ms]", eh < 2 ? "text-mars-300" : "text-yellow-200"),
                                    children: [ey && z("nav.points", {
                                        count: ec
                                    }), eb && (0, T.jsx)(ep, {
                                        end: 0,
                                        start: ec
                                    }), ew && (0, T.jsx)(ep, {
                                        end: ec,
                                        start: 0
                                    })]
                                }), (0, T.jsxs)("div", {
                                    className: "relative flex h-20 w-20 justify-between",
                                    children: [2 === eh && (0, T.jsx)("div", {
                                        style: {
                                            left: "8px",
                                            rotate: "-45deg",
                                            top: "-24px"
                                        },
                                        className: (0, X.m)("absolute h-8 w-1 animate-expand-contract rounded-sm")
                                    }), 2 === eh && (0, T.jsx)("div", {
                                        style: {
                                            left: "calc(50% - 6px)",
                                            top: "-32px"
                                        },
                                        className: (0, X.m)("absolute h-8 w-1 animate-expand-contract rounded-sm")
                                    }), 2 === eh && (0, T.jsx)("div", {
                                        style: {
                                            right: "16px",
                                            rotate: "45deg",
                                            top: "-24px"
                                        },
                                        className: (0, X.m)("absolute h-8 w-1 animate-expand-contract rounded-sm")
                                    }), (0, T.jsx)("div", {
                                        className: "absolute inset-0",
                                        children: (0, T.jsx)(LockLocked, {
                                            className: eh < 2 ? "fill-mars-300" : "fill-yellow-200 opacity-0"
                                        })
                                    }), (0, T.jsx)("div", {
                                        className: "absolute inset-0",
                                        children: (0, T.jsx)(LockUnlocked, {
                                            className: eh < 2 ? "fill-mars-300" : "fill-yellow-200"
                                        })
                                    })]
                                })]
                            }), (0, T.jsx)(eg, {
                                bottomCrosshairRef: el,
                                topCrosshairRef: eo
                            })]
                        })
                    })
                },
                LockLocked = l => (0, T.jsx)("svg", {
                    fill: "none",
                    height: "73",
                    viewBox: "0 0 73 73",
                    width: "73",
                    xmlns: "http://www.w3.org/2000/svg",
                    children: (0, T.jsx)("path", {
                        className: (0, X.m)(l.className, "transition-all duration-[750ms]"),
                        "clip-rule": "evenodd",
                        d: "M24.8982 15.342C27.1153 12.2625 30.7908 9.90625 36.3242 9.90625C41.8576 9.90625 45.5331 12.2625 47.7502 15.342C49.8847 18.3067 50.5742 21.7966 50.5742 24.1562V33.9062H52.5242C53.5983 33.9062 54.6285 34.3329 55.388 35.0925C56.1475 35.852 56.5742 36.8821 56.5742 37.9563V58.3562C56.5742 59.4304 56.1475 60.4605 55.388 61.22C54.6285 61.9796 53.5983 62.4062 52.5242 62.4062H20.1242C19.0501 62.4062 18.02 61.9796 17.2604 61.22C16.5009 60.4605 16.0742 59.4304 16.0742 58.3562V37.9563C16.0742 36.8821 16.5009 35.852 17.2604 35.0925C18.02 34.3329 19.0501 33.9062 20.1242 33.9062H22.0742V24.1562C22.0742 21.7966 22.7638 18.3067 24.8982 15.342ZM26.5742 33.9062H46.0742V24.1562C46.0742 22.5169 45.5638 20.0068 44.0982 17.9713C42.7153 16.0505 40.3908 14.4062 36.3242 14.4062C32.2576 14.4062 29.9331 16.0505 28.5502 17.9713C27.0847 20.0068 26.5742 22.5169 26.5742 24.1562V33.9062ZM20.5742 38.4062V57.9062H52.0742V38.4062H20.5742Z",
                        "fill-rule": "evenodd"
                    })
                }),
                LockUnlocked = l => (0, T.jsx)("svg", {
                    fill: "none",
                    height: "73",
                    viewBox: "0 0 73 73",
                    width: "73",
                    xmlns: "http://www.w3.org/2000/svg",
                    children: (0, T.jsx)("path", {
                        className: (0, X.m)(l.className, "transition-all duration-[750ms]"),
                        "clip-rule": "evenodd",
                        d: "M25.1557 13.5434C27.5053 11.259 31.1481 9.90625 36.3242 9.90625C41.8576 9.90625 45.5331 12.2625 47.7502 15.342C49.8847 18.3067 50.5742 21.7966 50.5742 24.1562V33.9062H52.5242C53.5983 33.9062 54.6285 34.3329 55.388 35.0925C56.1475 35.852 56.5742 36.8821 56.5742 37.9563V58.3562C56.5742 59.4304 56.1475 60.4605 55.388 61.22C54.6285 61.9796 53.5983 62.4062 52.5242 62.4062H20.1242C19.0501 62.4062 18.02 61.9796 17.2604 61.22C16.5009 60.4605 16.0742 59.4304 16.0742 58.3562V37.9563C16.0742 36.8821 16.5009 35.852 17.2604 35.0925C18.02 34.3329 19.0501 33.9062 20.1242 33.9062H46.0742V24.1562C46.0742 22.5169 45.5638 20.0068 44.0982 17.9713C42.7153 16.0505 40.3908 14.4062 36.3242 14.4062C31.9003 14.4062 29.5432 15.554 28.2927 16.7698C27.0401 17.9877 26.5742 19.5886 26.5742 21.1562C26.5742 22.3989 25.5669 23.4062 24.3242 23.4062C23.0816 23.4062 22.0742 22.3989 22.0742 21.1562C22.0742 18.7249 22.8083 15.8258 25.1557 13.5434ZM20.5742 38.4062V57.9062H52.0742V38.4062H20.5742Z",
                        "fill-rule": "evenodd"
                    })
                }),
                ep = M.memo(l => {
                    let {
                        end: c,
                        start: p
                    } = l, {
                        t: v
                    } = (0, Q.Z)("common"), _ = M.useRef(p);
                    return M.useEffect(() => {
                        _.current = c
                    }), (0, T.jsx)(eh.ZP, {
                        duration: 2,
                        end: c,
                        start: 0 === _.current && 0 !== p ? c : _.current,
                        easingFn: M.useCallback((l, c, p, v) => -p * (l /= v) * (l - 2) + c, []),
                        formattingFn: M.useCallback(l => v("nav.points", {
                            count: l
                        }), [v]),
                        children: l => {
                            let {
                                countUpRef: c
                            } = l;
                            return (0, T.jsx)("span", {
                                ref: c
                            })
                        }
                    })
                }, (l, c) => l.end === c.end && l.start === c.start);
            ep.displayName = "CountUpPoints";
            let eg = M.memo(l => {
                let {
                    bottomCrosshairRef: c,
                    topCrosshairRef: p
                } = l, randomAnimation = () => {
                    let l = ["animate-twinkle-1", "animate-twinkle-2", "animate-twinkle-3", "animate-twinkle-4"];
                    return l[Math.floor(Math.random() * l.length)]
                }, randomDelay = () => {
                    let l = ["0ms", "150ms", "600ms", "100ms", "1000ms", "250ms", "400ms"];
                    return l[Math.floor(Math.random() * l.length)]
                }, randomDuration = () => {
                    let l = ["2000ms", "2500ms", "3000ms", "4000ms", "5000ms"];
                    return l[Math.floor(Math.random() * l.length)]
                };
                return (0, T.jsxs)("svg", {
                    className: "h-full w-full",
                    fill: "none",
                    height: "829",
                    viewBox: "0 0 1326 829",
                    width: "1326",
                    xmlns: "http://www.w3.org/2000/svg",
                    children: [(0, T.jsx)("path", {
                        className: (0, X.m)("fill-yellow-200", randomAnimation()),
                        d: "M100.77 711.962C102.705 711.962 104.274 710.394 104.274 708.459C104.274 706.524 102.705 704.955 100.77 704.955C98.8352 704.955 97.2666 706.524 97.2666 708.459C97.2666 710.394 98.8352 711.962 100.77 711.962Z",
                        style: {
                            animationDelay: randomDelay(),
                            animationDuration: randomDuration()
                        }
                    }), (0, T.jsx)("path", {
                        className: (0, X.m)("fill-yellow-200", randomAnimation()),
                        d: "M110.782 711.962C112.717 711.962 114.285 710.394 114.285 708.459C114.285 706.524 112.717 704.955 110.782 704.955C108.847 704.955 107.278 706.524 107.278 708.459C107.278 710.394 108.847 711.962 110.782 711.962Z",
                        style: {
                            animationDelay: randomDelay(),
                            animationDuration: randomDuration()
                        }
                    }), (0, T.jsx)("path", {
                        className: (0, X.m)("fill-yellow-200", randomAnimation()),
                        d: "M120.794 711.962C122.728 711.962 124.297 710.394 124.297 708.459C124.297 706.524 122.728 704.955 120.794 704.955C118.859 704.955 117.29 706.524 117.29 708.459C117.29 710.394 118.859 711.962 120.794 711.962Z",
                        style: {
                            animationDelay: randomDelay(),
                            animationDuration: randomDuration()
                        }
                    }), (0, T.jsx)("path", {
                        className: (0, X.m)("fill-yellow-200", randomAnimation()),
                        d: "M100.77 828.431C102.705 828.431 104.274 826.862 104.274 824.927C104.274 822.992 102.705 821.424 100.77 821.424C98.8352 821.424 97.2666 822.992 97.2666 824.927C97.2666 826.862 98.8352 828.431 100.77 828.431Z",
                        style: {
                            animationDelay: randomDelay(),
                            animationDuration: randomDuration()
                        }
                    }), (0, T.jsx)("path", {
                        className: (0, X.m)("fill-yellow-200", randomAnimation()),
                        d: "M110.782 828.431C112.717 828.431 114.285 826.862 114.285 824.927C114.285 822.992 112.717 821.424 110.782 821.424C108.847 821.424 107.278 822.992 107.278 824.927C107.278 826.862 108.847 828.431 110.782 828.431Z",
                        style: {
                            animationDelay: randomDelay(),
                            animationDuration: randomDuration()
                        }
                    }), (0, T.jsx)("path", {
                        className: (0, X.m)("fill-yellow-200", randomAnimation()),
                        d: "M120.794 828.431C122.728 828.431 124.297 826.862 124.297 824.927C124.297 822.992 122.728 821.424 120.794 821.424C118.859 821.424 117.29 822.992 117.29 824.927C117.29 826.862 118.859 828.431 120.794 828.431Z",
                        style: {
                            animationDelay: randomDelay(),
                            animationDuration: randomDuration()
                        }
                    }), (0, T.jsx)("path", {
                        className: (0, X.m)("fill-yellow-200", randomAnimation()),
                        d: "M250.225 711.962C252.16 711.962 253.729 710.394 253.729 708.459C253.729 706.524 252.16 704.955 250.225 704.955C248.29 704.955 246.722 706.524 246.722 708.459C246.722 710.394 248.29 711.962 250.225 711.962Z",
                        style: {
                            animationDelay: randomDelay(),
                            animationDuration: randomDuration()
                        }
                    }), (0, T.jsx)("path", {
                        className: (0, X.m)("fill-yellow-200", randomAnimation()),
                        d: "M16.1461 550.933C18.081 550.933 19.6496 549.364 19.6496 547.429C19.6496 545.494 18.081 543.926 16.1461 543.926C14.2111 543.926 12.6426 545.494 12.6426 547.429C12.6426 549.364 14.2111 550.933 16.1461 550.933Z",
                        style: {
                            animationDelay: randomDelay(),
                            animationDuration: randomDuration()
                        }
                    }), (0, T.jsx)("path", {
                        className: (0, X.m)("fill-yellow-200", randomAnimation()),
                        d: "M16.1461 14.923C18.081 14.923 19.6496 13.3544 19.6496 11.4195C19.6496 9.48459 18.081 7.91602 16.1461 7.91602C14.2111 7.91602 12.6426 9.48459 12.6426 11.4195C12.6426 13.3544 14.2111 14.923 16.1461 14.923Z",
                        style: {
                            animationDelay: randomDelay(),
                            animationDuration: randomDuration()
                        }
                    }), (0, T.jsx)("path", {
                        className: (0, X.m)("fill-yellow-200", randomAnimation()),
                        d: "M16.1461 27.7238C18.081 27.7238 19.6496 26.1552 19.6496 24.2203C19.6496 22.2854 18.081 20.7168 16.1461 20.7168C14.2111 20.7168 12.6426 22.2854 12.6426 24.2203C12.6426 26.1552 14.2111 27.7238 16.1461 27.7238Z",
                        style: {
                            animationDelay: randomDelay(),
                            animationDuration: randomDuration()
                        }
                    }), (0, T.jsx)("path", {
                        className: (0, X.m)("fill-yellow-200", randomAnimation()),
                        d: "M16.1461 40.5226C18.081 40.5226 19.6496 38.9541 19.6496 37.0191C19.6496 35.0842 18.081 33.5156 16.1461 33.5156C14.2111 33.5156 12.6426 35.0842 12.6426 37.0191C12.6426 38.9541 14.2111 40.5226 16.1461 40.5226Z",
                        style: {
                            animationDelay: randomDelay(),
                            animationDuration: randomDuration()
                        }
                    }), (0, T.jsx)("path", {
                        className: (0, X.m)("fill-yellow-200", randomAnimation()),
                        d: "M29.5328 27.7238C31.4677 27.7238 33.0363 26.1552 33.0363 24.2203C33.0363 22.2854 31.4677 20.7168 29.5328 20.7168C27.5979 20.7168 26.0293 22.2854 26.0293 24.2203C26.0293 26.1552 27.5979 27.7238 29.5328 27.7238Z",
                        style: {
                            animationDelay: randomDelay(),
                            animationDuration: randomDuration()
                        }
                    }), (0, T.jsx)("path", {
                        className: (0, X.m)("fill-yellow-200", randomAnimation()),
                        d: "M29.5328 14.923C31.4677 14.923 33.0363 13.3544 33.0363 11.4195C33.0363 9.48459 31.4677 7.91602 29.5328 7.91602C27.5979 7.91602 26.0293 9.48459 26.0293 11.4195C26.0293 13.3544 27.5979 14.923 29.5328 14.923Z",
                        style: {
                            animationDelay: randomDelay(),
                            animationDuration: randomDuration()
                        }
                    }), (0, T.jsx)("path", {
                        className: (0, X.m)("fill-yellow-200", randomAnimation()),
                        d: "M42.9205 14.923C44.8554 14.923 46.424 13.3544 46.424 11.4195C46.424 9.48459 44.8554 7.91602 42.9205 7.91602C40.9856 7.91602 39.417 9.48459 39.417 11.4195C39.417 13.3544 40.9856 14.923 42.9205 14.923Z",
                        style: {
                            animationDelay: randomDelay(),
                            animationDuration: randomDuration()
                        }
                    }), (0, T.jsx)("path", {
                        className: (0, X.m)("fill-yellow-200", randomAnimation()),
                        d: "M56.3072 14.923C58.2421 14.923 59.8107 13.3544 59.8107 11.4195C59.8107 9.48459 58.2421 7.91602 56.3072 7.91602C54.3723 7.91602 52.8037 9.48459 52.8037 11.4195C52.8037 13.3544 54.3723 14.923 56.3072 14.923Z",
                        style: {
                            animationDelay: randomDelay(),
                            animationDuration: randomDuration()
                        }
                    }), (0, T.jsx)("path", {
                        className: (0, X.m)("fill-yellow-200", randomAnimation()),
                        d: "M1321.81 47.0636C1323.74 47.0636 1325.31 45.4951 1325.31 43.5601C1325.31 41.6252 1323.74 40.0566 1321.81 40.0566C1319.87 40.0566 1318.3 41.6252 1318.3 43.5601C1318.3 45.4951 1319.87 47.0636 1321.81 47.0636Z",
                        style: {
                            animationDelay: randomDelay(),
                            animationDuration: randomDuration()
                        }
                    }), (0, T.jsx)("path", {
                        className: (0, X.m)("fill-yellow-200", randomAnimation()),
                        d: "M1321.81 72.3644C1323.74 72.3644 1325.31 70.7958 1325.31 68.8609C1325.31 66.926 1323.74 65.3574 1321.81 65.3574C1319.87 65.3574 1318.3 66.926 1318.3 68.8609C1318.3 70.7958 1319.87 72.3644 1321.81 72.3644Z",
                        style: {
                            animationDelay: randomDelay(),
                            animationDuration: randomDuration()
                        }
                    }), (0, T.jsx)("path", {
                        className: (0, X.m)("fill-yellow-200", randomAnimation()),
                        d: "M1321.81 300.952C1323.74 300.952 1325.31 299.384 1325.31 297.449C1325.31 295.514 1323.74 293.945 1321.81 293.945C1319.87 293.945 1318.3 295.514 1318.3 297.449C1318.3 299.384 1319.87 300.952 1321.81 300.952Z",
                        style: {
                            animationDelay: randomDelay(),
                            animationDuration: randomDuration()
                        }
                    }), (0, T.jsx)("path", {
                        className: (0, X.m)("fill-yellow-200", randomAnimation()),
                        d: "M16.1461 692.753C18.081 692.753 19.6496 691.185 19.6496 689.25C19.6496 687.315 18.081 685.746 16.1461 685.746C14.2111 685.746 12.6426 687.315 12.6426 689.25C12.6426 691.185 14.2111 692.753 16.1461 692.753Z",
                        style: {
                            animationDelay: randomDelay(),
                            animationDuration: randomDuration()
                        }
                    }), (0, T.jsx)("path", {
                        className: (0, X.m)("fill-yellow-200", randomAnimation()),
                        d: "M16.1461 733.224C18.081 733.224 19.6496 731.655 19.6496 729.72C19.6496 727.785 18.081 726.217 16.1461 726.217C14.2111 726.217 12.6426 727.785 12.6426 729.72C12.6426 731.655 14.2111 733.224 16.1461 733.224Z",
                        style: {
                            animationDelay: randomDelay(),
                            animationDuration: randomDuration()
                        }
                    }), (0, T.jsx)("path", {
                        className: (0, X.m)("fill-yellow-200", randomAnimation()),
                        d: "M16.1461 773.696C18.081 773.696 19.6496 772.128 19.6496 770.193C19.6496 768.258 18.081 766.689 16.1461 766.689C14.2111 766.689 12.6426 768.258 12.6426 770.193C12.6426 772.128 14.2111 773.696 16.1461 773.696Z",
                        style: {
                            animationDelay: randomDelay(),
                            animationDuration: randomDuration()
                        }
                    }), (0, T.jsx)("path", {
                        className: (0, X.m)("fill-yellow-200", randomAnimation()),
                        d: "M250.225 828.431C252.16 828.431 253.729 826.862 253.729 824.927C253.729 822.992 252.16 821.424 250.225 821.424C248.29 821.424 246.722 822.992 246.722 824.927C246.722 826.862 248.29 828.431 250.225 828.431Z",
                        style: {
                            animationDelay: randomDelay(),
                            animationDuration: randomDuration()
                        }
                    }), (0, T.jsx)("path", {
                        className: "stroke-camo-500",
                        d: "M1126.66 710.463L1153.24 737.037H1254.24L1276.03 758.835",
                        strokeMiterlimit: "10"
                    }), (0, T.jsx)("path", {
                        className: "stroke-camo-500",
                        d: "M1129.93 705.785L1156.5 732.359H1257.5L1279.3 754.157",
                        strokeMiterlimit: "10"
                    }), (0, T.jsx)("path", {
                        className: "stroke-camo-500",
                        d: "M1179.73 609.174V555.275L1205.68 529.328",
                        strokeMiterlimit: "10",
                        strokeWidth: "4"
                    }), (0, T.jsx)("path", {
                        className: "stroke-camo-500",
                        d: "M1160.23 710.462L1179.73 690.955V609.174",
                        strokeMiterlimit: "10"
                    }), (0, T.jsx)("path", {
                        className: "stroke-camo-500",
                        d: "M1160.84 791.963C1205.85 791.963 1242.34 755.473 1242.34 710.461C1242.34 665.449 1205.85 628.959 1160.84 628.959C1115.83 628.959 1079.34 665.449 1079.34 710.461C1079.34 755.473 1115.83 791.963 1160.84 791.963Z",
                        strokeMiterlimit: "10"
                    }), (0, T.jsx)("path", {
                        className: (0, X.m)("fill-yellow-200", randomAnimation()),
                        d: "M1194.77 233.359C1196.7 233.359 1198.27 231.79 1198.27 229.855C1198.27 227.92 1196.7 226.352 1194.77 226.352C1192.83 226.352 1191.26 227.92 1191.26 229.855C1191.26 231.79 1192.83 233.359 1194.77 233.359Z",
                        style: {
                            animationDelay: randomDelay(),
                            animationDuration: randomDuration()
                        }
                    }), (0, T.jsx)("path", {
                        className: (0, X.m)("fill-yellow-200", randomAnimation()),
                        d: "M1204.78 233.359C1206.71 233.359 1208.28 231.79 1208.28 229.855C1208.28 227.92 1206.71 226.352 1204.78 226.352C1202.84 226.352 1201.28 227.92 1201.28 229.855C1201.28 231.79 1202.84 233.359 1204.78 233.359Z",
                        style: {
                            animationDelay: randomDelay(),
                            animationDuration: randomDuration()
                        }
                    }), (0, T.jsx)("path", {
                        className: (0, X.m)("fill-yellow-200", randomAnimation()),
                        d: "M1214.79 233.359C1216.73 233.359 1218.3 231.79 1218.3 229.855C1218.3 227.92 1216.73 226.352 1214.79 226.352C1212.86 226.352 1211.29 227.92 1211.29 229.855C1211.29 231.79 1212.86 233.359 1214.79 233.359Z",
                        style: {
                            animationDelay: randomDelay(),
                            animationDuration: randomDuration()
                        }
                    }), (0, T.jsx)("path", {
                        className: (0, X.m)("fill-yellow-200", randomAnimation()),
                        d: "M1138.03 51.923C1139.97 51.923 1141.54 50.3544 1141.54 48.4195C1141.54 46.4846 1139.97 44.916 1138.03 44.916C1136.1 44.916 1134.53 46.4846 1134.53 48.4195C1134.53 50.3544 1136.1 51.923 1138.03 51.923Z",
                        style: {
                            animationDelay: randomDelay(),
                            animationDuration: randomDuration()
                        }
                    }), (0, T.jsx)("path", {
                        className: (0, X.m)("fill-yellow-200", randomAnimation()),
                        d: "M1148.05 51.923C1149.98 51.923 1151.55 50.3544 1151.55 48.4195C1151.55 46.4846 1149.98 44.916 1148.05 44.916C1146.11 44.916 1144.54 46.4846 1144.54 48.4195C1144.54 50.3544 1146.11 51.923 1148.05 51.923Z",
                        style: {
                            animationDelay: randomDelay(),
                            animationDuration: randomDuration()
                        }
                    }), (0, T.jsx)("path", {
                        className: (0, X.m)("fill-yellow-200", randomAnimation()),
                        d: "M1158.06 51.923C1159.99 51.923 1161.56 50.3544 1161.56 48.4195C1161.56 46.4846 1159.99 44.916 1158.06 44.916C1156.12 44.916 1154.55 46.4846 1154.55 48.4195C1154.55 50.3544 1156.12 51.923 1158.06 51.923Z",
                        style: {
                            animationDelay: randomDelay(),
                            animationDuration: randomDuration()
                        }
                    }), (0, T.jsx)("path", {
                        className: (0, X.m)("fill-yellow-200", randomAnimation()),
                        d: "M1169.16 51.923C1171.1 51.923 1172.67 50.3544 1172.67 48.4195C1172.67 46.4846 1171.1 44.916 1169.16 44.916C1167.23 44.916 1165.66 46.4846 1165.66 48.4195C1165.66 50.3544 1167.23 51.923 1169.16 51.923Z",
                        style: {
                            animationDelay: randomDelay(),
                            animationDuration: randomDuration()
                        }
                    }), (0, T.jsx)("path", {
                        className: (0, X.m)("fill-yellow-200", randomAnimation()),
                        d: "M1179.18 51.923C1181.11 51.923 1182.68 50.3544 1182.68 48.4195C1182.68 46.4846 1181.11 44.916 1179.18 44.916C1177.24 44.916 1175.67 46.4846 1175.67 48.4195C1175.67 50.3544 1177.24 51.923 1179.18 51.923Z",
                        style: {
                            animationDelay: randomDelay(),
                            animationDuration: randomDuration()
                        }
                    }), (0, T.jsx)("path", {
                        className: (0, X.m)("fill-yellow-200", randomAnimation()),
                        d: "M1189.19 51.923C1191.12 51.923 1192.69 50.3544 1192.69 48.4195C1192.69 46.4846 1191.12 44.916 1189.19 44.916C1187.25 44.916 1185.68 46.4846 1185.68 48.4195C1185.68 50.3544 1187.25 51.923 1189.19 51.923Z",
                        style: {
                            animationDelay: randomDelay(),
                            animationDuration: randomDuration()
                        }
                    }), (0, T.jsx)("path", {
                        className: (0, X.m)("fill-yellow-200", randomAnimation()),
                        d: "M1208.98 51.923C1210.91 51.923 1212.48 50.3544 1212.48 48.4195C1212.48 46.4846 1210.91 44.916 1208.98 44.916C1207.04 44.916 1205.47 46.4846 1205.47 48.4195C1205.47 50.3544 1207.04 51.923 1208.98 51.923Z",
                        style: {
                            animationDelay: randomDelay(),
                            animationDuration: randomDuration()
                        }
                    }), (0, T.jsx)("path", {
                        className: "stroke-camo-500",
                        d: "M1048.6 207.627C1084.52 270.32 1103.37 341.342 1103.25 413.598",
                        strokeMiterlimit: "10",
                        strokeWidth: "6"
                    }), (0, T.jsx)("path", {
                        className: "stroke-camo-500",
                        d: "M990.21 393.581H1071.53L1100.39 362.712H1131.35L1178.11 315.953",
                        strokeMiterlimit: "10"
                    }), (0, T.jsx)("path", {
                        className: "stroke-camo-500",
                        d: "M990.21 412.031H1071.53L1100.39 442.9H1131.35L1178.11 489.659",
                        strokeMiterlimit: "10"
                    }), (0, T.jsx)("path", {
                        className: (0, X.m)("fill-yellow-200", randomAnimation()),
                        d: "M1177.85 319.458C1179.78 319.458 1181.35 317.89 1181.35 315.955C1181.35 314.02 1179.78 312.451 1177.85 312.451C1175.91 312.451 1174.34 314.02 1174.34 315.955C1174.34 317.89 1175.91 319.458 1177.85 319.458Z",
                        style: {
                            animationDelay: randomDelay(),
                            animationDuration: randomDuration()
                        }
                    }), (0, T.jsx)("path", {
                        className: (0, X.m)("fill-yellow-200", randomAnimation()),
                        d: "M1207.59 319.458C1209.52 319.458 1211.09 317.89 1211.09 315.955C1211.09 314.02 1209.52 312.451 1207.59 312.451C1205.65 312.451 1204.09 314.02 1204.09 315.955C1204.09 317.89 1205.65 319.458 1207.59 319.458Z",
                        style: {
                            animationDelay: randomDelay(),
                            animationDuration: randomDuration()
                        }
                    }), (0, T.jsx)("path", {
                        className: (0, X.m)("fill-yellow-200", randomAnimation()),
                        d: "M1177.85 330.905C1179.78 330.905 1181.35 329.337 1181.35 327.402C1181.35 325.467 1179.78 323.898 1177.85 323.898C1175.91 323.898 1174.34 325.467 1174.34 327.402C1174.34 329.337 1175.91 330.905 1177.85 330.905Z",
                        style: {
                            animationDelay: randomDelay(),
                            animationDuration: randomDuration()
                        }
                    }), (0, T.jsx)("path", {
                        className: (0, X.m)("fill-yellow-200", randomAnimation()),
                        d: "M1207.59 330.905C1209.52 330.905 1211.09 329.337 1211.09 327.402C1211.09 325.467 1209.52 323.898 1207.59 323.898C1205.65 323.898 1204.09 325.467 1204.09 327.402C1204.09 329.337 1205.65 330.905 1207.59 330.905Z",
                        style: {
                            animationDelay: randomDelay(),
                            animationDuration: randomDuration()
                        }
                    }), (0, T.jsx)("path", {
                        className: (0, X.m)("fill-yellow-200", randomAnimation()),
                        d: "M1177.85 481.294C1179.78 481.294 1181.35 479.726 1181.35 477.791C1181.35 475.856 1179.78 474.287 1177.85 474.287C1175.91 474.287 1174.34 475.856 1174.34 477.791C1174.34 479.726 1175.91 481.294 1177.85 481.294Z",
                        style: {
                            animationDelay: randomDelay(),
                            animationDuration: randomDuration()
                        }
                    }), (0, T.jsx)("path", {
                        className: (0, X.m)("fill-yellow-200", randomAnimation()),
                        d: "M1207.59 481.294C1209.52 481.294 1211.09 479.726 1211.09 477.791C1211.09 475.856 1209.52 474.287 1207.59 474.287C1205.65 474.287 1204.09 475.856 1204.09 477.791C1204.09 479.726 1205.65 481.294 1207.59 481.294Z",
                        style: {
                            animationDelay: randomDelay(),
                            animationDuration: randomDuration()
                        }
                    }), (0, T.jsx)("path", {
                        className: (0, X.m)("fill-yellow-200", randomAnimation()),
                        d: "M1177.85 492.741C1179.78 492.741 1181.35 491.173 1181.35 489.238C1181.35 487.303 1179.78 485.734 1177.85 485.734C1175.91 485.734 1174.34 487.303 1174.34 489.238C1174.34 491.173 1175.91 492.741 1177.85 492.741Z",
                        style: {
                            animationDelay: randomDelay(),
                            animationDuration: randomDuration()
                        }
                    }), (0, T.jsx)("path", {
                        className: (0, X.m)("fill-yellow-200", randomAnimation()),
                        d: "M1207.59 492.741C1209.52 492.741 1211.09 491.173 1211.09 489.238C1211.09 487.303 1209.52 485.734 1207.59 485.734C1205.65 485.734 1204.09 487.303 1204.09 489.238C1204.09 491.173 1205.65 492.741 1207.59 492.741Z",
                        style: {
                            animationDelay: randomDelay(),
                            animationDuration: randomDuration()
                        }
                    }), (0, T.jsx)("path", {
                        className: (0, X.m)("fill-yellow-200", randomAnimation()),
                        d: "M1252.48 595.794C1254.41 595.794 1255.98 594.226 1255.98 592.291C1255.98 590.356 1254.41 588.787 1252.48 588.787C1250.54 588.787 1248.97 590.356 1248.97 592.291C1248.97 594.226 1250.54 595.794 1252.48 595.794Z",
                        style: {
                            animationDelay: randomDelay(),
                            animationDuration: randomDuration()
                        }
                    }), (0, T.jsx)("path", {
                        className: (0, X.m)("fill-yellow-200", randomAnimation()),
                        d: "M1282.22 595.794C1284.16 595.794 1285.72 594.226 1285.72 592.291C1285.72 590.356 1284.16 588.787 1282.22 588.787C1280.29 588.787 1278.72 590.356 1278.72 592.291C1278.72 594.226 1280.29 595.794 1282.22 595.794Z",
                        style: {
                            animationDelay: randomDelay(),
                            animationDuration: randomDuration()
                        }
                    }), (0, T.jsx)("path", {
                        className: (0, X.m)("fill-yellow-200", randomAnimation()),
                        d: "M1252.48 607.241C1254.41 607.241 1255.98 605.673 1255.98 603.738C1255.98 601.803 1254.41 600.234 1252.48 600.234C1250.54 600.234 1248.97 601.803 1248.97 603.738C1248.97 605.673 1250.54 607.241 1252.48 607.241Z",
                        style: {
                            animationDelay: randomDelay(),
                            animationDuration: randomDuration()
                        }
                    }), (0, T.jsx)("path", {
                        className: (0, X.m)("fill-yellow-200", randomAnimation()),
                        d: "M1252.48 618.689C1254.41 618.689 1255.98 617.12 1255.98 615.185C1255.98 613.25 1254.41 611.682 1252.48 611.682C1250.54 611.682 1248.97 613.25 1248.97 615.185C1248.97 617.12 1250.54 618.689 1252.48 618.689Z",
                        style: {
                            animationDelay: randomDelay(),
                            animationDuration: randomDuration()
                        }
                    }), (0, T.jsx)("path", {
                        className: (0, X.m)("fill-yellow-200", randomAnimation()),
                        d: "M1252.48 630.136C1254.41 630.136 1255.98 628.567 1255.98 626.632C1255.98 624.698 1254.41 623.129 1252.48 623.129C1250.54 623.129 1248.97 624.698 1248.97 626.632C1248.97 628.567 1250.54 630.136 1252.48 630.136Z",
                        style: {
                            animationDelay: randomDelay(),
                            animationDuration: randomDuration()
                        }
                    }), (0, T.jsx)("path", {
                        className: (0, X.m)("fill-yellow-200", randomAnimation()),
                        d: "M1252.48 641.583C1254.41 641.583 1255.98 640.015 1255.98 638.08C1255.98 636.145 1254.41 634.576 1252.48 634.576C1250.54 634.576 1248.97 636.145 1248.97 638.08C1248.97 640.015 1250.54 641.583 1252.48 641.583Z",
                        style: {
                            animationDelay: randomDelay(),
                            animationDuration: randomDuration()
                        }
                    }), (0, T.jsx)("path", {
                        className: (0, X.m)("fill-yellow-200", randomAnimation()),
                        d: "M1252.48 692.753C1254.41 692.753 1255.98 691.185 1255.98 689.25C1255.98 687.315 1254.41 685.746 1252.48 685.746C1250.54 685.746 1248.97 687.315 1248.97 689.25C1248.97 691.185 1250.54 692.753 1252.48 692.753Z",
                        style: {
                            animationDelay: randomDelay(),
                            animationDuration: randomDuration()
                        }
                    }), (0, T.jsx)("path", {
                        className: (0, X.m)("fill-yellow-200", randomAnimation()),
                        d: "M1252.48 704.2C1254.41 704.2 1255.98 702.632 1255.98 700.697C1255.98 698.762 1254.41 697.193 1252.48 697.193C1250.54 697.193 1248.97 698.762 1248.97 700.697C1248.97 702.632 1250.54 704.2 1252.48 704.2Z",
                        style: {
                            animationDelay: randomDelay(),
                            animationDuration: randomDuration()
                        }
                    }), (0, T.jsx)("path", {
                        className: (0, X.m)("fill-yellow-200", randomAnimation()),
                        d: "M1292.85 406.724C1294.79 406.724 1296.36 405.155 1296.36 403.22C1296.36 401.285 1294.79 399.717 1292.85 399.717C1290.92 399.717 1289.35 401.285 1289.35 403.22C1289.35 405.155 1290.92 406.724 1292.85 406.724Z",
                        style: {
                            animationDelay: randomDelay(),
                            animationDuration: randomDuration()
                        }
                    }), (0, T.jsx)("path", {
                        className: (0, X.m)("fill-yellow-200", randomAnimation()),
                        d: "M1266.13 401.001C1268.07 401.001 1269.64 399.433 1269.64 397.498C1269.64 395.563 1268.07 393.994 1266.13 393.994C1264.2 393.994 1262.63 395.563 1262.63 397.498C1262.63 399.433 1264.2 401.001 1266.13 401.001Z",
                        style: {
                            animationDelay: randomDelay(),
                            animationDuration: randomDuration()
                        }
                    }), (0, T.jsx)("path", {
                        className: (0, X.m)("fill-yellow-200", randomAnimation()),
                        d: "M1266.13 412.448C1268.07 412.448 1269.64 410.88 1269.64 408.945C1269.64 407.01 1268.07 405.441 1266.13 405.441C1264.2 405.441 1262.63 407.01 1262.63 408.945C1262.63 410.88 1264.2 412.448 1266.13 412.448Z",
                        style: {
                            animationDelay: randomDelay(),
                            animationDuration: randomDuration()
                        }
                    }), (0, T.jsx)("path", {
                        className: "stroke-camo-500",
                        d: "M1177.85 312.451V188.842H1232.56",
                        strokeMiterlimit: "10"
                    }), (0, T.jsx)("path", {
                        className: "stroke-camo-500",
                        d: "M1207.3 168.896V208.136",
                        strokeMiterlimit: "10"
                    }), (0, T.jsx)("path", {
                        className: "stroke-camo-500",
                        d: "M1221.18 174.643L1193.43 202.389",
                        strokeMiterlimit: "10"
                    }), (0, T.jsx)("path", {
                        className: "stroke-camo-500",
                        d: "M1177.96 229.855H1186.85",
                        strokeMiterlimit: "10"
                    }), (0, T.jsx)("path", {
                        className: "stroke-camo-500",
                        d: "M1222.97 229.855H1231.86",
                        strokeMiterlimit: "10"
                    }), (0, T.jsx)("path", {
                        className: "stroke-camo-500",
                        d: "M1251.53 563.617V581.02",
                        strokeMiterlimit: "10",
                        strokeWidth: "4"
                    }), (0, T.jsx)("path", {
                        className: "stroke-camo-500",
                        d: "M1262.16 563.617V581.02",
                        strokeMiterlimit: "10",
                        strokeWidth: "4"
                    }), (0, T.jsx)("path", {
                        className: "stroke-camo-500",
                        d: "M306.906 34.8594V52.2624",
                        strokeMiterlimit: "10",
                        strokeWidth: "4"
                    }), (0, T.jsx)("path", {
                        className: "stroke-camo-500",
                        d: "M317.537 34.8594V52.2624",
                        strokeMiterlimit: "10",
                        strokeWidth: "4"
                    }), (0, T.jsx)("path", {
                        className: "stroke-camo-500",
                        d: "M1136.79 401.248H1208.85L1297.79 312.307",
                        strokeMiterlimit: "10"
                    }), (0, T.jsx)("path", {
                        className: "stroke-camo-500",
                        d: "M1136.79 406.148H1208.85L1297.79 495.09",
                        strokeMiterlimit: "10"
                    }), (0, T.jsx)("path", {
                        className: "stroke-camo-500",
                        d: "M1310.41 434.452C1302.14 434.437 1294.21 431.14 1288.36 425.285C1282.52 419.43 1279.23 411.494 1279.23 403.221C1279.23 394.948 1282.52 387.013 1288.36 381.157C1294.21 375.302 1302.14 372.005 1310.41 371.99",
                        strokeMiterlimit: "10",
                        strokeWidth: "4"
                    }), (0, T.jsx)("path", {
                        className: "fill-camo-500",
                        d: "M1266.13 185.598H1236.93V192.087H1266.13V185.598Z"
                    }), (0, T.jsx)("path", {
                        className: "fill-camo-500",
                        d: "M1272.8 185.598H1269.72V192.087H1272.8V185.598Z"
                    }), (0, T.jsx)("path", {
                        className: "fill-camo-500",
                        d: "M1278.78 185.598H1277.24V192.087H1278.78V185.598Z"
                    }), (0, T.jsx)("path", {
                        className: "fill-camo-500",
                        d: "M1292.85 185.598H1291.31V192.087H1292.85V185.598Z"
                    }), (0, T.jsx)("path", {
                        className: "fill-camo-500",
                        d: "M1315.69 185.598H1314.15V192.087H1315.69V185.598Z"
                    }), (0, T.jsx)("path", {
                        className: "fill-camo-500",
                        d: "M1284.94 190.838C1286.04 190.838 1286.93 189.945 1286.93 188.843C1286.93 187.741 1286.04 186.848 1284.94 186.848C1283.83 186.848 1282.94 187.741 1282.94 188.843C1282.94 189.945 1283.83 190.838 1284.94 190.838Z"
                    }), (0, T.jsx)("path", {
                        className: "fill-camo-500",
                        d: "M1320.68 190.838C1321.79 190.838 1322.68 189.945 1322.68 188.843C1322.68 187.741 1321.79 186.848 1320.68 186.848C1319.58 186.848 1318.69 187.741 1318.69 188.843C1318.69 189.945 1319.58 190.838 1320.68 190.838Z"
                    }), (0, T.jsx)("path", {
                        className: "fill-camo-500",
                        d: "M1070.28 734.426H1063.79V764.247H1070.28V734.426Z"
                    }), (0, T.jsx)("path", {
                        className: "fill-camo-500",
                        d: "M1060.31 761.164H1053.82V764.246H1060.31V761.164Z"
                    }), (0, T.jsx)("path", {
                        className: "fill-camo-500",
                        d: "M1060.3 755.18H1053.82V756.721H1060.3V755.18Z"
                    }), (0, T.jsx)("path", {
                        className: "fill-camo-500",
                        d: "M1060.3 741.111H1053.82V742.653H1060.3V741.111Z"
                    }), (0, T.jsx)("path", {
                        className: "fill-camo-500",
                        d: "M1060.3 718.277H1053.82V719.819H1060.3V718.277Z"
                    }), (0, T.jsx)("path", {
                        className: "fill-camo-500",
                        d: "M1070.28 725.594H1063.79V727.135H1070.28V725.594Z"
                    }), (0, T.jsx)("path", {
                        className: "fill-camo-500",
                        d: "M1070.28 718.277H1063.79V719.819H1070.28V718.277Z"
                    }), (0, T.jsx)("path", {
                        className: "fill-camo-500",
                        d: "M1070.28 712.508H1063.79V714.049H1070.28V712.508Z"
                    }), (0, T.jsx)("path", {
                        className: "fill-camo-500",
                        d: "M1057.06 751.022C1058.16 751.022 1059.06 750.128 1059.06 749.026C1059.06 747.925 1058.16 747.031 1057.06 747.031C1055.96 747.031 1055.07 747.925 1055.07 749.026C1055.07 750.128 1055.96 751.022 1057.06 751.022Z"
                    }), (0, T.jsx)("path", {
                        className: "fill-camo-500",
                        d: "M1057.06 715.274C1058.16 715.274 1059.06 714.38 1059.06 713.278C1059.06 712.177 1058.16 711.283 1057.06 711.283C1055.96 711.283 1055.07 712.177 1055.07 713.278C1055.07 714.38 1055.96 715.274 1057.06 715.274Z"
                    }), (0, T.jsx)("path", {
                        className: "stroke-camo-500",
                        d: "M1009.09 80.7675L1083.51 6.35547H1301.65",
                        strokeMiterlimit: "10"
                    }), (0, T.jsx)("path", {
                        className: "stroke-camo-500",
                        d: "M1013.97 86.1975L1055.65 44.5195H1103.25L1128.22 69.4905H1301.65",
                        strokeMiterlimit: "10"
                    }), (0, T.jsx)("path", {
                        className: "stroke-camo-500",
                        d: "M1119.5 44.5193L1135.88 60.9035H1207.36C1208.67 60.9035 1209.96 60.6468 1211.16 60.148C1212.36 59.6493 1213.46 58.9183 1214.38 57.9968C1215.3 57.0753 1216.03 55.9812 1216.53 54.7772C1217.03 53.5732 1217.29 52.2827 1217.29 50.9794C1217.29 49.0118 1218.07 47.1248 1219.46 45.7335C1220.85 44.3422 1222.74 43.5605 1224.7 43.5605H1301.65",
                        strokeMiterlimit: "10"
                    }), (0, T.jsx)("path", {
                        d: "M661.677 297.451V327.451",
                        stroke: "#75835D",
                        strokeWidth: "1.5"
                    }), (0, T.jsx)("path", {
                        ref: p,
                        d: "M676.677 312.451H646.677",
                        stroke: "#75835D",
                        strokeWidth: "1.5"
                    }), (0, T.jsx)("path", {
                        d: "M661.677 476.881V506.881",
                        stroke: "#75835D",
                        strokeWidth: "1.5"
                    }), (0, T.jsx)("path", {
                        ref: c,
                        d: "M676.677 491.881H646.677",
                        stroke: "#75835D",
                        strokeWidth: "1.5"
                    }), (0, T.jsx)("path", {
                        className: "stroke-camo-500",
                        d: "M629.414 2.31445C426.248 29.1962 269.469 203.089 269.469 413.599C269.469 622.636 424.061 795.566 625.154 824.298",
                        strokeMiterlimit: "10",
                        strokeWidth: "1.5"
                    }), (0, T.jsx)("path", {
                        className: "stroke-camo-500",
                        d: "M598.135 2.31445C394.97 29.1962 238.19 203.089 238.19 413.599C238.19 622.636 392.783 795.566 593.876 824.298",
                        strokeMiterlimit: "10",
                        strokeWidth: "1.5"
                    }), (0, T.jsx)("path", {
                        className: "stroke-camo-500",
                        d: "M566.858 2.31445C363.692 29.1962 206.913 203.089 206.913 413.599C206.913 622.636 361.505 795.566 562.599 824.298",
                        strokeMiterlimit: "10",
                        strokeWidth: "1.5"
                    }), (0, T.jsx)("path", {
                        className: "stroke-camo-500",
                        d: "M535.581 2.31445C332.415 29.1962 175.636 203.089 175.636 413.599C175.636 622.636 330.228 795.566 531.321 824.298",
                        strokeMiterlimit: "10",
                        strokeWidth: "1.5"
                    }), (0, T.jsx)("path", {
                        className: (0, X.m)("fill-yellow-200", randomAnimation()),
                        d: "M622.839 827.632C624.774 827.632 626.343 826.063 626.343 824.128C626.343 822.194 624.774 820.625 622.839 820.625C620.904 820.625 619.336 822.194 619.336 824.128C619.336 826.063 620.904 827.632 622.839 827.632Z",
                        style: {
                            animationDelay: randomDelay(),
                            animationDuration: randomDuration()
                        }
                    }), (0, T.jsx)("path", {
                        className: (0, X.m)("fill-yellow-200", randomAnimation()),
                        d: "M593.097 827.632C595.032 827.632 596.601 826.063 596.601 824.128C596.601 822.194 595.032 820.625 593.097 820.625C591.162 820.625 589.594 822.194 589.594 824.128C589.594 826.063 591.162 827.632 593.097 827.632Z",
                        style: {
                            animationDelay: randomDelay(),
                            animationDuration: randomDuration()
                        }
                    }), (0, T.jsx)("path", {
                        className: (0, X.m)("fill-yellow-200", randomAnimation()),
                        d: "M563.355 827.632C565.29 827.632 566.859 826.063 566.859 824.128C566.859 822.194 565.29 820.625 563.355 820.625C561.42 820.625 559.852 822.194 559.852 824.128C559.852 826.063 561.42 827.632 563.355 827.632Z",
                        style: {
                            animationDelay: randomDelay(),
                            animationDuration: randomDuration()
                        }
                    }), (0, T.jsx)("path", {
                        className: (0, X.m)("fill-yellow-200", randomAnimation()),
                        d: "M533.612 827.632C535.547 827.632 537.115 826.063 537.115 824.128C537.115 822.194 535.547 820.625 533.612 820.625C531.677 820.625 530.108 822.194 530.108 824.128C530.108 826.063 531.677 827.632 533.612 827.632Z",
                        style: {
                            animationDelay: randomDelay(),
                            animationDuration: randomDuration()
                        }
                    }), (0, T.jsx)("path", {
                        className: (0, X.m)("fill-yellow-200", randomAnimation()),
                        d: "M622.839 7.007C624.774 7.007 626.343 5.43843 626.343 3.5035C626.343 1.56857 624.774 0 622.839 0C620.904 0 619.336 1.56857 619.336 3.5035C619.336 5.43843 620.904 7.007 622.839 7.007Z",
                        style: {
                            animationDelay: randomDelay(),
                            animationDuration: randomDuration()
                        }
                    }), (0, T.jsx)("path", {
                        className: (0, X.m)("fill-yellow-200", randomAnimation()),
                        d: "M593.097 7.007C595.032 7.007 596.601 5.43843 596.601 3.5035C596.601 1.56857 595.032 0 593.097 0C591.162 0 589.594 1.56857 589.594 3.5035C589.594 5.43843 591.162 7.007 593.097 7.007Z",
                        style: {
                            animationDelay: randomDelay(),
                            animationDuration: randomDuration()
                        }
                    }), (0, T.jsx)("path", {
                        className: (0, X.m)("fill-yellow-200", randomAnimation()),
                        d: "M563.355 7.007C565.29 7.007 566.859 5.43843 566.859 3.5035C566.859 1.56857 565.29 0 563.355 0C561.42 0 559.852 1.56857 559.852 3.5035C559.852 5.43843 561.42 7.007 563.355 7.007Z",
                        style: {
                            animationDelay: randomDelay(),
                            animationDuration: randomDuration()
                        }
                    }), (0, T.jsx)("path", {
                        className: (0, X.m)("fill-yellow-200", randomAnimation()),
                        d: "M533.612 7.007C535.547 7.007 537.115 5.43843 537.115 3.5035C537.115 1.56857 535.547 0 533.612 0C531.677 0 530.108 1.56857 530.108 3.5035C530.108 5.43843 531.677 7.007 533.612 7.007Z",
                        style: {
                            animationDelay: randomDelay(),
                            animationDuration: randomDuration()
                        }
                    }), (0, T.jsx)("path", {
                        className: "stroke-camo-500",
                        d: "M330.69 630.627C338.171 642.79 346.273 654.56 354.965 665.89",
                        strokeMiterlimit: "10",
                        strokeWidth: "6"
                    }), (0, T.jsx)("path", {
                        className: "fill-camo-500",
                        d: "M109.038 763.354H102.549V793.175H109.038V763.354Z"
                    }), (0, T.jsx)("path", {
                        className: "fill-camo-500",
                        d: "M119.014 790.092H112.524V793.174H119.014V790.092Z"
                    }), (0, T.jsx)("path", {
                        className: "fill-camo-500",
                        d: "M119.015 784.107H112.525V785.649H119.015V784.107Z"
                    }), (0, T.jsx)("path", {
                        className: "fill-camo-500",
                        d: "M119.015 770.039H112.525V771.58H119.015V770.039Z"
                    }), (0, T.jsx)("path", {
                        className: "fill-camo-500",
                        d: "M119.015 747.205H112.525V748.746H119.015V747.205Z"
                    }), (0, T.jsx)("path", {
                        className: "fill-camo-500",
                        d: "M109.038 754.521H102.549V756.063H109.038V754.521Z"
                    }), (0, T.jsx)("path", {
                        className: "fill-camo-500",
                        d: "M109.038 747.205H102.549V748.746H109.038V747.205Z"
                    }), (0, T.jsx)("path", {
                        className: "fill-camo-500",
                        d: "M109.038 741.436H102.549V742.977H109.038V741.436Z"
                    }), (0, T.jsx)("path", {
                        className: "fill-camo-500",
                        d: "M115.77 779.949C116.872 779.949 117.765 779.056 117.765 777.954C117.765 776.852 116.872 775.959 115.77 775.959C114.668 775.959 113.774 776.852 113.774 777.954C113.774 779.056 114.668 779.949 115.77 779.949Z"
                    }), (0, T.jsx)("path", {
                        className: "fill-camo-500",
                        d: "M115.77 744.201C116.872 744.201 117.765 743.308 117.765 742.206C117.765 741.104 116.872 740.211 115.77 740.211C114.668 740.211 113.774 741.104 113.774 742.206C113.774 743.308 114.668 744.201 115.77 744.201Z"
                    }), (0, T.jsx)("path", {
                        className: "stroke-camo-500",
                        d: "M70.2974 146.862C67.9474 177.918 61.9521 199.995 54.9274 199.995C45.8526 199.995 38.4961 163.154 38.4961 117.708C38.4961 72.2614 45.8526 35.4199 54.9274 35.4199C62.8637 35.4199 69.4858 63.5971 71.0225 101.065",
                        strokeMiterlimit: "10"
                    }), (0, T.jsx)("path", {
                        className: "stroke-camo-500",
                        d: "M0.4375 158.995C7.9064 145.463 23.453 125.945 43.3083 106.09C61.126 88.2718 78.6724 73.9238 91.8645 65.7695",
                        strokeMiterlimit: "10"
                    }), (0, T.jsx)("path", {
                        className: "stroke-camo-500",
                        d: "M104.273 59.4813C108.476 58.0139 111.54 57.9489 113.113 59.5213C119.53 65.9381 98.6807 97.1913 66.5453 129.326C52.4781 143.393 38.5801 155.298 26.8604 163.699",
                        strokeMiterlimit: "10"
                    }), (0, T.jsx)("path", {
                        className: "stroke-camo-500",
                        d: "M82.6348 128.258L103.284 148.907H300.269",
                        strokeMiterlimit: "10"
                    }), (0, T.jsx)("path", {
                        className: "stroke-camo-500",
                        d: "M290.354 543.928L267.302 566.979H236.191L214.011 589.158H110.782V694.949",
                        strokeMiterlimit: "10"
                    }), (0, T.jsx)("path", {
                        className: "stroke-camo-500",
                        d: "M680.753 2.31445C883.919 29.1962 1040.7 203.089 1040.7 413.599C1040.7 622.636 886.106 795.566 685.012 824.298",
                        strokeMiterlimit: "10",
                        strokeWidth: "1.5"
                    }), (0, T.jsx)("path", {
                        className: "stroke-camo-500",
                        d: "M908.342 717.424C887.468 736.848 864.653 754.077 840.258 768.84",
                        strokeMiterlimit: "10",
                        strokeWidth: "6"
                    }), (0, T.jsx)("path", {
                        className: "stroke-camo-500",
                        d: "M979.475 630.627C971.995 642.79 963.893 654.561 955.201 665.89",
                        strokeMiterlimit: "10",
                        strokeWidth: "6"
                    }), (0, T.jsx)("path", {
                        className: "stroke-camo-500",
                        d: "M712.03 2.31445C915.196 29.1962 1071.98 203.089 1071.98 413.599C1071.98 622.636 917.384 795.566 716.29 824.298",
                        strokeMiterlimit: "10",
                        strokeWidth: "1.5"
                    }), (0, T.jsx)("path", {
                        className: "stroke-camo-500",
                        d: "M743.308 2.31445C946.473 29.1962 1103.25 203.089 1103.25 413.599C1103.25 622.636 948.66 795.566 747.567 824.298",
                        strokeMiterlimit: "10",
                        strokeWidth: "1.5"
                    }), (0, T.jsx)("path", {
                        className: "stroke-camo-500",
                        d: "M774.586 2.31445C977.752 29.1962 1134.53 203.089 1134.53 413.599C1134.53 622.636 979.939 795.566 778.845 824.298",
                        strokeMiterlimit: "10",
                        strokeWidth: "1.5"
                    }), (0, T.jsx)("path", {
                        className: (0, X.m)("fill-yellow-200", randomAnimation()),
                        d: "M687.326 827.632C689.261 827.632 690.829 826.063 690.829 824.128C690.829 822.194 689.261 820.625 687.326 820.625C685.391 820.625 683.822 822.194 683.822 824.128C683.822 826.063 685.391 827.632 687.326 827.632Z",
                        style: {
                            animationDelay: randomDelay(),
                            animationDuration: randomDuration()
                        }
                    }), (0, T.jsx)("path", {
                        className: (0, X.m)("fill-yellow-200", randomAnimation()),
                        d: "M717.069 827.632C719.004 827.632 720.572 826.063 720.572 824.128C720.572 822.194 719.004 820.625 717.069 820.625C715.134 820.625 713.565 822.194 713.565 824.128C713.565 826.063 715.134 827.632 717.069 827.632Z",
                        style: {
                            animationDelay: randomDelay(),
                            animationDuration: randomDuration()
                        }
                    }), (0, T.jsx)("path", {
                        className: (0, X.m)("fill-yellow-200", randomAnimation()),
                        d: "M746.811 827.632C748.746 827.632 750.315 826.063 750.315 824.128C750.315 822.194 748.746 820.625 746.811 820.625C744.876 820.625 743.308 822.194 743.308 824.128C743.308 826.063 744.876 827.632 746.811 827.632Z",
                        style: {
                            animationDelay: randomDelay(),
                            animationDuration: randomDuration()
                        }
                    }), (0, T.jsx)("path", {
                        className: (0, X.m)("fill-yellow-200", randomAnimation()),
                        d: "M776.554 827.632C778.489 827.632 780.058 826.063 780.058 824.128C780.058 822.194 778.489 820.625 776.554 820.625C774.619 820.625 773.051 822.194 773.051 824.128C773.051 826.063 774.619 827.632 776.554 827.632Z",
                        style: {
                            animationDelay: randomDelay(),
                            animationDuration: randomDuration()
                        }
                    }), (0, T.jsx)("path", {
                        className: (0, X.m)("fill-yellow-200", randomAnimation()),
                        d: "M687.326 7.007C689.261 7.007 690.829 5.43843 690.829 3.5035C690.829 1.56857 689.261 0 687.326 0C685.391 0 683.822 1.56857 683.822 3.5035C683.822 5.43843 685.391 7.007 687.326 7.007Z",
                        style: {
                            animationDelay: randomDelay(),
                            animationDuration: randomDuration()
                        }
                    }), (0, T.jsx)("path", {
                        className: (0, X.m)("fill-yellow-200", randomAnimation()),
                        d: "M717.069 7.007C719.004 7.007 720.572 5.43843 720.572 3.5035C720.572 1.56857 719.004 0 717.069 0C715.134 0 713.565 1.56857 713.565 3.5035C713.565 5.43843 715.134 7.007 717.069 7.007Z",
                        style: {
                            animationDelay: randomDelay(),
                            animationDuration: randomDuration()
                        }
                    }), (0, T.jsx)("path", {
                        className: (0, X.m)("fill-yellow-200", randomAnimation()),
                        d: "M746.811 7.007C748.746 7.007 750.315 5.43843 750.315 3.5035C750.315 1.56857 748.746 0 746.811 0C744.876 0 743.308 1.56857 743.308 3.5035C743.308 5.43843 744.876 7.007 746.811 7.007Z",
                        style: {
                            animationDelay: randomDelay(),
                            animationDuration: randomDuration()
                        }
                    }), (0, T.jsx)("path", {
                        className: (0, X.m)("fill-yellow-200", randomAnimation()),
                        d: "M776.554 7.007C778.489 7.007 780.058 5.43843 780.058 3.5035C780.058 1.56857 778.489 0 776.554 0C774.619 0 773.051 1.56857 773.051 3.5035C773.051 5.43843 774.619 7.007 776.554 7.007Z",
                        style: {
                            animationDelay: randomDelay(),
                            animationDuration: randomDuration()
                        }
                    }), (0, T.jsx)("path", {
                        d: "M84.8086 592.291V692.753",
                        stroke: "#75835D",
                        strokeWidth: "5"
                    }), (0, T.jsx)("path", {
                        d: "M84.8086 539.674V592.292",
                        stroke: "#75835D",
                        strokeWidth: "1.5"
                    }), (0, T.jsx)("path", {
                        className: "stroke-camo-500",
                        d: "M19.6494 216.443V316.015C19.6494 345.516 31.3686 373.808 52.2289 394.669C62.558 404.998 70.7515 417.26 76.3416 430.755C81.9317 444.251 84.8089 458.715 84.8089 473.323V539.673",
                        strokeMiterlimit: "10"
                    }), (0, T.jsx)("path", {
                        d: "M97.2666 592.291V692.753",
                        stroke: "#75835D",
                        strokeWidth: "5"
                    }), (0, T.jsx)("path", {
                        d: "M97.2666 539.674V592.292",
                        stroke: "#75835D",
                        strokeWidth: "1.5"
                    }), (0, T.jsx)("path", {
                        className: "stroke-camo-500",
                        d: "M64.6875 216.443V316.015C64.6875 345.516 70.5475 373.808 80.9775 394.669C91.4075 415.529 97.2675 443.822 97.2675 473.323V539.673",
                        strokeMiterlimit: "10"
                    }), (0, T.jsx)("path", {
                        className: "stroke-camo-500",
                        d: "M5.90332 265.479H35.4929",
                        strokeMiterlimit: "10"
                    }), (0, T.jsx)("path", {
                        className: "stroke-camo-500",
                        d: "M50.1543 265.479H79.7439",
                        strokeMiterlimit: "10"
                    }), (0, T.jsx)("path", {
                        className: (0, X.m)("fill-yellow-200", randomAnimation()),
                        d: "M27.3853 237.456C29.3203 237.456 30.8888 235.888 30.8888 233.953C30.8888 232.018 29.3203 230.449 27.3853 230.449C25.4504 230.449 23.8818 232.018 23.8818 233.953C23.8818 235.888 25.4504 237.456 27.3853 237.456Z",
                        style: {
                            animationDelay: randomDelay(),
                            animationDuration: randomDuration()
                        }
                    }), (0, T.jsx)("path", {
                        className: (0, X.m)("fill-yellow-200", randomAnimation()),
                        d: "M57.1285 237.456C59.0634 237.456 60.632 235.888 60.632 233.953C60.632 232.018 59.0634 230.449 57.1285 230.449C55.1936 230.449 53.625 232.018 53.625 233.953C53.625 235.888 55.1936 237.456 57.1285 237.456Z",
                        style: {
                            animationDelay: randomDelay(),
                            animationDuration: randomDuration()
                        }
                    }), (0, T.jsx)("path", {
                        className: (0, X.m)("fill-yellow-200", randomAnimation()),
                        d: "M27.3853 248.903C29.3203 248.903 30.8888 247.335 30.8888 245.4C30.8888 243.465 29.3203 241.896 27.3853 241.896C25.4504 241.896 23.8818 243.465 23.8818 245.4C23.8818 247.335 25.4504 248.903 27.3853 248.903Z",
                        style: {
                            animationDelay: randomDelay(),
                            animationDuration: randomDuration()
                        }
                    }), (0, T.jsx)("path", {
                        className: (0, X.m)("fill-yellow-200", randomAnimation()),
                        d: "M57.1285 248.903C59.0634 248.903 60.632 247.335 60.632 245.4C60.632 243.465 59.0634 241.896 57.1285 241.896C55.1936 241.896 53.625 243.465 53.625 245.4C53.625 247.335 55.1936 248.903 57.1285 248.903Z",
                        style: {
                            animationDelay: randomDelay(),
                            animationDuration: randomDuration()
                        }
                    }), (0, T.jsx)("path", {
                        className: (0, X.m)("fill-yellow-200", randomAnimation()),
                        d: "M187.028 219.946C188.963 219.946 190.531 218.378 190.531 216.443C190.531 214.508 188.963 212.939 187.028 212.939C185.093 212.939 183.524 214.508 183.524 216.443C183.524 218.378 185.093 219.946 187.028 219.946Z",
                        style: {
                            animationDelay: randomDelay(),
                            animationDuration: randomDuration()
                        }
                    }), (0, T.jsx)("path", {
                        className: (0, X.m)("fill-yellow-200", randomAnimation()),
                        d: "M146.829 269.446C148.764 269.446 150.332 267.878 150.332 265.943C150.332 264.008 148.764 262.439 146.829 262.439C144.894 262.439 143.325 264.008 143.325 265.943C143.325 267.878 144.894 269.446 146.829 269.446Z",
                        style: {
                            animationDelay: randomDelay(),
                            animationDuration: randomDuration()
                        }
                    }), (0, T.jsx)("path", {
                        className: (0, X.m)("fill-yellow-200", randomAnimation()),
                        d: "M146.829 322.96C148.764 322.96 150.332 321.392 150.332 319.457C150.332 317.522 148.764 315.953 146.829 315.953C144.894 315.953 143.325 317.522 143.325 319.457C143.325 321.392 144.894 322.96 146.829 322.96Z",
                        style: {
                            animationDelay: randomDelay(),
                            animationDuration: randomDuration()
                        }
                    }), (0, T.jsx)("path", {
                        className: (0, X.m)("fill-yellow-200", randomAnimation()),
                        d: "M146.829 376.476C148.764 376.476 150.332 374.907 150.332 372.972C150.332 371.037 148.764 369.469 146.829 369.469C144.894 369.469 143.325 371.037 143.325 372.972C143.325 374.907 144.894 376.476 146.829 376.476Z",
                        style: {
                            animationDelay: randomDelay(),
                            animationDuration: randomDuration()
                        }
                    }), (0, T.jsx)("path", {
                        className: (0, X.m)("fill-yellow-200", randomAnimation()),
                        d: "M146.829 387.9C148.764 387.9 150.332 386.331 150.332 384.396C150.332 382.461 148.764 380.893 146.829 380.893C144.894 380.893 143.325 382.461 143.325 384.396C143.325 386.331 144.894 387.9 146.829 387.9Z",
                        style: {
                            animationDelay: randomDelay(),
                            animationDuration: randomDuration()
                        }
                    }), (0, T.jsx)("path", {
                        className: (0, X.m)("fill-yellow-200", randomAnimation()),
                        d: "M146.829 399.193C148.764 399.193 150.332 397.624 150.332 395.689C150.332 393.754 148.764 392.186 146.829 392.186C144.894 392.186 143.325 393.754 143.325 395.689C143.325 397.624 144.894 399.193 146.829 399.193Z",
                        style: {
                            animationDelay: randomDelay(),
                            animationDuration: randomDuration()
                        }
                    }), (0, T.jsx)("path", {
                        className: (0, X.m)("fill-yellow-200", randomAnimation()),
                        d: "M135.665 168.445C137.6 168.445 139.168 166.876 139.168 164.941C139.168 163.006 137.6 161.438 135.665 161.438C133.73 161.438 132.161 163.006 132.161 164.941C132.161 166.876 133.73 168.445 135.665 168.445Z",
                        style: {
                            animationDelay: randomDelay(),
                            animationDuration: randomDuration()
                        }
                    }), (0, T.jsx)("path", {
                        className: "fill-camo-500",
                        d: "M1070.28 734.426H1063.79V764.247H1070.28V734.426Z"
                    }), (0, T.jsx)("path", {
                        className: "fill-camo-500",
                        d: "M1060.31 761.164H1053.82V764.246H1060.31V761.164Z"
                    }), (0, T.jsx)("path", {
                        className: "fill-camo-500",
                        d: "M1060.3 755.18H1053.82V756.721H1060.3V755.18Z"
                    }), (0, T.jsx)("path", {
                        className: "fill-camo-500",
                        d: "M1060.3 741.111H1053.82V742.653H1060.3V741.111Z"
                    }), (0, T.jsx)("path", {
                        className: "fill-camo-500",
                        d: "M1060.3 718.277H1053.82V719.819H1060.3V718.277Z"
                    }), (0, T.jsx)("path", {
                        className: "fill-camo-500",
                        d: "M1070.28 725.594H1063.79V727.135H1070.28V725.594Z"
                    }), (0, T.jsx)("path", {
                        className: "fill-camo-500",
                        d: "M1070.28 718.277H1063.79V719.819H1070.28V718.277Z"
                    }), (0, T.jsx)("path", {
                        className: "fill-camo-500",
                        d: "M1070.28 712.508H1063.79V714.049H1070.28V712.508Z"
                    }), (0, T.jsx)("path", {
                        className: "fill-camo-500",
                        d: "M1057.06 751.022C1058.16 751.022 1059.06 750.128 1059.06 749.026C1059.06 747.925 1058.16 747.031 1057.06 747.031C1055.96 747.031 1055.07 747.925 1055.07 749.026C1055.07 750.128 1055.96 751.022 1057.06 751.022Z"
                    }), (0, T.jsx)("path", {
                        className: "fill-camo-500",
                        d: "M1057.06 715.274C1058.16 715.274 1059.06 714.38 1059.06 713.278C1059.06 712.177 1058.16 711.283 1057.06 711.283C1055.96 711.283 1055.07 712.177 1055.07 713.278C1055.07 714.38 1055.96 715.274 1057.06 715.274Z"
                    }), (0, T.jsx)("path", {
                        className: "fill-camo-500",
                        d: "M1070.28 745.848H1063.79V775.669H1070.28V745.848Z"
                    }), (0, T.jsx)("path", {
                        className: "fill-camo-500",
                        d: "M1060.31 772.588H1053.82V775.67H1060.31V772.588Z"
                    }), (0, T.jsx)("path", {
                        className: "fill-camo-500",
                        d: "M1060.3 766.602H1053.82V768.143H1060.3V766.602Z"
                    }), (0, T.jsx)("path", {
                        className: "fill-camo-500",
                        d: "M1060.3 752.535H1053.82V754.076H1060.3V752.535Z"
                    }), (0, T.jsx)("path", {
                        className: "fill-camo-500",
                        d: "M1060.3 729.699H1053.82V731.24H1060.3V729.699Z"
                    }), (0, T.jsx)("path", {
                        className: "fill-camo-500",
                        d: "M1070.28 737.016H1063.79V738.557H1070.28V737.016Z"
                    }), (0, T.jsx)("path", {
                        className: "fill-camo-500",
                        d: "M1070.28 729.699H1063.79V731.24H1070.28V729.699Z"
                    }), (0, T.jsx)("path", {
                        className: "fill-camo-500",
                        d: "M1070.28 723.932H1063.79V725.473H1070.28V723.932Z"
                    }), (0, T.jsx)("path", {
                        className: "fill-camo-500",
                        d: "M1057.06 762.445C1058.16 762.445 1059.06 761.552 1059.06 760.45C1059.06 759.348 1058.16 758.455 1057.06 758.455C1055.96 758.455 1055.07 759.348 1055.07 760.45C1055.07 761.552 1055.96 762.445 1057.06 762.445Z"
                    }), (0, T.jsx)("path", {
                        className: "fill-camo-500",
                        d: "M1057.06 726.697C1058.16 726.697 1059.06 725.804 1059.06 724.702C1059.06 723.6 1058.16 722.707 1057.06 722.707C1055.96 722.707 1055.07 723.6 1055.07 724.702C1055.07 725.804 1055.96 726.697 1057.06 726.697Z"
                    }), (0, T.jsx)("path", {
                        className: (0, X.m)("fill-yellow-200", randomAnimation()),
                        d: "M27.3853 295.515C29.3203 295.515 30.8888 293.946 30.8888 292.011C30.8888 290.076 29.3203 288.508 27.3853 288.508C25.4504 288.508 23.8818 290.076 23.8818 292.011C23.8818 293.946 25.4504 295.515 27.3853 295.515Z",
                        style: {
                            animationDelay: randomDelay(),
                            animationDuration: randomDuration()
                        }
                    }), (0, T.jsx)("path", {
                        className: (0, X.m)("fill-yellow-200", randomAnimation()),
                        d: "M57.1285 295.515C59.0634 295.515 60.632 293.946 60.632 292.011C60.632 290.076 59.0634 288.508 57.1285 288.508C55.1936 288.508 53.625 290.076 53.625 292.011C53.625 293.946 55.1936 295.515 57.1285 295.515Z",
                        style: {
                            animationDelay: randomDelay(),
                            animationDuration: randomDuration()
                        }
                    }), (0, T.jsx)("path", {
                        className: (0, X.m)("fill-yellow-200", randomAnimation()),
                        d: "M27.3853 306.962C29.3203 306.962 30.8888 305.394 30.8888 303.459C30.8888 301.524 29.3203 299.955 27.3853 299.955C25.4504 299.955 23.8818 301.524 23.8818 303.459C23.8818 305.394 25.4504 306.962 27.3853 306.962Z",
                        style: {
                            animationDelay: randomDelay(),
                            animationDuration: randomDuration()
                        }
                    }), (0, T.jsx)("path", {
                        className: (0, X.m)("fill-yellow-200", randomAnimation()),
                        d: "M57.1285 306.962C59.0634 306.962 60.632 305.394 60.632 303.459C60.632 301.524 59.0634 299.955 57.1285 299.955C55.1936 299.955 53.625 301.524 53.625 303.459C53.625 305.394 55.1936 306.962 57.1285 306.962Z",
                        style: {
                            animationDelay: randomDelay(),
                            animationDuration: randomDuration()
                        }
                    }), (0, T.jsx)("path", {
                        className: "stroke-camo-500",
                        d: "M135.594 235.948C146.366 235.948 155.099 227.216 155.099 216.444C155.099 205.672 146.366 196.939 135.594 196.939C124.822 196.939 116.09 205.672 116.09 216.444C116.09 227.216 124.822 235.948 135.594 235.948Z",
                        strokeMiterlimit: "10"
                    }), (0, T.jsx)("path", {
                        className: "stroke-camo-500",
                        d: "M135.595 251.913C155.184 251.913 171.064 236.033 171.064 216.444C171.064 196.855 155.184 180.975 135.595 180.975C116.006 180.975 100.126 196.855 100.126 216.444C100.126 236.033 116.006 251.913 135.595 251.913Z",
                        strokeMiterlimit: "10",
                        strokeWidth: "1.8185"
                    }), (0, T.jsx)("path", {
                        className: "stroke-camo-500",
                        d: "M135.595 163.699V216.442H187.028",
                        strokeMiterlimit: "10",
                        strokeWidth: "1.8185"
                    }), (0, T.jsx)("path", {
                        className: "fill-camo-500",
                        d: "M138.445 315.492H131.956V345.313H138.445V315.492Z"
                    }), (0, T.jsx)("path", {
                        className: "fill-camo-500",
                        d: "M138.445 406.646H131.956V409.729H138.445V406.646Z"
                    }), (0, T.jsx)("path", {
                        className: "fill-camo-500",
                        d: "M138.445 400.66H131.956V402.201H138.445V400.66Z"
                    }), (0, T.jsx)("path", {
                        className: "fill-camo-500",
                        d: "M138.445 386.594H131.956V388.135H138.445V386.594Z"
                    }), (0, T.jsx)("path", {
                        className: "fill-camo-500",
                        d: "M138.445 363.758H131.956V365.299H138.445V363.758Z"
                    }), (0, T.jsx)("path", {
                        className: "fill-camo-500",
                        d: "M139.234 301.777H132.744V303.319H139.234V301.777Z"
                    }), (0, T.jsx)("path", {
                        className: "fill-camo-500",
                        d: "M139.234 294.461H132.744V296.002H139.234V294.461Z"
                    }), (0, T.jsx)("path", {
                        className: "fill-camo-500",
                        d: "M139.234 275.73H132.744V277.272H139.234V275.73Z"
                    }), (0, T.jsx)("path", {
                        className: "fill-camo-500",
                        d: "M135.201 396.504C136.303 396.504 137.196 395.611 137.196 394.509C137.196 393.407 136.303 392.514 135.201 392.514C134.099 392.514 133.206 393.407 133.206 394.509C133.206 395.611 134.099 396.504 135.201 396.504Z"
                    }), (0, T.jsx)("path", {
                        className: "fill-camo-500",
                        d: "M135.201 360.754C136.303 360.754 137.196 359.861 137.196 358.759C137.196 357.657 136.303 356.764 135.201 356.764C134.099 356.764 133.206 357.657 133.206 358.759C133.206 359.861 134.099 360.754 135.201 360.754Z"
                    }), (0, T.jsx)("path", {
                        className: "fill-camo-500",
                        d: "M135.201 425.684C136.303 425.684 137.196 424.79 137.196 423.689C137.196 422.587 136.303 421.693 135.201 421.693C134.099 421.693 133.206 422.587 133.206 423.689C133.206 424.79 134.099 425.684 135.201 425.684Z"
                    }), (0, T.jsx)("path", {
                        className: "fill-camo-500",
                        d: "M135.201 267.522C136.303 267.522 137.196 266.628 137.196 265.526C137.196 264.425 136.303 263.531 135.201 263.531C134.099 263.531 133.206 264.425 133.206 265.526C133.206 266.628 134.099 267.522 135.201 267.522Z"
                    }), (0, T.jsx)("path", {
                        className: "stroke-camo-500",
                        d: "M149.6 56.9395L176.173 83.5125H277.173L298.972 105.311",
                        strokeMiterlimit: "10"
                    }), (0, T.jsx)("path", {
                        className: "stroke-camo-500",
                        d: "M153.866 51.2617L180.439 77.8347H281.439L303.238 99.6337",
                        strokeMiterlimit: "10"
                    }), (0, T.jsx)("path", {
                        className: (0, X.m)("fill-yellow-200", randomAnimation()),
                        d: "M141.406 775.085C143.341 775.085 144.909 773.517 144.909 771.582C144.909 769.647 143.341 768.078 141.406 768.078C139.471 768.078 137.902 769.647 137.902 771.582C137.902 773.517 139.471 775.085 141.406 775.085Z",
                        style: {
                            animationDelay: randomDelay(),
                            animationDuration: randomDuration()
                        }
                    }), (0, T.jsx)("path", {
                        className: (0, X.m)("fill-yellow-200", randomAnimation()),
                        d: "M151.417 775.085C153.352 775.085 154.92 773.517 154.92 771.582C154.92 769.647 153.352 768.078 151.417 768.078C149.482 768.078 147.913 769.647 147.913 771.582C147.913 773.517 149.482 775.085 151.417 775.085Z",
                        style: {
                            animationDelay: randomDelay(),
                            animationDuration: randomDuration()
                        }
                    }), (0, T.jsx)("path", {
                        className: (0, X.m)("fill-yellow-200", randomAnimation()),
                        d: "M161.428 775.085C163.363 775.085 164.932 773.517 164.932 771.582C164.932 769.647 163.363 768.078 161.428 768.078C159.493 768.078 157.925 769.647 157.925 771.582C157.925 773.517 159.493 775.085 161.428 775.085Z",
                        style: {
                            animationDelay: randomDelay(),
                            animationDuration: randomDuration()
                        }
                    }), (0, T.jsx)("path", {
                        className: (0, X.m)("fill-yellow-200", randomAnimation()),
                        d: "M181.217 775.085C183.152 775.085 184.721 773.517 184.721 771.582C184.721 769.647 183.152 768.078 181.217 768.078C179.282 768.078 177.714 769.647 177.714 771.582C177.714 773.517 179.282 775.085 181.217 775.085Z",
                        style: {
                            animationDelay: randomDelay(),
                            animationDuration: randomDuration()
                        }
                    })]
                })
            }, (l, c) => !0);
            eg.displayName = "UnlockSplashBackground", (_ = P || (P = {}))[_.IDLE = 0] = "IDLE", _[_.READY = 1] = "READY", _[_.ACTIVE = 2] = "ACTIVE", _[_.EXITING = 3] = "EXITING", _[_.COMPLETE = 4] = "COMPLETE";
            let em = M.createContext(null),
                ProgressSplashProvider = l => {
                    let c = M.useRef(null),
                        p = M.useRef(null),
                        [v, _] = M.useState(0);
                    M.useEffect(() => {
                        2 === v && setTimeout(() => {
                            _(3)
                        }, 1e4), 3 === v && setTimeout(() => {
                            _(4)
                        }, 500)
                    }, [v]);
                    let C = M.useCallback(() => {
                            _(1)
                        }, []),
                        P = M.useCallback(() => {
                            _(2)
                        }, []);
                    return (0, T.jsxs)(em.Provider, {
                        value: {
                            anchorRef: c,
                            init: C,
                            start: P,
                            state: v,
                            progressOrbRef: p
                        },
                        children: [l.children, v >= 1 && null !== c.current && (0, T.jsx)(ProgressSplashScreen, {
                            anchorEl: c.current,
                            in: 2 === v,
                            mimicOrb: p.current
                        })]
                    })
                };

            function useProgressSplash() {
                let l = M.useContext(em);
                if (null === l) throw Error("Missing expected ProgressSplashContext");
                return l
            }
            let ey = M.createContext(null),
                UnlockSplashProvider = l => {
                    let c = M.useRef(null),
                        p = (0, J.$)(),
                        [v, _] = M.useState(0),
                        [C, P] = M.useState(!1),
                        [Q, X] = M.useState(!1);
                    M.useEffect(() => {
                        3 === v && setTimeout(() => {
                            _(4)
                        }, 500)
                    }, [v]);
                    let es = M.useCallback(() => {
                            _(1)
                        }, []),
                        eo = M.useCallback(() => {
                            p.toggleBackground("black", 1e3), _(2)
                        }, [p]),
                        el = M.useCallback(() => {
                            X(!0)
                        }, []),
                        ec = M.useCallback(() => {
                            _(3)
                        }, []),
                        eh = M.useCallback(() => {
                            P(!0)
                        }, []);
                    return (0, T.jsxs)(ey.Provider, {
                        value: {
                            anchorRef: c,
                            init: es,
                            isCountUpPhase: Q,
                            isUnlockPhase: C,
                            start: eo,
                            state: v
                        },
                        children: [l.children, null !== c.current && v >= 1 && (0, T.jsx)(z.h_, {
                            container: c.current,
                            children: (0, T.jsx)(UnlockSplash, {
                                anchorEl: c.current,
                                in: 2 === v,
                                onCountup: el,
                                onEnd: ec,
                                onUnlock: eh
                            })
                        })]
                    })
                };

            function useUnlockSplash() {
                let l = M.useContext(ey);
                if (null === l) throw Error("Missing expected UnlockSplashContext");
                return l
            }
        },
        8299: function(l, c, p) {
            "use strict";
            p.d(c, {
                IR: function() {
                    return AppearExpandX
                },
                LB: function() {
                    return AppearRotateQuadrant
                },
                S3: function() {
                    return AppearExpandY
                },
                gT: function() {
                    return Appear
                },
                h4: function() {
                    return AppearSlideLeft
                },
                oI: function() {
                    return AppearSlideRight
                },
                tB: function() {
                    return AppearExpandRight
                },
                ug: function() {
                    return AppearSlideUp
                },
                zz: function() {
                    return AppearExpandLeft
                }
            });
            var v = p(4817);
            p(1248);
            var _ = p(5916),
                C = p(1389),
                P = p(6227);
            let Appear = l => {
                    let {
                        classNames: c,
                        delay: p = 0,
                        duration: T = 500,
                        ...M
                    } = l;
                    return (0, v.jsx)(_.Z, {
                        appear: !0,
                        in: M.in,
                        timeout: p,
                        classNames: { ...c,
                            appearDone: (0, C.m)(c.appearDone, P.L[T]),
                            exitDone: (0, C.m)(c.exitDone, P.L[T])
                        },
                        onEntered: (l, c) => {
                            if (c) {
                                var p;
                                null === (p = M.onComplete) || void 0 === p || p.call(M)
                            }
                        },
                        children: M.children
                    })
                },
                AppearExpandLeft = l => (0, v.jsx)(Appear, { ...l,
                    classNames: {
                        appear: "scale-x-0",
                        appearDone: "scale-x-1 transition-transform origin-right",
                        exit: "scale-x-1",
                        exitDone: "scale-x-0 transition-transform origin-right"
                    }
                }),
                AppearExpandRight = l => (0, v.jsx)(Appear, { ...l,
                    classNames: {
                        appear: "scale-x-0",
                        appearDone: "scale-x-1 transition-transform origin-left",
                        exit: "scale-x-1",
                        exitDone: "scale-x-0 transition-transform origin-bottom"
                    }
                }),
                AppearExpandX = l => (0, v.jsx)(Appear, { ...l,
                    classNames: {
                        appear: "scale-x-0",
                        appearDone: "scale-x-1 transition-transform",
                        exit: "scale-x-1",
                        exitDone: "scale-x-0 transition-transform"
                    }
                }),
                AppearExpandY = l => (0, v.jsx)(Appear, { ...l,
                    classNames: {
                        appear: "scale-y-0",
                        appearDone: "scale-y-1 transition-transform",
                        exit: "scale-y-1",
                        exitDone: "scale-y-0 transition-transform"
                    }
                }),
                AppearRotateQuadrant = l => (0, v.jsx)(Appear, { ...l,
                    classNames: {
                        appear: "rotate-90",
                        appearDone: "rotate-0 transition-transform",
                        exit: "rotate-0",
                        exitDone: "rotate-90"
                    }
                }),
                AppearSlideLeft = l => (0, v.jsx)(Appear, { ...l,
                    classNames: {
                        appear: "translate-x-8",
                        appearDone: "translate-x-0 transition-transform",
                        exit: "translate-x-0",
                        exitDone: "translate-x-8 transition-transform"
                    }
                }),
                AppearSlideRight = l => (0, v.jsx)(Appear, { ...l,
                    classNames: {
                        appear: "-translate-x-8",
                        appearDone: "translate-x-0 transition-transform",
                        exit: "translate-x-0",
                        exitDone: "-translate-x-8 transition-transform"
                    }
                }),
                AppearSlideUp = l => (0, v.jsx)(Appear, { ...l,
                    classNames: {
                        appear: "translate-y-8",
                        appearDone: "translate-y-0 transition-transform",
                        exit: "translate-y-0",
                        exitDone: "translate-y-8 transition-transform"
                    }
                })
        },
        6227: function(l, c, p) {
            "use strict";
            p.d(c, {
                L: function() {
                    return v
                }
            });
            let v = {
                0: "duration-[0ms]",
                500: "duration-[500ms]",
                750: "duration-[750ms]",
                1e3: "duration-[1000ms]",
                1500: "duration-[1500ms]",
                1750: "duration-[1750ms]",
                2e3: "duration-[2000ms]",
                3e3: "duration-[3000ms]"
            }
        },
        414: function(l, c, p) {
            "use strict";
            p.d(c, {
                qQ: function() {
                    return EnterFadeUp
                },
                zW: function() {
                    return EnterFade
                }
            });
            var v = p(4817);
            p(1248);
            var _ = p(5916),
                C = p(1389),
                P = p(6227);
            let Enter = l => {
                    let {
                        appear: c = !0,
                        classNames: p,
                        delay: T = 0,
                        duration: M = 500,
                        ...z
                    } = l;
                    return (0, v.jsx)(_.Z, {
                        appear: c,
                        in: z.in,
                        timeout: T,
                        classNames: { ...p,
                            appearDone: (0, C.m)(p.appearDone, P.L[M]),
                            enterDone: (0, C.m)(p.enterDone, P.L[M]),
                            exitDone: (0, C.m)(p.exitDone, P.L[M])
                        },
                        onEntered: (l, c) => {
                            if (c) {
                                var p;
                                null === (p = z.onComplete) || void 0 === p || p.call(z)
                            }
                        },
                        children: z.children
                    })
                },
                EnterFade = l => (0, v.jsx)(Enter, { ...l,
                    classNames: {
                        appear: "opacity-[0]",
                        appearDone: "opacity-[100] transition-opacity",
                        enter: "opacity-[0]",
                        enterDone: "opacity-[100] transition-opacity",
                        exit: "opacity-[100]",
                        exitDone: "opacity-[0] transition-opacity"
                    }
                }),
                EnterFadeUp = l => (0, v.jsx)(Enter, { ...l,
                    classNames: {
                        appear: "translate-y-8 opacity-0",
                        appearDone: "translate-y-[0px] opacity-100 transition-all",
                        enter: "translate-y-8 opacity-0",
                        enterDone: "translate-y-[0px] opacity-100 transition-all",
                        exit: "translate-y-[0px] opacity-1",
                        exitDone: "translate-y-8 opacity-0 transition-all"
                    }
                })
        },
        7657: function(l, c, p) {
            "use strict";
            p.d(c, {
                E6: function() {
                    return MountExpandY
                },
                WV: function() {
                    return MountFade
                },
                XS: function() {
                    return MountFadeRight
                },
                rl: function() {
                    return MountFadeAbsolute
                },
                s_: function() {
                    return MountFadeLeft
                }
            });
            var v = p(4817);
            p(1248);
            var _ = p(5916),
                C = p(1389),
                P = p(6227);
            let Mount = l => {
                    let {
                        classNames: c,
                        duration: p = 500,
                        ...T
                    } = l;
                    return (0, v.jsx)(_.Z, {
                        appear: T.appear,
                        in: T.in,
                        mountOnEnter: !0,
                        onEntered: T.onMount,
                        onExited: T.onUnmount,
                        timeout: p,
                        unmountOnExit: !0,
                        classNames: { ...c,
                            appearActive: (0, C.m)(c.appearActive, P.L[p]),
                            enterActive: (0, C.m)(c.enterActive, P.L[p]),
                            exitActive: (0, C.m)(c.exitActive, P.L[p])
                        },
                        children: T.children
                    })
                },
                MountExpandY = l => (0, v.jsx)(Mount, { ...l,
                    classNames: {
                        appear: "scale-y-[0]",
                        appearActive: "scale-y-[1] transition-transform",
                        enter: "scale-y-[0]",
                        enterActive: "scale-y-[1] transition-transform",
                        exit: "scale-y-1",
                        exitActive: "scale-y-0 transition-transform"
                    }
                }),
                MountFade = l => (0, v.jsx)(Mount, { ...l,
                    classNames: {
                        appear: "opacity-0",
                        appearActive: "opacity-100 transition-opacity",
                        enter: "opacity-0",
                        enterActive: "opacity-100 transition-opacity",
                        exit: "opacity-1",
                        exitActive: "opacity-0 transition-opacity"
                    }
                }),
                MountFadeAbsolute = l => (0, v.jsx)(Mount, { ...l,
                    classNames: {
                        appear: "absolute top-0 left-0 opacity-0",
                        appearActive: "static opacity-100 transition-opacity",
                        enter: "absolute top-0 left-0 opacity-0",
                        enterActive: "static opacity-100 transition-opacity",
                        exit: "opacity-1 absolute top-0 left-0",
                        exitActive: "static opacity-0 transition-opacity"
                    }
                }),
                MountFadeLeft = l => (0, v.jsx)(Mount, { ...l,
                    classNames: {
                        appear: "translate-x-8 opacity-0",
                        appearActive: "translate-x-[-0px] opacity-100 transition-all",
                        enter: "translate-x-8 opacity-0",
                        enterActive: "translate-x-[-0px] opacity-100 transition-all",
                        exit: "translate-x-0 opacity-1",
                        exitActive: "translate-x-8 opacity-0 transition-all"
                    }
                }),
                MountFadeRight = l => (0, v.jsx)(Mount, { ...l,
                    classNames: {
                        appear: "translate-x-[-32px] opacity-0",
                        appearActive: "translate-x-[0px] opacity-100 transition-all",
                        enter: "translate-x-[-32px] opacity-0",
                        enterActive: "translate-x-[0px] opacity-100 transition-all",
                        exit: "translate-x-[-0px] opacity-1",
                        exitActive: "translate-x-[-32px] opacity-0 transition-all"
                    }
                })
        },
        9651: function(l, c, p) {
            "use strict";
            p.d(c, {
                B: function() {
                    return TvlFooter
                },
                j: function() {
                    return useTvl
                }
            });
            var v = p(4817),
                _ = p(8851),
                C = p(7833),
                P = p(1389),
                T = p(6359),
                M = p(7622),
                z = p(6179);

            function useTvl() {
                return (0, M.ZP)((0, z.FP)("leaderboard/total-value-bridged"), z.i3, {
                    refreshInterval: 3e3
                })
            }

            function TvlFooter(l) {
                var c;
                let {
                    tvlStyle: p = "dark"
                } = l, {
                    t: M
                } = (0, C.Z)("common"), {
                    data: z,
                    error: J
                } = useTvl();
                return !z || J ? null : (0, v.jsxs)("div", {
                    className: (0, P.m)("typography-brand-body flex w-full animate-appear-expand-right items-center gap-2.5 uppercase leading-[160%]", "bright" === p ? "text-yellow-100" : "text-camo-400"),
                    children: [(0, v.jsxs)("div", {
                        className: "flex flex-1 justify-end gap-1 overflow-x-hidden text-camo-400 opacity-50",
                        children: [(0, v.jsx)(T.oT, {
                            className: "h-[9px] min-w-max"
                        }), (0, v.jsx)(T.oT, {
                            className: "h-[9px] min-w-max"
                        }), (0, v.jsx)(T.oT, {
                            className: "h-[9px] min-w-max"
                        })]
                    }), (0, v.jsx)("div", {
                        children: (0, v.jsx)(_.Z, {
                            i18nKey: "common:tvl_footer.total_value_locked",
                            values: {
                                usdString: null === (c = Number(z.totalBridgeValueInUsd)) || void 0 === c ? void 0 : c.toLocaleString("en-US", {
                                    currency: "USD",
                                    maximumFractionDigits: 0,
                                    style: "currency"
                                })
                            }
                        })
                    }), (0, v.jsxs)("div", {
                        className: "hidden gap-1 opacity-50 min-[1260px]:flex",
                        children: [(0, v.jsx)("div", {
                            className: "h-[7px] w-[3px] bg-camo-400"
                        }), (0, v.jsx)("div", {
                            className: "h-[7px] w-[3px] bg-camo-400"
                        }), (0, v.jsx)("div", {
                            className: "h-[7px] w-[21px] bg-camo-400"
                        })]
                    }), (0, v.jsx)("div", {
                        className: "hidden min-[1260px]:block",
                        children: (0, v.jsx)(_.Z, {
                            i18nKey: "common:tvl_footer.total_users",
                            values: {
                                count: z.totalAddressesBridged
                            }
                        })
                    }), (0, v.jsxs)("div", {
                        className: "hidden gap-1 opacity-50 min-[1440px]:flex",
                        children: [(0, v.jsx)("div", {
                            className: "h-[7px] w-[14px] bg-camo-400"
                        }), (0, v.jsx)("div", {
                            className: "h-[7px] w-[3px] bg-camo-400"
                        })]
                    }), (0, v.jsx)("div", {
                        className: "hidden min-[1440px]:block",
                        children: M("tvl_footer.early_access_live")
                    })]
                })
            }
        },
        7467: function(l, c, p) {
            "use strict";
            p.d(c, {
                C: function() {
                    return SwitchWalletModal
                }
            });
            var v = p(4817),
                _ = p(7833);
            p(1248);
            var C = p(5834),
                P = p(9817);
            let SwitchWalletModal = l => {
                let {
                    authenticate: c,
                    isAuthenticating: p,
                    newAddress: T,
                    ...M
                } = l, {
                    t: z
                } = (0, _.Z)("common");
                return (0, v.jsxs)(C.u_, {
                    ariaLabel: z("aria-label_switch_wallet_modal"),
                    onClose: () => {},
                    ...M,
                    children: [(0, v.jsx)(C.Io, {
                        children: (0, v.jsx)("h2", {
                            className: "typography-brand-body-l-caps text-yellow-100",
                            children: z("h2_switch_wallet_modal")
                        })
                    }), (0, v.jsx)("p", {
                        className: "typography-brand-body-l mt-2 w-72 text-yellow-100",
                        children: z("p_switch_wallet_modal")
                    }), (0, v.jsx)("div", {
                        className: "typography-brand-body-l-caps my-11 text-center text-camo-300",
                        children: T.slice(0, 8)
                    }), (0, v.jsx)(P.h, {
                        glow: !0,
                        smallerText: !0,
                        stretch: !0,
                        isWalletPending: p,
                        onClick: c,
                        variant: "primary",
                        children: z("connect wallet")
                    })]
                })
            }
        },
        9817: function(l, c, p) {
            "use strict";
            p.d(c, {
                h: function() {
                    return J
                }
            });
            var v = p(4817),
                _ = p(7833),
                C = p(1248),
                P = p(1389),
                T = p(5834),
                M = p(3685),
                z = p(3460);
            let J = C.forwardRef((l, c) => {
                let {
                    children: p,
                    isWalletPending: C,
                    pendingText: J,
                    smallerText: Q = !1,
                    variant: X = "primary",
                    ...es
                } = l, {
                    t: eo
                } = (0, _.Z)("common"), el = (0, z.Nr)(C, 150), ec = C || el;
                return (0, v.jsx)("div", {
                    className: (0, P.m)("p-[1px] transition-all", ec && M.o, C ? "pointer-events-none cursor-wait bg-camo-400" : "bg-transparent"),
                    children: (0, v.jsx)(M.z, { ...es,
                        ref: c,
                        variant: C ? "tertiary" : X,
                        children: (0, v.jsx)("div", {
                            className: (0, P.m)(Q && "typography-brand-body-bold uppercase [letter-spacing:1.3px]"),
                            children: C ? (0, v.jsxs)("div", {
                                className: "flex w-full items-center justify-between gap-2 text-camo-200",
                                children: [(0, v.jsx)(T.aN, {}), null != J ? J : eo("confirm in wallet"), (0, v.jsx)(T.aN, {})]
                            }) : p
                        })
                    })
                })
            });
            J.displayName = "WalletActionButton"
        },
        8397: function(l, c, p) {
            "use strict";
            p.d(c, {
                h: function() {
                    return v.h
                }
            }), p(7467);
            var v = p(9817)
        },
        350: function(l, c, p) {
            "use strict";
            p.d(c, {
                K: function() {
                    return ClientWalletProvider
                },
                A: function() {
                    return useClientWallet
                }
            });
            var v = p(4817),
                _ = p(1248),
                C = p(3338),
                P = p(3096),
                T = p(7467),
                M = p(6179);
            async function authChallengeAndLogin(l) {
                try {
                    var c;
                    if (null === l.signer) throw Error();
                    let p = await fetch((0, M.FP)("/auth/wallet/challenge"), {
                            body: JSON.stringify({
                                walletAddress: l.signer.address
                            }),
                            credentials: "include",
                            headers: {
                                "Content-Type": "application/json"
                            },
                            method: "POST"
                        }),
                        v = await p.json();
                    if (null === (c = v.message) || void 0 === c ? void 0 : c.includes("already logged in")) return !0;
                    if (!0 !== v.success) return !1;
                    let {
                        challenge: _
                    } = v, C = await l.signer.signMessage(_.message), P = await fetch((0, M.FP)("/auth/wallet/login"), {
                        body: JSON.stringify({
                            signature: C,
                            ..._
                        }),
                        credentials: "include",
                        headers: {
                            "Content-Type": "application/json"
                        },
                        method: "POST"
                    }), T = await P.json(), {
                        success: z
                    } = T;
                    return z
                } catch (l) {
                    return console.error(l), !1
                }
            }
            let z = _.createContext(null),
                ClientWalletProvider = l => {
                    var c;
                    let {
                        signer: p
                    } = (0, P.O)(), {
                        me: M,
                        refreshMe: J
                    } = (0, C.Hi)(), [Q, X] = _.useState(null), [es, eo] = _.useState(!1), [el, ec] = _.useState(!1), [eh, ed] = _.useState(null), ef = "string" != typeof M && "string" == typeof M.registeredOn, ep = "string" == typeof Q && "string" == typeof(null == p ? void 0 : p.address) && Q !== p.address, eg = _.useRef(!1);
                    eg.current = el;
                    let em = _.useRef(!1);
                    ("unauthorized" === M || ef) && (em.current = !0), ep && (em.current = !1);
                    let ey = _.useCallback(async l => {
                            ec(!0);
                            let c = await authChallengeAndLogin({
                                signer: l
                            });
                            eo(c), c && X(l.address), await J(), ec(!1), ed(new Date().toISOString())
                        }, [J]),
                        eb = _.useCallback(async () => {
                            if (null !== p) return await ey(p)
                        }, [p, ey]);
                    return _.useEffect(() => {
                        null !== p && !0 !== eg.current && !1 !== em.current && ey(p)
                    }, [p, ey]), (0, v.jsxs)(z.Provider, {
                        value: {
                            address: Q,
                            authenticate: eb,
                            isAuthenticated: es,
                            isAuthenticating: el,
                            lastAuthenticated: eh,
                            autoAuthenticate: () => em.current = !0
                        },
                        children: [l.children, (0, v.jsx)(T.C, {
                            authenticate: eb,
                            isAuthenticating: el,
                            newAddress: null !== (c = null == p ? void 0 : p.address) && void 0 !== c ? c : "",
                            open: ep
                        })]
                    })
                };

            function useClientWallet() {
                let l = _.useContext(z);
                if (null === l) throw Error("Missing expected ClientWalletContext");
                return l
            }
        },
        3460: function(l, c, p) {
            "use strict";
            p.d(c, {
                WE: function() {
                    return useBrowserStorage
                },
                Nr: function() {
                    return useDebounce
                },
                Yz: function() {
                    return useInterval
                },
                D9: function() {
                    return usePrevious
                },
                Pr: function() {
                    return useScrollLock
                }
            });
            var v = p(1248);

            function useBrowserStorage(l, c) {
                let p = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : "localStorage",
                    _ = arguments.length > 3 ? arguments[3] : void 0,
                    C = arguments.length > 4 ? arguments[4] : void 0,
                    [P, T] = v.useState(c),
                    M = v.useMemo(() => null != _ ? _ : l => JSON.stringify(l), [_]),
                    z = v.useMemo(() => null != C ? C : l => JSON.parse(l), [C]),
                    J = v.useCallback(c => T(v => {
                        let _ = c instanceof Function ? c(v) : c;
                        return window[p].setItem(l, M(_)), _
                    }), [l, M, p]);
                return v.useEffect(() => {
                    {
                        let c = window[p].getItem(l);
                        c && T(z(c))
                    }
                }, [z, l, p]), [P, J]
            }

            function useDebounce(l, c) {
                let [p, _] = v.useState(l);
                return v.useEffect(() => {
                    let p = setTimeout(() => {
                        _(l)
                    }, c);
                    return () => {
                        clearTimeout(p)
                    }
                }, [l, c]), p
            }

            function useInterval(l, c) {
                let p = !(arguments.length > 2) || void 0 === arguments[2] || arguments[2],
                    _ = v.useRef(l);
                v.useEffect(() => {
                    _.current = l
                }, [l]), v.useEffect(() => {
                    if (null === c) return;
                    p && _.current();
                    let l = setInterval(() => {
                        _.current()
                    }, c);
                    return () => {
                        clearInterval(l)
                    }
                }, [c, p])
            }

            function usePrevious(l) {
                let [c, p] = v.useState(l), [_, C] = v.useState(l);
                return l !== c && (C(c), p(l)), _
            }

            function useScrollLock(l) {
                v.useEffect(() => {
                    if (l) {
                        let l = window.scrollY;
                        return document.body.style.position = "fixed", document.body.style.top = "-".concat(l, "px"), () => {
                            document.body.style.position = "", document.body.style.top = "", window.scrollTo(0, l)
                        }
                    }
                }, [l])
            }
        },
        3338: function(l, c, p) {
            "use strict";
            p.d(c, {
                Hi: function() {
                    return useClientMe
                },
                LB: function() {
                    return MeClientProvider
                },
                aM: function() {
                    return fetchMe
                },
                mg: function() {
                    return initMe
                },
                nm: function() {
                    return postViewedPoints
                },
                w$: function() {
                    return postViewedBridge
                }
            });
            var v = p(4817),
                _ = p(1248),
                C = p(7622),
                P = p(6179);
            async function fetchMe(l) {
                var c;
                let p = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},
                    v = await (0, P.U2)(l, p);
                return null !== (c = v.user) && void 0 !== c ? c : "unauthorized"
            }
            async function initMe(l) {
                let c = await fetch((0, P.FP)("/auth/init"), {
                        body: JSON.stringify({
                            inviteCode: l.toLowerCase()
                        }),
                        credentials: "include",
                        headers: {
                            "Content-Type": "application/json"
                        },
                        method: "POST"
                    }),
                    p = await c.json();
                return !!p.success
            }
            async function postViewedPoints() {
                let l = await fetch((0, P.FP)("/user/viewed-points"), {
                        credentials: "include",
                        headers: {
                            "Content-Type": "application/json"
                        },
                        method: "POST"
                    }),
                    c = await l.json();
                return !!c.success
            }
            async function postViewedBridge() {
                let l = await fetch((0, P.FP)("/user/viewed-bridge"), {
                        credentials: "include",
                        headers: {
                            "Content-Type": "application/json"
                        },
                        method: "POST"
                    }),
                    c = await l.json();
                return !!c.success
            }
            let T = _.createContext(null),
                MeClientProvider = l => {
                    let {
                        data: c,
                        mutate: p
                    } = (0, C.ZP)((0, P.FP)("/auth/me"), fetchMe), M = _.useCallback(async () => {
                        let l = await p();
                        return null != l ? l : "unauthorized"
                    }, [p]);
                    return (0, v.jsx)(T.Provider, {
                        value: {
                            refreshMe: M,
                            me: null != c ? c : "loading"
                        },
                        children: l.children
                    })
                };

            function useClientMe(l) {
                let c = _.useContext(T);
                if (null === c) throw Error("Missing expected MeClientContext");
                return {
                    me: "loading" === c.me && void 0 !== l ? l : c.me,
                    refreshMe: c.refreshMe
                }
            }
        },
        8810: function(l, c, p) {
            "use strict";
            p.r(c), p.d(c, {
                default: function() {
                    return eg
                }
            });
            var v = p(4817),
                _ = p(3303),
                C = p.n(_),
                P = p(1248),
                T = p(3742),
                __awaiter = function(l, c, p, v) {
                    return new(p || (p = Promise))(function(_, C) {
                        function fulfilled(l) {
                            try {
                                step(v.next(l))
                            } catch (l) {
                                C(l)
                            }
                        }

                        function rejected(l) {
                            try {
                                step(v.throw(l))
                            } catch (l) {
                                C(l)
                            }
                        }

                        function step(l) {
                            var c;
                            l.done ? _(l.value) : ((c = l.value) instanceof p ? c : new p(function(l) {
                                l(c)
                            })).then(fulfilled, rejected)
                        }
                        step((v = v.apply(l, c || [])).next())
                    })
                },
                __generator = function(l, c) {
                    var p, v, _, C, P = {
                        label: 0,
                        sent: function() {
                            if (1 & _[0]) throw _[1];
                            return _[1]
                        },
                        trys: [],
                        ops: []
                    };
                    return C = {
                        next: verb(0),
                        throw: verb(1),
                        return: verb(2)
                    }, "function" == typeof Symbol && (C[Symbol.iterator] = function() {
                        return this
                    }), C;

                    function verb(T) {
                        return function(M) {
                            return function(T) {
                                if (p) throw TypeError("Generator is already executing.");
                                for (; C && (C = 0, T[0] && (P = 0)), P;) try {
                                    if (p = 1, v && (_ = 2 & T[0] ? v.return : T[0] ? v.throw || ((_ = v.return) && _.call(v), 0) : v.next) && !(_ = _.call(v, T[1])).done) return _;
                                    switch (v = 0, _ && (T = [2 & T[0], _.value]), T[0]) {
                                        case 0:
                                        case 1:
                                            _ = T;
                                            break;
                                        case 4:
                                            return P.label++, {
                                                value: T[1],
                                                done: !1
                                            };
                                        case 5:
                                            P.label++, v = T[1], T = [0];
                                            continue;
                                        case 7:
                                            T = P.ops.pop(), P.trys.pop();
                                            continue;
                                        default:
                                            if (!(_ = (_ = P.trys).length > 0 && _[_.length - 1]) && (6 === T[0] || 2 === T[0])) {
                                                P = 0;
                                                continue
                                            }
                                            if (3 === T[0] && (!_ || T[1] > _[0] && T[1] < _[3])) {
                                                P.label = T[1];
                                                break
                                            }
                                            if (6 === T[0] && P.label < _[1]) {
                                                P.label = _[1], _ = T;
                                                break
                                            }
                                            if (_ && P.label < _[2]) {
                                                P.label = _[2], P.ops.push(T);
                                                break
                                            }
                                            _[2] && P.ops.pop(), P.trys.pop();
                                            continue
                                    }
                                    T = c.call(l, P)
                                } catch (l) {
                                    T = [6, l], v = 0
                                } finally {
                                    p = _ = 0
                                }
                                if (5 & T[0]) throw T[1];
                                return {
                                    value: T[0] ? T[1] : void 0,
                                    done: !0
                                }
                            }([T, M])
                        }
                    }
                },
                __spreadArray = function(l, c, p) {
                    if (p || 2 == arguments.length)
                        for (var v, _ = 0, C = c.length; _ < C; _++) !v && _ in c || (v || (v = Array.prototype.slice.call(c, 0, _)), v[_] = c[_]);
                    return l.concat(v || Array.prototype.slice.call(c))
                };

            function flat(l) {
                return l.reduce(function(l, c) {
                    return l.concat(c)
                }, [])
            }
            var __assign = function() {
                    return (__assign = Object.assign || function(l) {
                        for (var c, p = 1, v = arguments.length; p < v; p++)
                            for (var _ in c = arguments[p]) Object.prototype.hasOwnProperty.call(c, _) && (l[_] = c[_]);
                        return l
                    }).apply(this, arguments)
                },
                loadNamespaces_generator = function(l, c) {
                    var p, v, _, C, P = {
                        label: 0,
                        sent: function() {
                            if (1 & _[0]) throw _[1];
                            return _[1]
                        },
                        trys: [],
                        ops: []
                    };
                    return C = {
                        next: verb(0),
                        throw: verb(1),
                        return: verb(2)
                    }, "function" == typeof Symbol && (C[Symbol.iterator] = function() {
                        return this
                    }), C;

                    function verb(T) {
                        return function(M) {
                            return function(T) {
                                if (p) throw TypeError("Generator is already executing.");
                                for (; C && (C = 0, T[0] && (P = 0)), P;) try {
                                    if (p = 1, v && (_ = 2 & T[0] ? v.return : T[0] ? v.throw || ((_ = v.return) && _.call(v), 0) : v.next) && !(_ = _.call(v, T[1])).done) return _;
                                    switch (v = 0, _ && (T = [2 & T[0], _.value]), T[0]) {
                                        case 0:
                                        case 1:
                                            _ = T;
                                            break;
                                        case 4:
                                            return P.label++, {
                                                value: T[1],
                                                done: !1
                                            };
                                        case 5:
                                            P.label++, v = T[1], T = [0];
                                            continue;
                                        case 7:
                                            T = P.ops.pop(), P.trys.pop();
                                            continue;
                                        default:
                                            if (!(_ = (_ = P.trys).length > 0 && _[_.length - 1]) && (6 === T[0] || 2 === T[0])) {
                                                P = 0;
                                                continue
                                            }
                                            if (3 === T[0] && (!_ || T[1] > _[0] && T[1] < _[3])) {
                                                P.label = T[1];
                                                break
                                            }
                                            if (6 === T[0] && P.label < _[1]) {
                                                P.label = _[1], _ = T;
                                                break
                                            }
                                            if (_ && P.label < _[2]) {
                                                P.label = _[2], P.ops.push(T);
                                                break
                                            }
                                            _[2] && P.ops.pop(), P.trys.pop();
                                            continue
                                    }
                                    T = c.call(l, P)
                                } catch (l) {
                                    T = [6, l], v = 0
                                } finally {
                                    p = _ = 0
                                }
                                if (5 & T[0]) throw T[1];
                                return {
                                    value: T[0] ? T[1] : void 0,
                                    done: !0
                                }
                            }([T, M])
                        }
                    }
                },
                appWithI18n_assign = function() {
                    return (appWithI18n_assign = Object.assign || function(l) {
                        for (var c, p = 1, v = arguments.length; p < v; p++)
                            for (var _ in c = arguments[p]) Object.prototype.hasOwnProperty.call(c, _) && (l[_] = c[_]);
                        return l
                    }).apply(this, arguments)
                },
                appWithI18n_generator = function(l, c) {
                    var p, v, _, C, P = {
                        label: 0,
                        sent: function() {
                            if (1 & _[0]) throw _[1];
                            return _[1]
                        },
                        trys: [],
                        ops: []
                    };
                    return C = {
                        next: verb(0),
                        throw: verb(1),
                        return: verb(2)
                    }, "function" == typeof Symbol && (C[Symbol.iterator] = function() {
                        return this
                    }), C;

                    function verb(T) {
                        return function(M) {
                            return function(T) {
                                if (p) throw TypeError("Generator is already executing.");
                                for (; C && (C = 0, T[0] && (P = 0)), P;) try {
                                    if (p = 1, v && (_ = 2 & T[0] ? v.return : T[0] ? v.throw || ((_ = v.return) && _.call(v), 0) : v.next) && !(_ = _.call(v, T[1])).done) return _;
                                    switch (v = 0, _ && (T = [2 & T[0], _.value]), T[0]) {
                                        case 0:
                                        case 1:
                                            _ = T;
                                            break;
                                        case 4:
                                            return P.label++, {
                                                value: T[1],
                                                done: !1
                                            };
                                        case 5:
                                            P.label++, v = T[1], T = [0];
                                            continue;
                                        case 7:
                                            T = P.ops.pop(), P.trys.pop();
                                            continue;
                                        default:
                                            if (!(_ = (_ = P.trys).length > 0 && _[_.length - 1]) && (6 === T[0] || 2 === T[0])) {
                                                P = 0;
                                                continue
                                            }
                                            if (3 === T[0] && (!_ || T[1] > _[0] && T[1] < _[3])) {
                                                P.label = T[1];
                                                break
                                            }
                                            if (6 === T[0] && P.label < _[1]) {
                                                P.label = _[1], _ = T;
                                                break
                                            }
                                            if (_ && P.label < _[2]) {
                                                P.label = _[2], P.ops.push(T);
                                                break
                                            }
                                            _[2] && P.ops.pop(), P.trys.pop();
                                            continue
                                    }
                                    T = c.call(l, P)
                                } catch (l) {
                                    T = [6, l], v = 0
                                } finally {
                                    p = _ = 0
                                }
                                if (5 & T[0]) throw T[1];
                                return {
                                    value: T[0] ? T[1] : void 0,
                                    done: !0
                                }
                            }([T, M])
                        }
                    }
                },
                M = p(4389),
                z = p.n(M),
                J = p(6497),
                Q = p(3096),
                X = p(3125),
                es = p(6359),
                eo = p(1173),
                el = p(5644),
                ec = p(6388),
                eh = p(350),
                ed = p(8356),
                ef = p.n(ed),
                ep = p(3338);
            p(7375);
            let getLayout = l => (0, v.jsx)(es.RQ, {
                children: l
            });
            var eg = function(l, c) {
                var v = this;

                function AppWithTranslations(p) {
                    var v, _, C = c.defaultLocale;
                    return P.createElement(T.Z, {
                        lang: (null === (v = p.pageProps) || void 0 === v ? void 0 : v.__lang) || p.__lang || C,
                        namespaces: (null === (_ = p.pageProps) || void 0 === _ ? void 0 : _.__namespaces) || p.__namespaces,
                        config: c
                    }, P.createElement(l, appWithI18n_assign({}, p)))
                }
                return void 0 === c && (c = {}), c.isLoader || !1 === c.loader || console.warn('\uD83D\uDEA8 [next-translate] You can remove the "appWithI18n" HoC on the _app.js, unless you set "loader: false" in your i18n config file.'), "function" == typeof c.staticsHoc && c.staticsHoc(AppWithTranslations, l), "undefined" == typeof window ? p.g.i18nConfig = c : window.i18nConfig = c, c.skipInitialProps || (AppWithTranslations.getInitialProps = function(_) {
                    var C, P, T;
                    return C = void 0, P = void 0, T = function() {
                        var v, C, P;
                        return appWithI18n_generator(this, function(T) {
                            switch (T.label) {
                                case 0:
                                    if (v = appWithI18n_assign(appWithI18n_assign({}, _.ctx || {}), _ || {}), C = {
                                            pageProps: {}
                                        }, !l.getInitialProps) return [3, 2];
                                    return [4, l.getInitialProps(_)];
                                case 1:
                                    C = T.sent() || {}, T.label = 2;
                                case 2:
                                    return P = [appWithI18n_assign({}, C)], [4, function(l) {
                                        var c, v, _, C, P, T;
                                        return void 0 === l && (l = {}), _ = this, C = void 0, P = void 0, T = function() {
                                            var _, C, P, T, M, z;
                                            return loadNamespaces_generator(this, function(J) {
                                                switch (J.label) {
                                                    case 0:
                                                        var Q;
                                                        if (C = (_ = __assign(__assign({}, ("undefined" == typeof window ? p.g : window).i18nConfig), l)).localesToIgnore || ["default"], P = (null === (c = _.req) || void 0 === c ? void 0 : c.locale) || _.locale || (null === (v = _.router) || void 0 === v ? void 0 : v.locale) || _.defaultLocale || "", !_.pathname) return console.warn('\uD83D\uDEA8 [next-translate] You forgot to pass the "pathname" inside "loadNamespaces" configuration'), [2, {
                                                            __lang: P
                                                        }];
                                                        if (C.includes(P)) return [2, {
                                                            __lang: P
                                                        }];
                                                        return _.loaderName || !1 === _.loader || console.warn('\uD83D\uDEA8 [next-translate] You can remove the "loadNamespaces" helper, unless you set "loader: false" in your i18n config file.'), void 0 === (Q = _.pathname.replace(/\/index$/, "")) && (Q = ""), T = (Q.length > 1 && Q.endsWith("/") ? Q.slice(0, -1) : Q) || "/", [4, function(l, c, p) {
                                                            var v = l.pages,
                                                                _ = void 0 === v ? {} : v;
                                                            return __awaiter(this, void 0, void 0, function() {
                                                                var l, v, C, P, T, M, z, J = this;
                                                                return __generator(this, function(Q) {
                                                                    switch (Q.label) {
                                                                        case 0:
                                                                            return l = "rgx:", v = function(l) {
                                                                                return __awaiter(J, void 0, void 0, function() {
                                                                                    return __generator(this, function(c) {
                                                                                        return [2, "function" == typeof l ? l(p) : l || []]
                                                                                    })
                                                                                })
                                                                            }, C = Object.keys(_).reduce(function(p, C) {
                                                                                return C.substring(0, l.length) === l && new RegExp(C.replace(l, "")).test(c) && p.push(v(_[C])), p
                                                                            }, []), P = [
                                                                                []
                                                                            ], [4, v(_["*"])];
                                                                        case 1:
                                                                            return T = [__spreadArray.apply(void 0, P.concat([Q.sent(), !0]))], [4, v(_[c])];
                                                                        case 2:
                                                                            return M = [__spreadArray.apply(void 0, T.concat([Q.sent(), !0]))], z = flat, [4, Promise.all(C)];
                                                                        case 3:
                                                                            return [2, __spreadArray.apply(void 0, M.concat([z.apply(void 0, [Q.sent()]), !0]))]
                                                                    }
                                                                })
                                                            })
                                                        }(_, T, _)];
                                                    case 1:
                                                        return [4, Promise.all((M = J.sent()).map(function(l) {
                                                            return "function" == typeof _.loadLocaleFrom ? _.loadLocaleFrom(P, l).catch(function() {
                                                                return {}
                                                            }) : Promise.resolve({})
                                                        }))];
                                                    case 2:
                                                        return z = J.sent() || [],
                                                            function(l, c) {
                                                                var p = c.page,
                                                                    v = c.lang,
                                                                    _ = c.namespaces;
                                                                if (!1 !== l.logBuild && "undefined" == typeof window) {
                                                                    var C = null == ({
                                                                            BUILD_ID: "rPlKWyq5lgx0xpN1VdXrR",
                                                                            NEXT_PUBLIC_APP_ENVIRONMENT: "production",
                                                                            NEXT_PUBLIC_APP_RELEASE_ID: "ba3767f43ffc44e8ba5f21e4cc793c50a7fa8054"
                                                                        }).NODE_DISABLE_COLORS && null == ({
                                                                            BUILD_ID: "rPlKWyq5lgx0xpN1VdXrR",
                                                                            NEXT_PUBLIC_APP_ENVIRONMENT: "production",
                                                                            NEXT_PUBLIC_APP_RELEASE_ID: "ba3767f43ffc44e8ba5f21e4cc793c50a7fa8054"
                                                                        }).NO_COLOR && "dumb" !== ({
                                                                            BUILD_ID: "rPlKWyq5lgx0xpN1VdXrR",
                                                                            NEXT_PUBLIC_APP_ENVIRONMENT: "production",
                                                                            NEXT_PUBLIC_APP_RELEASE_ID: "ba3767f43ffc44e8ba5f21e4cc793c50a7fa8054"
                                                                        }).TERM && "0" !== ({
                                                                            BUILD_ID: "rPlKWyq5lgx0xpN1VdXrR",
                                                                            NEXT_PUBLIC_APP_ENVIRONMENT: "production",
                                                                            NEXT_PUBLIC_APP_RELEASE_ID: "ba3767f43ffc44e8ba5f21e4cc793c50a7fa8054"
                                                                        }).FORCE_COLOR,
                                                                        color = function(l) {
                                                                            return C ? "\x1b[36m".concat(l, "\x1b[0m") : l
                                                                        };
                                                                    console.log(color("next-translate"), "- compiled page:", color(p), "- locale:", color(v), "- namespaces:", color(_.join(", ")), "- used loader:", color(l.loaderName || "-"))
                                                                }
                                                            }(_, {
                                                                page: T,
                                                                lang: P,
                                                                namespaces: M
                                                            }), [2, {
                                                                __lang: P,
                                                                __namespaces: M.reduce(function(l, c, p) {
                                                                    return l[c] = z[p] || null, l
                                                                }, {})
                                                            }]
                                                }
                                            })
                                        }, new(P || (P = Promise))(function(l, c) {
                                            function fulfilled(l) {
                                                try {
                                                    step(T.next(l))
                                                } catch (l) {
                                                    c(l)
                                                }
                                            }

                                            function rejected(l) {
                                                try {
                                                    step(T.throw(l))
                                                } catch (l) {
                                                    c(l)
                                                }
                                            }

                                            function step(c) {
                                                var p;
                                                c.done ? l(c.value) : ((p = c.value) instanceof P ? p : new P(function(l) {
                                                    l(p)
                                                })).then(fulfilled, rejected)
                                            }
                                            step((T = T.apply(_, C || [])).next())
                                        })
                                    }(appWithI18n_assign(appWithI18n_assign(appWithI18n_assign({}, v), c), {
                                        loaderName: "getInitialProps"
                                    }))];
                                case 3:
                                    return [2, appWithI18n_assign.apply(void 0, P.concat([T.sent()]))]
                            }
                        })
                    }, new(P || (P = Promise))(function(l, c) {
                        function fulfilled(l) {
                            try {
                                step(T.next(l))
                            } catch (l) {
                                c(l)
                            }
                        }

                        function rejected(l) {
                            try {
                                step(T.throw(l))
                            } catch (l) {
                                c(l)
                            }
                        }

                        function step(c) {
                            var p;
                            c.done ? l(c.value) : ((p = c.value) instanceof P ? p : new P(function(l) {
                                l(p)
                            })).then(fulfilled, rejected)
                        }
                        step((T = T.apply(v, C || [])).next())
                    })
                }), AppWithTranslations
            }(function(l) {
                var c;
                let {
                    Component: p,
                    pageProps: _
                } = l;
                ! function() {
                    let {
                        defaultLocale: l,
                        locale: c
                    } = (0, J.useRouter)();
                    P.useEffect(() => {
                        if (c !== l) {
                            let l = new Date;
                            l.setTime(l.getTime() + 2592e6), document.cookie = "NEXT_LOCALE=".concat(c, ";expires=").concat(l.toUTCString(), ";path=/")
                        }
                    }, [c, l])
                }();
                let C = null !== (c = p.getLayout) && void 0 !== c ? c : getLayout;
                return (0, v.jsxs)(P.Fragment, {
                    children: [(0, v.jsx)(z(), {
                        children: (0, v.jsx)("title", {
                            children: "Blast"
                        })
                    }), (0, v.jsx)(ep.LB, {
                        children: (0, v.jsx)(Q.x, {
                            children: (0, v.jsx)(eh.K, {
                                children: (0, v.jsx)(eo.a, {
                                    children: (0, v.jsx)(X.U, {
                                        children: (0, v.jsx)(el.a, {
                                            children: (0, v.jsx)(ec.ar, {
                                                children: (0, v.jsx)(ec.WO, {
                                                    children: (0, v.jsx)("div", {
                                                        className: ef().variable,
                                                        children: C((0, v.jsx)(p, { ..._
                                                        }))
                                                    })
                                                })
                                            })
                                        })
                                    })
                                })
                            })
                        })
                    })]
                })
            }, { ...C(),
                isLoader: !0,
                skipInitialProps: !0,
                loadLocaleFrom: C().loadLocaleFrom || ((l, c) => p(242)("./".concat(l, "/").concat(c)).then(l => l.default))
            })
        },
        7375: function() {},
        8356: function(l) {
            l.exports = {
                style: {
                    fontFamily: "'__geomGraphic_d69ff7', '__geomGraphic_Fallback_d69ff7'"
                },
                className: "__className_d69ff7",
                variable: "__variable_d69ff7"
            }
        },
        5856: function() {},
        5883: function() {},
        3856: function(l, c, p) {
            "use strict";
            let v = p(941);
            l.exports = pino;
            let _ = function() {
                function defd(l) {
                    return void 0 !== l && l
                }
                try {
                    if ("undefined" != typeof globalThis) return globalThis;
                    return Object.defineProperty(Object.prototype, "globalThis", {
                        get: function() {
                            return delete Object.prototype.globalThis, this.globalThis = this
                        },
                        configurable: !0
                    }), globalThis
                } catch (l) {
                    return defd(self) || defd(window) || defd(this) || {}
                }
            }().console || {};

            function pino(l) {
                var c;
                (l = l || {}).browser = l.browser || {};
                let p = l.browser.transmit;
                if (p && "function" != typeof p.send) throw Error("pino: transmit option must have a send function");
                let v = l.browser.write || _;
                l.browser.write && (l.browser.asObject = !0);
                let C = l.serializers || {},
                    P = function(l, c) {
                        if (Array.isArray(l)) {
                            let c = l.filter(function(l) {
                                return "!stdSerializers.err" !== l
                            });
                            return c
                        }
                        return !0 === l && Object.keys(c)
                    }(l.browser.serialize, C),
                    T = l.browser.serialize;
                Array.isArray(l.browser.serialize) && l.browser.serialize.indexOf("!stdSerializers.err") > -1 && (T = !1), "function" == typeof v && (v.error = v.fatal = v.warn = v.info = v.debug = v.trace = v), !1 === l.enabled && (l.level = "silent");
                let M = l.level || "info",
                    z = Object.create(v);
                z.log || (z.log = noop), Object.defineProperty(z, "levelVal", {
                    get: function() {
                        return "silent" === this.level ? 1 / 0 : this.levels.values[this.level]
                    }
                }), Object.defineProperty(z, "level", {
                    get: function() {
                        return this._level
                    },
                    set: function(l) {
                        if ("silent" !== l && !this.levels.values[l]) throw Error("unknown level " + l);
                        this._level = l, set(J, z, "error", "log"), set(J, z, "fatal", "error"), set(J, z, "warn", "error"), set(J, z, "info", "log"), set(J, z, "debug", "log"), set(J, z, "trace", "log")
                    }
                });
                let J = {
                    transmit: p,
                    serialize: P,
                    asObject: l.browser.asObject,
                    levels: ["error", "fatal", "warn", "info", "debug", "trace"],
                    timestamp: "function" == typeof(c = l).timestamp ? c.timestamp : !1 === c.timestamp ? nullTime : epochTime
                };
                return z.levels = pino.levels, z.level = M, z.setMaxListeners = z.getMaxListeners = z.emit = z.addListener = z.on = z.prependListener = z.once = z.prependOnceListener = z.removeListener = z.removeAllListeners = z.listeners = z.listenerCount = z.eventNames = z.write = z.flush = noop, z.serializers = C, z._serialize = P, z._stdErrSerialize = T, z.child = function(c, v) {
                    if (!c) throw Error("missing bindings for child Pino");
                    v = v || {}, P && c.serializers && (v.serializers = c.serializers);
                    let _ = v.serializers;
                    if (P && _) {
                        var T = Object.assign({}, C, _),
                            M = !0 === l.browser.serialize ? Object.keys(T) : P;
                        delete c.serializers, applySerializers([c], M, T, this._stdErrSerialize)
                    }

                    function Child(l) {
                        this._childLevel = (0 | l._childLevel) + 1, this.error = bind(l, c, "error"), this.fatal = bind(l, c, "fatal"), this.warn = bind(l, c, "warn"), this.info = bind(l, c, "info"), this.debug = bind(l, c, "debug"), this.trace = bind(l, c, "trace"), T && (this.serializers = T, this._serialize = M), p && (this._logEvent = createLogEventShape([].concat(l._logEvent.bindings, c)))
                    }
                    return Child.prototype = this, new Child(this)
                }, p && (z._logEvent = createLogEventShape()), z
            }

            function set(l, c, p, C) {
                let P = Object.getPrototypeOf(c);
                c[p] = c.levelVal > c.levels.values[p] ? noop : P[p] ? P[p] : _[p] || _[C] || noop,
                    function(l, c, p) {
                        if (l.transmit || c[p] !== noop) {
                            var C;
                            c[p] = (C = c[p], function() {
                                let P = l.timestamp(),
                                    T = Array(arguments.length),
                                    M = Object.getPrototypeOf && Object.getPrototypeOf(this) === _ ? _ : this;
                                for (var z = 0; z < T.length; z++) T[z] = arguments[z];
                                if (l.serialize && !l.asObject && applySerializers(T, this._serialize, this.serializers, this._stdErrSerialize), l.asObject ? C.call(M, function(l, c, p, _) {
                                        l._serialize && applySerializers(p, l._serialize, l.serializers, l._stdErrSerialize);
                                        let C = p.slice(),
                                            P = C[0],
                                            T = {};
                                        _ && (T.time = _), T.level = pino.levels.values[c];
                                        let M = (0 | l._childLevel) + 1;
                                        if (M < 1 && (M = 1), null !== P && "object" == typeof P) {
                                            for (; M-- && "object" == typeof C[0];) Object.assign(T, C.shift());
                                            P = C.length ? v(C.shift(), C) : void 0
                                        } else "string" == typeof P && (P = v(C.shift(), C));
                                        return void 0 !== P && (T.msg = P), T
                                    }(this, p, T, P)) : C.apply(M, T), l.transmit) {
                                    let v = l.transmit.level || c.level,
                                        _ = pino.levels.values[v],
                                        C = pino.levels.values[p];
                                    if (C < _) return;
                                    (function(l, c, p) {
                                        let v = c.send,
                                            _ = c.ts,
                                            C = c.methodLevel,
                                            P = c.methodValue,
                                            T = c.val,
                                            M = l._logEvent.bindings;
                                        applySerializers(p, l._serialize || Object.keys(l.serializers), l.serializers, void 0 === l._stdErrSerialize || l._stdErrSerialize), l._logEvent.ts = _, l._logEvent.messages = p.filter(function(l) {
                                            return -1 === M.indexOf(l)
                                        }), l._logEvent.level.label = C, l._logEvent.level.value = P, v(C, l._logEvent, T), l._logEvent = createLogEventShape(M)
                                    })(this, {
                                        ts: P,
                                        methodLevel: p,
                                        methodValue: C,
                                        transmitLevel: v,
                                        transmitValue: pino.levels.values[l.transmit.level || c.level],
                                        send: l.transmit.send,
                                        val: c.levelVal
                                    }, T)
                                }
                            })
                        }
                    }(l, c, p)
            }

            function applySerializers(l, c, p, v) {
                for (let _ in l)
                    if (v && l[_] instanceof Error) l[_] = pino.stdSerializers.err(l[_]);
                    else if ("object" == typeof l[_] && !Array.isArray(l[_]))
                    for (let v in l[_]) c && c.indexOf(v) > -1 && v in p && (l[_][v] = p[v](l[_][v]))
            }

            function bind(l, c, p) {
                return function() {
                    let v = Array(1 + arguments.length);
                    v[0] = c;
                    for (var _ = 1; _ < v.length; _++) v[_] = arguments[_ - 1];
                    return l[p].apply(this, v)
                }
            }

            function createLogEventShape(l) {
                return {
                    ts: 0,
                    messages: [],
                    bindings: l || [],
                    level: {
                        label: "",
                        value: 0
                    }
                }
            }

            function mock() {
                return {}
            }

            function passthrough(l) {
                return l
            }

            function noop() {}

            function nullTime() {
                return !1
            }

            function epochTime() {
                return Date.now()
            }
            pino.levels = {
                values: {
                    fatal: 60,
                    error: 50,
                    warn: 40,
                    info: 30,
                    debug: 20,
                    trace: 10
                },
                labels: {
                    10: "trace",
                    20: "debug",
                    30: "info",
                    40: "warn",
                    50: "error",
                    60: "fatal"
                }
            }, pino.stdSerializers = {
                mapHttpRequest: mock,
                mapHttpResponse: mock,
                wrapRequestSerializer: passthrough,
                wrapResponseSerializer: passthrough,
                wrapErrorSerializer: passthrough,
                req: mock,
                res: mock,
                err: function(l) {
                    let c = {
                        type: l.constructor.name,
                        msg: l.message,
                        stack: l.stack
                    };
                    for (let p in l) void 0 === c[p] && (c[p] = l[p]);
                    return c
                }
            }, pino.stdTimeFunctions = Object.assign({}, {
                nullTime,
                epochTime,
                unixTime: function() {
                    return Math.round(Date.now() / 1e3)
                },
                isoTime: function() {
                    return new Date(Date.now()).toISOString()
                }
            })
        },
        8105: function(l, c, p) {
            "use strict";

            function number(l) {
                if (!Number.isSafeInteger(l) || l < 0) throw Error(`Wrong positive integer: ${l}`)
            }

            function bytes(l, ...c) {
                if (!(l instanceof Uint8Array)) throw TypeError("Expected Uint8Array");
                if (c.length > 0 && !c.includes(l.length)) throw TypeError(`Expected Uint8Array of length ${c}, not of length=${l.length}`)
            }
            c.ZP = {
                number,
                bool: function(l) {
                    if ("boolean" != typeof l) throw Error(`Expected boolean, not ${l}`)
                },
                bytes,
                hash: function(l) {
                    if ("function" != typeof l || "function" != typeof l.create) throw Error("Hash should be wrapped by utils.wrapConstructor");
                    number(l.outputLen), number(l.blockLen)
                },
                exists: function(l, c = !0) {
                    if (l.destroyed) throw Error("Hash instance has been destroyed");
                    if (c && l.finished) throw Error("Hash#digest() has already been called")
                },
                output: function(l, c) {
                    bytes(l);
                    let p = c.outputLen;
                    if (l.length < p) throw Error(`digestInto() expects output buffer of length at least ${p}`)
                }
            }
        },
        3913: function(l, c, p) {
            "use strict";
            let v = BigInt(4294967296 - 1),
                _ = BigInt(32);

            function fromBig(l, c = !1) {
                return c ? {
                    h: Number(l & v),
                    l: Number(l >> _ & v)
                } : {
                    h: 0 | Number(l >> _ & v),
                    l: 0 | Number(l & v)
                }
            }
            c.ZP = {
                fromBig,
                split: function(l, c = !1) {
                    let p = new Uint32Array(l.length),
                        v = new Uint32Array(l.length);
                    for (let _ = 0; _ < l.length; _++) {
                        let {
                            h: C,
                            l: P
                        } = fromBig(l[_], c);
                        [p[_], v[_]] = [C, P]
                    }
                    return [p, v]
                },
                toBig: (l, c) => BigInt(l >>> 0) << _ | BigInt(c >>> 0),
                shrSH: (l, c, p) => l >>> p,
                shrSL: (l, c, p) => l << 32 - p | c >>> p,
                rotrSH: (l, c, p) => l >>> p | c << 32 - p,
                rotrSL: (l, c, p) => l << 32 - p | c >>> p,
                rotrBH: (l, c, p) => l << 64 - p | c >>> p - 32,
                rotrBL: (l, c, p) => l >>> p - 32 | c << 64 - p,
                rotr32H: (l, c) => c,
                rotr32L: (l, c) => l,
                rotlSH: (l, c, p) => l << p | c >>> 32 - p,
                rotlSL: (l, c, p) => c << p | l >>> 32 - p,
                rotlBH: (l, c, p) => c << p - 32 | l >>> 64 - p,
                rotlBL: (l, c, p) => l << p - 32 | c >>> 64 - p,
                add: function(l, c, p, v) {
                    let _ = (c >>> 0) + (v >>> 0);
                    return {
                        h: l + p + (_ / 4294967296 | 0) | 0,
                        l: 0 | _
                    }
                },
                add3L: (l, c, p) => (l >>> 0) + (c >>> 0) + (p >>> 0),
                add3H: (l, c, p, v) => c + p + v + (l / 4294967296 | 0) | 0,
                add4L: (l, c, p, v) => (l >>> 0) + (c >>> 0) + (p >>> 0) + (v >>> 0),
                add4H: (l, c, p, v, _) => c + p + v + _ + (l / 4294967296 | 0) | 0,
                add5H: (l, c, p, v, _, C) => c + p + v + _ + C + (l / 4294967296 | 0) | 0,
                add5L: (l, c, p, v, _) => (l >>> 0) + (c >>> 0) + (p >>> 0) + (v >>> 0) + (_ >>> 0)
            }
        },
        6769: function(l, c, p) {
            "use strict";
            p.d(c, {
                kb: function() {
                    return Hash
                },
                GL: function() {
                    return createView
                },
                np: function() {
                    return rotr
                },
                O0: function() {
                    return toBytes
                },
                Jq: function() {
                    return u32
                },
                hE: function() {
                    return wrapConstructor
                },
                K$: function() {
                    return wrapConstructorWithOpts
                }
            }), "object" == typeof self && "crypto" in self && self.crypto;
            let u32 = l => new Uint32Array(l.buffer, l.byteOffset, Math.floor(l.byteLength / 4)),
                createView = l => new DataView(l.buffer, l.byteOffset, l.byteLength),
                rotr = (l, c) => l << 32 - c | l >>> c,
                v = 68 === new Uint8Array(new Uint32Array([287454020]).buffer)[0];
            if (!v) throw Error("Non little-endian hardware is not supported");

            function toBytes(l) {
                if ("string" == typeof l && (l = function(l) {
                        if ("string" != typeof l) throw TypeError(`utf8ToBytes expected string, got ${typeof l}`);
                        return new TextEncoder().encode(l)
                    }(l)), !(l instanceof Uint8Array)) throw TypeError(`Expected input type is Uint8Array (got ${typeof l})`);
                return l
            }
            Array.from({
                length: 256
            }, (l, c) => c.toString(16).padStart(2, "0"));
            let Hash = class Hash {
                clone() {
                    return this._cloneInto()
                }
            };

            function wrapConstructor(l) {
                let hashC = c => l().update(toBytes(c)).digest(),
                    c = l();
                return hashC.outputLen = c.outputLen, hashC.blockLen = c.blockLen, hashC.create = () => l(), hashC
            }

            function wrapConstructorWithOpts(l) {
                let hashC = (c, p) => l(p).update(toBytes(c)).digest(),
                    c = l({});
                return hashC.outputLen = c.outputLen, hashC.blockLen = c.blockLen, hashC.create = c => l(c), hashC
            }
        },
        4072: function(l, c, p) {
            "use strict";
            p.d(c, {
                K: function() {
                    return getAddress
                }
            });
            var v = p(5930),
                _ = p(8582),
                C = p(9644);
            let P = BigInt(0),
                T = BigInt(36);

            function getChecksumAddress(l) {
                l = l.toLowerCase();
                let c = l.substring(2).split(""),
                    p = new Uint8Array(40);
                for (let l = 0; l < 40; l++) p[l] = c[l].charCodeAt(0);
                let C = (0, _.Pw)((0, v.w)(p));
                for (let l = 0; l < 40; l += 2) C[l >> 1] >> 4 >= 8 && (c[l] = c[l].toUpperCase()), (15 & C[l >> 1]) >= 8 && (c[l + 1] = c[l + 1].toUpperCase());
                return "0x" + c.join("")
            }
            let M = {};
            for (let l = 0; l < 10; l++) M[String(l)] = String(l);
            for (let l = 0; l < 26; l++) M[String.fromCharCode(65 + l)] = String(10 + l);
            let z = function() {
                let l = {};
                for (let c = 0; c < 36; c++) {
                    let p = "0123456789abcdefghijklmnopqrstuvwxyz" [c];
                    l[p] = BigInt(c)
                }
                return l
            }();

            function getAddress(l) {
                if ((0, C.en)("string" == typeof l, "invalid address", "address", l), l.match(/^(0x)?[0-9a-fA-F]{40}$/)) {
                    l.startsWith("0x") || (l = "0x" + l);
                    let c = getChecksumAddress(l);
                    return (0, C.en)(!l.match(/([A-F].*[a-f])|([a-f].*[A-F])/) || c === l, "bad address checksum", "address", l), c
                }
                if (l.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {
                    (0, C.en)(l.substring(2, 4) === function(l) {
                        let c = (l = (l = l.toUpperCase()).substring(4) + l.substring(0, 2) + "00").split("").map(l => M[l]).join("");
                        for (; c.length >= 15;) {
                            let l = c.substring(0, 15);
                            c = parseInt(l, 10) % 97 + c.substring(l.length)
                        }
                        let p = String(98 - parseInt(c, 10) % 97);
                        for (; p.length < 2;) p = "0" + p;
                        return p
                    }(l), "bad icap checksum", "address", l);
                    let c = (function(l) {
                        l = l.toLowerCase();
                        let c = P;
                        for (let p = 0; p < l.length; p++) c = c * T + z[l[p]];
                        return c
                    })(l.substring(4)).toString(16);
                    for (; c.length < 40;) c = "0" + c;
                    return getChecksumAddress("0x" + c)
                }(0, C.en)(!1, "invalid address", "address", l)
            }
        },
        5930: function(l, c, p) {
            "use strict";
            p.d(c, {
                w: function() {
                    return keccak256
                }
            });
            var v = p(8105),
                _ = p(3913),
                C = p(6769);
            let [P, T, M] = [
                [],
                [],
                []
            ], z = BigInt(0), J = BigInt(1), Q = BigInt(2), X = BigInt(7), es = BigInt(256), eo = BigInt(113);
            for (let l = 0, c = J, p = 1, v = 0; l < 24; l++) {
                [p, v] = [v, (2 * p + 3 * v) % 5], P.push(2 * (5 * v + p)), T.push((l + 1) * (l + 2) / 2 % 64);
                let _ = z;
                for (let l = 0; l < 7; l++)(c = (c << J ^ (c >> X) * eo) % es) & Q && (_ ^= J << (J << BigInt(l)) - J);
                M.push(_)
            }
            let [el, ec] = _.ZP.split(M, !0), rotlH = (l, c, p) => p > 32 ? _.ZP.rotlBH(l, c, p) : _.ZP.rotlSH(l, c, p), rotlL = (l, c, p) => p > 32 ? _.ZP.rotlBL(l, c, p) : _.ZP.rotlSL(l, c, p);
            let Keccak = class Keccak extends C.kb {
                constructor(l, c, p, _ = !1, P = 24) {
                    if (super(), this.blockLen = l, this.suffix = c, this.outputLen = p, this.enableXOF = _, this.rounds = P, this.pos = 0, this.posOut = 0, this.finished = !1, this.destroyed = !1, v.ZP.number(p), 0 >= this.blockLen || this.blockLen >= 200) throw Error("Sha3 supports only keccak-f1600 function");
                    this.state = new Uint8Array(200), this.state32 = (0, C.Jq)(this.state)
                }
                keccak() {
                    ! function(l, c = 24) {
                        let p = new Uint32Array(10);
                        for (let v = 24 - c; v < 24; v++) {
                            for (let c = 0; c < 10; c++) p[c] = l[c] ^ l[c + 10] ^ l[c + 20] ^ l[c + 30] ^ l[c + 40];
                            for (let c = 0; c < 10; c += 2) {
                                let v = (c + 8) % 10,
                                    _ = (c + 2) % 10,
                                    C = p[_],
                                    P = p[_ + 1],
                                    T = rotlH(C, P, 1) ^ p[v],
                                    M = rotlL(C, P, 1) ^ p[v + 1];
                                for (let p = 0; p < 50; p += 10) l[c + p] ^= T, l[c + p + 1] ^= M
                            }
                            let c = l[2],
                                _ = l[3];
                            for (let p = 0; p < 24; p++) {
                                let v = T[p],
                                    C = rotlH(c, _, v),
                                    M = rotlL(c, _, v),
                                    z = P[p];
                                c = l[z], _ = l[z + 1], l[z] = C, l[z + 1] = M
                            }
                            for (let c = 0; c < 50; c += 10) {
                                for (let v = 0; v < 10; v++) p[v] = l[c + v];
                                for (let v = 0; v < 10; v++) l[c + v] ^= ~p[(v + 2) % 10] & p[(v + 4) % 10]
                            }
                            l[0] ^= el[v], l[1] ^= ec[v]
                        }
                        p.fill(0)
                    }(this.state32, this.rounds), this.posOut = 0, this.pos = 0
                }
                update(l) {
                    v.ZP.exists(this);
                    let {
                        blockLen: c,
                        state: p
                    } = this;
                    l = (0, C.O0)(l);
                    let _ = l.length;
                    for (let v = 0; v < _;) {
                        let C = Math.min(c - this.pos, _ - v);
                        for (let c = 0; c < C; c++) p[this.pos++] ^= l[v++];
                        this.pos === c && this.keccak()
                    }
                    return this
                }
                finish() {
                    if (this.finished) return;
                    this.finished = !0;
                    let {
                        state: l,
                        suffix: c,
                        pos: p,
                        blockLen: v
                    } = this;
                    l[p] ^= c, (128 & c) != 0 && p === v - 1 && this.keccak(), l[v - 1] ^= 128, this.keccak()
                }
                writeInto(l) {
                    v.ZP.exists(this, !1), v.ZP.bytes(l), this.finish();
                    let c = this.state,
                        {
                            blockLen: p
                        } = this;
                    for (let v = 0, _ = l.length; v < _;) {
                        this.posOut >= p && this.keccak();
                        let C = Math.min(p - this.posOut, _ - v);
                        l.set(c.subarray(this.posOut, this.posOut + C), v), this.posOut += C, v += C
                    }
                    return l
                }
                xofInto(l) {
                    if (!this.enableXOF) throw Error("XOF is not possible for this instance");
                    return this.writeInto(l)
                }
                xof(l) {
                    return v.ZP.number(l), this.xofInto(new Uint8Array(l))
                }
                digestInto(l) {
                    if (v.ZP.output(l, this), this.finished) throw Error("digest() was already called");
                    return this.writeInto(l), this.destroy(), l
                }
                digest() {
                    return this.digestInto(new Uint8Array(this.outputLen))
                }
                destroy() {
                    this.destroyed = !0, this.state.fill(0)
                }
                _cloneInto(l) {
                    let {
                        blockLen: c,
                        suffix: p,
                        outputLen: v,
                        rounds: _,
                        enableXOF: C
                    } = this;
                    return l || (l = new Keccak(c, p, v, C, _)), l.state32.set(this.state32), l.pos = this.pos, l.posOut = this.posOut, l.finished = this.finished, l.rounds = _, l.suffix = p, l.outputLen = v, l.enableXOF = C, l.destroyed = this.destroyed, l
                }
            };
            let gen = (l, c, p) => (0, C.hE)(() => new Keccak(c, l, p));
            gen(6, 144, 28), gen(6, 136, 32), gen(6, 104, 48), gen(6, 72, 64), gen(1, 144, 28);
            let eh = gen(1, 136, 32);
            gen(1, 104, 48), gen(1, 72, 64);
            let genShake = (l, c, p) => (0, C.K$)((v = {}) => new Keccak(c, l, void 0 === v.dkLen ? p : v.dkLen, !0));
            genShake(31, 168, 16), genShake(31, 136, 32);
            var ed = p(8582);
            let ef = !1,
                _keccak256 = function(l) {
                    return eh(l)
                },
                ep = _keccak256;

            function keccak256(l) {
                let c = (0, ed.Pw)(l, "data");
                return (0, ed.Dv)(ep(c))
            }
            keccak256._ = _keccak256, keccak256.lock = function() {
                ef = !0
            }, keccak256.register = function(l) {
                if (ef) throw TypeError("keccak256 is locked");
                ep = l
            }, Object.freeze(keccak256)
        },
        3515: function(l, c, p) {
            "use strict";
            p.d(c, {
                Kn: function() {
                    return dnsEncode
                },
                w3: function() {
                    return ensNormalize
                },
                VM: function() {
                    return namehash
                }
            });
            var v = p(5930),
                _ = p(9644),
                C = p(3100),
                P = p(8582);

            function read_compressed_payload(l) {
                var c;
                let p;
                return c = function(l) {
                    let c = 0;

                    function u16() {
                        return l[c++] << 8 | l[c++]
                    }
                    let p = u16(),
                        v = 1,
                        _ = [0, 1];
                    for (let l = 1; l < p; l++) _.push(v += u16());
                    let C = u16(),
                        P = c;
                    c += C;
                    let T = 0,
                        M = 0;

                    function read_bit() {
                        return 0 == T && (M = M << 8 | l[c++], T = 8), M >> --T & 1
                    }
                    let z = 2147483648 - 1,
                        J = 0;
                    for (let l = 0; l < 31; l++) J = J << 1 | read_bit();
                    let Q = [],
                        X = 0,
                        es = 2147483648;
                    for (;;) {
                        let l = Math.floor(((J - X + 1) * v - 1) / es),
                            c = 0,
                            C = p;
                        for (; C - c > 1;) {
                            let p = c + C >>> 1;
                            l < _[p] ? C = p : c = p
                        }
                        if (0 == c) break;
                        Q.push(c);
                        let P = X + Math.floor(es * _[c] / v),
                            T = X + Math.floor(es * _[c + 1] / v) - 1;
                        for (;
                            ((P ^ T) & 1073741824) == 0;) J = J << 1 & z | read_bit(), P = P << 1 & z, T = T << 1 & z | 1;
                        for (; P & ~T & 536870912;) J = 1073741824 & J | J << 1 & z >>> 1 | read_bit(), P = P << 1 ^ 1073741824, T = (1073741824 ^ T) << 1 | 1073741825;
                        X = P, es = 1 + T - P
                    }
                    let eo = p - 4;
                    return Q.map(c => {
                        switch (c - eo) {
                            case 3:
                                return eo + 65792 + (l[P++] << 16 | l[P++] << 8 | l[P++]);
                            case 2:
                                return eo + 256 + (l[P++] << 8 | l[P++]);
                            case 1:
                                return eo + l[P++];
                            default:
                                return c - 1
                        }
                    })
                }(function(l) {
                    let c = [];
                    [..."ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"].forEach((l, p) => c[l.charCodeAt(0)] = p);
                    let p = l.length,
                        v = new Uint8Array(6 * p >> 3);
                    for (let _ = 0, C = 0, P = 0, T = 0; _ < p; _++) T = T << 6 | c[l.charCodeAt(_)], (P += 6) >= 8 && (v[C++] = T >> (P -= 8));
                    return v
                }(l)), p = 0, () => c[p++]
            }

            function read_sorted(l, c = 0) {
                let p = [];
                for (;;) {
                    let v = l(),
                        _ = l();
                    if (!_) break;
                    c += v;
                    for (let l = 0; l < _; l++) p.push(c + l);
                    c += _ + 1
                }
                return p
            }

            function read_sorted_arrays(l) {
                return read_array_while(() => {
                    let c = read_sorted(l);
                    if (c.length) return c
                })
            }

            function read_mapped(l) {
                let c = [];
                for (;;) {
                    let p = l();
                    if (0 == p) break;
                    c.push(function(l, c) {
                        let p = 1 + c(),
                            v = c(),
                            _ = read_array_while(c);
                        return read_transposed(_.length, 1 + l, c).flatMap((l, c) => {
                            let [C, ...P] = l;
                            return Array(_[c]).fill().map((l, c) => {
                                let _ = c * v;
                                return [C + c * p, P.map(l => l + _)]
                            })
                        })
                    }(p, l))
                }
                for (;;) {
                    let p = l() - 1;
                    if (p < 0) break;
                    c.push(read_transposed(1 + l(), 1 + p, l).map(l => [l[0], l.slice(1)]))
                }
                return c.flat()
            }

            function read_array_while(l) {
                let c = [];
                for (;;) {
                    let p = l(c.length);
                    if (!p) break;
                    c.push(p)
                }
                return c
            }

            function read_transposed(l, c, p) {
                let v = Array(l).fill().map(() => []);
                for (let _ = 0; _ < c; _++)(function(l, c) {
                    let p = Array(l);
                    for (let _ = 0, C = 0; _ < l; _++) {
                        var v;
                        p[_] = C += 1 & (v = c()) ? ~v >> 1 : v >> 1
                    }
                    return p
                })(l, p).forEach((l, c) => v[c].push(l));
                return v
            }
            var T = read_compressed_payload("AEgSbwjEDVYByQKaAQsBOQDpATQAngDUAHsAoABoANQAagCNAEQAhABMAHIAOwA9ACsANgAmAGIAHgAvACgAJwAXAC0AGgAjAB8ALwAUACkAEgAeAAkAGwARABkAFgA5ACgALQArADcAFQApABAAHgAiABAAGAAeABMAFwAXAA0ADgAWAA8AFAAVBFsF1QEXE0o3xAXUALIArkABaACmAgPGAK6AMDAwMAE/qAYK7P4HQAblMgVYBVkAPSw5Afa3EgfJwgAPA8meNALGCjACjqIChtk/j2+KAsXMAoPzASDgCgDyrgFCAi6OCkCQAOQA4woWABjVuskNDD6eBBx4AP4COhi+D+wKBirqBgSCaA0cBy4ArABqku+mnIAAXAaUJAbqABwAPAyUFvyp/Mo8INAIvCoDshQ8APcubKQAon4ZABgEJtgXAR4AuhnOBPsKIE04CZgJiR8cVlpM5INDABQADQAWAA9sVQAiAA8ASO8W2T30OVnKluYvChEeX05ZPe0AFAANABYAD2wgXUCYAMPsABwAOgzGFryp/AHauQVcBeMC0KACxLEKTR2kZhR0Gm5M9gC8DmgC4gAMLjSKF8qSAoF8ARMcAL4OaALiAAwuAUlQJpJMCwMt/AUpCthqGK4B2EQAciwSeAIyFiIDKCi6OGwAOuIB9iYAyA7MtgEcZIIAsgYABgCK1EoFHNZsGACoKNIBogAAAAAAKy4DnABoAQoaPu43dQQZGACrAcgCIgDgLBJ0OvRQsTOiKDVJBfsoBVoFWbC5BWo7XkITO1hCmHuUZmCh+QwUA8YIJvJ4JASkTAJUVAJ2HKwoAZCkpjZcA0YYBIRiCgDSBqxAMCQHKgI6XgBsAWIgcgCEHhoAlgFKuAAoahgBsMYDOC4iRFQBcFoGZgJmAPJKGAMqAgYASkIArABeAHQALLYGCPTwGo6AAAAKIgAqALQcSAHSAdwIDDKXeYHpAAsAEgA1AD4AOTR3etTBEGAQXQJNCkxtOxUMAq0PpwvmERYM0irM09kANKoH7ANUB+wDVANUB+wH7ANUB+wDVANUA1QDVBwL8BvUwRBgD0kEbgWPBYwE1wiEJkoRggcpCNNUDnQfHEgDRgD9IyZJHTuUMwwlQ0wNTQQH/TZDbKh9OQNIMaxU9pCjA8wyUDltAh5yEqEAKw90HTW2Tn96SHGhCkxPr7WASWNOaAK/Oqk/+QoiCZRvvHdPBj4QGCeiEPQMMAGyATgN6kvVBO4GOATGH3oZFg/KlZkIoi3aDOom4C6egFcj8iqABepL8TzaC0pRZQ9WC2IJ4DpggUsDHgEKIogK2g02CGoQ8ArGaA3iEUIHNgPSSZcAogb+Cw4dMhWyJg1iqQsGOXQG+BrzC4wmrBMmevkF0BoeBkoBJhr8AMwu5IWtWi5cGU9cBgALIiPEFKVQHQ0iQLR4RRoYBxIlpgKOQ21KhFEzHpAh8zw6DWMuEFF5B/I8AhlMC348m0aoRQsRzz6KPUUiRkwpBDJ8LCwniAnMD4IMtnxvAVYJHgmuDG4TLhEUN8IINgcWKpchJxIIHkaSYJcE9JwD8BPOAwgFPAk+BxADshwqEysVJgUKgSHUAvA20i6wAoxWfQEUBcgPIh/cEE1H3Q7mCJgCYgOAJegAKhUeABQimAhAYABcj9VTAi7ICMRqaSNxA2QU5F4RcAeODlQHpBwwFbwc3nDFXgiGBSigrAlYAXIJlgFcBOAIBjVYjJ0gPmdQi1UYmCBeQTxd+QIuDGIVnES6h3UCiA9oEhgBMgFwBzYM/gJ0EeoRaBCSCOiGATWyM/U6IgRMIYAgDgokA0xsywskJvYM9WYBoBJfAwk0OnfrZ6hgsyEX+gcWMsJBXSHuC49PygyZGr4YP1QrGeEHvAPwGvAn50FUBfwDoAAQOkoz6wS6C2YIiAk8AEYOoBQH1BhnCm6MzQEuiAG0lgNUjoACbIwGNAcIAGQIhAV24gAaAqQIoAACAMwDVAA2AqoHmgAWAII+AToDJCwBHuICjAOQCC7IAZIsAfAmBBjADBIA9DRuRwLDrgKAZ2afBdpVAosCRjIBSiIEAktETgOsbt4A2ABIBhDcRAESqEfIF+BAAdxsKADEAPgAAjIHAj4BygHwagC0AVwLLgmfsLIBSuYmAIAAEmgB1AKGANoAMgB87gFQAEoFVvYF0AJMRgEOLhUoVF4BuAMcATABCgB2BsiKosYEHARqB9ACEBgV3gLvKweyAyLcE8pCwgK921IAMhMKNQqkCqNgWF0wAy5vPU0ACx+lPsQ/SwVOO1A7VTtQO1U7UDtVO1A7VTtQO1UDlLzfvN8KaV9CYegMow3RRMU6RhPYYE5gLxPFLbQUvhXLJVMZOhq5JwIl4VUGDwEt0GYtCCk0che5ADwpZYM+Y4MeLQpIHORTjlT1LRgArkufM6wNqRsSRD0FRHXqYicWCwofAmR+AmI/WEqsWDcdAqH0AmiVAmYGAp+BOBgIAmY4AmYjBGsEfAN/EAN+jzkDOXQUOX86ICACbBoCMjM4BwJtxAJtq+yHMGRCKAFkANsA3gBHAgeVDIoA+wi/AAqyAncsAnafPAJ5SEACeLcaWdhFq0bwAnw8AnrFAn0GAnztR/1IemAhACgSSVVKWBIUSskC0P4C0MlLJAOITAOH40TCkS8C8p5dAAMDq0vLTCoiAMxNSU2sAos8AorVvhgEGkBkArQCjjQCjlk9lH4CjtYCjll1UbFTMgdS0VSCApP4ApMJAOYAGVUbVaxVzQMsGCmSgzLeeGNFODYCl5wC769YHqUAViIClowClnmZAKZZqVoGfkoAOAKWsgKWS1xBXM4CmcgCmWFcx10EFgKcmDm/OpoCnBMCn5gCnrWHABoMLicMAp3uAp6PALI6YTFh7AKe0AKgawGmAp6cHAKeS6JjxWQkIigCJ6wCJnsCoPgCoEnUAqYsAqXLAqf8AHoCp+9oeWiuAABGahlqzgKs4AKsqwKtZAKs/wJXGgJV2QKx3tQDH0tslAKyugoCsuUUbN1tYG1FXAMlygK2WTg8bo0DKUICuFsCuUQSArkndHAzcN4CvRYDLa8DMg4CvoVx/wMzbgK+F3Mfc0wCw8gCwwFzf3RIMkJ03QM8pAM8lwM9vALFeQLGRALGDYYCyGZOAshBAslMAskrAmSaAt3PeHZeeKt5IkvNAxigZv8CYfEZ8JUhewhej164DgLPaALPaSxIUM/wEJwAw6oCz3ABJucDTg9+SAIC3CQC24cC0kwDUlkDU1wA/gNViYCGPMgT6l1CcoLLg4oC2sQC2duEDYRGpzkDhqIALANkC4ZuVvYAUgLfYgLetXB0AuIs7REB8y0kAfSYAfLPhALr8ALpbXYC6vYC6uEA9kQBtgLuhgLrmZanlwAC7jwDhd2YdnDdcZ4C8wAAZgOOE5mQAvcQA5FrA5KEAveVAvnWAvhjmhmaqLg0mxsDnYAC/vcBGAA2nxmfsAMFigOmZwOm1gDOwgMGZ6GFogIGAwxGAQwBHAdqBl62ZAIAuARovA6IHrAKABRyNgAgAzASSgOGfAFgJB4AjOwAHgDmoAScjgi0BhygwgCoBRK86h4+PxZ5BWk4P0EsQiJCtV9yEl+9AJbGBTMAkE0am7o7J2AzErrQDjAYxxiKyfcFWAVZBVgFWQVkBVkFWAVZBVgFWQVYBVkFWAVZRxYI2IZoAwMDCmVe6iwEygOyBjC8vAC8BKi8AOhBKhazBUc+aj5xQkBCt192OF/pAFgSM6wAjP/MbMv9puhGez4nJAUsFyg3Nn5u32vB8hnDLGoBbNdvMRgFYAVrycLJuQjQSlwBAQEKfV5+jL8AND+CAAQW0gbmriQGAIzEDAMCDgDlZh4+JSBLQrJCvUI5JF8oYDcoOSQJwj4KRT9EPnk+gj5xPnICikK9SkM8X8xPUGtOCy1sVTBrDG8gX+E0OxwJaJwKYyQsPR4nQqxCvSzMAsv9X8oPIC8KCQoAACN+nt9rOy5LGMmsya0JZsLMzQphQWAP5hCkEgCTjh5GQiYbqm06zjkKND9EPnFCQBwICx5NSG1cLS5a4rwTCn7uHixCQBxeCUsKDzRVREM4BTtEnC0KghwuQkAb9glUIyQZMTIBBo9i8F8KcmTKYAxgLiRvAERgGjoDHB9gtAcDbBFmT2BOEgIAZOhgFmCWYH5gtGBMYJJpFhgGtg/cVqq8WwtDF6wBvCzOwgMgFgEdBB8BegJtMDGWU4EBiwq5SBsA5SR0jwvLDqdN6wGcAoidUAVBYAD4AD4LATUXWHsMpg0lILuwSABQDTUAFhO4NVUC0wxLZhEcANlPBnYECx9bADIAtwKbKAsWcKwzOaAaAVwBhwn9A9ruEAarBksGugAey1aqWwq7YhOKCy1ADrwBvAEjA0hbKSkpIR8gIi0TJwciDY4AVQJvWJFKlgJvIA9ySAHUdRDPUiEaqrFN6wcSBU1gAPgAPgsBewAHJW0LiAymOTEuyLBXDgwAYL0MAGRKaFAiIhzAADIAtwKbKC08D88CkRh8ULxYyXRzjtilnA72mhU+G+0S2hIHDxwByAk7EJQGESwNNwwAPAC0zwEDAKUA4gCbizAAFQBcG8cvbXcrDsIRAzwlRNTiHR8MG34CfATCC6vxbQA4Oi4Opzkuz6IdB7wKABA7Ls8SGgB9rNsdD7wbSBzOoncfAT4qYB0C7KAJBE3z5R9mDL0M+wg9Cj8ABcELPgJMDbwIvQ09CT0KvS7PoisOvAaYAhwPjBriBBwLvBY8AKELPBC8BRihe90AO2wMPQACpwm9BRzR9QYFB2/LBnwAB7wSXBISvQECAOsCAAB1FVwHFswV/HAXvBg8AC68AuyovAAevAJWISuAAAG8AALkFT0VvCvso7zJqDwEAp8nTAACXADn3hm8CaVcD7/FAPUafAiiBQv/cQDfvKe8GNwavKOMeXMG/KmchAASvAcbDAADlABtvAcAC7ynPAIaPLsIopzLDvwHwak8AOF8L7dtvwNJAAPsABW8AAb8AAm8AGmMABq8AA68Axi8jmoV/AABXAAObAAuTB8ABrwAF7wIIgANSwC6vCcAA7wADpwq7ACyWwAcHAAbvAAB7AqiAAXHCxYV3AAHnABCvAEDAGm8AAt8AB28AAi8CaIABcsAbqAZ1gCSCCIABcsAATwAB9wAHZwIIgAGmwAJfAAbLABtHADmvIEACFwACDwAFLwAaPwJIgAGywDjjAAJPAuiDsX7YAAHPABunUBJAEgACrwFAAM8AAmuAzgABxwAGXwAAgym/AAKHAAKPAAJ/KfsBrwACRwAAwwAEDwBABQ8ABFsAA+MAA3sAA28ABkMBxYcABU8AG6cFrQBvAC7ABM8BABpLAsA4UwAAjwABFMAF3wFHAAG0QAYvB8BfClTADpGALAJBw4McwApK3EBpQYIXwJtJA0ACghwTG1gK4oggRVjLjcDogq1AALZABcC/ARvAXdzSFMVIgNQAhY/AS0GBHRHvnxTe0EAKgAyAvwAVAvcAHyRLQEsAHfmDhIzRwJLAFgGAAJRAQiLzQB5PAQhpgBbANcWAJZpOCCMAM5ssgDQ1RcJw3Z0HBlXHgrSAYmRrCNUVE5JEz3DivoAgB04QSos4RKYUABzASosMSlDGhADMVYE+MbvAExm3QBrAnICQBF7Osh4LzXWBhETIAUVCK6v/xPNACYAAQIbAIYAiQCONgDjALQA1QCdPQC7AKsApgChAOcAnwDTAJwA4AEBAPwAwAB6AFsAywDNAPwA1wDrAIkAogEqAOMA2ADVBAIIKzTT09PTtb/bzM/NQjEWAUsBVS5GAVMBYgFhAVQBRUpCRGcMAUwUBgkEMzcMBwAgDSQmKCs3OTk8PDw9Pg0/HVBQUFBSUlFSKFNUVlVVHFxgYF9hYCNlZ29ucXFxcXFxc3Nzc3Nzc3Nzc3N1dXZ1dFsAPesAQgCTAHEAKwBf8QCHAFAAUAAwAm/oAIT+8fEAXQCM6wCYAEgAWwBd+PipAH4AfgBiAE8AqgAdAK8AfAI5AjwA9QDgAPcA9wDhAPgA4gDiAOEA3wAoAnQBSgE5ATcBTQE3ATcBNwEyATEBMQExARUBURAAKgkBAEwYCxcEFhcPAIcAjwCfAEoAYxkCKgBvAGgAkAMOAyArAxpCP0gqAIoCSADAAlACnQC5Ao8CjwKPAo8CjwKPAoQCjwKPAo8CjwKPAo8CjgKOApECmQKQAo8CjwKNAo0CjQKNAosCjgJuAc0CkAKYAo8CjwKOF3oMAPcGA5gCWgIzGAFNETYC2xILLBQBRzgUTpIBdKU9AWJaAP4DOkgA/wCSKh4ZkGsAKmEAagAvAIoDlcyM8K+FWwa7LA/DEgKe1nUrCwQkWwGzAN5/gYB/gX+Cg4N/hIeFf4aJh4GIg4mDin+Lf4x/jYuOf49/kIORf5J/k3+Uf5WElomXg5h/AIMloQCEBDwEOQQ7BD4EPARCBD8EOgRABEIEQQQ9BD8EQgCkA4gAylIA0AINAPdbAPcBGgD3APUA9QD2APXVhSRmvwD3APUA9QD2APUdAIpbAPcAigEaAPcAigLtAPcAitWFJGa/HQD4WwEaAPcA9wD1APUA9gD1APgA9QD1APYA9dWFJGa/HQCKWwEaAPcAigD3AIoC7QD3AIrVhSRmvx0CRAE3AksBOgJMwgOfAu0Dn9WFJGa/HQCKWwEaA58AigOfAIoC7QOfAIrVhSRmvx0EMQCKBDIAigeOMm4hLQCKAT9vBCQA/gDHWwMAVVv/FDMDAIoDPtkASgMAigMAl2dBtv/TrfLzakaPh3aztmIuZQrR3ER2n5Yo+qNR2jK/aP/V04UK1njIJXLgkab9PjOxyJDVbIN3R/FZLoZVl2kYFQIZ7V6LpRqGDt9OdDohnJKp5yX/HLj0voPpLrneDaN11t5W3sSM4ALscgSw8fyWLVkKa/cNcQmjYOgTLZUgOLi2F05g4TR0RfgZ4PBdntxdV3qvdxQt8DeaMMgjJMgwUxYN3tUNpUNx21AvwADDAIa0+raTWaoBXmShAl5AThpMi282o+WzOKMlxjHj7a+DI6AM6VI9w+xyh3Eyg/1XvPmbqjeg2MGXugHt8wW03DQMRTd5iqqOhjLvyOCcKtViGwAHVLyl86KqvxVX7MxSW8HLq6KCrLpB8SspAOHO9IuOwCh9poLoMEha9CHCxlRAXJNDobducWjqhFHqCkzjTM2V9CHslwq4iU19IxqhIFZMve15lDTiMVZIPdADXGxTqzSTv0dDWyk1ht430yvaYCy9qY0MQ3cC5c1uw4mHcTGkMHTAGC99TkNXFAiLQgw9ZWhwKJjGCe+J5FIaMpYhhyUnEgfrF3zEtzn40DdgCIJUJfZ0mo3eXsDwneJ8AYCr7Vx2eHFnt2H6ZEyAHs9JoQ4Lzh5zBoGOGwAz37NOPuqSNmZf51hBEovtpm2T1wI79OBWDyvCFYkONqAKGVYgIL0F+uxTcMLSPtFbiNDbBPFgip8MGDmLLHbSyGXdCMO6f7teiW9EEmorZ+75KzanZwvUySgjoUQBTfHlOIerJs6Y9wLlgDw18AB1ne0tZRNgGjcrqHbtubSUooEpy4hWpDzTSrmvqw0H9AoXQLolMt9eOM+l9RitBB1OBnrdC1XL4yLFyXqZSgZhv7FnnDEXLUeffb4nVDqYTLY6X7gHVaK4ZZlepja2Oe6OhLDI/Ve5SQTCmJdH3HJeb14cw99XsBQAlDy5s5kil2sGezZA3tFok2IsNja7QuFgM30Hff3NGSsSVFYZLOcTBOvlPx8vLhjJrSI7xrNMA/BOzpBIJrdR1+v+zw4RZ7ry6aq4/tFfvPQxQCPDsXlcRvIZYl+E5g3kJ+zLMZon0yElBvEOQTh6SaAdIO6BwdqJqfvgU+e8Y65FQhdiHkZMVt9/39N2jGd26J6cNjq8cQIyp6RonRPgVn2fl89uRDcQ27GacaN0MPrcNyRlbUWelKfDfyrNVVGBG5sjd3jXzTx06ywyzuWn5jbvEfPPCTbpClkgEu9oPLKICxU5HuDe3jA1XnvU85IYYhaEtOU1YVWYhEFsa4/TQj3rHdsU2da2eVbF8YjSI0m619/8bLMZu3xildwqM7zf1cjn4Whx0PSYXcY5bR7wEQfGC7CTOXwZdmsdTO8q3uGm7Rh/RfCWwpzBHCAaVfjxgibL5vUeL0pH6bzDmI9yCXKC/okkmbc28OJvI87L/bjFzpq0DHepw4kT1Od+fL7cyuFaRgfaUWB2++TCFvz11J0leEtrGkpccfX9z2LY39sph4PBHCjNOOkd0ybUm+ZzS8GkFbqMpq8uiX2yHpa0jllTLfGTDBMYR6FT5FWLLDPMkYxt1Q0eyMvxJWztDjy0m6VvZPvamrFXjHmPpU6WxrZqH6WW//I37RwvqPQhPz8I3RPuXAk1C94ZprQWm9iGM/KgiGDO6SV9sjp+Jmk4TBajMNJ5zzWZ1k1jrteQQBp9C2dOvmbIeeEME8y573Q8TgGe+ZCzutM45gYLBzYm2LNvgq2kebAbMpHRDSyh6dQ27GbsAAdCqQVVXWC1C+zpwBM2Lr4eqtobmmu1vJEDlIQR1iN8CUWpztq50z7FFQBn3SKViX6wSqzVQCoYvAjByjeSa+h1PRnYWvBinTDB9cHt4eqDsPS4jcD3FwXJKT0RQsl8EvslI2SFaz2OtmYLFV8FwgvWroZ3fKmh7btewX9tfL2upXsrsqpLJzpzNGyNlnuZyetg7DIOxQTMBR7dqlrTlZ6FWi1g4j1NSjA2j1Yd7fzTH6k9LxCyUCneAKYCU581bnvKih6KJTeTeCX4Zhme/QIz7w2o+AdSgtLAkdrLS9nfweYEqrMLsrGGSWXtgWamAWp6+x6GM/Z8jNw3BqPNQ39hrzYLECn3tPvh/LqKbRSCiDGauDKBBj/kGbpnM1Bb/my8hv4NWStclkwjfl57y4oNDgw1JAG9VOti3QVVoSziMEsSdfEjaCPIDb7SgpLXykQsM+nbqbt97I0mIlzWv0uqFobLMAq8Rd9pszUBKxFhBPwOjf//gVOz2r7URJ2OnpviCXv9iz3a4X/YLBYbXoYwxBv/Kq0a5s4utQHzoTerJ7PmFW/no/ZAsid/hRIV82tD+Qabh5F1ssIM8Ri3chu0PuPD3sSJRMjDoxLAbwUbroiPAz/V52e8s3DIixxlO7OrvhMj3qfzA0kKxzwicr5wJmZwJxTXgrwYsqhRvpgC2Nfdyd+TYYxJSZgk+gk2g9KyHSlwQVAyPtWWgvVGyVBqsU2LpDlLNosSAtolC1uBKt5pQZLhAxTjeGCWIC/HVpagc5rRwkgpCHKEsjA8d+scp8aiMewwQBhp5dYTV5t/Nvl+HbDMu8F3S0psPyZb1bSnqlHPFUnMQeQqSqwDBT23fJO9gO3aVaa1icrXU0PKwlMM5K+iL3ATcVq2fFWKk0irCTF4LDVDG4gUpkyplq6efcZS+WDR1woApjD18x+2JQR9oOXzuA7uy4b+/91WsJd/tSd1QcAH8PVPXApieA37B7YXPhDPH1azP3PKR+HfHmOoDYLeuKsIi/ssSsdYs62qJo14Hw1P2N/6zpr8F3FTWmJ4ysAVcl84Iv/tl///Z8FaAWbBQbyMNDZjrZ2JwdRjtd1jOeNumSodFtr4/Zf45iRJf/8HSW+KIB/+GlKu8Rv1BPLr/4duoL+kFPRqrstEr41gfJupoJRf4hcYDWX93FOcfEBiIivxtjtV8g7mvOReiamYWKE7vfPbv3v2L9Kwq3cIDFGLyhyfOGuf/9vA5muH6Pjg7B4SUj2ydDXra9fSBI+DrsNHA6l51wfHssJb+11TfNk7B8OleUe3Y+ZmHboMFHdv7FFP2cfISFyeAQR0sk/Xv62HBTdW4HmnGSLFk/cqyWVVFJkdIIa+4hos3JRHcqLoRKM5h2Qtk1RZtzISMtlXTfTqIc77YsCCgQD0r61jtxskCctwJOtjE/pL8wC4LBD4AZFjh2wzzFCrT/PNqW0/DeBbkfMfzVm9yy06WiF+1mTdNNEAytVtohBKg3brWd2VQa+aF+cQ0mW5CvbwOlWCT07liX226PjiVLwFCRs/Ax2/u+ZNPjrNFIWIPf5GjHyUKp60OeXe9F01f7IaPf/SDTvyDAf7LSWWejtiZcsqtWZjrdn6A2MqBwnSeKhrZOlUMmgMionmiCIvXqKZfmhGZ1MwD3uMF4n9KJcfWLA3cL5pq48tm5NDYNh3SS/TKUtmFSlQR89MR4+kxcqJgpGbhm9gXneDELkyqAN5nitmIzTscKeJRXqd64RiaOALR2d295NWwbjHRNG2AU5oR9OS2oJg/5CY6BFPc1JvD2Mxdhp2/MZdI8dLePxiP4KRIp8VXmqfg+jqd/RNG7GNuq1U2SiI4735Bdc0MVFx6mH5UOWEa5HuhYykd6t4M1gYLVS8m1B+9bUqi5DziQq7qT8d94cxB6AB4WqMCOF/zPPtRSZUUaMSsvHOWxGASufywTX8ogy6HgUf9p+Z30wUEosl8qgmwm6o2AV6nO9HKQjRHpN6SUegI5pvR61RLnUJ1lqCtmfcsRQutEizVpAaPXN7xMp5UQ5OSZK6tniCK9CpyMd7LjR6+MxfoMEDPpWdf2p2m5N3KO4QMxf+V7vGdYjemQczQ+m2MGIkFNYDMf0Yop2eSx81sP36WHUczqEhKysp2iJSYAvfgJjinKwToPvRKb+HBi+7cJ96S5ngfLOXaHAFRLkulo4TnXTFO51gX0TCCo4ZUHdbpdgkMEwUZAPjh6M+hA8DzycbtxAgH3uD6i0nN1aTiIuQ4BYCE9dEHHwAmINU+4YEWx4EC3OZwFGfYZMPLScVlb+BAAJeARUh+gdWA3/gRqCrf1jecgqeFf1MdzrrP4SVlGm5mMihSP+zYYksAB7O+SBPwNQqSNMiLnkviY/klwgcRmvqtCqeWeA0gjuir4CMZqmw/ntP6M+l0pdN8/P9xI53aP7x/zavJbbKOz8VzO/nXxIr1tjparMnqd6iWdByHKw4lF4p/u57Yv07WeZPDnRl7wgmDVZZ44fQsjdYO/gmXQ+940PRGst8UMQApFC4OOV22e4N+lVOPyFLAOj4t8R3PFw/FjbSWy0ELuAFReNkee8ORcBOT2NPDcs7OfpUmzvn/F9Czk9o9naMyVYy/j8I5qVFmQDFcptBp65J/+sJA3w/j6y/eqUkKxTsf0CZjtNdRSBEmJ2tmfgmJbqpcsSagk+Ul9qdyV+NnqFBIJZFCB1XwPvWGDBOjVUmpWGHsWA5uDuMgLUNKZ4vlq5qfzY1LnRhCc/mh5/EX+hzuGdDy5aYYx4BAdwTTeZHcZpl3X0YyuxZFWNE6wFNppYs3LcFJePOyfKZ8KYb7dmRyvDOcORLPH0sytC6mH1US3JVj6paYM1GEr+CUmyHRnabHPqLlh6Kl0/BWd3ebziDfvpRQpPoR7N+LkUeYWtQ6Rn5v5+NtNeBPs2+DKDlzEVR5aYbTVPrZekJsZ9UC9qtVcP99thVIt1GREnN8zXP8mBfzS+wKYym8fcW6KqrE702Zco+hFQAEIR7qimo7dd7wO8B7R+QZPTuCWm1UAwblDTyURSbd85P4Pz+wBpQyGPeEpsEvxxIZkKsyfSOUcfE3UqzMFwZKYijb7sOkzpou+tC4bPXey5GI1GUAg9c3vLwIwAhcdPHRsYvpAfzkZHWY20vWxxJO0lvKfj6sG2g/pJ1vd/X2EBZkyEjLN4nUZOpOO7MewyHCrxQK8d5aF7rCeQlFX+XksK6l6z971BPuJqwdjj68ULOj9ZTDdOLopMdOLL0PFSS792SXE/EC9EDnIXZGYhr52aQb+9b2zEdBSnpkxAdBUkwJDqGCpZk/HkRidjdp0zKv/Cm52EenmfeKX6HkLUJgMbTTxxIZkIeL/6xuAaAAHbA7mONVduTHNX/UJj1nJEaI7f3HlUyiqKn7VfBE+bdb4HWln1HPJx001Ulq1tOxFf8WZEARvq5Da1+pE7fPVxLntGACz3nkoLsKcPdUqdCwwiyWkmXTd5+bv3j7HaReRt3ESn783Ew3SWsvkEjKtbocNksbrLmV+GVZn1+Uneo35MT1/4r8fngQX5/ptORfgmWfF6KSB/ssJmUSijXxQqUpzkANEkSkYgYj560OOjJr6uqckFuO15TRNgABEwNDjus1V3q2huLPYERMCLXUNmJJpbMrUQsSO7Qnxta55TvPWL6gWmMOvFknqETzqzFVO8SVkovEdYatypLGmDy9VWfgAc0KyIChiOhbd7UlbAeVLPZyEDp4POXKBwN/KP5pT6Cyqs6yaI00vXMn1ubk9OWT9Q/O2t/C25qlnO/zO0xcBzpMBCAB8vsdsh3U8fnPX1XlPEWfaYJxKVaTUgfCESWl4CCkIyjE6iQ5JFcwU6S4/IH0/Agacp8d5Gzq2+GzPnJ7+sqk40mfFQpKrDbAKwLlr3ONEati2k/ycLMSUu7V/7BBkDlNyXoN9tvqXCbbMc4SSQXgC/DBUY9QjtrCtQ+susEomCq8xcNJNNMWCH31GtlTw2BdCXkJBjT+/QNWlBWwQ5SWCh1LdQ99QVii/DyTxjSR6rmdap3l3L3aiplQpPYlrzNm9er88fXd2+ao+YdUNjtqmxiVxmyYPzJxl67OokDcTezEGqldkGgPbRdXA+fGcuZVkembZByo7J1dMnkGNjwwCny+FNcVcWvWYL9mg8oF7jACVWI3bA64EXpdM8bSIEVIAs5JJH+LHXgnCsgcMGPZyAAVBncvbLiexzg9YozcytjPXVlAbQAC7Tc4S0C8QN4LlAGjj4pQAVWrwkaDoUYGxxvkCWKRRHkdzJB5zpREleBDL1oDKEvAqmkDibVC4kTqF89YO6laUjgtJPebBfzr16tg4t10GmN1sJ5vezk2sUOq8blCn5mPZyT3ltaDcddKupQjqusNM9wtFVD0ABzv17fZDn7GPT1nkCtdcgYejcK1qOcTGtPxnCX1rErEjVWCnEJv5HaOAUjgpiKQjUKkQi64D5g2COgwas8FcgIl0Pw95H9dWxE3QG0VbMNffh6BPlAojLDf4es2/5Xfq7hw5NGcON2g8Qsy2UQm94KddKyy3kdJxWgpNaEc15xcylbLC3vnT26u8qS90qc2MU8LdOJc5VPF5KnSpXIhnj1eJJ/jszjZ01oR6JDFJRoeTPO/wh4IPFbdG9KljuSzeuI92p8JF/bpgDE8wG86/W2EBKgPrmzdLijxssQn8mM44ky/KLGOJcrSwXIpZa/Z3v7W6HCRk7ewds99LTsUW1LbeJytw8Q/BFZVZyfO9BUHOCe2suuEkO8DU4fLX0IQSQ2TdOkKXDtPf3sNV9tYhYFueuPRhfQlEEy+aYM/MCz7diDNmFSswYYlZZPmKr2Q5AxLsSVEqqBtn6hVl1BCFOFExnqnIsmyY/NA8jXnDaNzr7Zv3hu+I1Mf/PJjk0gALN2G8ABzdf9FNvWHvZHhv6xIoDCXf964MxG92vGZtx/LYU5PeZqgly8tT5tGeQGeJzMMsJc5p+a5Rn2PtEhiRzo/5Owjy1n0Lzx3ev8GHQmeWb8vagG6O5Qk5nrZuQTiKODI4UqL0LLAusS2Ve7j1Ivdxquu1BR9Rc4QkOiUPwQXJv6du2E8i5pDhVoQpUhyMWGUT2O2YODIhjAfI71gxep5r5zAY7GBUZpy51hAw0pcCCrhOmU8Wp6ujQTdZQsCjtq6SHX8QAMNiPCIIkoxhHEZPgsBcOlP4aErJZPhF7qvx6gHrn8hEwPwYbx8YmT/n7lbcmTip1v8kgsrIjFTAlvLY4Nuil0KDmgz3svYs0ZJ3O3Is/vSx4xpxF1e2VAtZE8dJxGYEIhCSuPvCjP54l/NSNDnwlKvAW8mG+AQkgp7a87Igh26uKMFGD0PoPHTSvoWxiHuk+su8XkQiHIjeYKl/RdcOHpxhQH3zHCNE3aARm83Bl6zGxU/vMltlVPQhubcqhW4RYkl6uXk5JdP/QpzaKFpw2M8zvysv2qj7xaQECuu2akM0Cssj/uB9+wDR7uA6XOnLNaoczalHoMj33eiiu+DRaFsUmlmUZuh9bjDY4INMNSSAivSh03uJvny4Gj+D+neudoa7iJi7c4VFlZ/J5gUR82308zSNAt/ZroBXDWw0fV3eVPAn3aX0mtJabF6RsUZmL+Ehn+wn51/4QipMjD+6y64t7bjL6bjENan2prQ4h7++hBJ9NXvX8CUocJqMC937IasLzm5K0qwXeFMAimMHkEIQIQI2LrQ9sLBfXuyp66zWvlsh74GPv7Xpabj993pRNNDuFud5oIcn/92isbADXdpRPbjmbCNOrwRbxGZx2XmYNGMiV5kjF4IKyxCBvKier9U4uVoheCdmk83rp5G0PihAm2fAtczI4b9BWqX+nrZTrJX5kSwQddi93NQrXG+Cl3eBGNkM77VBsMpEolhXex1MVvMkZN9fG59GGbciH11FEXaY1MxrArovaSjE/lUUqBg2cZBNmiWbvzCHCPJ4RVGFK2dTbObM1m+gJyEX53fa7u3+TZpm74mNEzWbkVL4vjNwfL9uzRCu1cgbrNx5Yv5dDruNrIOgwIk+UZWwJfdbu/WHul6PMmRflVCIzd7B37Pgm/Up/NuCiQW7RXyafevN3AL6ycciCc4ZPlTRzEu+aURGlUBOJbUEsheX7PPyrrhdUt5JAG12EEEZpY/N3Vhbl5uLAfT0CbC2XmpnryFkxZmBTs5prvEeuf0bn73i3O82WTiQtJWEPLsBXnQmdnKhB06NbbhLtlTZYJMxDMJpFeajSNRDB2v61BMUHqXggUwRJ19m6p5zl51v11q34T74lTXdJURuV6+bg2D6qpfGnLy7KGLuLZngobM4pIouz4+n0/UzFKxDgLM4h+fUwKZozQ9UGrHjcif51Ruonz7oIVZ56xWtZS8z7u5zay6J2LD4gCYh2RXoBRLDKsUlZ80R8kmoxlJiL8aZCy2wCAonnucFxCLT1HKoMhbPKt34D97EXPPh0joO93iJVF1Uruew61Qoy3ZUVNX9uIJDt9AQWKLLo+mSzmTibyLHq0D6hhzpvgUgI6ekyVEL3FD+Fi5R3A8MRHPXspN1VyKkfRlC+OGiNgPC4NREZpFETgVmdXrQ2TxChuS3aY+Ndc7CiYv5+CmzfiqeZrWIQJW/C4RvjbGUoJFf1K6ZdR2xL/bG4kVq1+I4jQWX+26YUijpp+lpN7o5c6ZodXJCF56UkFGsqz44sIg8jrdWvbjRCxi2Bk0iyM3a7ecAV93zB6h1Ei38c0s6+8nrbkopArccGP8vntQe1bFeEh2nJIFOHX/k3/UHb5PtKGpnzbkmnRETMX+9X/QduLZWw/feklW/kH/JnzToJe9Kgu9Hct1UGbH5BPCLo4OOtQnZonW0xnyCcdtKyPQ/sbLiSTYJdSx4sJqWLMnfn6fIqPB3WAgk00J+fCOkomPHqtS67pf0mFmKoItYZUlJu6BihSZ8qve8+/X+LX1MhQXF95AshfUleCtmdn6l6QFXzLg2sgLn1oyVFuZecv7fzsIHzoRlAGp0gwYDOn1S4qabWvB5xUaE+Svw4KmjWtxdnuQbI32dw87D4N95u8qQRJTSQg0wLxOLkxSrPMLEn1UIhNKjAa9VLs3WLaXGrtCIt8bKY2AQP/ZdyRU6zT/E8qP2ltyBE2CCZPgWgEYDoJJO4n92y61ylNaSFXKohJhLjkfvYWm592539sIpmBNLlDo1bExFBfmHJJ0lFEiC/fj8v42OoMC9Mo3whIoWvyHfq6Uacqq55mzFf/EGC+NP/gHjhd6urc6R0hES27VXux7UY8CGKPohplWIZtTrFSaPWslCWy78E22Pw8fvReSUZx/txqLtHrFqg1DY/Eus6Iq1heZdrdcqE0/c971Bz1HW/XNXHsXpUIbI4kHdOfCc6T5zHZzvzQJB0ggMFL6IGPAilU9bj/ASdPk6fNvNtZqPuwEDhMBtBnhCexo6D6VAGIOPvJPPV523Y8R8a9vCqZbswSZKzOT1291BsUbmUWehtbb1fdRX9hiJKXvwr1QX6GjnZMgyMvnwOo2Dr24amr7FqEAbVeJAjRNOceM2EQ1Mna9fInqPJ5mh5X8CzT1aDOv08An0blz0fF5Gq4mS2cwq5glwIOlY5nznE8X4j/UdZ3FJsVIXte1JH0A7iibuPfazStM5O/Vo3KXIpXBeGORV0M9XDXFvsYZUHGvFCUubWzTw248EHE0cpQM2zNg6rjavreq3NHCAWsoZ7wvVy7l5gvtKRmIj1MnvfWEm0yFnGcuOq192350a5WefpfKCcX3Sn+AgHU+qnpstNtddbdVebagJU390lq9ko4aI9rqdaWXYG8tv5O/ZQHSqDRYHC6zfH10l5z++opso7aOSaIczlQ13iAzXvLdEu0V7kwNUZ1c8Y8aq7SeIEe5p902FlNkW8DnwHyueHchbK8vVFJfmr9mz7P8nUSccl1ULaoWMRSI1ls32kvlK0h46h3J25Yd9AzfcJbp9qYF/SEt3H5j69mMdcsNxZcAzT/A89ov3tglTX54y/EwjMfuoDoxPwLJDm5I7q6F9Kp469yNy1zSxz0N4HbRRBj9xFFuogvBspv7DXUNIsGxTINEQfmctb42XImWAODgARNo7dfcTqFKq6aTfivmvunLmzP9f8yLsJvXD3JbcPcDGNriMAcjzeDTNr65t8YB5tsnFDFLa0Uwmd2OvUdkLMX9TsAUYUfooSv47sw5J88j7CpahRjjO3/UhOXjTS39W5YZAel2KTbQd1h7INOw9P23GW7GDAe4agIUFHP48MZr7ubq0efFmmtwYMyk7D0r1oeG/CGOODgb9Ur+JMHxkwzPbtCX2ZnENQuI0RN5SyTIZuoY4XS9Rd/tPe3vNAZGSHM/YYwqs9xkkENx0O+eC2YVW1cwOJ3ckE890nbQeHLKlW15L0P0W2VliyYrfNr0nrIYddoRyGaCtj4OYd2MT7ebApqZOAQIaSHJM4mphhfjNjtnjg6YRyx9qM2FT3xOiYIMqXPFWdzhSgFF8ItocqVV09CmIoO8k6U/oJB7++wSX/YksxfPXHyjSgAGZOj1aKEq9fSvXBqtp2wu8/FxEf5AxapAD06pPGuLVUYLdgEzHR8wqRGYEwiUO9MyYbgswstuLYhwYFpSVKOdzAihZ9LuHtD598EGhINU9xc9xhL+QgTLAstmPIvvm2xyRw/WTUPXkP3ZHu6GyPmj5xFH9/QGpkglKXRVUBgVmLOJx8uZO2AstxQYocZH2JhORlxawj66BAXUEs7K/gPxINIRAFyK3WLuyq9oBTF9wEbnmCot82WjIg7CPNwYK3KrZMrKAz5yFszg4wCVLJVnIL8+OYA0xRDH8cHQjQUiQ2i1mr/be32k/3Xej9sdf3iuGvZHyLFSJvPSqz/wltnxumTJYKZsrWXtx/Rmu39jjV9lFaJttfFn57/No2h/unsJmMHbrnZ8csxkp5HQ4xR1s0HH+t3Iz82a3iQWTUDGq/+l2W3TUYLE8zNdL8Y+5oXaIH/Y2UUcX67cXeN4WvENZjz4+8q7vjhowOI3rSjFhGZ6KzwmU7+5nFV+kGWAZ5z2UWvzq0TK0pk1hPwAN4jbw//1CApRvIaIjhSGhioY6TUmsToek9cF9XjJdHvLPcyyCV3lbR5Jiz/ts46ay2F820VjTXvllElwrGzKcNSyvQlWDXdwrUINXmHorAM3fE19ngLZmgeUaCJLsSITf2VcfAOuWwX7mTPdP8Zb/04KqRniufCpwnDUk7sP0RX6cud/sanFMagnzKInSRVey0YzlVSOtA/AjrofmSH6RYbJQ8b4NDeTkIGc6247+Mnbez/qhJ9GAv9fGNFercPnnrf285Qgs+UqThLRgflcAKFuqWhLzZaR4QqvSwa3xe0LPkqj9xJWub195r7NrrR0e78FR+0mRBNMPsraqZctAUVAJfYKehTDV1MGGQSeDsOK9J3sbUuKRIS/WilX/64CBms9jCZocBlsBSZaIAjWm/SUZ8daWL2a/cJFyUOFqE3Epc2RWbtjNyPwOGpWtzu32kUooUqsJud7IV4E8rstUBXM7tGEtBx99x60g1duhyvxeKJSl8s5E34HTMmADT0836aEdg5Dv9rVyCz8i2REOmiz6wtIVFN0HsjAoN37SrY0bV1Ms8CRUILhvZvvRaDzoVCaSI0u8EPuTe4b7OPowgRGODl22UBBmHSTUY8e4DyL+Bc7bngo+2T8HtNvzyATSL5iJZgFPKpmUyZv54vVL90+/RQGATUmNKnrIvcJMYON9fl83naW5sf6hRkbbTC9RUEE6XADwjgA46wWfUQ+QWZl0J4PVTWAln/YfAz/SV3q3J9+yCYDleruoN5uoc/wT2f4YONGTb6zTGq3V+3JqzmCOjwebKln+fExVLN7sqtqfMnsKVXWbb2Ai5m3D/fCTgX7oKYzTZvj+m28XnDqPbXuP4MyWdmPezcesdrh7rCzA7BWdObiuyDEKjjzBbQ0qnuwjliz+b+j7aPMKlkXyIznV3tGzAfYwIbzGGt098oh4eq3ruDjdgHtjxfFCjHrjjRbHajoz/YOY4raojPFQ910GIlBV7hq47UDgpyajBxQUmD8NctiLV1rTSLAEsQDLTeRKcmPBMVMFF0SPBBhZ5oXoxtD3lMhuAQXmA+57OcciczVW9e9zwSIAHS+FJmvfXMJGF1dMBsIUMaPjvgaVqUc3p32qVCMQYFEiRLzlVSOGMCmv/HJIxAHe3mL/XnoZ1IkWLeRZfgyByjnDbbeRK5KL7bYHSVJZ9UFq+yCiNKeRUaYjgbC3hVUvfJAhy/QNl/JqLKVvGMk9ZcfyGidNeo/VTxK9vUpodzfQI9Z2eAre4nmrkzgxKSnT5IJ1D69oHuUS5hp7pK9IAWuNrAOtOH0mAuwCrY8mXAtVXUeaNK3OXr6PRvmWg4VQqFSy+a1GZfFYgdsJELG8N0kvqmzvwZ02Plf5fH9QTy6br0oY/IDsEA+GBf9pEVWCIuBCjsup3LDSDqI+5+0IKSUFr7A96A2f0FbcU9fqljdqvsd8sG55KcKloHIFZem2Wb6pCLXybnVSB0sjCXzdS8IKvE");
            let M = new Map([
                [8217, "apostrophe"],
                [8260, "fraction slash"],
                [12539, "middle dot"]
            ]);

            function quote_cp(l) {
                return `{${l.toString(16).toUpperCase().padStart(2,"0")}}`
            }

            function str_from_cps(l) {
                let c = l.length;
                if (c < 4096) return String.fromCodePoint(...l);
                let p = [];
                for (let v = 0; v < c;) p.push(String.fromCodePoint(...l.slice(v, v += 4096)));
                return p.join("")
            }
            var z = read_compressed_payload("AEUDTAHBCFQATQDRADAAcgAgADQAFAAsABQAHwAOACQADQARAAoAFwAHABIACAAPAAUACwAFAAwABAAQAAMABwAEAAoABQAIAAIACgABAAQAFAALAAIACwABAAIAAQAHAAMAAwAEAAsADAAMAAwACgANAA0AAwAKAAkABAAdAAYAZwDSAdsDJgC0CkMB8xhZAqfoC190UGcThgBurwf7PT09Pb09AjgJum8OjDllxHYUKXAPxzq6tABAxgK8ysUvWAgMPT09PT09PSs6LT2HcgWXWwFLoSMEEEl5RFVMKvO0XQ8ExDdJMnIgsj26PTQyy8FfEQ8AY8IPAGcEbwRwBHEEcgRzBHQEdQR2BHcEeAR6BHsEfAR+BIAEgfndBQoBYgULAWIFDAFiBNcE2ATZBRAFEQUvBdALFAsVDPcNBw13DYcOMA4xDjMB4BllHI0B2grbAMDpHLkQ7QHVAPRNQQFnGRUEg0yEB2uaJF8AJpIBpob5AERSMAKNoAXqaQLUBMCzEiACnwRZEkkVsS7tANAsBG0RuAQLEPABv9HICTUBXigPZwRBApMDOwAamhtaABqEAY8KvKx3LQ4ArAB8UhwEBAVSagD8AEFZADkBIadVj2UMUgx5Il4ANQC9AxIB1BlbEPMAs30CGxlXAhwZKQIECBc6EbsCoxngzv7UzRQA8M0BawL6ZwkN7wABAD33OQRcsgLJCjMCjqUChtw/km+NAsXPAoP2BT84PwURAK0RAvptb6cApQS/OMMey5HJS84UdxpxTPkCogVFITaTOwERAK5pAvkNBOVyA7q3BKlOJSALAgUIBRcEdASpBXqzABXFSWZOawLCOqw//AolCZdvv3dSBkEQGyelEPcMMwG1ATsN7UvYBPEGOwTJH30ZGQ/NlZwIpS3dDO0m4y6hgFoj9SqDBe1L9DzdC01RaA9ZC2UJ4zpjgU4DIQENIosK3Q05CG0Q8wrJaw3lEUUHOQPVSZoApQcBCxEdNRW1JhBirAsJOXcG+xr2C48mrxMpevwF0xohBk0BKRr/AM8u54WwWjFcHE9fBgMLJSPHFKhQIA0lQLd4SBobBxUlqQKRQ3BKh1E2HpMh9jw9DWYuE1F8B/U8BRlPC4E8nkarRQ4R0j6NPUgiSUwsBDV/LC8niwnPD4UMuXxyAVkJIQmxDHETMREXN8UIOQcZLZckJxUIIUaVYJoE958D8xPRAwsFPwlBBxMDtRwtEy4VKQUNgSTXAvM21S6zAo9WgAEXBcsPJR/fEFBH4A7pCJsCZQODJesALRUhABcimwhDYwBfj9hTBS7LCMdqbCN0A2cU52ERcweRDlcHpxwzFb8c4XDIXguGCCijrwlbAXUJmQFfBOMICTVbjKAgQWdTi1gYmyBhQT9d/AIxDGUVn0S9h3gCiw9rEhsBNQFzBzkNAQJ3Ee0RaxCVCOuGBDW1M/g6JQRPIYMgEQonA09szgsnJvkM+GkBoxJiAww0PXfuZ6tgtiQX/QcZMsVBYCHxC5JPzQycGsEYQlQuGeQHvwPzGvMn6kFXBf8DowMTOk0z7gS9C2kIiwk/AEkOoxcH1xhqCnGM0AExiwG3mQNXkYMCb48GNwcLAGcLhwV55QAdAqcIowAFAM8DVwA5Aq0HnQAZAIVBAT0DJy8BIeUCjwOTCDHLAZUvAfMpBBvDDBUA9zduSgLDsQKAamaiBd1YAo4CSTUBTSUEBU5HUQOvceEA2wBLBhPfRwEVq0rLGuNDAd9vKwDHAPsABTUHBUEBzQHzbQC3AV8LMQmis7UBTekpAIMAFWsB1wKJAN0ANQB/8QFTAE0FWfkF0wJPSQERMRgrV2EBuwMfATMBDQB5BsuNpckHHwRtB9MCEBsV4QLvLge1AQMi3xPNQsUCvd5VoWACZIECYkJbTa9bNyACofcCaJgCZgkCn4Q4GwsCZjsCZiYEbgR/A38TA36SOQY5dxc5gjojIwJsHQIyNjgKAm3HAm2u74ozZ0UrAWcA3gDhAEoFB5gMjQD+C8IADbUCdy8CdqI/AnlLQwJ4uh1c20WuRtcCfD8CesgCfQkCfPAFWQUgSABIfWMkAoFtAoAAAoAFAn+uSVhKWxUXSswC0QEC0MxLJwOITwOH5kTFkTIC8qFdAwMDrkvOTC0lA89NTE2vAos/AorYwRsHHUNnBbcCjjcCjlxAl4ECjtkCjlx4UbRTNQpS1FSFApP7ApMMAOkAHFUeVa9V0AYsGymVhjLheGZFOzkCl58C77JYIagAWSUClo8ClnycAKlZrFoJgU0AOwKWtQKWTlxEXNECmcsCmWRcyl0HGQKcmznCOp0CnBYCn5sCnriKAB0PMSoPAp3xAp6SALU9YTRh7wKe0wKgbgGpAp6fHwKeTqVjyGQnJSsCJ68CJn4CoPsCoEwCot0CocQCpi8Cpc4Cp/8AfQKn8mh8aLEAA0lqHGrRAqzjAqyuAq1nAq0CAlcdAlXcArHh1wMfTmyXArK9DQKy6Bds4G1jbUhfAyXNArZcOz9ukAMpRQK4XgK5RxUCuSp3cDZw4QK9GQK72nCWAzIRAr6IcgIDM3ECvhpzInNPAsPLAsMEc4J0SzVFdOADPKcDPJoDPb8CxXwCxkcCxhCJAshpUQLIRALJTwLJLgJknQLd0nh5YXiueSVL0AMYo2cCAmH0GfOVJHsLXpJeuxECz2sCz2wvS1PS8xOfAMatAs9zASnqA04SfksFAtwnAtuKAtJPA1JcA1NfAQEDVYyAiT8AyxbtYEWCHILTgs6DjQLaxwLZ3oQQhEmnPAOGpQAvA2QOhnFZ+QBVAt9lAt64c3cC4i/tFAHzMCcB9JsB8tKHAuvzAulweQLq+QLq5AD5RwG5Au6JAuuclqqXAwLuPwOF4Jh5cOBxoQLzAwBpA44WmZMC9xMDkW4DkocC95gC+dkC+GaaHJqruzebHgOdgwL++gEbADmfHJ+zAwWNA6ZqA6bZANHFAwZqoYiiBQkDDEkCwAA/AwDhQRdTARHzA2sHl2cFAJMtK7evvdsBiZkUfxEEOQH7KQUhDp0JnwCS/SlXxQL3AZ0AtwW5AG8LbUEuFCaNLgFDAYD8AbUmAHUDDgRtACwCFgyhAAAKAj0CagPdA34EkQEgRQUhfAoABQBEABMANhICdwEABdUDa+8KxQIA9wqfJ7+xt+UBkSFBQgHpFH8RNMCJAAQAGwBaAkUChIsABjpTOpSNbQC4Oo860ACNOME63AClAOgAywE6gTo7Ofw5+Tt2iTpbO56JOm85GAFWATMBbAUvNV01njWtNWY1dTW2NcU1gjWRNdI14TWeNa017jX9NbI1wTYCNhE1xjXVNhY2JzXeNe02LjY9Ni41LSE2OjY9Njw2yTcIBJA8VzY4Nt03IDcPNsogN4k3MAoEsDxnNiQ3GTdsOo03IULUQwdC4EMLHA8PCZsobShRVQYA6X8A6bABFCnXAukBowC9BbcAbwNzBL8MDAMMAQgDAAkKCwsLCQoGBAVVBI/DvwDz9b29kaUCb0QtsRTNLt4eGBcSHAMZFhYZEhYEARAEBUEcQRxBHEEcQRxBHEEaQRxBHEFCSTxBPElISUhBNkM2QTYbNklISVmBVIgBFLWZAu0BhQCjBcEAbykBvwGJAaQcEZ0ePCklMAAhMvAIMAL54gC7Bm8EescjzQMpARQpKgDUABavAj626xQAJP0A3etzuf4NNRA7efy2Z9NQrCnC0OSyANz5BBIbJ5IFDR6miIavYS6tprjjmuKebxm5C74Q225X1pkaYYPb6f1DK4k3xMEBb9S2WMjEibTNWhsRJIA+vwNVEiXTE5iXs/wezV66oFLfp9NZGYW+Gk19J2+bCT6Ye2w6LDYdgzKMUabk595eLBCXANz9HUpWbATq9vqXVx9XDg+Pc9Xp4+bsS005SVM/BJBM4687WUuf+Uj9dEi8aDNaPxtpbDxcG1THTImUMZq4UCaaNYpsVqraNyKLJXDYsFZ/5jl7bLRtO88t7P3xZaAxhb5OdPMXqsSkp1WCieG8jXm1U99+blvLlXzPCS+M93VnJCiK+09LfaSaBAVBomyDgJua8dfUzR7ga34IvR2Nvj+A9heJ6lsl1KG4NkI1032Cnff1m1wof2B9oHJK4bi6JkEdSqeNeiuo6QoZZincoc73/TH9SXF8sCE7XyuYyW8WSgbGFCjPV0ihLKhdPs08Tx82fYAkLLc4I2wdl4apY7GU5lHRFzRWJep7Ww3wbeA3qmd59/86P4xuNaqDpygXt6M85glSBHOCGgJDnt+pN9bK7HApMguX6+06RZNjzVmcZJ+wcUrJ9//bpRNxNuKpNl9uFds+S9tdx7LaM5ZkIrPj6nIU9mnbFtVbs9s/uLgl8MVczAwet+iOEzzBlYW7RCMgE6gyNLeq6+1tIx4dpgZnd0DksJS5f+JNDpwwcPNXaaVspq1fbQajOrJgK0ofKtJ1Ne90L6VO4MOl5S886p7u6xo7OLjG8TGL+HU1JXGJgppg4nNbNJ5nlzSpuPYy21JUEcUA94PoFiZfjZue+QnyQ80ekOuZVkxx4g+cvhJfHgNl4hy1/a6+RKcKlar/J29y//EztlbVPHVUeQ1zX86eQVAjR/M3dA9w4W8LfaXp4EgM85wOWasli837PzVMOnsLzR+k3o75/lRPAJSE1xAKQzEi5v10ke+VBvRt1cwQRMd+U5mLCTGVd6XiZtgBG5cDi0w22GKcVNvHiu5LQbZEDVtz0onn7k5+heuKXVsZtSzilkLRAUmjMXEMB3J9YC50XBxPiz53SC+EhnPl9WsKCv92SM/OFFIMJZYfl0WW8tIO3UxYcwdMAj7FSmgrsZ2aAZO03BOhP1bNNZItyXYQFTpC3SG1VuPDqH9GkiCDmE+JwxyIVSO5siDErAOpEXFgjy6PQtOVDj+s6e1r8heWVvmZnTciuf4EiNZzCAd7SOMhXERIOlsHIMG399i9aLTy3m2hRLZjJVDNLS53iGIK11dPqQt0zBDyg6qc7YqkDm2M5Ve6dCWCaCbTXX2rToaIgz6+zh4lYUi/+6nqcFMAkQJKHYLK0wYk5N9szV6xihDbDDFr45lN1K4aCXBq/FitPSud9gLt5ZVn+ZqGX7cwm2z5EGMgfFpIFyhGGuDPmso6TItTMwny+7uPnLCf4W6goFQFV0oQSsc9VfMmVLcLr6ZetDZbaSFTLqnSO/bIPjA3/zAUoqgGFAEQS4IhuMzEp2I3jJzbzkk/IEmyax+rhZTwd6f+CGtwPixu8IvzACquPWPREu9ZvGkUzpRwvRRuaNN6cr0W1wWits9ICdYJ7ltbgMiSL3sTPeufgNcVqMVWFkCPDH4jG2jA0XcVgQj62Cb29v9f/z/+2KbYvIv/zzjpQAPkliaVDzNrW57TZ/ZOyZD0nlfMmAIBIAGAI0D3k/mdN4xr9v85ZbZbbqfH2jGd5hUqNZWwl5SPfoGmfElmazUIeNL1j/mkF7VNAzTq4jNt8JoQ11NQOcmhprXoxSxfRGJ9LDEOAQ+dmxAQH90iti9e2u/MoeuaGcDTHoC+xsmEeWmxEKefQuIzHbpw5Tc5cEocboAD09oipWQhtTO1wivf/O+DRe2rpl/E9wlrzBorjJsOeG1B/XPW4EaJEFdNlECEZga5ZoGRHXgYouGRuVkm8tDESiEyFNo+3s5M5puSdTyUL2llnINVHEt91XUNW4ewdMgJ4boJfEyt/iY5WXqbA+A2Fkt5Z0lutiWhe9nZIyIUjyXDC3UsaG1t+eNx6z4W/OYoTB7A6x+dNSTOi9AInctbESqm5gvOLww7OWXPrmHwVZasrl4eD113pm+JtT7JVOvnCXqdzzdTRHgJ0PiGTFYW5Gvt9R9LD6Lzfs0v/TZZHSmyVNq7viIHE6DBK7Qp07Iz55EM8SYtQvZf/obBniTWi5C2/ovHfw4VndkE5XYdjOhCMRjDeOEfXeN/CwfGduiUIfsoFeUxXeQXba7c7972XNv8w+dTjjUM0QeNAReW+J014dKAD/McQYXT7c0GQPIkn3Ll6R7gGjuiQoZD0TEeEqQpKoZ15g/0OPQI17QiSv9AUROa/V/TQN3dvLArec3RrsYlvBm1b8LWzltdugsC50lNKYLEp2a+ZZYqPejULRlOJh5zj/LVMyTDvwKhMxxwuDkxJ1QpoNI0OTWLom4Z71SNzI9TV1iXJrIu9Wcnd+MCaAw8o1jSXd94YU/1gnkrC9BUEOtQvEIQ7g0i6h+KL2JKk8Ydl7HruvgWMSAmNe+LshGhV4qnWHhO9/RIPQzY1tHRj2VqOyNsDpK0cww+56AdDC4gsWwY0XxoucIWIqs/GcwnWqlaT0KPr8mbK5U94/301i1WLt4YINTVvCFBrFZbIbY8eycOdeJ2teD5IfPLCRg7jjcFTwlMFNl9zdh/o3E/hHPwj7BWg0MU09pPrBLbrCgm54A6H+I6v27+jL5gkjWg/iYdks9jbfVP5y/n0dlgWEMlKasl7JvFZd56LfybW1eeaVO0gxTfXZwD8G4SI116yx7UKVRgui6Ya1YpixqXeNLc8IxtAwCU5IhwQgn+NqHnRaDv61CxKhOq4pOX7M6pkA+Pmpd4j1vn6ACUALoLLc4vpXci8VidLxzm7qFBe7s+quuJs6ETYmnpgS3LwSZxPIltgBDXz8M1k/W2ySNv2f9/NPhxLGK2D21dkHeSGmenRT3Yqcdl0m/h3OYr8V+lXNYGf8aCCpd4bWjE4QIPj7vUKN4Nrfs7ML6Y2OyS830JCnofg/k7lpFpt4SqZc5HGg1HCOrHvOdC8bP6FGDbE/VV0mX4IakzbdS/op+Kt3G24/8QbBV7y86sGSQ/vZzU8FXs7u6jIvwchsEP2BpIhW3G8uWNwa3HmjfH/ZjhhCWvluAcF+nMf14ClKg5hGgtPLJ98ueNAkc5Hs2WZlk2QHvfreCK1CCGO6nMZVSb99VM/ajr8WHTte9JSmkXq/i/U943HEbdzW6Re/S88dKgg8pGOLlAeNiqrcLkUR3/aClFpMXcOUP3rmETcWSfMXZE3TUOi8i+fqRnTYLflVx/Vb/6GJ7eIRZUA6k3RYR3iFSK9c4iDdNwJuZL2FKz/IK5VimcNWEqdXjSoxSgmF0UPlDoUlNrPcM7ftmA8Y9gKiqKEHuWN+AZRIwtVSxye2Kf8rM3lhJ5XcBXU9n4v0Oy1RU2M+4qM8AQPVwse8ErNSob5oFPWxuqZnVzo1qB/IBxkM3EVUKFUUlO3e51259GgNcJbCmlvrdjtoTW7rChm1wyCKzpCTwozUUEOIcWLneRLgMXh+SjGSFkAllzbGS5HK7LlfCMRNRDSvbQPjcXaenNYxCvu2Qyznz6StuxVj66SgI0T8B6/sfHAJYZaZ78thjOSIFumNWLQbeZixDCCC+v0YBtkxiBB3jefHqZ/dFHU+crbj6OvS1x/JDD7vlm7zOVPwpUC01nhxZuY/63E7g");

            function unpack_cc(l) {
                return l >> 24 & 255
            }

            function unpack_cp(l) {
                return 16777215 & l
            }
            let J = new Map(read_sorted_arrays(z).flatMap((l, c) => l.map(l => [l, c + 1 << 24]))),
                Q = new Set(read_sorted(z)),
                X = new Map,
                es = new Map;
            for (let [l, c] of read_mapped(z)) {
                if (!Q.has(l) && 2 == c.length) {
                    let [p, v] = c, _ = es.get(p);
                    _ || (_ = new Map, es.set(p, _)), _.set(v, l)
                }
                X.set(l, c.reverse())
            }

            function is_hangul(l) {
                return l >= 44032 && l < 55204
            }

            function decomposed(l) {
                let c = [],
                    p = [],
                    v = !1;

                function add(l) {
                    let p = J.get(l);
                    p && (v = !0, l |= p), c.push(l)
                }
                for (let v of l)
                    for (;;) {
                        if (v < 128) c.push(v);
                        else if (is_hangul(v)) {
                            let l = v - 44032,
                                c = l / 588 | 0,
                                p = l % 588 / 28 | 0,
                                _ = l % 28;
                            add(4352 + c), add(4449 + p), _ > 0 && add(4519 + _)
                        } else {
                            let l = X.get(v);
                            l ? p.push(...l) : add(v)
                        }
                        if (!p.length) break;
                        v = p.pop()
                    }
                if (v && c.length > 1) {
                    let l = unpack_cc(c[0]);
                    for (let p = 1; p < c.length; p++) {
                        let v = unpack_cc(c[p]);
                        if (0 == v || l <= v) {
                            l = v;
                            continue
                        }
                        let _ = p - 1;
                        for (;;) {
                            let p = c[_ + 1];
                            if (c[_ + 1] = c[_], c[_] = p, !_ || (l = unpack_cc(c[--_])) <= v) break
                        }
                        l = unpack_cc(c[p])
                    }
                }
                return c
            }

            function nfc(l) {
                return function(l) {
                    let c = [],
                        p = [],
                        v = -1,
                        _ = 0;
                    for (let C of l) {
                        let l = unpack_cc(C),
                            P = unpack_cp(C);
                        if (-1 == v) 0 == l ? v = P : c.push(P);
                        else if (_ > 0 && _ >= l) 0 == l ? (c.push(v, ...p), p.length = 0, v = P) : p.push(P), _ = l;
                        else {
                            let C = function(l, c) {
                                if (l >= 4352 && l < 4371 && c >= 4449 && c < 4470) return 44032 + (l - 4352) * 588 + (c - 4449) * 28;
                                if (is_hangul(l) && c > 4519 && c < 4547 && (l - 44032) % 28 == 0) return l + (c - 4519); {
                                    let p = es.get(l);
                                    return p && (p = p.get(c)) ? p : -1
                                }
                            }(v, P);
                            C >= 0 ? v = C : 0 == _ && 0 == l ? (c.push(v), v = P) : (p.push(P), _ = l)
                        }
                    }
                    return v >= 0 && c.push(v, ...p), c
                }(decomposed(l))
            }

            function read_set() {
                return new Set(read_sorted(T))
            }
            let eo = new Map(read_mapped(T)),
                el = read_set(),
                ec = read_set(),
                eh = new Set(read_sorted(T).map(function(l) {
                    return this[l]
                }, [...ec])),
                ed = read_set();
            read_set();
            let ef = read_sorted_arrays(T);

            function read_chunked() {
                return new Set([read_sorted(T).map(l => ef[l]), read_sorted(T)].flat(2))
            }
            let ep = T(),
                eg = read_array_while(l => {
                    let c = read_array_while(T).map(l => l + 96);
                    if (c.length) {
                        let p = l >= ep;
                        c[0] -= 32, c = str_from_cps(c), p && (c = `Restricted[${c}]`);
                        let v = read_chunked(),
                            _ = [...v, ...read_chunked()].sort((l, c) => l - c);
                        return {
                            N: c,
                            P: v,
                            M: !T(),
                            R: p,
                            V: new Set(_)
                        }
                    }
                }),
                em = read_set(),
                ey = new Map;
            for (let {
                    V: l,
                    M: c
                } of ([...em, ...read_set()].sort((l, c) => l - c).map((l, c, p) => {
                    let v = T(),
                        _ = p[c] = v ? p[c - v] : {
                            V: [],
                            M: new Map
                        };
                    _.V.push(l), em.has(l) || ey.set(l, _)
                }), new Set(ey.values()))) {
                let p = [];
                for (let c of l) {
                    let l = eg.filter(l => l.V.has(c)),
                        v = p.find(({
                            G: c
                        }) => l.some(l => c.has(l)));
                    v || (v = {
                        G: new Set,
                        V: []
                    }, p.push(v)), v.V.push(c), l.forEach(l => v.G.add(l))
                }
                let v = p.flatMap(({
                    G: l
                }) => [...l]);
                for (let {
                        G: l,
                        V: _
                    } of p) {
                    let p = new Set(v.filter(c => !l.has(c)));
                    for (let l of _) c.set(l, p)
                }
            }
            let eb = new Set,
                ew = new Set;
            for (let l of eg)
                for (let c of l.V)(eb.has(c) ? ew : eb).add(c);
            for (let l of eb) ey.has(l) || ew.has(l) || ey.set(l, 1);
            let ex = new Set([...eb, ...decomposed(eb).map(unpack_cp)]),
                e_ = read_sorted(T),
                eE = function read_emoji_trie(l) {
                    let c = read_array_while(() => {
                            let l = read_sorted(T).map(l => e_[l]);
                            if (l.length) return read_emoji_trie(l)
                        }).sort((l, c) => c.Q.size - l.Q.size),
                        p = T();
                    return {
                        B: c,
                        V: p % 3,
                        F: 1 & (p = p / 3 | 0),
                        S: 1 & (p >>= 1),
                        C: 2 & p,
                        Q: new Set(l)
                    }
                }([]);
            let Emoji = class Emoji extends Array {
                get is_emoji() {
                    return !0
                }
            };

            function safe_str_from_cps(l, c = quote_cp) {
                var p;
                let v = [];
                p = l[0], ec.has(p) && v.push("◌");
                let _ = 0,
                    C = l.length;
                for (let p = 0; p < C; p++) {
                    let C = l[p];
                    ed.has(C) && (v.push(str_from_cps(l.slice(_, p))), v.push(c(C)), _ = p + 1)
                }
                return v.push(str_from_cps(l.slice(_, C))), v.join("")
            }

            function quoted_cp(l) {
                return (ed.has(l) ? "" : `${bidi_qq(safe_str_from_cps([l]))} `) + quote_cp(l)
            }

            function bidi_qq(l) {
                return `"${l}"\u200E`
            }

            function check_leading_underscore(l) {
                for (let c = l.lastIndexOf(95); c > 0;)
                    if (95 !== l[--c]) throw Error("underscore allowed only at start")
            }

            function error_disallowed(l) {
                return Error(`disallowed character: ${quoted_cp(l)}`)
            }

            function error_group_member(l, c) {
                let p = quoted_cp(c),
                    v = eg.find(l => l.P.has(c));
                return v && (p = `${v.N} ${p}`), Error(`illegal mixture: ${l.N} + ${p}`)
            }

            function error_placement(l) {
                return Error(`illegal placement: ${l}`)
            }
            let eA = new Uint8Array(32);

            function checkComponent(l) {
                return (0, _.en)(0 !== l.length, "invalid ENS name; empty component", "comp", l), l
            }

            function ensNameSplit(l) {
                let c = (0, C.Y0)(ensNormalize(l)),
                    p = [];
                if (0 === l.length) return p;
                let v = 0;
                for (let l = 0; l < c.length; l++) {
                    let _ = c[l];
                    46 === _ && (p.push(checkComponent(c.slice(v, l))), v = l + 1)
                }
                return (0, _.en)(v < c.length, "invalid ENS name; empty component", "name", l), p.push(checkComponent(c.slice(v))), p
            }

            function ensNormalize(l) {
                try {
                    var c;
                    let p;
                    return (p = 0, c = l.split(".").map(l => {
                        let c, v = function(l) {
                                let c = [];
                                for (let p = 0, v = l.length; p < v;) {
                                    let v = l.codePointAt(p);
                                    p += v < 65536 ? 1 : 2, c.push(v)
                                }
                                return c
                            }(l),
                            _ = {
                                input: v,
                                offset: p
                            };
                        p += v.length + 1;
                        try {
                            let l, p = _.tokens = function(l, c) {
                                    let p = [],
                                        v = [];
                                    for (l = l.slice().reverse(); l.length;) {
                                        let _ = function(l, c) {
                                            let p, v, _ = eE,
                                                C = [],
                                                P = l.length;
                                            for (c && (c.length = 0); P;) {
                                                let T = l[--P];
                                                if (!(_ = _.B.find(l => l.Q.has(T)))) break;
                                                if (_.S) v = T;
                                                else if (_.C && T === v) break;
                                                C.push(T), _.F && (C.push(65039), P > 0 && 65039 == l[P - 1] && P--), _.V && (p = function(l, c) {
                                                    let p = Emoji.from(l);
                                                    return 2 == c.V && p.splice(1, 1), p
                                                }(C, _), c && c.push(...l.slice(P).reverse()), l.length = P)
                                            }
                                            return p
                                        }(l);
                                        if (_) v.length && (p.push(c(v)), v = []), p.push(_);
                                        else {
                                            let c = l.pop();
                                            if (ex.has(c)) v.push(c);
                                            else {
                                                let l = eo.get(c);
                                                if (l) v.push(...l);
                                                else if (!el.has(c)) throw error_disallowed(c)
                                            }
                                        }
                                    }
                                    return v.length && p.push(c(v)), p
                                }(v, nfc),
                                C = p.length;
                            if (C) {
                                let v = p[0],
                                    P = C > 1 || v.is_emoji;
                                if (!P && v.every(l => l < 128)) c = v, check_leading_underscore(c),
                                    function(l) {
                                        if (l.length >= 4 && 45 == l[2] && 45 == l[3]) throw Error("invalid label extension")
                                    }(c), l = "ASCII";
                                else if (P && (_.emoji = !0, v = p.flatMap(l => l.is_emoji ? [] : l)), c = p.flatMap(l => l.is_emoji ? l.filter(l => 65039 != l) : l), check_leading_underscore(c), v.length) {
                                    if (ec.has(c[0])) throw error_placement("leading combining mark");
                                    for (let l = 1; l < C; l++) {
                                        let c = p[l];
                                        if (!c.is_emoji && ec.has(c[0])) throw error_placement(`emoji + combining mark: "${str_from_cps(p[l-1])} + ${safe_str_from_cps([c[0]])}"`)
                                    }! function(l) {
                                        let c = l[0],
                                            p = M.get(c);
                                        if (p) throw error_placement(`leading ${p}`);
                                        let v = l.length,
                                            _ = -1;
                                        for (let C = 1; C < v; C++) {
                                            c = l[C];
                                            let v = M.get(c);
                                            if (v) {
                                                if (_ == C) throw error_placement(`${p} + ${v}`);
                                                _ = C + 1, p = v
                                            }
                                        }
                                        if (_ == v) throw error_placement(`trailing ${p}`)
                                    }(c);
                                    let _ = [...new Set(v)],
                                        [P] = function(l) {
                                            let c = eg;
                                            for (let p of l) {
                                                let l = c.filter(l => l.V.has(p));
                                                if (!l.length) {
                                                    if (c === eg) throw error_disallowed(p);
                                                    throw error_group_member(c[0], p)
                                                }
                                                if (c = l, 1 == l.length) break
                                            }
                                            return c
                                        }(_);
                                    (function(l, c) {
                                        let {
                                            V: p,
                                            M: v
                                        } = l;
                                        for (let v of c)
                                            if (!p.has(v)) throw error_group_member(l, v);
                                        if (v) {
                                            let l = decomposed(c).map(unpack_cp);
                                            for (let c = 1, p = l.length; c < p; c++)
                                                if (eh.has(l[c])) {
                                                    let v = c + 1;
                                                    for (let _; v < p && eh.has(_ = l[v]); v++)
                                                        for (let p = c; p < v; p++)
                                                            if (l[p] == _) throw Error(`non-spacing marks: repeated ${quoted_cp(_)}`);
                                                    if (v - c > 4) throw Error(`non-spacing marks: too many ${bidi_qq(safe_str_from_cps(l.slice(c-1,v)))} (${v-c}/4)`);
                                                    c = v
                                                }
                                        }
                                    })(P, v),
                                    function(l, c) {
                                        let p;
                                        let v = [];
                                        for (let l of c) {
                                            let c = ey.get(l);
                                            if (1 === c) return;
                                            if (c) {
                                                let v = c.M.get(l);
                                                if (!(p = p ? p.filter(l => v.has(l)) : [...v]).length) return
                                            } else v.push(l)
                                        }
                                        if (p) {
                                            for (let c of p)
                                                if (v.every(l => c.V.has(l))) throw Error(`whole-script confusable: ${l.N}/${c.N}`)
                                        }
                                    }(P, _), l = P.N
                                } else l = "Emoji"
                            } else throw Error("empty label");
                            _.type = l
                        } catch (l) {
                            _.error = l
                        }
                        return _.output = c, _
                    })).map(({
                        input: l,
                        error: p,
                        output: v
                    }) => {
                        if (p) {
                            let v = p.message;
                            throw Error(1 == c.length ? v : `Invalid label ${bidi_qq(safe_str_from_cps(l))}: ${v}`)
                        }
                        return str_from_cps(v)
                    }).join(".")
                } catch (c) {
                    (0, _.en)(!1, `invalid ENS name (${c.message})`, "name", l)
                }
            }

            function namehash(l) {
                (0, _.en)("string" == typeof l, "invalid ENS name; not a string", "name", l);
                let c = eA,
                    p = ensNameSplit(l);
                for (; p.length;) c = (0, v.w)((0, P.zo)([c, (0, v.w)(p.pop())]));
                return (0, P.Dv)(c)
            }

            function dnsEncode(l) {
                return (0, P.Dv)((0, P.zo)(ensNameSplit(l).map(l => {
                    if (l.length > 63) throw Error("invalid DNS encoded entry; length exceeds 63 bytes");
                    let c = new Uint8Array(l.length + 1);
                    return c.set(l, 1), c[0] = c.length - 1, c
                }))) + "00"
            }
            eA.fill(0)
        },
        8004: function(l, c, p) {
            "use strict";
            p.d(c, {
                Z: function() {
                    return Network
                }
            });
            var v = p(2204),
                _ = p(8101),
                C = p(9644),
                P = p(2671);
            let NetworkPlugin = class NetworkPlugin {
                name;
                constructor(l) {
                    (0, P.h)(this, {
                        name: l
                    })
                }
                clone() {
                    return new NetworkPlugin(this.name)
                }
            };
            let GasCostPlugin = class GasCostPlugin extends NetworkPlugin {
                effectiveBlock;
                txBase;
                txCreate;
                txDataZero;
                txDataNonzero;
                txAccessListStorageKey;
                txAccessListAddress;
                constructor(l, c) {
                    null == l && (l = 0), super(`org.ethers.network.plugins.GasCost#${l||0}`);
                    let p = {
                        effectiveBlock: l
                    };

                    function set(l, v) {
                        let _ = (c || {})[l];
                        null == _ && (_ = v), (0, C.en)("number" == typeof _, `invalud value for ${l}`, "costs", c), p[l] = _
                    }
                    set("txBase", 21e3), set("txCreate", 32e3), set("txDataZero", 4), set("txDataNonzero", 16), set("txAccessListStorageKey", 1900), set("txAccessListAddress", 2400), (0, P.h)(this, p)
                }
                clone() {
                    return new GasCostPlugin(this.effectiveBlock, this)
                }
            };
            let EnsPlugin = class EnsPlugin extends NetworkPlugin {
                address;
                targetNetwork;
                constructor(l, c) {
                    super("org.ethers.plugins.network.Ens"), (0, P.h)(this, {
                        address: l || "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
                        targetNetwork: null == c ? 1 : c
                    })
                }
                clone() {
                    return new EnsPlugin(this.address, this.targetNetwork)
                }
            };
            let FetchUrlFeeDataNetworkPlugin = class FetchUrlFeeDataNetworkPlugin extends NetworkPlugin {#
                t;#
                r;
                get url() {
                    return this.#t
                }
                get processFunc() {
                    return this.#r
                }
                constructor(l, c) {
                    super("org.ethers.plugins.network.FetchUrlFeeDataPlugin"), this.#t = l, this.#r = c
                }
                clone() {
                    return this
                }
            };
            let T = new Map;
            let Network = class Network {#
                n;#
                i;#
                s;
                constructor(l, c) {
                    this.#n = l, this.#i = (0, _.yT)(c), this.#s = new Map
                }
                toJSON() {
                    return {
                        name: this.name,
                        chainId: String(this.chainId)
                    }
                }
                get name() {
                    return this.#n
                }
                set name(l) {
                    this.#n = l
                }
                get chainId() {
                    return this.#i
                }
                set chainId(l) {
                    this.#i = (0, _.yT)(l, "chainId")
                }
                matches(l) {
                    if (null == l) return !1;
                    if ("string" == typeof l) {
                        try {
                            return this.chainId === (0, _.yT)(l)
                        } catch (l) {}
                        return this.name === l
                    }
                    if ("number" == typeof l || "bigint" == typeof l) {
                        try {
                            return this.chainId === (0, _.yT)(l)
                        } catch (l) {}
                        return !1
                    }
                    if ("object" == typeof l) {
                        if (null != l.chainId) {
                            try {
                                return this.chainId === (0, _.yT)(l.chainId)
                            } catch (l) {}
                            return !1
                        }
                        if (null != l.name) return this.name === l.name
                    }
                    return !1
                }
                get plugins() {
                    return Array.from(this.#s.values())
                }
                attachPlugin(l) {
                    if (this.#s.get(l.name)) throw Error(`cannot replace existing plugin: ${l.name} `);
                    return this.#s.set(l.name, l.clone()), this
                }
                getPlugin(l) {
                    return this.#s.get(l) || null
                }
                getPlugins(l) {
                    return this.plugins.filter(c => c.name.split("#")[0] === l)
                }
                clone() {
                    let l = new Network(this.name, this.chainId);
                    return this.plugins.forEach(c => {
                        l.attachPlugin(c.clone())
                    }), l
                }
                computeIntrinsicGas(l) {
                    let c = this.getPlugin("org.ethers.plugins.network.GasCost") || new GasCostPlugin,
                        p = c.txBase;
                    if (null == l.to && (p += c.txCreate), l.data)
                        for (let v = 2; v < l.data.length; v += 2) "00" === l.data.substring(v, v + 2) ? p += c.txDataZero : p += c.txDataNonzero;
                    if (l.accessList) {
                        let _ = (0, v.z)(l.accessList);
                        for (let l in _) p += c.txAccessListAddress + c.txAccessListStorageKey * _[l].storageKeys.length
                    }
                    return p
                }
                static from(l) {
                    if (function() {
                            var l;

                            function registerEth(l, c, p) {
                                let func = function() {
                                    let v = new Network(l, c);
                                    return null != p.ensNetwork && v.attachPlugin(new EnsPlugin(null, p.ensNetwork)), v.attachPlugin(new GasCostPlugin), (p.plugins || []).forEach(l => {
                                        v.attachPlugin(l)
                                    }), v
                                };
                                Network.register(l, func), Network.register(c, func), p.altNames && p.altNames.forEach(l => {
                                    Network.register(l, func)
                                })
                            }
                            M || (M = !0, registerEth("mainnet", 1, {
                                ensNetwork: 1,
                                altNames: ["homestead"]
                            }), registerEth("ropsten", 3, {
                                ensNetwork: 3
                            }), registerEth("rinkeby", 4, {
                                ensNetwork: 4
                            }), registerEth("goerli", 5, {
                                ensNetwork: 5
                            }), registerEth("kovan", 42, {
                                ensNetwork: 42
                            }), registerEth("sepolia", 11155111, {}), registerEth("classic", 61, {}), registerEth("classicKotti", 6, {}), registerEth("arbitrum", 42161, {
                                ensNetwork: 1
                            }), registerEth("arbitrum-goerli", 421613, {}), registerEth("bnb", 56, {
                                ensNetwork: 1
                            }), registerEth("bnbt", 97, {}), registerEth("linea", 59144, {
                                ensNetwork: 1
                            }), registerEth("linea-goerli", 59140, {}), registerEth("matic", 137, {
                                ensNetwork: 1,
                                plugins: [getGasStationPlugin("https://gasstation.polygon.technology/v2")]
                            }), registerEth("matic-mumbai", 80001, {
                                altNames: ["maticMumbai", "maticmum"],
                                plugins: [getGasStationPlugin("https://gasstation-testnet.polygon.technology/v2")]
                            }), registerEth("optimism", 10, {
                                ensNetwork: 1,
                                plugins: [(l = BigInt("1000000"), new FetchUrlFeeDataNetworkPlugin("data:", async (c, p, v) => {
                                    let _ = await c();
                                    if (null == _.maxFeePerGas || null == _.maxPriorityFeePerGas) return _;
                                    let C = _.maxFeePerGas - _.maxPriorityFeePerGas;
                                    return {
                                        gasPrice: _.gasPrice,
                                        maxFeePerGas: C + l,
                                        maxPriorityFeePerGas: l
                                    }
                                }))]
                            }), registerEth("optimism-goerli", 420, {}), registerEth("xdai", 100, {
                                ensNetwork: 1
                            }))
                        }(), null == l) return Network.from("mainnet");
                    if ("number" == typeof l && (l = BigInt(l)), "string" == typeof l || "bigint" == typeof l) {
                        let c = T.get(l);
                        if (c) return c();
                        if ("bigint" == typeof l) return new Network("unknown", l);
                        (0, C.en)(!1, "unknown network", "network", l)
                    }
                    if ("function" == typeof l.clone) {
                        let c = l.clone();
                        return c
                    }
                    if ("object" == typeof l) {
                        (0, C.en)("string" == typeof l.name && "number" == typeof l.chainId, "invalid network object name or chainId", "network", l);
                        let c = new Network(l.name, l.chainId);
                        return (l.ensAddress || null != l.ensNetwork) && c.attachPlugin(new EnsPlugin(l.ensAddress, l.ensNetwork)), c
                    }(0, C.en)(!1, "invalid network", "network", l)
                }
                static register(l, c) {
                    "number" == typeof l && (l = BigInt(l));
                    let p = T.get(l);
                    p && (0, C.en)(!1, `conflicting network for ${JSON.stringify(p.name)}`, "nameOrChainId", l), T.set(l, c)
                }
            };

            function parseUnits(l, c) {
                let p = String(l);
                if (!p.match(/^[0-9.]+$/)) throw Error(`invalid gwei value: ${l}`);
                let v = p.split(".");
                if (1 === v.length && v.push(""), 2 !== v.length) throw Error(`invalid gwei value: ${l}`);
                for (; v[1].length < c;) v[1] += "0";
                if (v[1].length > 9) {
                    let l = BigInt(v[1].substring(0, 9));
                    !v[1].substring(9).match(/^0+$/) && l++, v[1] = l.toString()
                }
                return BigInt(v[0] + v[1])
            }

            function getGasStationPlugin(l) {
                return new FetchUrlFeeDataNetworkPlugin(l, async (l, c, p) => {
                    let v;
                    p.setHeader("User-Agent", "ethers");
                    try {
                        let [c, _] = await Promise.all([p.send(), l()]);
                        v = c;
                        let C = v.bodyJson.standard,
                            P = {
                                gasPrice: _.gasPrice,
                                maxFeePerGas: parseUnits(C.maxFee, 9),
                                maxPriorityFeePerGas: parseUnits(C.maxPriorityFee, 9)
                            };
                        return P
                    } catch (l) {
                        (0, C.hu)(!1, `error encountered with polygon gas station (${JSON.stringify(p.url)})`, "SERVER_ERROR", {
                            request: p,
                            response: v,
                            error: l
                        })
                    }
                })
            }
            let M = !1
        },
        9215: function(l, c, p) {
            "use strict";
            let v, _;
            p.d(c, {
                JU: function() {
                    return JsonRpcApiPollingProvider
                },
                C1: function() {
                    return JsonRpcSigner
                }
            });
            var C = p(9644),
                P = p(8101),
                T = p(8582),
                M = p(2671);
            let z = new Uint8Array(32),
                J = ["then"],
                Q = {};

            function throwError(l, c) {
                let p = Error(`deferred error during ABI decoding triggered accessing ${l}`);
                throw p.error = c, p
            }
            let Result = class Result extends Array {#
                a;
                constructor(...l) {
                    let c = l[0],
                        p = l[1],
                        v = (l[2] || []).slice(),
                        _ = !0;
                    c !== Q && (p = l, v = [], _ = !1), super(p.length), p.forEach((l, c) => {
                        this[c] = l
                    });
                    let C = v.reduce((l, c) => ("string" == typeof c && l.set(c, (l.get(c) || 0) + 1), l), new Map);
                    if (this.#a = Object.freeze(p.map((l, c) => {
                            let p = v[c];
                            return null != p && 1 === C.get(p) ? p : null
                        })), !_) return;
                    return Object.freeze(this), new Proxy(this, {
                        get: (l, c, p) => {
                            if ("string" == typeof c) {
                                if (c.match(/^[0-9]+$/)) {
                                    let p = (0, P.Dx)(c, "%index");
                                    if (p < 0 || p >= this.length) throw RangeError("out of result range");
                                    let v = l[p];
                                    return v instanceof Error && throwError(`index ${p}`, v), v
                                }
                                if (J.indexOf(c) >= 0) return Reflect.get(l, c, p);
                                let v = l[c];
                                if (v instanceof Function) return function(...c) {
                                    return v.apply(this === p ? l : this, c)
                                };
                                if (!(c in l)) return l.getValue.apply(this === p ? l : this, [c])
                            }
                            return Reflect.get(l, c, p)
                        }
                    })
                }
                toArray() {
                    let l = [];
                    return this.forEach((c, p) => {
                        c instanceof Error && throwError(`index ${p}`, c), l.push(c)
                    }), l
                }
                toObject() {
                    return this.#a.reduce((l, c, p) => ((0, C.hu)(null != c, "value at index ${ index } unnamed", "UNSUPPORTED_OPERATION", {
                        operation: "toObject()"
                    }), c in l || (l[c] = this.getValue(c)), l), {})
                }
                slice(l, c) {
                    null == l && (l = 0), l < 0 && (l += this.length) < 0 && (l = 0), null == c && (c = this.length), c < 0 && (c += this.length) < 0 && (c = 0), c > this.length && (c = this.length);
                    let p = [],
                        v = [];
                    for (let _ = l; _ < c; _++) p.push(this[_]), v.push(this.#a[_]);
                    return new Result(Q, p, v)
                }
                filter(l, c) {
                    let p = [],
                        v = [];
                    for (let _ = 0; _ < this.length; _++) {
                        let C = this[_];
                        C instanceof Error && throwError(`index ${_}`, C), l.call(c, C, _, this) && (p.push(C), v.push(this.#a[_]))
                    }
                    return new Result(Q, p, v)
                }
                map(l, c) {
                    let p = [];
                    for (let v = 0; v < this.length; v++) {
                        let _ = this[v];
                        _ instanceof Error && throwError(`index ${v}`, _), p.push(l.call(c, _, v, this))
                    }
                    return p
                }
                getValue(l) {
                    let c = this.#a.indexOf(l);
                    if (-1 === c) return;
                    let p = this[c];
                    return p instanceof Error && throwError(`property ${JSON.stringify(l)}`, p.error), p
                }
                static fromItems(l, c) {
                    return new Result(Q, l, c)
                }
            };

            function getValue(l) {
                let c = (0, P.ot)(l);
                return (0, C.hu)(c.length <= 32, "value out-of-bounds", "BUFFER_OVERRUN", {
                    buffer: c,
                    length: 32,
                    offset: c.length
                }), 32 !== c.length && (c = (0, T.h_)((0, T.zo)([z.slice(c.length % 32), c]))), c
            }
            let Coder = class Coder {
                name;
                type;
                localName;
                dynamic;
                constructor(l, c, p, v) {
                    (0, M.h)(this, {
                        name: l,
                        type: c,
                        localName: p,
                        dynamic: v
                    }, {
                        name: "string",
                        type: "string",
                        localName: "string",
                        dynamic: "boolean"
                    })
                }
                _throwError(l, c) {
                    (0, C.en)(!1, l, this.localName, c)
                }
            };
            let Writer = class Writer {#
                o;#
                l;
                constructor() {
                    this.#o = [], this.#l = 0
                }
                get data() {
                    return (0, T.zo)(this.#o)
                }
                get length() {
                    return this.#l
                }#
                c(l) {
                    return this.#o.push(l), this.#l += l.length, l.length
                }
                appendWriter(l) {
                    return this.#c((0, T.h_)(l.data))
                }
                writeBytes(l) {
                    let c = (0, T.h_)(l),
                        p = c.length % 32;
                    return p && (c = (0, T.h_)((0, T.zo)([c, z.slice(p)]))), this.#c(c)
                }
                writeValue(l) {
                    return this.#c(getValue(l))
                }
                writeUpdatableValue() {
                    let l = this.#o.length;
                    return this.#o.push(z), this.#l += 32, c => {
                        this.#o[l] = getValue(c)
                    }
                }
            };
            let Reader = class Reader {
                allowLoose;#
                o;#
                u;
                constructor(l, c) {
                    (0, M.h)(this, {
                        allowLoose: !!c
                    }), this.#o = (0, T.h_)(l), this.#u = 0
                }
                get data() {
                    return (0, T.Dv)(this.#o)
                }
                get dataLength() {
                    return this.#o.length
                }
                get consumed() {
                    return this.#u
                }
                get bytes() {
                    return new Uint8Array(this.#o)
                }#
                h(l, c, p) {
                    let v = 32 * Math.ceil(c / 32);
                    return this.#u + v > this.#o.length && (this.allowLoose && p && this.#u + c <= this.#o.length ? v = c : (0, C.hu)(!1, "data out-of-bounds", "BUFFER_OVERRUN", {
                        buffer: (0, T.h_)(this.#o),
                        length: this.#o.length,
                        offset: this.#u + v
                    })), this.#o.slice(this.#u, this.#u + v)
                }
                subReader(l) {
                    return new Reader(this.#o.slice(this.#u + l), this.allowLoose)
                }
                readBytes(l, c) {
                    let p = this.#h(0, l, !!c);
                    return this.#u += p.length, p.slice(0, l)
                }
                readValue() {
                    return (0, P.Gh)(this.readBytes(32))
                }
                readIndex() {
                    return (0, P.He)(this.readBytes(32))
                }
            };
            var X = p(4072);
            let es = {};

            function n(l, c) {
                let p = !1;
                return c < 0 && (p = !0, c *= -1), new Typed(es, `${p?"":"u"}int${c}`, l, {
                    signed: p,
                    width: c
                })
            }

            function b(l, c) {
                return new Typed(es, `bytes${c||""}`, l, {
                    size: c
                })
            }
            let eo = Symbol.for("_ethers_typed");
            let Typed = class Typed {
                type;
                value;#
                d;
                _typedSymbol;
                constructor(l, c, p, v) {
                    null == v && (v = null), (0, C.NK)(es, l, "Typed"), (0, M.h)(this, {
                        _typedSymbol: eo,
                        type: c,
                        value: p
                    }), this.#d = v, this.format()
                }
                format() {
                    if ("array" === this.type || "dynamicArray" === this.type) throw Error("");
                    return "tuple" === this.type ? `tuple(${this.value.map(l=>l.format()).join(",")})` : this.type
                }
                defaultValue() {
                    return 0
                }
                minValue() {
                    return 0
                }
                maxValue() {
                    return 0
                }
                isBigInt() {
                    return !!this.type.match(/^u?int[0-9]+$/)
                }
                isData() {
                    return this.type.startsWith("bytes")
                }
                isString() {
                    return "string" === this.type
                }
                get tupleName() {
                    if ("tuple" !== this.type) throw TypeError("not a tuple");
                    return this.#d
                }
                get arrayLength() {
                    if ("array" !== this.type) throw TypeError("not an array");
                    return !0 === this.#d ? -1 : !1 === this.#d ? this.value.length : null
                }
                static from(l, c) {
                    return new Typed(es, l, c)
                }
                static uint8(l) {
                    return n(l, 8)
                }
                static uint16(l) {
                    return n(l, 16)
                }
                static uint24(l) {
                    return n(l, 24)
                }
                static uint32(l) {
                    return n(l, 32)
                }
                static uint40(l) {
                    return n(l, 40)
                }
                static uint48(l) {
                    return n(l, 48)
                }
                static uint56(l) {
                    return n(l, 56)
                }
                static uint64(l) {
                    return n(l, 64)
                }
                static uint72(l) {
                    return n(l, 72)
                }
                static uint80(l) {
                    return n(l, 80)
                }
                static uint88(l) {
                    return n(l, 88)
                }
                static uint96(l) {
                    return n(l, 96)
                }
                static uint104(l) {
                    return n(l, 104)
                }
                static uint112(l) {
                    return n(l, 112)
                }
                static uint120(l) {
                    return n(l, 120)
                }
                static uint128(l) {
                    return n(l, 128)
                }
                static uint136(l) {
                    return n(l, 136)
                }
                static uint144(l) {
                    return n(l, 144)
                }
                static uint152(l) {
                    return n(l, 152)
                }
                static uint160(l) {
                    return n(l, 160)
                }
                static uint168(l) {
                    return n(l, 168)
                }
                static uint176(l) {
                    return n(l, 176)
                }
                static uint184(l) {
                    return n(l, 184)
                }
                static uint192(l) {
                    return n(l, 192)
                }
                static uint200(l) {
                    return n(l, 200)
                }
                static uint208(l) {
                    return n(l, 208)
                }
                static uint216(l) {
                    return n(l, 216)
                }
                static uint224(l) {
                    return n(l, 224)
                }
                static uint232(l) {
                    return n(l, 232)
                }
                static uint240(l) {
                    return n(l, 240)
                }
                static uint248(l) {
                    return n(l, 248)
                }
                static uint256(l) {
                    return n(l, 256)
                }
                static uint(l) {
                    return n(l, 256)
                }
                static int8(l) {
                    return n(l, -8)
                }
                static int16(l) {
                    return n(l, -16)
                }
                static int24(l) {
                    return n(l, -24)
                }
                static int32(l) {
                    return n(l, -32)
                }
                static int40(l) {
                    return n(l, -40)
                }
                static int48(l) {
                    return n(l, -48)
                }
                static int56(l) {
                    return n(l, -56)
                }
                static int64(l) {
                    return n(l, -64)
                }
                static int72(l) {
                    return n(l, -72)
                }
                static int80(l) {
                    return n(l, -80)
                }
                static int88(l) {
                    return n(l, -88)
                }
                static int96(l) {
                    return n(l, -96)
                }
                static int104(l) {
                    return n(l, -104)
                }
                static int112(l) {
                    return n(l, -112)
                }
                static int120(l) {
                    return n(l, -120)
                }
                static int128(l) {
                    return n(l, -128)
                }
                static int136(l) {
                    return n(l, -136)
                }
                static int144(l) {
                    return n(l, -144)
                }
                static int152(l) {
                    return n(l, -152)
                }
                static int160(l) {
                    return n(l, -160)
                }
                static int168(l) {
                    return n(l, -168)
                }
                static int176(l) {
                    return n(l, -176)
                }
                static int184(l) {
                    return n(l, -184)
                }
                static int192(l) {
                    return n(l, -192)
                }
                static int200(l) {
                    return n(l, -200)
                }
                static int208(l) {
                    return n(l, -208)
                }
                static int216(l) {
                    return n(l, -216)
                }
                static int224(l) {
                    return n(l, -224)
                }
                static int232(l) {
                    return n(l, -232)
                }
                static int240(l) {
                    return n(l, -240)
                }
                static int248(l) {
                    return n(l, -248)
                }
                static int256(l) {
                    return n(l, -256)
                }
                static int(l) {
                    return n(l, -256)
                }
                static bytes1(l) {
                    return b(l, 1)
                }
                static bytes2(l) {
                    return b(l, 2)
                }
                static bytes3(l) {
                    return b(l, 3)
                }
                static bytes4(l) {
                    return b(l, 4)
                }
                static bytes5(l) {
                    return b(l, 5)
                }
                static bytes6(l) {
                    return b(l, 6)
                }
                static bytes7(l) {
                    return b(l, 7)
                }
                static bytes8(l) {
                    return b(l, 8)
                }
                static bytes9(l) {
                    return b(l, 9)
                }
                static bytes10(l) {
                    return b(l, 10)
                }
                static bytes11(l) {
                    return b(l, 11)
                }
                static bytes12(l) {
                    return b(l, 12)
                }
                static bytes13(l) {
                    return b(l, 13)
                }
                static bytes14(l) {
                    return b(l, 14)
                }
                static bytes15(l) {
                    return b(l, 15)
                }
                static bytes16(l) {
                    return b(l, 16)
                }
                static bytes17(l) {
                    return b(l, 17)
                }
                static bytes18(l) {
                    return b(l, 18)
                }
                static bytes19(l) {
                    return b(l, 19)
                }
                static bytes20(l) {
                    return b(l, 20)
                }
                static bytes21(l) {
                    return b(l, 21)
                }
                static bytes22(l) {
                    return b(l, 22)
                }
                static bytes23(l) {
                    return b(l, 23)
                }
                static bytes24(l) {
                    return b(l, 24)
                }
                static bytes25(l) {
                    return b(l, 25)
                }
                static bytes26(l) {
                    return b(l, 26)
                }
                static bytes27(l) {
                    return b(l, 27)
                }
                static bytes28(l) {
                    return b(l, 28)
                }
                static bytes29(l) {
                    return b(l, 29)
                }
                static bytes30(l) {
                    return b(l, 30)
                }
                static bytes31(l) {
                    return b(l, 31)
                }
                static bytes32(l) {
                    return b(l, 32)
                }
                static address(l) {
                    return new Typed(es, "address", l)
                }
                static bool(l) {
                    return new Typed(es, "bool", !!l)
                }
                static bytes(l) {
                    return new Typed(es, "bytes", l)
                }
                static string(l) {
                    return new Typed(es, "string", l)
                }
                static array(l, c) {
                    throw Error("not implemented yet")
                }
                static tuple(l, c) {
                    throw Error("not implemented yet")
                }
                static overrides(l) {
                    return new Typed(es, "overrides", Object.assign({}, l))
                }
                static isTyped(l) {
                    return l && "object" == typeof l && "_typedSymbol" in l && l._typedSymbol === eo
                }
                static dereference(l, c) {
                    if (Typed.isTyped(l)) {
                        if (l.type !== c) throw Error(`invalid type: expecetd ${c}, got ${l.type}`);
                        return l.value
                    }
                    return l
                }
            };
            let AddressCoder = class AddressCoder extends Coder {
                constructor(l) {
                    super("address", "address", l, !1)
                }
                defaultValue() {
                    return "0x0000000000000000000000000000000000000000"
                }
                encode(l, c) {
                    let p = Typed.dereference(c, "string");
                    try {
                        p = (0, X.K)(p)
                    } catch (l) {
                        return this._throwError(l.message, c)
                    }
                    return l.writeValue(p)
                }
                decode(l) {
                    return (0, X.K)((0, P.m9)(l.readValue(), 20))
                }
            };
            let AnonymousCoder = class AnonymousCoder extends Coder {
                coder;
                constructor(l) {
                    super(l.name, l.type, "_", l.dynamic), this.coder = l
                }
                defaultValue() {
                    return this.coder.defaultValue()
                }
                encode(l, c) {
                    return this.coder.encode(l, c)
                }
                decode(l) {
                    return this.coder.decode(l)
                }
            };

            function pack(l, c, p) {
                let v = [];
                if (Array.isArray(p)) v = p;
                else if (p && "object" == typeof p) {
                    let l = {};
                    v = c.map(c => {
                        let v = c.localName;
                        return (0, C.hu)(v, "cannot encode object for signature with missing names", "INVALID_ARGUMENT", {
                            argument: "values",
                            info: {
                                coder: c
                            },
                            value: p
                        }), (0, C.hu)(!l[v], "cannot encode object for signature with duplicate names", "INVALID_ARGUMENT", {
                            argument: "values",
                            info: {
                                coder: c
                            },
                            value: p
                        }), l[v] = !0, p[v]
                    })
                } else(0, C.en)(!1, "invalid tuple value", "tuple", p);
                (0, C.en)(c.length === v.length, "types/value length mismatch", "tuple", p);
                let _ = new Writer,
                    P = new Writer,
                    T = [];
                return c.forEach((l, c) => {
                    let p = v[c];
                    if (l.dynamic) {
                        let c = P.length;
                        l.encode(P, p);
                        let v = _.writeUpdatableValue();
                        T.push(l => {
                            v(l + c)
                        })
                    } else l.encode(_, p)
                }), T.forEach(l => {
                    l(_.length)
                }), l.appendWriter(_) + l.appendWriter(P)
            }

            function unpack(l, c) {
                let p = [],
                    v = [],
                    _ = l.subReader(0);
                return c.forEach(c => {
                    let P = null;
                    if (c.dynamic) {
                        let p = l.readIndex(),
                            v = _.subReader(p);
                        try {
                            P = c.decode(v)
                        } catch (l) {
                            if ((0, C.VZ)(l, "BUFFER_OVERRUN")) throw l;
                            (P = l).baseType = c.name, P.name = c.localName, P.type = c.type
                        }
                    } else try {
                        P = c.decode(l)
                    } catch (l) {
                        if ((0, C.VZ)(l, "BUFFER_OVERRUN")) throw l;
                        (P = l).baseType = c.name, P.name = c.localName, P.type = c.type
                    }
                    if (void 0 == P) throw Error("investigate");
                    p.push(P), v.push(c.localName || null)
                }), Result.fromItems(p, v)
            }
            let ArrayCoder = class ArrayCoder extends Coder {
                coder;
                length;
                constructor(l, c, p) {
                    let v = l.type + "[" + (c >= 0 ? c : "") + "]",
                        _ = -1 === c || l.dynamic;
                    super("array", v, p, _), (0, M.h)(this, {
                        coder: l,
                        length: c
                    })
                }
                defaultValue() {
                    let l = this.coder.defaultValue(),
                        c = [];
                    for (let p = 0; p < this.length; p++) c.push(l);
                    return c
                }
                encode(l, c) {
                    let p = Typed.dereference(c, "array");
                    Array.isArray(p) || this._throwError("expected array value", p);
                    let v = this.length; - 1 === v && (v = p.length, l.writeValue(p.length)), (0, C.fG)(p.length, v, "coder array" + (this.localName ? " " + this.localName : ""));
                    let _ = [];
                    for (let l = 0; l < p.length; l++) _.push(this.coder);
                    return pack(l, _, p)
                }
                decode(l) {
                    let c = this.length; - 1 === c && (c = l.readIndex(), (0, C.hu)(32 * c <= l.dataLength, "insufficient data length", "BUFFER_OVERRUN", {
                        buffer: l.bytes,
                        offset: 32 * c,
                        length: l.dataLength
                    }));
                    let p = [];
                    for (let l = 0; l < c; l++) p.push(new AnonymousCoder(this.coder));
                    return unpack(l, p)
                }
            };
            let BooleanCoder = class BooleanCoder extends Coder {
                constructor(l) {
                    super("bool", "bool", l, !1)
                }
                defaultValue() {
                    return !1
                }
                encode(l, c) {
                    let p = Typed.dereference(c, "bool");
                    return l.writeValue(p ? 1 : 0)
                }
                decode(l) {
                    return !!l.readValue()
                }
            };
            let DynamicBytesCoder = class DynamicBytesCoder extends Coder {
                constructor(l, c) {
                    super(l, l, c, !0)
                }
                defaultValue() {
                    return "0x"
                }
                encode(l, c) {
                    return c = (0, T.h_)(c), l.writeValue(c.length) + l.writeBytes(c)
                }
                decode(l) {
                    return l.readBytes(l.readIndex(), !0)
                }
            };
            let BytesCoder = class BytesCoder extends DynamicBytesCoder {
                constructor(l) {
                    super("bytes", l)
                }
                decode(l) {
                    return (0, T.Dv)(super.decode(l))
                }
            };
            let FixedBytesCoder = class FixedBytesCoder extends Coder {
                size;
                constructor(l, c) {
                    let p = "bytes" + String(l);
                    super(p, p, c, !1), (0, M.h)(this, {
                        size: l
                    }, {
                        size: "number"
                    })
                }
                defaultValue() {
                    return "0x0000000000000000000000000000000000000000000000000000000000000000".substring(0, 2 + 2 * this.size)
                }
                encode(l, c) {
                    let p = (0, T.h_)(Typed.dereference(c, this.type));
                    return p.length !== this.size && this._throwError("incorrect data length", c), l.writeBytes(p)
                }
                decode(l) {
                    return (0, T.Dv)(l.readBytes(this.size))
                }
            };
            let el = new Uint8Array([]);
            let NullCoder = class NullCoder extends Coder {
                constructor(l) {
                    super("null", "", l, !1)
                }
                defaultValue() {
                    return null
                }
                encode(l, c) {
                    return null != c && this._throwError("not null", c), l.writeBytes(el)
                }
                decode(l) {
                    return l.readBytes(0), null
                }
            };
            let ec = BigInt(0),
                eh = BigInt(1),
                ed = BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
            let NumberCoder = class NumberCoder extends Coder {
                size;
                signed;
                constructor(l, c, p) {
                    let v = (c ? "int" : "uint") + 8 * l;
                    super(v, v, p, !1), (0, M.h)(this, {
                        size: l,
                        signed: c
                    }, {
                        size: "number",
                        signed: "boolean"
                    })
                }
                defaultValue() {
                    return 0
                }
                encode(l, c) {
                    let p = (0, P.yT)(Typed.dereference(c, this.type)),
                        v = (0, P.sS)(ed, 256);
                    if (this.signed) {
                        let l = (0, P.sS)(v, 8 * this.size - 1);
                        (p > l || p < -(l + eh)) && this._throwError("value out-of-bounds", c), p = (0, P.$j)(p, 256)
                    } else(p < ec || p > (0, P.sS)(v, 8 * this.size)) && this._throwError("value out-of-bounds", c);
                    return l.writeValue(p)
                }
                decode(l) {
                    let c = (0, P.sS)(l.readValue(), 8 * this.size);
                    return this.signed && (c = (0, P._Y)(c, 8 * this.size)), c
                }
            };
            var ef = p(3100);
            let StringCoder = class StringCoder extends DynamicBytesCoder {
                constructor(l) {
                    super("string", l)
                }
                defaultValue() {
                    return ""
                }
                encode(l, c) {
                    return super.encode(l, (0, ef.Y0)(Typed.dereference(c, "string")))
                }
                decode(l) {
                    return (0, ef.ZN)(super.decode(l))
                }
            };
            let TupleCoder = class TupleCoder extends Coder {
                coders;
                constructor(l, c) {
                    let p = !1,
                        v = [];
                    l.forEach(l => {
                        l.dynamic && (p = !0), v.push(l.type)
                    });
                    let _ = "tuple(" + v.join(",") + ")";
                    super("tuple", _, c, p), (0, M.h)(this, {
                        coders: Object.freeze(l.slice())
                    })
                }
                defaultValue() {
                    let l = [];
                    this.coders.forEach(c => {
                        l.push(c.defaultValue())
                    });
                    let c = this.coders.reduce((l, c) => {
                        let p = c.localName;
                        return p && (l[p] || (l[p] = 0), l[p]++), l
                    }, {});
                    return this.coders.forEach((p, v) => {
                        let _ = p.localName;
                        _ && 1 === c[_] && ("length" === _ && (_ = "_length"), null == l[_] && (l[_] = l[v]))
                    }), Object.freeze(l)
                }
                encode(l, c) {
                    let p = Typed.dereference(c, "tuple");
                    return pack(l, this.coders, p)
                }
                decode(l) {
                    return unpack(l, this.coders)
                }
            };
            var ep = p(5930);

            function id(l) {
                return (0, ep.w)((0, ef.Y0)(l))
            }

            function setify(l) {
                let c = new Set;
                return l.forEach(l => c.add(l)), Object.freeze(c)
            }
            let eg = setify("external public payable".split(" ")),
                em = "constant external internal payable private public pure view",
                ey = setify(em.split(" ")),
                eb = "constructor error event fallback function receive struct",
                ew = setify(eb.split(" ")),
                ex = "calldata memory storage payable indexed",
                e_ = setify(ex.split(" ")),
                eE = [eb, ex, "tuple returns", em].join(" "),
                eA = setify(eE.split(" ")),
                eC = {
                    "(": "OPEN_PAREN",
                    ")": "CLOSE_PAREN",
                    "[": "OPEN_BRACKET",
                    "]": "CLOSE_BRACKET",
                    ",": "COMMA",
                    "@": "AT"
                },
                eS = RegExp("^(\\s*)"),
                eN = RegExp("^([0-9]+)"),
                eP = RegExp("^([a-zA-Z$_][a-zA-Z0-9$_]*)"),
                eD = RegExp("^([a-zA-Z$_][a-zA-Z0-9$_]*)$"),
                ek = RegExp("^(address|bool|bytes([0-9]*)|string|u?int([0-9]*))$");
            let TokenString = class TokenString {#
                u;#
                f;
                get offset() {
                    return this.#u
                }
                get length() {
                    return this.#f.length - this.#u
                }
                constructor(l) {
                    this.#u = 0, this.#f = l.slice()
                }
                clone() {
                    return new TokenString(this.#f)
                }
                reset() {
                    this.#u = 0
                }#
                p(l = 0, c = 0) {
                    return new TokenString(this.#f.slice(l, c).map(c => Object.freeze(Object.assign({}, c, {
                        match: c.match - l,
                        linkBack: c.linkBack - l,
                        linkNext: c.linkNext - l
                    }))))
                }
                popKeyword(l) {
                    let c = this.peek();
                    if ("KEYWORD" !== c.type || !l.has(c.text)) throw Error(`expected keyword ${c.text}`);
                    return this.pop().text
                }
                popType(l) {
                    if (this.peek().type !== l) throw Error(`expected ${l}; got ${JSON.stringify(this.peek())}`);
                    return this.pop().text
                }
                popParen() {
                    let l = this.peek();
                    if ("OPEN_PAREN" !== l.type) throw Error("bad start");
                    let c = this.#p(this.#u + 1, l.match + 1);
                    return this.#u = l.match + 1, c
                }
                popParams() {
                    let l = this.peek();
                    if ("OPEN_PAREN" !== l.type) throw Error("bad start");
                    let c = [];
                    for (; this.#u < l.match - 1;) {
                        let l = this.peek().linkNext;
                        c.push(this.#p(this.#u + 1, l)), this.#u = l
                    }
                    return this.#u = l.match + 1, c
                }
                peek() {
                    if (this.#u >= this.#f.length) throw Error("out-of-bounds");
                    return this.#f[this.#u]
                }
                peekKeyword(l) {
                    let c = this.peekType("KEYWORD");
                    return null != c && l.has(c) ? c : null
                }
                peekType(l) {
                    if (0 === this.length) return null;
                    let c = this.peek();
                    return c.type === l ? c.text : null
                }
                pop() {
                    let l = this.peek();
                    return this.#u++, l
                }
                toString() {
                    let l = [];
                    for (let c = this.#u; c < this.#f.length; c++) {
                        let p = this.#f[c];
                        l.push(`${p.type}:${p.text}`)
                    }
                    return `<TokenString ${l.join(" ")}>`
                }
            };

            function lex(l) {
                let c = [],
                    throwError = c => {
                        let p = _ < l.length ? JSON.stringify(l[_]) : "$EOI";
                        throw Error(`invalid token ${p} at ${_}: ${c}`)
                    },
                    p = [],
                    v = [],
                    _ = 0;
                for (; _ < l.length;) {
                    let C = l.substring(_),
                        T = C.match(eS);
                    T && (_ += T[1].length, C = l.substring(_));
                    let M = {
                        depth: p.length,
                        linkBack: -1,
                        linkNext: -1,
                        match: -1,
                        type: "",
                        text: "",
                        offset: _,
                        value: -1
                    };
                    c.push(M);
                    let z = eC[C[0]] || "";
                    if (z) {
                        if (M.type = z, M.text = C[0], _++, "OPEN_PAREN" === z) p.push(c.length - 1), v.push(c.length - 1);
                        else if ("CLOSE_PAREN" == z) 0 === p.length && throwError("no matching open bracket"), M.match = p.pop(), c[M.match].match = c.length - 1, M.depth--, M.linkBack = v.pop(), c[M.linkBack].linkNext = c.length - 1;
                        else if ("COMMA" === z) M.linkBack = v.pop(), c[M.linkBack].linkNext = c.length - 1, v.push(c.length - 1);
                        else if ("OPEN_BRACKET" === z) M.type = "BRACKET";
                        else if ("CLOSE_BRACKET" === z) {
                            let l = c.pop().text;
                            if (c.length > 0 && "NUMBER" === c[c.length - 1].type) {
                                let p = c.pop().text;
                                l = p + l, c[c.length - 1].value = (0, P.Dx)(p)
                            }
                            if (0 === c.length || "BRACKET" !== c[c.length - 1].type) throw Error("missing opening bracket");
                            c[c.length - 1].text += l
                        }
                        continue
                    }
                    if (T = C.match(eP)) {
                        if (M.text = T[1], _ += M.text.length, eA.has(M.text)) {
                            M.type = "KEYWORD";
                            continue
                        }
                        if (M.text.match(ek)) {
                            M.type = "TYPE";
                            continue
                        }
                        M.type = "ID";
                        continue
                    }
                    if (T = C.match(eN)) {
                        M.text = T[1], M.type = "NUMBER", _ += M.text.length;
                        continue
                    }
                    throw Error(`unexpected token ${JSON.stringify(C[0])} at position ${_}`)
                }
                return new TokenString(c.map(l => Object.freeze(l)))
            }

            function allowSingle(l, c) {
                let p = [];
                for (let v in c.keys()) l.has(v) && p.push(v);
                if (p.length > 1) throw Error(`conflicting types: ${p.join(", ")}`)
            }

            function consumeName(l, c) {
                if (c.peekKeyword(ew)) {
                    let p = c.pop().text;
                    if (p !== l) throw Error(`expected ${l}, got ${p}`)
                }
                return c.popType("ID")
            }

            function consumeKeywords(l, c) {
                let p = new Set;
                for (;;) {
                    let v = l.peekType("KEYWORD");
                    if (null == v || c && !c.has(v)) break;
                    if (l.pop(), p.has(v)) throw Error(`duplicate keywords: ${JSON.stringify(v)}`);
                    p.add(v)
                }
                return Object.freeze(p)
            }

            function consumeMutability(l) {
                let c = consumeKeywords(l, ey);
                return (allowSingle(c, setify("constant payable nonpayable".split(" "))), allowSingle(c, setify("pure view payable nonpayable".split(" "))), c.has("view")) ? "view" : c.has("pure") ? "pure" : c.has("payable") ? "payable" : c.has("nonpayable") ? "nonpayable" : c.has("constant") ? "view" : "nonpayable"
            }

            function consumeParams(l, c) {
                return l.popParams().map(l => ParamType.from(l, c))
            }

            function consumeGas(l) {
                if (l.peekType("AT")) {
                    if (l.pop(), l.peekType("NUMBER")) return (0, P.yT)(l.pop().text);
                    throw Error("invalid gas")
                }
                return null
            }

            function consumeEoi(l) {
                if (l.length) throw Error(`unexpected tokens: ${l.toString()}`)
            }
            let eI = new RegExp(/^(.*)\[([0-9]*)\]$/);

            function verifyBasicType(l) {
                let c = l.match(ek);
                if ((0, C.en)(c, "invalid type", "type", l), "uint" === l) return "uint256";
                if ("int" === l) return "int256";
                if (c[2]) {
                    let p = parseInt(c[2]);
                    (0, C.en)(0 !== p && p <= 32, "invalid bytes length", "type", l)
                } else if (c[3]) {
                    let p = parseInt(c[3]);
                    (0, C.en)(0 !== p && p <= 256 && p % 8 == 0, "invalid numeric width", "type", l)
                }
                return l
            }
            let eO = {},
                ej = Symbol.for("_ethers_internal"),
                eT = "_ParamTypeInternal",
                eR = "_ErrorInternal",
                eL = "_EventInternal",
                eM = "_ConstructorInternal",
                eU = "_FallbackInternal",
                eB = "_FunctionInternal",
                eF = "_StructInternal";
            let ParamType = class ParamType {
                name;
                type;
                baseType;
                indexed;
                components;
                arrayLength;
                arrayChildren;
                constructor(l, c, p, v, _, P, T, z) {
                    if ((0, C.NK)(l, eO, "ParamType"), Object.defineProperty(this, ej, {
                            value: eT
                        }), P && (P = Object.freeze(P.slice())), "array" === v) {
                        if (null == T || null == z) throw Error("")
                    } else if (null != T || null != z) throw Error("");
                    if ("tuple" === v) {
                        if (null == P) throw Error("")
                    } else if (null != P) throw Error("");
                    (0, M.h)(this, {
                        name: c,
                        type: p,
                        baseType: v,
                        indexed: _,
                        components: P,
                        arrayLength: T,
                        arrayChildren: z
                    })
                }
                format(l) {
                    if (null == l && (l = "sighash"), "json" === l) {
                        let c = this.name || "";
                        if (this.isArray()) {
                            let l = JSON.parse(this.arrayChildren.format("json"));
                            return l.name = c, l.type += `[${this.arrayLength<0?"":String(this.arrayLength)}]`, JSON.stringify(l)
                        }
                        let p = {
                            type: "tuple" === this.baseType ? "tuple" : this.type,
                            name: c
                        };
                        return "boolean" == typeof this.indexed && (p.indexed = this.indexed), this.isTuple() && (p.components = this.components.map(c => JSON.parse(c.format(l)))), JSON.stringify(p)
                    }
                    let c = "";
                    return this.isArray() ? c += this.arrayChildren.format(l) + `[${this.arrayLength<0?"":String(this.arrayLength)}]` : this.isTuple() ? ("sighash" !== l && (c += this.type), c += "(" + this.components.map(c => c.format(l)).join("full" === l ? ", " : ",") + ")") : c += this.type, "sighash" !== l && (!0 === this.indexed && (c += " indexed"), "full" === l && this.name && (c += " " + this.name)), c
                }
                isArray() {
                    return "array" === this.baseType
                }
                isTuple() {
                    return "tuple" === this.baseType
                }
                isIndexable() {
                    return null != this.indexed
                }
                walk(l, c) {
                    if (this.isArray()) {
                        if (!Array.isArray(l)) throw Error("invalid array value");
                        if (-1 !== this.arrayLength && l.length !== this.arrayLength) throw Error("array is wrong length");
                        let p = this;
                        return l.map(l => p.arrayChildren.walk(l, c))
                    }
                    if (this.isTuple()) {
                        if (!Array.isArray(l)) throw Error("invalid tuple value");
                        if (l.length !== this.components.length) throw Error("array is wrong length");
                        let p = this;
                        return l.map((l, v) => p.components[v].walk(l, c))
                    }
                    return c(this.type, l)
                }#
                g(l, c, p, v) {
                    if (this.isArray()) {
                        if (!Array.isArray(c)) throw Error("invalid array value");
                        if (-1 !== this.arrayLength && c.length !== this.arrayLength) throw Error("array is wrong length");
                        let _ = this.arrayChildren,
                            C = c.slice();
                        C.forEach((c, v) => {
                            _.#g(l, c, p, l => {
                                C[v] = l
                            })
                        }), v(C);
                        return
                    }
                    if (this.isTuple()) {
                        let _;
                        let C = this.components;
                        if (Array.isArray(c)) _ = c.slice();
                        else {
                            if (null == c || "object" != typeof c) throw Error("invalid tuple value");
                            _ = C.map(l => {
                                if (!l.name) throw Error("cannot use object value with unnamed components");
                                if (!(l.name in c)) throw Error(`missing value for component ${l.name}`);
                                return c[l.name]
                            })
                        }
                        if (_.length !== this.components.length) throw Error("array is wrong length");
                        _.forEach((c, v) => {
                            C[v].#g(l, c, p, l => {
                                _[v] = l
                            })
                        }), v(_);
                        return
                    }
                    let _ = p(this.type, c);
                    _.then ? l.push(async function() {
                        v(await _)
                    }()) : v(_)
                }
                async walkAsync(l, c) {
                    let p = [],
                        v = [l];
                    return this.#g(p, l, c, l => {
                        v[0] = l
                    }), p.length && await Promise.all(p), v[0]
                }
                static from(l, c) {
                    if (ParamType.isParamType(l)) return l;
                    if ("string" == typeof l) try {
                        return ParamType.from(lex(l), c)
                    } catch (c) {
                        (0, C.en)(!1, "invalid param type", "obj", l)
                    } else if (l instanceof TokenString) {
                        let p = "",
                            v = "",
                            _ = null;
                        consumeKeywords(l, setify(["tuple"])).has("tuple") || l.peekType("OPEN_PAREN") ? (v = "tuple", _ = l.popParams().map(l => ParamType.from(l)), p = `tuple(${_.map(l=>l.format()).join(",")})`) : v = p = verifyBasicType(l.popType("TYPE"));
                        let C = null,
                            P = null;
                        for (; l.length && l.peekType("BRACKET");) {
                            let c = l.pop();
                            C = new ParamType(eO, "", p, v, null, _, P, C), P = c.value, p += c.text, v = "array", _ = null
                        }
                        let T = null,
                            M = consumeKeywords(l, e_);
                        if (M.has("indexed")) {
                            if (!c) throw Error("");
                            T = !0
                        }
                        let z = l.peekType("ID") ? l.pop().text : "";
                        if (l.length) throw Error("leftover tokens");
                        return new ParamType(eO, z, p, v, T, _, P, C)
                    }
                    let p = l.name;
                    (0, C.en)(!p || "string" == typeof p && p.match(eD), "invalid name", "obj.name", p);
                    let v = l.indexed;
                    null != v && ((0, C.en)(c, "parameter cannot be indexed", "obj.indexed", l.indexed), v = !!v);
                    let _ = l.type,
                        P = _.match(eI);
                    if (P) {
                        let c = parseInt(P[2] || "-1"),
                            C = ParamType.from({
                                type: P[1],
                                components: l.components
                            });
                        return new ParamType(eO, p || "", _, "array", v, null, c, C)
                    }
                    if ("tuple" === _ || _.startsWith("tuple(") || _.startsWith("(")) {
                        let c = null != l.components ? l.components.map(l => ParamType.from(l)) : null,
                            C = new ParamType(eO, p || "", _, "tuple", v, c, null, null);
                        return C
                    }
                    return _ = verifyBasicType(l.type), new ParamType(eO, p || "", _, _, v, null, null, null)
                }
                static isParamType(l) {
                    return l && l[ej] === eT
                }
            };
            let Fragment = class Fragment {
                type;
                inputs;
                constructor(l, c, p) {
                    (0, C.NK)(l, eO, "Fragment"), p = Object.freeze(p.slice()), (0, M.h)(this, {
                        type: c,
                        inputs: p
                    })
                }
                static from(l) {
                    if ("string" == typeof l) {
                        try {
                            Fragment.from(JSON.parse(l))
                        } catch (l) {}
                        return Fragment.from(lex(l))
                    }
                    if (l instanceof TokenString) {
                        let c = l.peekKeyword(ew);
                        switch (c) {
                            case "constructor":
                                return ConstructorFragment.from(l);
                            case "error":
                                return ErrorFragment.from(l);
                            case "event":
                                return EventFragment.from(l);
                            case "fallback":
                            case "receive":
                                return FallbackFragment.from(l);
                            case "function":
                                return FunctionFragment.from(l);
                            case "struct":
                                return StructFragment.from(l)
                        }
                    } else if ("object" == typeof l) {
                        switch (l.type) {
                            case "constructor":
                                return ConstructorFragment.from(l);
                            case "error":
                                return ErrorFragment.from(l);
                            case "event":
                                return EventFragment.from(l);
                            case "fallback":
                            case "receive":
                                return FallbackFragment.from(l);
                            case "function":
                                return FunctionFragment.from(l);
                            case "struct":
                                return StructFragment.from(l)
                        }(0, C.hu)(!1, `unsupported type: ${l.type}`, "UNSUPPORTED_OPERATION", {
                            operation: "Fragment.from"
                        })
                    }(0, C.en)(!1, "unsupported frgament object", "obj", l)
                }
                static isConstructor(l) {
                    return ConstructorFragment.isFragment(l)
                }
                static isError(l) {
                    return ErrorFragment.isFragment(l)
                }
                static isEvent(l) {
                    return EventFragment.isFragment(l)
                }
                static isFunction(l) {
                    return FunctionFragment.isFragment(l)
                }
                static isStruct(l) {
                    return StructFragment.isFragment(l)
                }
            };
            let NamedFragment = class NamedFragment extends Fragment {
                name;
                constructor(l, c, p, v) {
                    super(l, c, v), (0, C.en)("string" == typeof p && p.match(eD), "invalid identifier", "name", p), v = Object.freeze(v.slice()), (0, M.h)(this, {
                        name: p
                    })
                }
            };

            function joinParams(l, c) {
                return "(" + c.map(c => c.format(l)).join("full" === l ? ", " : ",") + ")"
            }
            let ErrorFragment = class ErrorFragment extends NamedFragment {
                constructor(l, c, p) {
                    super(l, "error", c, p), Object.defineProperty(this, ej, {
                        value: eR
                    })
                }
                get selector() {
                    return id(this.format("sighash")).substring(0, 10)
                }
                format(l) {
                    if (null == l && (l = "sighash"), "json" === l) return JSON.stringify({
                        type: "error",
                        name: this.name,
                        inputs: this.inputs.map(c => JSON.parse(c.format(l)))
                    });
                    let c = [];
                    return "sighash" !== l && c.push("error"), c.push(this.name + joinParams(l, this.inputs)), c.join(" ")
                }
                static from(l) {
                    if (ErrorFragment.isFragment(l)) return l;
                    if ("string" == typeof l) return ErrorFragment.from(lex(l));
                    if (l instanceof TokenString) {
                        let c = consumeName("error", l),
                            p = consumeParams(l);
                        return consumeEoi(l), new ErrorFragment(eO, c, p)
                    }
                    return new ErrorFragment(eO, l.name, l.inputs ? l.inputs.map(ParamType.from) : [])
                }
                static isFragment(l) {
                    return l && l[ej] === eR
                }
            };
            let EventFragment = class EventFragment extends NamedFragment {
                anonymous;
                constructor(l, c, p, v) {
                    super(l, "event", c, p), Object.defineProperty(this, ej, {
                        value: eL
                    }), (0, M.h)(this, {
                        anonymous: v
                    })
                }
                get topicHash() {
                    return id(this.format("sighash"))
                }
                format(l) {
                    if (null == l && (l = "sighash"), "json" === l) return JSON.stringify({
                        type: "event",
                        anonymous: this.anonymous,
                        name: this.name,
                        inputs: this.inputs.map(c => JSON.parse(c.format(l)))
                    });
                    let c = [];
                    return "sighash" !== l && c.push("event"), c.push(this.name + joinParams(l, this.inputs)), "sighash" !== l && this.anonymous && c.push("anonymous"), c.join(" ")
                }
                static getTopicHash(l, c) {
                    c = (c || []).map(l => ParamType.from(l));
                    let p = new EventFragment(eO, l, c, !1);
                    return p.topicHash
                }
                static from(l) {
                    if (EventFragment.isFragment(l)) return l;
                    if ("string" == typeof l) try {
                        return EventFragment.from(lex(l))
                    } catch (c) {
                        (0, C.en)(!1, "invalid event fragment", "obj", l)
                    } else if (l instanceof TokenString) {
                        let c = consumeName("event", l),
                            p = consumeParams(l, !0),
                            v = !!consumeKeywords(l, setify(["anonymous"])).has("anonymous");
                        return consumeEoi(l), new EventFragment(eO, c, p, v)
                    }
                    return new EventFragment(eO, l.name, l.inputs ? l.inputs.map(l => ParamType.from(l, !0)) : [], !!l.anonymous)
                }
                static isFragment(l) {
                    return l && l[ej] === eL
                }
            };
            let ConstructorFragment = class ConstructorFragment extends Fragment {
                payable;
                gas;
                constructor(l, c, p, v, _) {
                    super(l, c, p), Object.defineProperty(this, ej, {
                        value: eM
                    }), (0, M.h)(this, {
                        payable: v,
                        gas: _
                    })
                }
                format(l) {
                    if ((0, C.hu)(null != l && "sighash" !== l, "cannot format a constructor for sighash", "UNSUPPORTED_OPERATION", {
                            operation: "format(sighash)"
                        }), "json" === l) return JSON.stringify({
                        type: "constructor",
                        stateMutability: this.payable ? "payable" : "undefined",
                        payable: this.payable,
                        gas: null != this.gas ? this.gas : void 0,
                        inputs: this.inputs.map(c => JSON.parse(c.format(l)))
                    });
                    let c = [`constructor${joinParams(l,this.inputs)}`];
                    return c.push(this.payable ? "payable" : "nonpayable"), null != this.gas && c.push(`@${this.gas.toString()}`), c.join(" ")
                }
                static from(l) {
                    if (ConstructorFragment.isFragment(l)) return l;
                    if ("string" == typeof l) try {
                        return ConstructorFragment.from(lex(l))
                    } catch (c) {
                        (0, C.en)(!1, "invalid constuctor fragment", "obj", l)
                    } else if (l instanceof TokenString) {
                        consumeKeywords(l, setify(["constructor"]));
                        let c = consumeParams(l),
                            p = !!consumeKeywords(l, eg).has("payable"),
                            v = consumeGas(l);
                        return consumeEoi(l), new ConstructorFragment(eO, "constructor", c, p, v)
                    }
                    return new ConstructorFragment(eO, "constructor", l.inputs ? l.inputs.map(ParamType.from) : [], !!l.payable, null != l.gas ? l.gas : null)
                }
                static isFragment(l) {
                    return l && l[ej] === eM
                }
            };
            let FallbackFragment = class FallbackFragment extends Fragment {
                payable;
                constructor(l, c, p) {
                    super(l, "fallback", c), Object.defineProperty(this, ej, {
                        value: eU
                    }), (0, M.h)(this, {
                        payable: p
                    })
                }
                format(l) {
                    let c = 0 === this.inputs.length ? "receive" : "fallback";
                    if ("json" === l) {
                        let l = this.payable ? "payable" : "nonpayable";
                        return JSON.stringify({
                            type: c,
                            stateMutability: l
                        })
                    }
                    return `${c}()${this.payable?" payable":""}`
                }
                static from(l) {
                    if (FallbackFragment.isFragment(l)) return l;
                    if ("string" == typeof l) try {
                        return FallbackFragment.from(lex(l))
                    } catch (c) {
                        (0, C.en)(!1, "invalid fallback fragment", "obj", l)
                    } else if (l instanceof TokenString) {
                        let c = l.toString(),
                            p = l.peekKeyword(setify(["fallback", "receive"]));
                        (0, C.en)(p, "type must be fallback or receive", "obj", c);
                        let v = l.popKeyword(setify(["fallback", "receive"]));
                        if ("receive" === v) {
                            let c = consumeParams(l);
                            return (0, C.en)(0 === c.length, "receive cannot have arguments", "obj.inputs", c), consumeKeywords(l, setify(["payable"])), consumeEoi(l), new FallbackFragment(eO, [], !0)
                        }
                        let _ = consumeParams(l);
                        _.length ? (0, C.en)(1 === _.length && "bytes" === _[0].type, "invalid fallback inputs", "obj.inputs", _.map(l => l.format("minimal")).join(", ")) : _ = [ParamType.from("bytes")];
                        let P = consumeMutability(l);
                        if ((0, C.en)("nonpayable" === P || "payable" === P, "fallback cannot be constants", "obj.stateMutability", P), consumeKeywords(l, setify(["returns"])).has("returns")) {
                            let c = consumeParams(l);
                            (0, C.en)(1 === c.length && "bytes" === c[0].type, "invalid fallback outputs", "obj.outputs", c.map(l => l.format("minimal")).join(", "))
                        }
                        return consumeEoi(l), new FallbackFragment(eO, _, "payable" === P)
                    }
                    if ("receive" === l.type) return new FallbackFragment(eO, [], !0);
                    if ("fallback" === l.type) {
                        let c = [ParamType.from("bytes")],
                            p = "payable" === l.stateMutability;
                        return new FallbackFragment(eO, c, p)
                    }(0, C.en)(!1, "invalid fallback description", "obj", l)
                }
                static isFragment(l) {
                    return l && l[ej] === eU
                }
            };
            let FunctionFragment = class FunctionFragment extends NamedFragment {
                constant;
                outputs;
                stateMutability;
                payable;
                gas;
                constructor(l, c, p, v, _, C) {
                    super(l, "function", c, v), Object.defineProperty(this, ej, {
                        value: eB
                    }), _ = Object.freeze(_.slice());
                    let P = "view" === p || "pure" === p,
                        T = "payable" === p;
                    (0, M.h)(this, {
                        constant: P,
                        gas: C,
                        outputs: _,
                        payable: T,
                        stateMutability: p
                    })
                }
                get selector() {
                    return id(this.format("sighash")).substring(0, 10)
                }
                format(l) {
                    if (null == l && (l = "sighash"), "json" === l) return JSON.stringify({
                        type: "function",
                        name: this.name,
                        constant: this.constant,
                        stateMutability: "nonpayable" !== this.stateMutability ? this.stateMutability : void 0,
                        payable: this.payable,
                        gas: null != this.gas ? this.gas : void 0,
                        inputs: this.inputs.map(c => JSON.parse(c.format(l))),
                        outputs: this.outputs.map(c => JSON.parse(c.format(l)))
                    });
                    let c = [];
                    return "sighash" !== l && c.push("function"), c.push(this.name + joinParams(l, this.inputs)), "sighash" !== l && ("nonpayable" !== this.stateMutability && c.push(this.stateMutability), this.outputs && this.outputs.length && (c.push("returns"), c.push(joinParams(l, this.outputs))), null != this.gas && c.push(`@${this.gas.toString()}`)), c.join(" ")
                }
                static getSelector(l, c) {
                    c = (c || []).map(l => ParamType.from(l));
                    let p = new FunctionFragment(eO, l, "view", c, [], null);
                    return p.selector
                }
                static from(l) {
                    if (FunctionFragment.isFragment(l)) return l;
                    if ("string" == typeof l) try {
                        return FunctionFragment.from(lex(l))
                    } catch (c) {
                        (0, C.en)(!1, "invalid function fragment", "obj", l)
                    } else if (l instanceof TokenString) {
                        let c = consumeName("function", l),
                            p = consumeParams(l),
                            v = consumeMutability(l),
                            _ = [];
                        consumeKeywords(l, setify(["returns"])).has("returns") && (_ = consumeParams(l));
                        let C = consumeGas(l);
                        return consumeEoi(l), new FunctionFragment(eO, c, v, p, _, C)
                    }
                    let c = l.stateMutability;
                    return null != c || (c = "payable", "boolean" == typeof l.constant ? (c = "view", l.constant || (c = "payable", "boolean" != typeof l.payable || l.payable || (c = "nonpayable"))) : "boolean" != typeof l.payable || l.payable || (c = "nonpayable")), new FunctionFragment(eO, l.name, c, l.inputs ? l.inputs.map(ParamType.from) : [], l.outputs ? l.outputs.map(ParamType.from) : [], null != l.gas ? l.gas : null)
                }
                static isFragment(l) {
                    return l && l[ej] === eB
                }
            };
            let StructFragment = class StructFragment extends NamedFragment {
                constructor(l, c, p) {
                    super(l, "struct", c, p), Object.defineProperty(this, ej, {
                        value: eF
                    })
                }
                format() {
                    throw Error("@TODO")
                }
                static from(l) {
                    if ("string" == typeof l) try {
                        return StructFragment.from(lex(l))
                    } catch (c) {
                        (0, C.en)(!1, "invalid struct fragment", "obj", l)
                    } else if (l instanceof TokenString) {
                        let c = consumeName("struct", l),
                            p = consumeParams(l);
                        return consumeEoi(l), new StructFragment(eO, c, p)
                    }
                    return new StructFragment(eO, l.name, l.inputs ? l.inputs.map(ParamType.from) : [])
                }
                static isFragment(l) {
                    return l && l[ej] === eF
                }
            };
            let eH = new Map;
            eH.set(0, "GENERIC_PANIC"), eH.set(1, "ASSERT_FALSE"), eH.set(17, "OVERFLOW"), eH.set(18, "DIVIDE_BY_ZERO"), eH.set(33, "ENUM_RANGE_ERROR"), eH.set(34, "BAD_STORAGE_DATA"), eH.set(49, "STACK_UNDERFLOW"), eH.set(50, "ARRAY_RANGE_ERROR"), eH.set(65, "OUT_OF_MEMORY"), eH.set(81, "UNINITIALIZED_FUNCTION_CALL");
            let eV = new RegExp(/^bytes([0-9]*)$/),
                ez = new RegExp(/^(u?int)([0-9]*)$/),
                eW = null;
            let AbiCoder = class AbiCoder {#
                m(l) {
                    if (l.isArray()) return new ArrayCoder(this.#m(l.arrayChildren), l.arrayLength, l.name);
                    if (l.isTuple()) return new TupleCoder(l.components.map(l => this.#m(l)), l.name);
                    switch (l.baseType) {
                        case "address":
                            return new AddressCoder(l.name);
                        case "bool":
                            return new BooleanCoder(l.name);
                        case "string":
                            return new StringCoder(l.name);
                        case "bytes":
                            return new BytesCoder(l.name);
                        case "":
                            return new NullCoder(l.name)
                    }
                    let c = l.type.match(ez);
                    if (c) {
                        let p = parseInt(c[2] || "256");
                        return (0, C.en)(0 !== p && p <= 256 && p % 8 == 0, "invalid " + c[1] + " bit length", "param", l), new NumberCoder(p / 8, "int" === c[1], l.name)
                    }
                    if (c = l.type.match(eV)) {
                        let p = parseInt(c[1]);
                        return (0, C.en)(0 !== p && p <= 32, "invalid bytes length", "param", l), new FixedBytesCoder(p, l.name)
                    }(0, C.en)(!1, "invalid type", "type", l.type)
                }
                getDefaultValue(l) {
                    let c = l.map(l => this.#m(ParamType.from(l))),
                        p = new TupleCoder(c, "_");
                    return p.defaultValue()
                }
                encode(l, c) {
                    (0, C.fG)(c.length, l.length, "types/values length mismatch");
                    let p = l.map(l => this.#m(ParamType.from(l))),
                        v = new TupleCoder(p, "_"),
                        _ = new Writer;
                    return v.encode(_, c), _.data
                }
                decode(l, c, p) {
                    let v = l.map(l => this.#m(ParamType.from(l))),
                        _ = new TupleCoder(v, "_");
                    return _.decode(new Reader(c, p))
                }
                static defaultAbiCoder() {
                    return null == eW && (eW = new AbiCoder), eW
                }
                static getBuiltinCallException(l, c, p) {
                    return function(l, c, p, v) {
                        let _ = "missing revert data",
                            P = null,
                            M = null;
                        if (p) {
                            _ = "execution reverted";
                            let l = (0, T.Pw)(p);
                            if (p = (0, T.Dv)(p), 0 === l.length) _ += " (no data present; likely require(false) occurred", P = "require(false)";
                            else if (l.length % 32 != 4) _ += " (could not decode reason; invalid data length)";
                            else if ("0x08c379a0" === (0, T.Dv)(l.slice(0, 4))) try {
                                P = v.decode(["string"], l.slice(4))[0], M = {
                                    signature: "Error(string)",
                                    name: "Error",
                                    args: [P]
                                }, _ += `: ${JSON.stringify(P)}`
                            } catch (l) {
                                _ += " (could not decode reason; invalid string data)"
                            } else if ("0x4e487b71" === (0, T.Dv)(l.slice(0, 4))) try {
                                let c = Number(v.decode(["uint256"], l.slice(4))[0]);
                                M = {
                                    signature: "Panic(uint256)",
                                    name: "Panic",
                                    args: [c]
                                }, P = `Panic due to ${eH.get(c)||"UNKNOWN"}(${c})`, _ += `: ${P}`
                            } catch (l) {
                                _ += " (could not decode panic code)"
                            } else _ += " (unknown custom error)"
                        }
                        let z = {
                            to: c.to ? (0, X.K)(c.to) : null,
                            data: c.data || "0x"
                        };
                        return c.from && (z.from = (0, X.K)(c.from)), (0, C.wf)(_, "CALL_EXCEPTION", {
                            action: l,
                            data: p,
                            reason: P,
                            transaction: z,
                            invocation: null,
                            revert: M
                        })
                    }(l, c, p, AbiCoder.defaultAbiCoder())
                }
            };

            function isAddressable(l) {
                return l && "function" == typeof l.getAddress
            }
            async function checkAddress(l, c) {
                let p = await c;
                return (null == p || "0x0000000000000000000000000000000000000000" === p) && ((0, C.hu)("string" != typeof l, "unconfigured name", "UNCONFIGURED_NAME", {
                    value: l
                }), (0, C.en)(!1, "invalid AddressLike value; did not resolve to a value address", "target", l)), (0, X.K)(p)
            }

            function resolveAddress(l, c) {
                return "string" == typeof l ? l.match(/^0x[0-9a-f]{40}$/i) ? (0, X.K)(l) : ((0, C.hu)(null != c, "ENS resolution requires a provider", "UNSUPPORTED_OPERATION", {
                    operation: "resolveName"
                }), checkAddress(l, c.resolveName(l))) : isAddressable(l) ? checkAddress(l, l.getAddress()) : l && "function" == typeof l.then ? checkAddress(l, l) : void(0, C.en)(!1, "unsupported addressable value", "target", l)
            }
            let eG = new Uint8Array(32);
            eG.fill(0);
            let eK = BigInt(-1),
                eZ = BigInt(0),
                eJ = BigInt(1),
                eQ = BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"),
                e$ = (0, P.m9)(eJ, 32),
                eY = (0, P.m9)(eZ, 32),
                eX = {
                    name: "string",
                    version: "string",
                    chainId: "uint256",
                    verifyingContract: "address",
                    salt: "bytes32"
                },
                e0 = ["name", "version", "chainId", "verifyingContract", "salt"];

            function checkString(l) {
                return function(c) {
                    return (0, C.en)("string" == typeof c, `invalid domain value for ${JSON.stringify(l)}`, `domain.${l}`, c), c
                }
            }
            let e1 = {
                name: checkString("name"),
                version: checkString("version"),
                chainId: function(l) {
                    let c = (0, P.yT)(l, "domain.chainId");
                    return ((0, C.en)(c >= 0, "invalid chain ID", "domain.chainId", l), Number.isSafeInteger(c)) ? Number(c) : (0, P.B4)(c)
                },
                verifyingContract: function(l) {
                    try {
                        return (0, X.K)(l).toLowerCase()
                    } catch (l) {}(0, C.en)(!1, 'invalid domain value "verifyingContract"', "domain.verifyingContract", l)
                },
                salt: function(l) {
                    let c = (0, T.Pw)(l, "domain.salt");
                    return (0, C.en)(32 === c.length, 'invalid domain value "salt"', "domain.salt", l), (0, T.Dv)(c)
                }
            };

            function getBaseEncoder(l) {
                {
                    let c = l.match(/^(u?)int(\d*)$/);
                    if (c) {
                        let p = "" === c[1],
                            v = parseInt(c[2] || "256");
                        (0, C.en)(v % 8 == 0 && 0 !== v && v <= 256 && (null == c[2] || c[2] === String(v)), "invalid numeric width", "type", l);
                        let _ = (0, P.sS)(eQ, p ? v - 1 : v),
                            T = p ? (_ + eJ) * eK : eZ;
                        return function(c) {
                            let v = (0, P.yT)(c, "value");
                            return (0, C.en)(v >= T && v <= _, `value out-of-bounds for ${l}`, "value", v), (0, P.m9)(p ? (0, P.$j)(v, 256) : v, 32)
                        }
                    }
                } {
                    let c = l.match(/^bytes(\d+)$/);
                    if (c) {
                        let p = parseInt(c[1]);
                        return (0, C.en)(0 !== p && p <= 32 && c[1] === String(p), "invalid bytes width", "type", l),
                            function(c) {
                                let v = (0, T.Pw)(c);
                                return (0, C.en)(v.length === p, `invalid length for ${l}`, "value", c),
                                    function(l) {
                                        let c = (0, T.Pw)(l),
                                            p = c.length % 32;
                                        return p ? (0, T.zo)([c, eG.slice(p)]) : (0, T.Dv)(c)
                                    }(c)
                            }
                    }
                }
                switch (l) {
                    case "address":
                        return function(l) {
                            return (0, T.U3)((0, X.K)(l), 32)
                        };
                    case "bool":
                        return function(l) {
                            return l ? e$ : eY
                        };
                    case "bytes":
                        return function(l) {
                            return (0, ep.w)(l)
                        };
                    case "string":
                        return function(l) {
                            return id(l)
                        }
                }
                return null
            }

            function encodeType(l, c) {
                return `${l}(${c.map(({name:l,type:c})=>c+" "+l).join(",")})`
            }
            let TypedDataEncoder = class TypedDataEncoder {
                primaryType;#
                y;
                get types() {
                    return JSON.parse(this.#y)
                }#
                v;#
                b;
                constructor(l) {
                    this.#y = JSON.stringify(l), this.#v = new Map, this.#b = new Map;
                    let c = new Map,
                        p = new Map,
                        v = new Map;
                    for (let _ in Object.keys(l).forEach(l => {
                            c.set(l, new Set), p.set(l, []), v.set(l, new Set)
                        }), l) {
                        let v = new Set;
                        for (let P of l[_]) {
                            (0, C.en)(!v.has(P.name), `duplicate variable name ${JSON.stringify(P.name)} in ${JSON.stringify(_)}`, "types", l), v.add(P.name);
                            let T = P.type.match(/^([^\x5b]*)(\x5b|$)/)[1] || null;
                            (0, C.en)(T !== _, `circular type reference to ${JSON.stringify(T)}`, "types", l);
                            let M = getBaseEncoder(T);
                            M || ((0, C.en)(p.has(T), `unknown type ${JSON.stringify(T)}`, "types", l), p.get(T).push(_), c.get(_).add(T))
                        }
                    }
                    let _ = Array.from(p.keys()).filter(l => 0 === p.get(l).length);
                    for (let [P, T] of ((0, C.en)(0 !== _.length, "missing primary type", "types", l), (0, C.en)(1 === _.length, `ambiguous primary types or unused types: ${_.map(l=>JSON.stringify(l)).join(", ")}`, "types", l), (0, M.h)(this, {
                            primaryType: _[0]
                        }), ! function checkCircular(_, P) {
                            for (let T of ((0, C.en)(!P.has(_), `circular type reference to ${JSON.stringify(_)}`, "types", l), P.add(_), c.get(_)))
                                if (p.has(T))
                                    for (let l of (checkCircular(T, P), P)) v.get(l).add(T);
                            P.delete(_)
                        }(this.primaryType, new Set), v)) {
                        let c = Array.from(T);
                        c.sort(), this.#v.set(P, encodeType(P, l[P]) + c.map(c => encodeType(c, l[c])).join(""))
                    }
                }
                getEncoder(l) {
                    let c = this.#b.get(l);
                    return c || (c = this.#w(l), this.#b.set(l, c)), c
                }#
                w(l) {
                    {
                        let c = getBaseEncoder(l);
                        if (c) return c
                    }
                    let c = l.match(/^(.*)(\x5b(\d*)\x5d)$/);
                    if (c) {
                        let l = c[1],
                            p = this.getEncoder(l);
                        return v => {
                            (0, C.en)(!c[3] || parseInt(c[3]) === v.length, `array length mismatch; expected length ${parseInt(c[3])}`, "value", v);
                            let _ = v.map(p);
                            return this.#v.has(l) && (_ = _.map(ep.w)), (0, ep.w)((0, T.zo)(_))
                        }
                    }
                    let p = this.types[l];
                    if (p) {
                        let c = id(this.#v.get(l));
                        return l => {
                            let v = p.map(({
                                name: c,
                                type: p
                            }) => {
                                let v = this.getEncoder(p)(l[c]);
                                return this.#v.has(p) ? (0, ep.w)(v) : v
                            });
                            return v.unshift(c), (0, T.zo)(v)
                        }
                    }(0, C.en)(!1, `unknown type: ${l}`, "type", l)
                }
                encodeType(l) {
                    let c = this.#v.get(l);
                    return (0, C.en)(c, `unknown type: ${JSON.stringify(l)}`, "name", l), c
                }
                encodeData(l, c) {
                    return this.getEncoder(l)(c)
                }
                hashStruct(l, c) {
                    return (0, ep.w)(this.encodeData(l, c))
                }
                encode(l) {
                    return this.encodeData(this.primaryType, l)
                }
                hash(l) {
                    return this.hashStruct(this.primaryType, l)
                }
                _visit(l, c, p) {
                    {
                        let v = getBaseEncoder(l);
                        if (v) return p(l, c)
                    }
                    let v = l.match(/^(.*)(\x5b(\d*)\x5d)$/);
                    if (v) return (0, C.en)(!v[3] || parseInt(v[3]) === c.length, `array length mismatch; expected length ${parseInt(v[3])}`, "value", c), c.map(l => this._visit(v[1], l, p));
                    let _ = this.types[l];
                    if (_) return _.reduce((l, {
                        name: v,
                        type: _
                    }) => (l[v] = this._visit(_, c[v], p), l), {});
                    (0, C.en)(!1, `unknown type: ${l}`, "type", l)
                }
                visit(l, c) {
                    return this._visit(this.primaryType, l, c)
                }
                static from(l) {
                    return new TypedDataEncoder(l)
                }
                static getPrimaryType(l) {
                    return TypedDataEncoder.from(l).primaryType
                }
                static hashStruct(l, c, p) {
                    return TypedDataEncoder.from(c).hashStruct(l, p)
                }
                static hashDomain(l) {
                    let c = [];
                    for (let p in l) {
                        if (null == l[p]) continue;
                        let v = eX[p];
                        (0, C.en)(v, `invalid typed-data domain key: ${JSON.stringify(p)}`, "domain", l), c.push({
                            name: p,
                            type: v
                        })
                    }
                    return c.sort((l, c) => e0.indexOf(l.name) - e0.indexOf(c.name)), TypedDataEncoder.hashStruct("EIP712Domain", {
                        EIP712Domain: c
                    }, l)
                }
                static encode(l, c, p) {
                    return (0, T.zo)(["0x1901", TypedDataEncoder.hashDomain(l), TypedDataEncoder.from(c).hash(p)])
                }
                static hash(l, c, p) {
                    return (0, ep.w)(TypedDataEncoder.encode(l, c, p))
                }
                static async resolveNames(l, c, p, v) {
                    for (let c in l = Object.assign({}, l)) null == l[c] && delete l[c];
                    let _ = {};
                    l.verifyingContract && !(0, T.A7)(l.verifyingContract, 20) && (_[l.verifyingContract] = "0x");
                    let C = TypedDataEncoder.from(c);
                    for (let l in C.visit(p, (l, c) => ("address" !== l || (0, T.A7)(c, 20) || (_[c] = "0x"), c)), _) _[l] = await v(l);
                    return l.verifyingContract && _[l.verifyingContract] && (l.verifyingContract = _[l.verifyingContract]), {
                        domain: l,
                        value: p = C.visit(p, (l, c) => "address" === l && _[c] ? _[c] : c)
                    }
                }
                static getPayload(l, c, p) {
                    TypedDataEncoder.hashDomain(l);
                    let v = {},
                        _ = [];
                    e0.forEach(c => {
                        let p = l[c];
                        null != p && (v[c] = e1[c](p), _.push({
                            name: c,
                            type: eX[c]
                        }))
                    });
                    let M = TypedDataEncoder.from(c),
                        z = Object.assign({}, c);
                    return (0, C.en)(null == z.EIP712Domain, "types must not contain EIP712Domain type", "types.EIP712Domain", c), z.EIP712Domain = _, M.encode(p), {
                        types: z,
                        domain: v,
                        primaryType: M.primaryType,
                        message: M.visit(p, (l, c) => {
                            if (l.match(/^bytes(\d*)/)) return (0, T.Dv)((0, T.Pw)(c));
                            if (l.match(/^u?int/)) return (0, P.yT)(c).toString();
                            switch (l) {
                                case "address":
                                    return c.toLowerCase();
                                case "bool":
                                    return !!c;
                                case "string":
                                    return (0, C.en)("string" == typeof c, "invalid string", "value", c), c
                            }(0, C.en)(!1, "unsupported type", "type", l)
                        })
                    }
                }
            };
            var e2 = p(2204);
            let e5 = "0x0000000000000000000000000000000000000000";
            let LogDescription = class LogDescription {
                fragment;
                name;
                signature;
                topic;
                args;
                constructor(l, c, p) {
                    let v = l.name,
                        _ = l.format();
                    (0, M.h)(this, {
                        fragment: l,
                        name: v,
                        signature: _,
                        topic: c,
                        args: p
                    })
                }
            };
            let TransactionDescription = class TransactionDescription {
                fragment;
                name;
                args;
                signature;
                selector;
                value;
                constructor(l, c, p, v) {
                    let _ = l.name,
                        C = l.format();
                    (0, M.h)(this, {
                        fragment: l,
                        name: _,
                        args: p,
                        signature: C,
                        selector: c,
                        value: v
                    })
                }
            };
            let ErrorDescription = class ErrorDescription {
                fragment;
                name;
                args;
                signature;
                selector;
                constructor(l, c, p) {
                    let v = l.name,
                        _ = l.format();
                    (0, M.h)(this, {
                        fragment: l,
                        name: v,
                        args: p,
                        signature: _,
                        selector: c
                    })
                }
            };
            let Indexed = class Indexed {
                hash;
                _isIndexed;
                static isIndexed(l) {
                    return !!(l && l._isIndexed)
                }
                constructor(l) {
                    (0, M.h)(this, {
                        hash: l,
                        _isIndexed: !0
                    })
                }
            };
            let e3 = {
                    0: "generic panic",
                    1: "assert(false)",
                    17: "arithmetic overflow",
                    18: "division or modulo by zero",
                    33: "enum overflow",
                    34: "invalid encoded storage byte array accessed",
                    49: "out-of-bounds array access; popping on an empty array",
                    50: "out-of-bounds access of an array or bytesN",
                    65: "out of memory",
                    81: "uninitialized function"
                },
                e6 = {
                    "0x08c379a0": {
                        signature: "Error(string)",
                        name: "Error",
                        inputs: ["string"],
                        reason: l => `reverted with reason string ${JSON.stringify(l)}`
                    },
                    "0x4e487b71": {
                        signature: "Panic(uint256)",
                        name: "Panic",
                        inputs: ["uint256"],
                        reason: l => {
                            let c = "unknown panic code";
                            return l >= 0 && l <= 255 && e3[l.toString()] && (c = e3[l.toString()]), `reverted with panic code 0x${l.toString(16)} (${c})`
                        }
                    }
                };
            let Interface = class Interface {
                fragments;
                deploy;
                fallback;
                receive;#
                x;#
                _;#
                E;#
                A;
                constructor(l) {
                    let c = [];
                    c = "string" == typeof l ? JSON.parse(l) : l, this.#E = new Map, this.#x = new Map, this.#_ = new Map;
                    let p = [];
                    for (let l of c) try {
                        p.push(Fragment.from(l))
                    } catch (l) {
                        console.log("EE", l)
                    }(0, M.h)(this, {
                        fragments: Object.freeze(p)
                    });
                    let v = null,
                        _ = !1;
                    this.#A = this.getAbiCoder(), this.fragments.forEach((l, c) => {
                        let p;
                        switch (l.type) {
                            case "constructor":
                                if (this.deploy) {
                                    console.log("duplicate definition - constructor");
                                    return
                                }(0, M.h)(this, {
                                    deploy: l
                                });
                                return;
                            case "fallback":
                                0 === l.inputs.length ? _ = !0 : ((0, C.en)(!v || l.payable !== v.payable, "conflicting fallback fragments", `fragments[${c}]`, l), _ = (v = l).payable);
                                return;
                            case "function":
                                p = this.#E;
                                break;
                            case "event":
                                p = this.#_;
                                break;
                            case "error":
                                p = this.#x;
                                break;
                            default:
                                return
                        }
                        let P = l.format();
                        p.has(P) || p.set(P, l)
                    }), this.deploy || (0, M.h)(this, {
                        deploy: ConstructorFragment.from("constructor()")
                    }), (0, M.h)(this, {
                        fallback: v,
                        receive: _
                    })
                }
                format(l) {
                    let c = l ? "minimal" : "full",
                        p = this.fragments.map(l => l.format(c));
                    return p
                }
                formatJson() {
                    let l = this.fragments.map(l => l.format("json"));
                    return JSON.stringify(l.map(l => JSON.parse(l)))
                }
                getAbiCoder() {
                    return AbiCoder.defaultAbiCoder()
                }#
                C(l, c, p) {
                    if ((0, T.A7)(l)) {
                        let c = l.toLowerCase();
                        for (let l of this.#E.values())
                            if (c === l.selector) return l;
                        return null
                    }
                    if (-1 === l.indexOf("(")) {
                        let v = [];
                        for (let [c, p] of this.#E) c.split("(")[0] === l && v.push(p);
                        if (c) {
                            let l = c.length > 0 ? c[c.length - 1] : null,
                                p = c.length,
                                _ = !0;
                            Typed.isTyped(l) && "overrides" === l.type && (_ = !1, p--);
                            for (let l = v.length - 1; l >= 0; l--) {
                                let c = v[l].inputs.length;
                                c === p || _ && c === p - 1 || v.splice(l, 1)
                            }
                            for (let l = v.length - 1; l >= 0; l--) {
                                let p = v[l].inputs;
                                for (let _ = 0; _ < c.length; _++)
                                    if (Typed.isTyped(c[_])) {
                                        if (_ >= p.length) {
                                            if ("overrides" === c[_].type) continue;
                                            v.splice(l, 1);
                                            break
                                        }
                                        if (c[_].type !== p[_].baseType) {
                                            v.splice(l, 1);
                                            break
                                        }
                                    }
                            }
                        }
                        if (1 === v.length && c && c.length !== v[0].inputs.length) {
                            let l = c[c.length - 1];
                            (null == l || Array.isArray(l) || "object" != typeof l) && v.splice(0, 1)
                        }
                        if (0 === v.length) return null;
                        if (v.length > 1 && p) {
                            let c = v.map(l => JSON.stringify(l.format())).join(", ");
                            (0, C.en)(!1, `ambiguous function description (i.e. matches ${c})`, "key", l)
                        }
                        return v[0]
                    }
                    let v = this.#E.get(FunctionFragment.from(l).format());
                    return v || null
                }
                getFunctionName(l) {
                    let c = this.#C(l, null, !1);
                    return (0, C.en)(c, "no matching function", "key", l), c.name
                }
                hasFunction(l) {
                    return !!this.#C(l, null, !1)
                }
                getFunction(l, c) {
                    return this.#C(l, c || null, !0)
                }
                forEachFunction(l) {
                    let c = Array.from(this.#E.keys());
                    c.sort((l, c) => l.localeCompare(c));
                    for (let p = 0; p < c.length; p++) {
                        let v = c[p];
                        l(this.#E.get(v), p)
                    }
                }#
                S(l, c, p) {
                    if ((0, T.A7)(l)) {
                        let c = l.toLowerCase();
                        for (let l of this.#_.values())
                            if (c === l.topicHash) return l;
                        return null
                    }
                    if (-1 === l.indexOf("(")) {
                        let v = [];
                        for (let [c, p] of this.#_) c.split("(")[0] === l && v.push(p);
                        if (c) {
                            for (let l = v.length - 1; l >= 0; l--) v[l].inputs.length < c.length && v.splice(l, 1);
                            for (let l = v.length - 1; l >= 0; l--) {
                                let p = v[l].inputs;
                                for (let _ = 0; _ < c.length; _++)
                                    if (Typed.isTyped(c[_]) && c[_].type !== p[_].baseType) {
                                        v.splice(l, 1);
                                        break
                                    }
                            }
                        }
                        if (0 === v.length) return null;
                        if (v.length > 1 && p) {
                            let c = v.map(l => JSON.stringify(l.format())).join(", ");
                            (0, C.en)(!1, `ambiguous event description (i.e. matches ${c})`, "key", l)
                        }
                        return v[0]
                    }
                    let v = this.#_.get(EventFragment.from(l).format());
                    return v || null
                }
                getEventName(l) {
                    let c = this.#S(l, null, !1);
                    return (0, C.en)(c, "no matching event", "key", l), c.name
                }
                hasEvent(l) {
                    return !!this.#S(l, null, !1)
                }
                getEvent(l, c) {
                    return this.#S(l, c || null, !0)
                }
                forEachEvent(l) {
                    let c = Array.from(this.#_.keys());
                    c.sort((l, c) => l.localeCompare(c));
                    for (let p = 0; p < c.length; p++) {
                        let v = c[p];
                        l(this.#_.get(v), p)
                    }
                }
                getError(l, c) {
                    if ((0, T.A7)(l)) {
                        let c = l.toLowerCase();
                        if (e6[c]) return ErrorFragment.from(e6[c].signature);
                        for (let l of this.#x.values())
                            if (c === l.selector) return l;
                        return null
                    }
                    if (-1 === l.indexOf("(")) {
                        let c = [];
                        for (let [p, v] of this.#x) p.split("(")[0] === l && c.push(v);
                        if (0 === c.length) return "Error" === l ? ErrorFragment.from("error Error(string)") : "Panic" === l ? ErrorFragment.from("error Panic(uint256)") : null;
                        if (c.length > 1) {
                            let p = c.map(l => JSON.stringify(l.format())).join(", ");
                            (0, C.en)(!1, `ambiguous error description (i.e. ${p})`, "name", l)
                        }
                        return c[0]
                    }
                    if ("Error(string)" === (l = ErrorFragment.from(l).format())) return ErrorFragment.from("error Error(string)");
                    if ("Panic(uint256)" === l) return ErrorFragment.from("error Panic(uint256)");
                    let p = this.#x.get(l);
                    return p || null
                }
                forEachError(l) {
                    let c = Array.from(this.#x.keys());
                    c.sort((l, c) => l.localeCompare(c));
                    for (let p = 0; p < c.length; p++) {
                        let v = c[p];
                        l(this.#x.get(v), p)
                    }
                }
                _decodeParams(l, c) {
                    return this.#A.decode(l, c)
                }
                _encodeParams(l, c) {
                    return this.#A.encode(l, c)
                }
                encodeDeploy(l) {
                    return this._encodeParams(this.deploy.inputs, l || [])
                }
                decodeErrorResult(l, c) {
                    if ("string" == typeof l) {
                        let c = this.getError(l);
                        (0, C.en)(c, "unknown error", "fragment", l), l = c
                    }
                    return (0, C.en)((0, T.QB)(c, 0, 4) === l.selector, `data signature does not match error ${l.name}.`, "data", c), this._decodeParams(l.inputs, (0, T.QB)(c, 4))
                }
                encodeErrorResult(l, c) {
                    if ("string" == typeof l) {
                        let c = this.getError(l);
                        (0, C.en)(c, "unknown error", "fragment", l), l = c
                    }
                    return (0, T.zo)([l.selector, this._encodeParams(l.inputs, c || [])])
                }
                decodeFunctionData(l, c) {
                    if ("string" == typeof l) {
                        let c = this.getFunction(l);
                        (0, C.en)(c, "unknown function", "fragment", l), l = c
                    }
                    return (0, C.en)((0, T.QB)(c, 0, 4) === l.selector, `data signature does not match function ${l.name}.`, "data", c), this._decodeParams(l.inputs, (0, T.QB)(c, 4))
                }
                encodeFunctionData(l, c) {
                    if ("string" == typeof l) {
                        let c = this.getFunction(l);
                        (0, C.en)(c, "unknown function", "fragment", l), l = c
                    }
                    return (0, T.zo)([l.selector, this._encodeParams(l.inputs, c || [])])
                }
                decodeFunctionResult(l, c) {
                    if ("string" == typeof l) {
                        let c = this.getFunction(l);
                        (0, C.en)(c, "unknown function", "fragment", l), l = c
                    }
                    let p = "invalid length for result data",
                        v = (0, T.h_)(c);
                    if (v.length % 32 == 0) try {
                        return this.#A.decode(l.outputs, v)
                    } catch (l) {
                        p = "could not decode result data"
                    }(0, C.hu)(!1, p, "BAD_DATA", {
                        value: (0, T.Dv)(v),
                        info: {
                            method: l.name,
                            signature: l.format()
                        }
                    })
                }
                makeError(l, c) {
                    let p = (0, T.Pw)(l, "data"),
                        v = AbiCoder.getBuiltinCallException("call", c, p);
                    if (v.message.startsWith("execution reverted (unknown custom error)")) {
                        let l = (0, T.Dv)(p.slice(0, 4)),
                            c = this.getError(l);
                        if (c) try {
                            let l = this.#A.decode(c.inputs, p.slice(4));
                            v.revert = {
                                name: c.name,
                                signature: c.format(),
                                args: l
                            }, v.reason = v.revert.signature, v.message = `execution reverted: ${v.reason}`
                        } catch (l) {
                            v.message = "execution reverted (coult not decode custom error)"
                        }
                    }
                    let _ = this.parseTransaction(c);
                    return _ && (v.invocation = {
                        method: _.name,
                        signature: _.signature,
                        args: _.args
                    }), v
                }
                encodeFunctionResult(l, c) {
                    if ("string" == typeof l) {
                        let c = this.getFunction(l);
                        (0, C.en)(c, "unknown function", "fragment", l), l = c
                    }
                    return (0, T.Dv)(this.#A.encode(l.outputs, c || []))
                }
                encodeFilterTopics(l, c) {
                    if ("string" == typeof l) {
                        let c = this.getEvent(l);
                        (0, C.en)(c, "unknown event", "eventFragment", l), l = c
                    }(0, C.hu)(c.length <= l.inputs.length, `too many arguments for ${l.format()}`, "UNEXPECTED_ARGUMENT", {
                        count: c.length,
                        expectedCount: l.inputs.length
                    });
                    let p = [];
                    l.anonymous || p.push(l.topicHash);
                    let encodeTopic = (l, c) => "string" === l.type ? id(c) : "bytes" === l.type ? (0, ep.w)((0, T.Dv)(c)) : ("bool" === l.type && "boolean" == typeof c ? c = c ? "0x01" : "0x00" : l.type.match(/^u?int/) ? c = (0, P.m9)(c) : l.type.match(/^bytes/) ? c = (0, T.SK)(c, 32) : "address" === l.type && this.#A.encode(["address"], [c]), (0, T.U3)((0, T.Dv)(c), 32));
                    for (c.forEach((c, v) => {
                            let _ = l.inputs[v];
                            if (!_.indexed) {
                                (0, C.en)(null == c, "cannot filter non-indexed parameters; must be null", "contract." + _.name, c);
                                return
                            }
                            null == c ? p.push(null) : "array" === _.baseType || "tuple" === _.baseType ? (0, C.en)(!1, "filtering with tuples or arrays not supported", "contract." + _.name, c) : Array.isArray(c) ? p.push(c.map(l => encodeTopic(_, l))) : p.push(encodeTopic(_, c))
                        }); p.length && null === p[p.length - 1];) p.pop();
                    return p
                }
                encodeEventLog(l, c) {
                    if ("string" == typeof l) {
                        let c = this.getEvent(l);
                        (0, C.en)(c, "unknown event", "eventFragment", l), l = c
                    }
                    let p = [],
                        v = [],
                        _ = [];
                    return l.anonymous || p.push(l.topicHash), (0, C.en)(c.length === l.inputs.length, "event arguments/values mismatch", "values", c), l.inputs.forEach((l, C) => {
                        let P = c[C];
                        if (l.indexed) {
                            if ("string" === l.type) p.push(id(P));
                            else if ("bytes" === l.type) p.push((0, ep.w)(P));
                            else if ("tuple" === l.baseType || "array" === l.baseType) throw Error("not implemented");
                            else p.push(this.#A.encode([l.type], [P]))
                        } else v.push(l), _.push(P)
                    }), {
                        data: this.#A.encode(v, _),
                        topics: p
                    }
                }
                decodeEventLog(l, c, p) {
                    if ("string" == typeof l) {
                        let c = this.getEvent(l);
                        (0, C.en)(c, "unknown event", "eventFragment", l), l = c
                    }
                    if (null != p && !l.anonymous) {
                        let c = l.topicHash;
                        (0, C.en)((0, T.A7)(p[0], 32) && p[0].toLowerCase() === c, "fragment/topic mismatch", "topics[0]", p[0]), p = p.slice(1)
                    }
                    let v = [],
                        _ = [],
                        P = [];
                    l.inputs.forEach((l, c) => {
                        l.indexed ? "string" === l.type || "bytes" === l.type || "tuple" === l.baseType || "array" === l.baseType ? (v.push(ParamType.from({
                            type: "bytes32",
                            name: l.name
                        })), P.push(!0)) : (v.push(l), P.push(!1)) : (_.push(l), P.push(!1))
                    });
                    let M = null != p ? this.#A.decode(v, (0, T.zo)(p)) : null,
                        z = this.#A.decode(_, c, !0),
                        J = [],
                        Q = [],
                        X = 0,
                        es = 0;
                    return l.inputs.forEach((l, c) => {
                        let p = null;
                        if (l.indexed) {
                            if (null == M) p = new Indexed(null);
                            else if (P[c]) p = new Indexed(M[es++]);
                            else try {
                                p = M[es++]
                            } catch (l) {
                                p = l
                            }
                        } else try {
                            p = z[X++]
                        } catch (l) {
                            p = l
                        }
                        J.push(p), Q.push(l.name || null)
                    }), Result.fromItems(J, Q)
                }
                parseTransaction(l) {
                    let c = (0, T.Pw)(l.data, "tx.data"),
                        p = (0, P.yT)(null != l.value ? l.value : 0, "tx.value"),
                        v = this.getFunction((0, T.Dv)(c.slice(0, 4)));
                    if (!v) return null;
                    let _ = this.#A.decode(v.inputs, c.slice(4));
                    return new TransactionDescription(v, v.selector, _, p)
                }
                parseCallResult(l) {
                    throw Error("@TODO")
                }
                parseLog(l) {
                    let c = this.getEvent(l.topics[0]);
                    return !c || c.anonymous ? null : new LogDescription(c, c.topicHash, this.decodeEventLog(c, l.data, l.topics))
                }
                parseError(l) {
                    let c = (0, T.Dv)(l),
                        p = this.getError((0, T.QB)(c, 0, 4));
                    if (!p) return null;
                    let v = this.#A.decode(p.inputs, (0, T.QB)(c, 4));
                    return new ErrorDescription(p, p.selector, v)
                }
                static from(l) {
                    return l instanceof Interface ? l : new Interface("string" == typeof l ? JSON.parse(l) : "function" == typeof l.format ? l.format("json") : l)
                }
            };
            var e4 = p(795);
            let EventPayload = class EventPayload {
                filter;
                emitter;#
                N;
                constructor(l, c, p) {
                    this.#N = c, (0, M.h)(this, {
                        emitter: l,
                        filter: p
                    })
                }
                async removeListener() {
                    null != this.#N && await this.emitter.off(this.filter, this.#N)
                }
            };
            let EventLog = class EventLog extends e4.Zb {
                interface;
                fragment;
                args;
                constructor(l, c, p) {
                    super(l, l.provider);
                    let v = c.decodeEventLog(p, l.data, l.topics);
                    (0, M.h)(this, {
                        args: v,
                        fragment: p,
                        interface: c
                    })
                }
                get eventName() {
                    return this.fragment.name
                }
                get eventSignature() {
                    return this.fragment.format()
                }
            };
            let UndecodedEventLog = class UndecodedEventLog extends e4.Zb {
                error;
                constructor(l, c) {
                    super(l, l.provider), (0, M.h)(this, {
                        error: c
                    })
                }
            };
            let ContractTransactionReceipt = class ContractTransactionReceipt extends e4.IX {#
                P;
                constructor(l, c, p) {
                    super(p, c), this.#P = l
                }
                get logs() {
                    return super.logs.map(l => {
                        let c = l.topics.length ? this.#P.getEvent(l.topics[0]) : null;
                        if (c) try {
                            return new EventLog(l, this.#P, c)
                        } catch (c) {
                            return new UndecodedEventLog(l, c)
                        }
                        return l
                    })
                }
            };
            let ContractTransactionResponse = class ContractTransactionResponse extends e4.Mw {#
                P;
                constructor(l, c, p) {
                    super(p, c), this.#P = l
                }
                async wait(l) {
                    let c = await super.wait(l);
                    return null == c ? null : new ContractTransactionReceipt(this.#P, this.provider, c)
                }
            };
            let ContractUnknownEventPayload = class ContractUnknownEventPayload extends EventPayload {
                log;
                constructor(l, c, p, v) {
                    super(l, c, p), (0, M.h)(this, {
                        log: v
                    })
                }
                async getBlock() {
                    return await this.log.getBlock()
                }
                async getTransaction() {
                    return await this.log.getTransaction()
                }
                async getTransactionReceipt() {
                    return await this.log.getTransactionReceipt()
                }
            };
            let ContractEventPayload = class ContractEventPayload extends ContractUnknownEventPayload {
                constructor(l, c, p, v, _) {
                    super(l, c, p, new EventLog(_, l.interface, v));
                    let C = l.interface.decodeEventLog(v, this.log.data, this.log.topics);
                    (0, M.h)(this, {
                        args: C,
                        fragment: v
                    })
                }
                get eventName() {
                    return this.fragment.name
                }
                get eventSignature() {
                    return this.fragment.format()
                }
            };
            let e8 = BigInt(0);

            function canCall(l) {
                return l && "function" == typeof l.call
            }

            function canEstimate(l) {
                return l && "function" == typeof l.estimateGas
            }

            function canResolve(l) {
                return l && "function" == typeof l.resolveName
            }

            function canSend(l) {
                return l && "function" == typeof l.sendTransaction
            }
            let PreparedTopicFilter = class PreparedTopicFilter {#
                D;
                fragment;
                constructor(l, c, p) {
                    if ((0, M.h)(this, {
                            fragment: c
                        }), c.inputs.length < p.length) throw Error("too many arguments");
                    let v = getRunner(l.runner, "resolveName"),
                        _ = canResolve(v) ? v : null;
                    this.#D = async function() {
                        let v = await Promise.all(c.inputs.map((l, c) => {
                            let v = p[c];
                            return null == v ? null : l.walkAsync(p[c], (l, c) => "address" === l ? Array.isArray(c) ? Promise.all(c.map(l => resolveAddress(l, _))) : resolveAddress(c, _) : c)
                        }));
                        return l.interface.encodeFilterTopics(c, v)
                    }()
                }
                getTopicFilter() {
                    return this.#D
                }
            };

            function getRunner(l, c) {
                return null == l ? null : "function" == typeof l[c] ? l : l.provider && "function" == typeof l.provider[c] ? l.provider : null
            }

            function getProvider(l) {
                return null == l ? null : l.provider || null
            }
            async function copyOverrides(l, c) {
                let p = Typed.dereference(l, "overrides");
                (0, C.en)("object" == typeof p, "invalid overrides parameter", "overrides", l);
                let v = (0, e4.kK)(p);
                return (0, C.en)(null == v.to || (c || []).indexOf("to") >= 0, "cannot override to", "overrides.to", v.to), (0, C.en)(null == v.data || (c || []).indexOf("data") >= 0, "cannot override data", "overrides.data", v.data), v.from && (v.from = await resolveAddress(v.from)), v
            }
            async function resolveArgs(l, c, p) {
                let v = getRunner(l, "resolveName"),
                    _ = canResolve(v) ? v : null;
                return await Promise.all(c.map((l, c) => l.walkAsync(p[c], (l, c) => (c = Typed.dereference(c, l), "address" === l) ? resolveAddress(c, _) : c)))
            }
            let e9 = Symbol.for("_ethersInternal_contract"),
                e7 = new WeakMap;

            function getInternal(l) {
                return e7.get(l[e9])
            }
            async function getSubInfo(l, c) {
                let p;
                let v = null;
                if (Array.isArray(c)) {
                    let topicHashify = function(c) {
                        if ((0, T.A7)(c, 32)) return c;
                        let p = l.interface.getEvent(c);
                        return (0, C.en)(p, "unknown fragment", "name", c), p.topicHash
                    };
                    p = c.map(l => null == l ? null : Array.isArray(l) ? l.map(topicHashify) : topicHashify(l))
                } else "*" === c ? p = [null] : "string" == typeof c ? (0, T.A7)(c, 32) ? p = [c] : (v = l.interface.getEvent(c), (0, C.en)(v, "unknown fragment", "event", c), p = [v.topicHash]) : c && "object" == typeof c && "getTopicFilter" in c && "function" == typeof c.getTopicFilter && c.fragment ? p = await c.getTopicFilter() : "fragment" in c ? p = [(v = c.fragment).topicHash] : (0, C.en)(!1, "unknown event name", "event", c);
                p = p.map(l => {
                    if (null == l) return null;
                    if (Array.isArray(l)) {
                        let c = Array.from(new Set(l.map(l => l.toLowerCase())).values());
                        return 1 === c.length ? c[0] : (c.sort(), c)
                    }
                    return l.toLowerCase()
                });
                let _ = p.map(l => null == l ? "null" : Array.isArray(l) ? l.join("|") : l).join("&");
                return {
                    fragment: v,
                    tag: _,
                    topics: p
                }
            }
            async function hasSub(l, c) {
                let {
                    subs: p
                } = getInternal(l);
                return p.get((await getSubInfo(l, c)).tag) || null
            }
            async function getSub(l, c, p) {
                let v = getProvider(l.runner);
                (0, C.hu)(v, "contract runner does not support subscribing", "UNSUPPORTED_OPERATION", {
                    operation: c
                });
                let {
                    fragment: _,
                    tag: P,
                    topics: T
                } = await getSubInfo(l, p), {
                    addr: M,
                    subs: z
                } = getInternal(l), J = z.get(P);
                if (!J) {
                    let c = M || l,
                        C = {
                            address: c,
                            topics: T
                        },
                        listener = c => {
                            let v = _;
                            if (null == v) try {
                                v = l.interface.getEvent(c.topics[0])
                            } catch (l) {}
                            if (v) {
                                let C = v,
                                    P = _ ? l.interface.decodeEventLog(_, c.data, c.topics) : [];
                                emit(l, p, P, v => new ContractEventPayload(l, v, p, C, c))
                            } else emit(l, p, [], v => new ContractUnknownEventPayload(l, v, p, c))
                        },
                        Q = [],
                        stop = async () => {
                            if (0 == Q.length) return;
                            let l = Q;
                            Q = [], await Promise.all(l), v.off(C, listener)
                        };
                    J = {
                        tag: P,
                        listeners: [],
                        start: () => {
                            Q.length || Q.push(v.on(C, listener))
                        },
                        stop
                    }, z.set(P, J)
                }
                return J
            }
            let tn = Promise.resolve();
            async function _emit(l, c, p, v) {
                await tn;
                let _ = await hasSub(l, c);
                if (!_) return !1;
                let C = _.listeners.length;
                return _.listeners = _.listeners.filter(({
                    listener: c,
                    once: _
                }) => {
                    let C = Array.from(p);
                    v && C.push(v(_ ? null : c));
                    try {
                        c.call(l, ...C)
                    } catch (l) {}
                    return !_
                }), 0 === _.listeners.length && (_.stop(), getInternal(l).subs.delete(_.tag)), C > 0
            }
            async function emit(l, c, p, v) {
                try {
                    await tn
                } catch (l) {}
                let _ = _emit(l, c, p, v);
                return tn = _, await _
            }
            let ts = ["then"];
            let BaseContract = class BaseContract {
                target;
                interface;
                runner;
                filters;
                [e9];
                fallback;
                constructor(l, c, p, v) {
                    var _;
                    let z;
                    (0, C.en)("string" == typeof l || isAddressable(l), "invalid value for Contract target", "target", l), null == p && (p = null);
                    let J = Interface.from(c);
                    (0, M.h)(this, {
                        target: l,
                        runner: p,
                        interface: J
                    }), Object.defineProperty(this, e9, {
                        value: {}
                    });
                    let Q = null,
                        X = null;
                    if (v) {
                        let l = getProvider(p);
                        X = new ContractTransactionResponse(this.interface, l, v)
                    }
                    let es = new Map;
                    if ("string" == typeof l) {
                        if ((0, T.A7)(l)) Q = l, z = Promise.resolve(l);
                        else {
                            let c = getRunner(p, "resolveName");
                            if (!canResolve(c)) throw (0, C.wf)("contract runner does not support name resolution", "UNSUPPORTED_OPERATION", {
                                operation: "resolveName"
                            });
                            z = c.resolveName(l).then(c => {
                                if (null == c) throw (0, C.wf)("an ENS name used for a contract target must be correctly configured", "UNCONFIGURED_NAME", {
                                    value: l
                                });
                                return getInternal(this).addr = c, c
                            })
                        }
                    } else z = l.getAddress().then(l => {
                        if (null == l) throw Error("TODO");
                        return getInternal(this).addr = l, l
                    });
                    _ = {
                        addrPromise: z,
                        addr: Q,
                        deployTx: X,
                        subs: es
                    }, e7.set(this[e9], _);
                    let eo = new Proxy({}, {
                        get: (l, c, p) => {
                            if ("symbol" == typeof c || ts.indexOf(c) >= 0) return Reflect.get(l, c, p);
                            try {
                                return this.getEvent(c)
                            } catch (l) {
                                if (!(0, C.VZ)(l, "INVALID_ARGUMENT") || "key" !== l.argument) throw l
                            }
                        },
                        has: (l, c) => ts.indexOf(c) >= 0 ? Reflect.has(l, c) : Reflect.has(l, c) || this.interface.hasEvent(String(c))
                    });
                    return (0, M.h)(this, {
                        filters: eo
                    }), (0, M.h)(this, {
                        fallback: J.receive || J.fallback ? function(l) {
                            let populateTransaction = async function(c) {
                                    let p = await copyOverrides(c, ["data"]);
                                    p.to = await l.getAddress();
                                    let v = l.interface,
                                        _ = (0, P.yT)(p.value || e8, "overrides.value") === e8,
                                        T = "0x" === (p.data || "0x");
                                    !v.fallback || v.fallback.payable || !v.receive || T || _ || (0, C.en)(!1, "cannot send data to receive or send value to non-payable fallback", "overrides", c), (0, C.en)(v.fallback || T, "cannot send data to receive-only contract", "overrides.data", p.data);
                                    let M = v.receive || v.fallback && v.fallback.payable;
                                    return (0, C.en)(M || _, "cannot send value to non-payable fallback", "overrides.value", p.value), (0, C.en)(v.fallback || T, "cannot send data to receive-only contract", "overrides.data", p.data), p
                                },
                                staticCall = async function(c) {
                                    let p = getRunner(l.runner, "call");
                                    (0, C.hu)(canCall(p), "contract runner does not support calling", "UNSUPPORTED_OPERATION", {
                                        operation: "call"
                                    });
                                    let v = await populateTransaction(c);
                                    try {
                                        return await p.call(v)
                                    } catch (c) {
                                        if ((0, C.Hl)(c) && c.data) throw l.interface.makeError(c.data, v);
                                        throw c
                                    }
                                },
                                send = async function(c) {
                                    let p = l.runner;
                                    (0, C.hu)(canSend(p), "contract runner does not support sending transactions", "UNSUPPORTED_OPERATION", {
                                        operation: "sendTransaction"
                                    });
                                    let v = await p.sendTransaction(await populateTransaction(c)),
                                        _ = getProvider(l.runner);
                                    return new ContractTransactionResponse(l.interface, _, v)
                                },
                                estimateGas = async function(c) {
                                    let p = getRunner(l.runner, "estimateGas");
                                    return (0, C.hu)(canEstimate(p), "contract runner does not support gas estimation", "UNSUPPORTED_OPERATION", {
                                        operation: "estimateGas"
                                    }), await p.estimateGas(await populateTransaction(c))
                                },
                                method = async l => await send(l);
                            return (0, M.h)(method, {
                                _contract: l,
                                estimateGas,
                                populateTransaction,
                                send,
                                staticCall
                            }), method
                        }(this) : null
                    }), new Proxy(this, {
                        get: (l, c, p) => {
                            if ("symbol" == typeof c || c in l || ts.indexOf(c) >= 0) return Reflect.get(l, c, p);
                            try {
                                return l.getFunction(c)
                            } catch (l) {
                                if (!(0, C.VZ)(l, "INVALID_ARGUMENT") || "key" !== l.argument) throw l
                            }
                        },
                        has: (l, c) => "symbol" == typeof c || c in l || ts.indexOf(c) >= 0 ? Reflect.has(l, c) : l.interface.hasFunction(c)
                    })
                }
                connect(l) {
                    return new BaseContract(this.target, this.interface, l)
                }
                attach(l) {
                    return new BaseContract(l, this.interface, this.runner)
                }
                async getAddress() {
                    return await getInternal(this).addrPromise
                }
                async getDeployedCode() {
                    let l = getProvider(this.runner);
                    (0, C.hu)(l, "runner does not support .provider", "UNSUPPORTED_OPERATION", {
                        operation: "getDeployedCode"
                    });
                    let c = await l.getCode(await this.getAddress());
                    return "0x" === c ? null : c
                }
                async waitForDeployment() {
                    let l = this.deploymentTransaction();
                    if (l) return await l.wait(), this;
                    let c = await this.getDeployedCode();
                    if (null != c) return this;
                    let p = getProvider(this.runner);
                    return (0, C.hu)(null != p, "contract runner does not support .provider", "UNSUPPORTED_OPERATION", {
                        operation: "waitForDeployment"
                    }), new Promise((l, c) => {
                        let checkCode = async () => {
                            try {
                                let c = await this.getDeployedCode();
                                if (null != c) return l(this);
                                p.once("block", checkCode)
                            } catch (l) {
                                c(l)
                            }
                        };
                        checkCode()
                    })
                }
                deploymentTransaction() {
                    return getInternal(this).deployTx
                }
                getFunction(l) {
                    "string" != typeof l && (l = l.format());
                    let c = function(l, c) {
                        let getFragment = function(...p) {
                                let v = l.interface.getFunction(c, p);
                                return (0, C.hu)(v, "no matching fragment", "UNSUPPORTED_OPERATION", {
                                    operation: "fragment",
                                    info: {
                                        key: c,
                                        args: p
                                    }
                                }), v
                            },
                            populateTransaction = async function(...c) {
                                let p = getFragment(...c),
                                    v = {};
                                if (p.inputs.length + 1 === c.length && (v = await copyOverrides(c.pop())), p.inputs.length !== c.length) throw Error("internal error: fragment inputs doesn't match arguments; should not happen");
                                let _ = await resolveArgs(l.runner, p.inputs, c);
                                return Object.assign({}, v, await (0, M.m)({
                                    to: l.getAddress(),
                                    data: l.interface.encodeFunctionData(p, _)
                                }))
                            },
                            staticCall = async function(...l) {
                                let c = await staticCallResult(...l);
                                return 1 === c.length ? c[0] : c
                            },
                            send = async function(...c) {
                                let p = l.runner;
                                (0, C.hu)(canSend(p), "contract runner does not support sending transactions", "UNSUPPORTED_OPERATION", {
                                    operation: "sendTransaction"
                                });
                                let v = await p.sendTransaction(await populateTransaction(...c)),
                                    _ = getProvider(l.runner);
                                return new ContractTransactionResponse(l.interface, _, v)
                            },
                            estimateGas = async function(...c) {
                                let p = getRunner(l.runner, "estimateGas");
                                return (0, C.hu)(canEstimate(p), "contract runner does not support gas estimation", "UNSUPPORTED_OPERATION", {
                                    operation: "estimateGas"
                                }), await p.estimateGas(await populateTransaction(...c))
                            },
                            staticCallResult = async function(...c) {
                                let p = getRunner(l.runner, "call");
                                (0, C.hu)(canCall(p), "contract runner does not support calling", "UNSUPPORTED_OPERATION", {
                                    operation: "call"
                                });
                                let v = await populateTransaction(...c),
                                    _ = "0x";
                                try {
                                    _ = await p.call(v)
                                } catch (c) {
                                    if ((0, C.Hl)(c) && c.data) throw l.interface.makeError(c.data, v);
                                    throw c
                                }
                                let P = getFragment(...c);
                                return l.interface.decodeFunctionResult(P, _)
                            },
                            method = async (...l) => {
                                let c = getFragment(...l);
                                return c.constant ? await staticCall(...l) : await send(...l)
                            };
                        return (0, M.h)(method, {
                            name: l.interface.getFunctionName(c),
                            _contract: l,
                            _key: c,
                            getFragment,
                            estimateGas,
                            populateTransaction,
                            send,
                            staticCall,
                            staticCallResult
                        }), Object.defineProperty(method, "fragment", {
                            configurable: !1,
                            enumerable: !0,
                            get: () => {
                                let p = l.interface.getFunction(c);
                                return (0, C.hu)(p, "no matching fragment", "UNSUPPORTED_OPERATION", {
                                    operation: "fragment",
                                    info: {
                                        key: c
                                    }
                                }), p
                            }
                        }), method
                    }(this, l);
                    return c
                }
                getEvent(l) {
                    return "string" != typeof l && (l = l.format()),
                        function(l, c) {
                            let getFragment = function(...p) {
                                    let v = l.interface.getEvent(c, p);
                                    return (0, C.hu)(v, "no matching fragment", "UNSUPPORTED_OPERATION", {
                                        operation: "fragment",
                                        info: {
                                            key: c,
                                            args: p
                                        }
                                    }), v
                                },
                                method = function(...c) {
                                    return new PreparedTopicFilter(l, getFragment(...c), c)
                                };
                            return (0, M.h)(method, {
                                name: l.interface.getEventName(c),
                                _contract: l,
                                _key: c,
                                getFragment
                            }), Object.defineProperty(method, "fragment", {
                                configurable: !1,
                                enumerable: !0,
                                get: () => {
                                    let p = l.interface.getEvent(c);
                                    return (0, C.hu)(p, "no matching fragment", "UNSUPPORTED_OPERATION", {
                                        operation: "fragment",
                                        info: {
                                            key: c
                                        }
                                    }), p
                                }
                            }), method
                        }(this, l)
                }
                async queryTransaction(l) {
                    throw Error("@TODO")
                }
                async queryFilter(l, c, p) {
                    null == c && (c = 0), null == p && (p = "latest");
                    let {
                        addr: v,
                        addrPromise: _
                    } = getInternal(this), P = v || await _, {
                        fragment: T,
                        topics: M
                    } = await getSubInfo(this, l), z = {
                        address: P,
                        topics: M,
                        fromBlock: c,
                        toBlock: p
                    }, J = getProvider(this.runner);
                    return (0, C.hu)(J, "contract runner does not have a provider", "UNSUPPORTED_OPERATION", {
                        operation: "queryFilter"
                    }), (await J.getLogs(z)).map(l => {
                        let c = T;
                        if (null == c) try {
                            c = this.interface.getEvent(l.topics[0])
                        } catch (l) {}
                        if (c) try {
                            return new EventLog(l, this.interface, c)
                        } catch (c) {
                            return new UndecodedEventLog(l, c)
                        }
                        return new e4.Zb(l, J)
                    })
                }
                async on(l, c) {
                    let p = await getSub(this, "on", l);
                    return p.listeners.push({
                        listener: c,
                        once: !1
                    }), p.start(), this
                }
                async once(l, c) {
                    let p = await getSub(this, "once", l);
                    return p.listeners.push({
                        listener: c,
                        once: !0
                    }), p.start(), this
                }
                async emit(l, ...c) {
                    return await emit(this, l, c, null)
                }
                async listenerCount(l) {
                    if (l) {
                        let c = await hasSub(this, l);
                        return c ? c.listeners.length : 0
                    }
                    let {
                        subs: c
                    } = getInternal(this), p = 0;
                    for (let {
                            listeners: l
                        } of c.values()) p += l.length;
                    return p
                }
                async listeners(l) {
                    if (l) {
                        let c = await hasSub(this, l);
                        return c ? c.listeners.map(({
                            listener: l
                        }) => l) : []
                    }
                    let {
                        subs: c
                    } = getInternal(this), p = [];
                    for (let {
                            listeners: l
                        } of c.values()) p = p.concat(l.map(({
                        listener: l
                    }) => l));
                    return p
                }
                async off(l, c) {
                    let p = await hasSub(this, l);
                    if (!p) return this;
                    if (c) {
                        let l = p.listeners.map(({
                            listener: l
                        }) => l).indexOf(c);
                        l >= 0 && p.listeners.splice(l, 1)
                    }
                    return (null == c || 0 === p.listeners.length) && (p.stop(), getInternal(this).subs.delete(p.tag)), this
                }
                async removeAllListeners(l) {
                    if (l) {
                        let c = await hasSub(this, l);
                        if (!c) return this;
                        c.stop(), getInternal(this).subs.delete(c.tag)
                    } else {
                        let {
                            subs: l
                        } = getInternal(this);
                        for (let {
                                tag: c,
                                stop: p
                            } of l.values()) p(), l.delete(c)
                    }
                    return this
                }
                async addListener(l, c) {
                    return await this.on(l, c)
                }
                async removeListener(l, c) {
                    return await this.off(l, c)
                }
                static buildClass(l) {
                    return class extends BaseContract {
                        constructor(c, p = null) {
                            super(c, l, p)
                        }
                    }
                }
                static from(l, c, p) {
                    null == p && (p = null);
                    let v = new this(l, c, p);
                    return v
                }
            };

            function _ContractBase() {
                return BaseContract
            }
            let Contract = class Contract extends _ContractBase() {};
            var ta = p(3515);
            let to = "0x0000000000000000000000000000000000000000000000000000000000000000",
                tl = BigInt(0),
                tc = BigInt(1),
                th = BigInt(2),
                td = BigInt(27),
                tf = BigInt(28),
                tp = BigInt(35),
                tg = {};

            function toUint256(l) {
                return (0, T.U3)((0, P.ot)(l), 32)
            }
            let Signature = class Signature {#
                k;#
                I;#
                O;#
                j;
                get r() {
                    return this.#k
                }
                set r(l) {
                    (0, C.en)(32 === (0, T.M5)(l), "invalid r", "value", l), this.#k = (0, T.Dv)(l)
                }
                get s() {
                    return this.#I
                }
                set s(l) {
                    (0, C.en)(32 === (0, T.M5)(l), "invalid s", "value", l);
                    let c = (0, T.Dv)(l);
                    (0, C.en)(8 > parseInt(c.substring(0, 3)), "non-canonical s", "value", c), this.#I = c
                }
                get v() {
                    return this.#O
                }
                set v(l) {
                    let c = (0, P.Dx)(l, "value");
                    (0, C.en)(27 === c || 28 === c, "invalid v", "v", l), this.#O = c
                }
                get networkV() {
                    return this.#j
                }
                get legacyChainId() {
                    let l = this.networkV;
                    return null == l ? null : Signature.getChainId(l)
                }
                get yParity() {
                    return 27 === this.v ? 0 : 1
                }
                get yParityAndS() {
                    let l = (0, T.Pw)(this.s);
                    return this.yParity && (l[0] |= 128), (0, T.Dv)(l)
                }
                get compactSerialized() {
                    return (0, T.zo)([this.r, this.yParityAndS])
                }
                get serialized() {
                    return (0, T.zo)([this.r, this.s, this.yParity ? "0x1c" : "0x1b"])
                }
                constructor(l, c, p, v) {
                    (0, C.NK)(l, tg, "Signature"), this.#k = c, this.#I = p, this.#O = v, this.#j = null
                }[Symbol.for("nodejs.util.inspect.custom")]() {
                    return `Signature { r: "${this.r}", s: "${this.s}", yParity: ${this.yParity}, networkV: ${this.networkV} }`
                }
                clone() {
                    let l = new Signature(tg, this.r, this.s, this.v);
                    return this.networkV && (l.#j = this.networkV), l
                }
                toJSON() {
                    let l = this.networkV;
                    return {
                        _type: "signature",
                        networkV: null != l ? l.toString() : null,
                        r: this.r,
                        s: this.s,
                        v: this.v
                    }
                }
                static getChainId(l) {
                    let c = (0, P.yT)(l, "v");
                    return c == td || c == tf ? tl : ((0, C.en)(c >= tp, "invalid EIP-155 v", "v", l), (c - tp) / th)
                }
                static getChainIdV(l, c) {
                    return (0, P.yT)(l) * th + BigInt(35 + c - 27)
                }
                static getNormalizedV(l) {
                    let c = (0, P.yT)(l);
                    return c === tl || c === td ? 27 : c === tc || c === tf ? 28 : ((0, C.en)(c >= tp, "invalid v", "v", l), c & tc ? 27 : 28)
                }
                static from(l) {
                    function assertError(c, p) {
                        (0, C.en)(c, p, "signature", l)
                    }
                    if (null == l) return new Signature(tg, to, to, 27);
                    if ("string" == typeof l) {
                        let c = (0, T.Pw)(l, "signature");
                        if (64 === c.length) {
                            let l = (0, T.Dv)(c.slice(0, 32)),
                                p = c.slice(32, 64),
                                v = 128 & p[0] ? 28 : 27;
                            return p[0] &= 127, new Signature(tg, l, (0, T.Dv)(p), v)
                        }
                        if (65 === c.length) {
                            let l = (0, T.Dv)(c.slice(0, 32)),
                                p = c.slice(32, 64);
                            assertError((128 & p[0]) == 0, "non-canonical s");
                            let v = Signature.getNormalizedV(c[64]);
                            return new Signature(tg, l, (0, T.Dv)(p), v)
                        }
                        assertError(!1, "invalid raw signature length")
                    }
                    if (l instanceof Signature) return l.clone();
                    let c = l.r;
                    assertError(null != c, "missing r");
                    let p = toUint256(c),
                        v = function(l, c) {
                            if (null != l) return toUint256(l);
                            if (null != c) {
                                assertError((0, T.A7)(c, 32), "invalid yParityAndS");
                                let l = (0, T.Pw)(c);
                                return l[0] &= 127, (0, T.Dv)(l)
                            }
                            assertError(!1, "missing s")
                        }(l.s, l.yParityAndS);
                    assertError((128 & (0, T.Pw)(v)[0]) == 0, "non-canonical s");
                    let {
                        networkV: _,
                        v: M
                    } = function(l, c, p) {
                        if (null != l) {
                            let c = (0, P.yT)(l);
                            return {
                                networkV: c >= tp ? c : void 0,
                                v: Signature.getNormalizedV(c)
                            }
                        }
                        if (null != c) return assertError((0, T.A7)(c, 32), "invalid yParityAndS"), {
                            v: 128 & (0, T.Pw)(c)[0] ? 28 : 27
                        };
                        if (null != p) {
                            switch ((0, P.Dx)(p, "sig.yParity")) {
                                case 0:
                                    return {
                                        v: 27
                                    };
                                case 1:
                                    return {
                                        v: 28
                                    }
                            }
                            assertError(!1, "invalid yParity")
                        }
                        assertError(!1, "missing v")
                    }(l.v, l.yParityAndS, l.yParity), z = new Signature(tg, p, v, M);
                    return _ && (z.#j = _), assertError(null == l.yParity || (0, P.Dx)(l.yParity, "sig.yParity") === z.yParity, "yParity mismatch"), assertError(null == l.yParityAndS || l.yParityAndS === z.yParityAndS, "yParityAndS mismatch"), z
                }
            };
            var tm = p(5856),
                ty = p.t(tm, 2); /*! noble-secp256k1 - MIT License (c) 2019 Paul Miller (paulmillr.com) */
            let tb = BigInt(0),
                tw = BigInt(1),
                tx = BigInt(2),
                t_ = BigInt(3),
                tE = BigInt(8),
                tA = Object.freeze({
                    a: tb,
                    b: BigInt(7),
                    P: BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),
                    n: BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),
                    h: tw,
                    Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
                    Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
                    beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee")
                }),
                divNearest = (l, c) => (l + c / tx) / c,
                tC = {
                    beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
                    splitScalar(l) {
                        let {
                            n: c
                        } = tA, p = BigInt("0x3086d221a7d46bcde86c90e49284eb15"), v = -tw * BigInt("0xe4437ed6010e88286f547fa90abfe4c3"), _ = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"), C = BigInt("0x100000000000000000000000000000000"), P = divNearest(p * l, c), T = divNearest(-v * l, c), M = mod(l - P * p - T * _, c), z = mod(-P * v - T * p, c), J = M > C, Q = z > C;
                        if (J && (M = c - M), Q && (z = c - z), M > C || z > C) throw Error("splitScalarEndo: Endomorphism failed, k=" + l);
                        return {
                            k1neg: J,
                            k1: M,
                            k2neg: Q,
                            k2: z
                        }
                    }
                };

            function weierstrass(l) {
                let {
                    a: c,
                    b: p
                } = tA, v = mod(l * l), _ = mod(v * l);
                return mod(_ + c * l + p)
            }
            let tS = tA.a === tb;
            let ShaError = class ShaError extends Error {
                constructor(l) {
                    super(l)
                }
            };

            function assertJacPoint(l) {
                if (!(l instanceof JacobianPoint)) throw TypeError("JacobianPoint expected")
            }
            let JacobianPoint = class JacobianPoint {
                constructor(l, c, p) {
                    this.x = l, this.y = c, this.z = p
                }
                static fromAffine(l) {
                    if (!(l instanceof Point)) throw TypeError("JacobianPoint#fromAffine: expected Point");
                    return l.equals(Point.ZERO) ? JacobianPoint.ZERO : new JacobianPoint(l.x, l.y, tw)
                }
                static toAffineBatch(l) {
                    let c = function(l, c = tA.P) {
                        let p = Array(l.length),
                            v = l.reduce((l, v, _) => v === tb ? l : (p[_] = l, mod(l * v, c)), tw),
                            _ = invert(v, c);
                        return l.reduceRight((l, v, _) => v === tb ? l : (p[_] = mod(l * p[_], c), mod(l * v, c)), _), p
                    }(l.map(l => l.z));
                    return l.map((l, p) => l.toAffine(c[p]))
                }
                static normalizeZ(l) {
                    return JacobianPoint.toAffineBatch(l).map(JacobianPoint.fromAffine)
                }
                equals(l) {
                    assertJacPoint(l);
                    let {
                        x: c,
                        y: p,
                        z: v
                    } = this, {
                        x: _,
                        y: C,
                        z: P
                    } = l, T = mod(v * v), M = mod(P * P), z = mod(c * M), J = mod(_ * T), Q = mod(mod(p * P) * M), X = mod(mod(C * v) * T);
                    return z === J && Q === X
                }
                negate() {
                    return new JacobianPoint(this.x, mod(-this.y), this.z)
                }
                double() {
                    let {
                        x: l,
                        y: c,
                        z: p
                    } = this, v = mod(l * l), _ = mod(c * c), C = mod(_ * _), P = l + _, T = mod(tx * (mod(P * P) - v - C)), M = mod(t_ * v), z = mod(M * M), J = mod(z - tx * T), Q = mod(M * (T - J) - tE * C), X = mod(tx * c * p);
                    return new JacobianPoint(J, Q, X)
                }
                add(l) {
                    assertJacPoint(l);
                    let {
                        x: c,
                        y: p,
                        z: v
                    } = this, {
                        x: _,
                        y: C,
                        z: P
                    } = l;
                    if (_ === tb || C === tb) return this;
                    if (c === tb || p === tb) return l;
                    let T = mod(v * v),
                        M = mod(P * P),
                        z = mod(c * M),
                        J = mod(_ * T),
                        Q = mod(mod(p * P) * M),
                        X = mod(mod(C * v) * T),
                        es = mod(J - z),
                        eo = mod(X - Q);
                    if (es === tb) return eo === tb ? this.double() : JacobianPoint.ZERO;
                    let el = mod(es * es),
                        ec = mod(es * el),
                        eh = mod(z * el),
                        ed = mod(eo * eo - ec - tx * eh),
                        ef = mod(eo * (eh - ed) - Q * ec),
                        ep = mod(v * P * es);
                    return new JacobianPoint(ed, ef, ep)
                }
                subtract(l) {
                    return this.add(l.negate())
                }
                multiplyUnsafe(l) {
                    let c = JacobianPoint.ZERO;
                    if ("bigint" == typeof l && l === tb) return c;
                    let p = normalizeScalar(l);
                    if (p === tw) return this;
                    if (!tS) {
                        let l = c,
                            v = this;
                        for (; p > tb;) p & tw && (l = l.add(v)), v = v.double(), p >>= tw;
                        return l
                    }
                    let {
                        k1neg: v,
                        k1: _,
                        k2neg: C,
                        k2: P
                    } = tC.splitScalar(p), T = c, M = c, z = this;
                    for (; _ > tb || P > tb;) _ & tw && (T = T.add(z)), P & tw && (M = M.add(z)), z = z.double(), _ >>= tw, P >>= tw;
                    return v && (T = T.negate()), C && (M = M.negate()), M = new JacobianPoint(mod(M.x * tC.beta), M.y, M.z), T.add(M)
                }
                precomputeWindow(l) {
                    let c = tS ? 128 / l + 1 : 256 / l + 1,
                        p = [],
                        v = this,
                        _ = v;
                    for (let C = 0; C < c; C++) {
                        _ = v, p.push(_);
                        for (let c = 1; c < 2 ** (l - 1); c++) _ = _.add(v), p.push(_);
                        v = _.double()
                    }
                    return p
                }
                wNAF(l, c) {
                    !c && this.equals(JacobianPoint.BASE) && (c = Point.BASE);
                    let p = c && c._WINDOW_SIZE || 1;
                    if (256 % p) throw Error("Point#wNAF: Invalid precomputation window, must be power of 2");
                    let v = c && tN.get(c);
                    !v && (v = this.precomputeWindow(p), c && 1 !== p && (v = JacobianPoint.normalizeZ(v), tN.set(c, v)));
                    let _ = JacobianPoint.ZERO,
                        C = JacobianPoint.BASE,
                        P = 1 + (tS ? 128 / p : 256 / p),
                        T = 2 ** (p - 1),
                        M = BigInt(2 ** p - 1),
                        z = 2 ** p,
                        J = BigInt(p);
                    for (let c = 0; c < P; c++) {
                        let p = c * T,
                            P = Number(l & M);
                        l >>= J, P > T && (P -= z, l += tw);
                        let Q = p + Math.abs(P) - 1,
                            X = c % 2 != 0,
                            es = P < 0;
                        0 === P ? C = C.add(constTimeNegate(X, v[p])) : _ = _.add(constTimeNegate(es, v[Q]))
                    }
                    return {
                        p: _,
                        f: C
                    }
                }
                multiply(l, c) {
                    let p, v, _ = normalizeScalar(l);
                    if (tS) {
                        let {
                            k1neg: l,
                            k1: C,
                            k2neg: P,
                            k2: T
                        } = tC.splitScalar(_), {
                            p: M,
                            f: z
                        } = this.wNAF(C, c), {
                            p: J,
                            f: Q
                        } = this.wNAF(T, c);
                        M = constTimeNegate(l, M), J = constTimeNegate(P, J), J = new JacobianPoint(mod(J.x * tC.beta), J.y, J.z), p = M.add(J), v = z.add(Q)
                    } else {
                        let {
                            p: l,
                            f: C
                        } = this.wNAF(_, c);
                        p = l, v = C
                    }
                    return JacobianPoint.normalizeZ([p, v])[0]
                }
                toAffine(l) {
                    let {
                        x: c,
                        y: p,
                        z: v
                    } = this, _ = this.equals(JacobianPoint.ZERO);
                    null == l && (l = _ ? tE : invert(v));
                    let C = l,
                        P = mod(C * C),
                        T = mod(P * C),
                        M = mod(c * P),
                        z = mod(p * T),
                        J = mod(v * C);
                    if (_) return Point.ZERO;
                    if (J !== tw) throw Error("invZ was invalid");
                    return new Point(M, z)
                }
            };

            function constTimeNegate(l, c) {
                let p = c.negate();
                return l ? p : c
            }
            JacobianPoint.BASE = new JacobianPoint(tA.Gx, tA.Gy, tw), JacobianPoint.ZERO = new JacobianPoint(tb, tw, tb);
            let tN = new WeakMap;
            let Point = class Point {
                constructor(l, c) {
                    this.x = l, this.y = c
                }
                _setWindowSize(l) {
                    this._WINDOW_SIZE = l, tN.delete(this)
                }
                hasEvenY() {
                    return this.y % tx === tb
                }
                static fromCompressedHex(l) {
                    let c = 32 === l.length,
                        p = bytesToNumber(c ? l : l.subarray(1));
                    if (!isValidFieldElement(p)) throw Error("Point is not on curve");
                    let v = weierstrass(p),
                        _ = function(l) {
                            let {
                                P: c
                            } = tA, p = BigInt(6), v = BigInt(11), _ = BigInt(22), C = BigInt(23), P = BigInt(44), T = BigInt(88), M = l * l * l % c, z = M * M * l % c, J = pow2(z, t_) * z % c, Q = pow2(J, t_) * z % c, X = pow2(Q, tx) * M % c, es = pow2(X, v) * X % c, eo = pow2(es, _) * es % c, el = pow2(eo, P) * eo % c, ec = pow2(el, T) * el % c, eh = pow2(ec, P) * eo % c, ed = pow2(eh, t_) * z % c, ef = pow2(ed, C) * es % c, ep = pow2(ef, p) * M % c, eg = pow2(ep, tx);
                            if (eg * eg % c !== l) throw Error("Cannot find square root");
                            return eg
                        }(v),
                        C = (_ & tw) === tw;
                    if (c) C && (_ = mod(-_));
                    else {
                        let c = (1 & l[0]) == 1;
                        c !== C && (_ = mod(-_))
                    }
                    let P = new Point(p, _);
                    return P.assertValidity(), P
                }
                static fromUncompressedHex(l) {
                    let c = bytesToNumber(l.subarray(1, 33)),
                        p = bytesToNumber(l.subarray(33, 65)),
                        v = new Point(c, p);
                    return v.assertValidity(), v
                }
                static fromHex(l) {
                    let c = ensureBytes(l),
                        p = c.length,
                        v = c[0];
                    if (32 === p || 33 === p && (2 === v || 3 === v)) return this.fromCompressedHex(c);
                    if (65 === p && 4 === v) return this.fromUncompressedHex(c);
                    throw Error(`Point.fromHex: received invalid point. Expected 32-33 compressed bytes or 65 uncompressed bytes, not ${p}`)
                }
                static fromPrivateKey(l) {
                    return Point.BASE.multiply(normalizePrivateKey(l))
                }
                static fromSignature(l, c, p) {
                    let {
                        r: v,
                        s: _
                    } = function(l) {
                        if (l instanceof esm_Signature) return l.assertValidity(), l;
                        try {
                            return esm_Signature.fromDER(l)
                        } catch (c) {
                            return esm_Signature.fromCompact(l)
                        }
                    }(c);
                    if (![0, 1, 2, 3].includes(p)) throw Error("Cannot recover: invalid recovery bit");
                    let C = truncateHash(ensureBytes(l)),
                        {
                            n: P
                        } = tA,
                        T = 2 === p || 3 === p ? v + P : v,
                        M = invert(T, P),
                        z = mod(-C * M, P),
                        J = mod(_ * M, P),
                        Q = 1 & p ? "03" : "02",
                        X = Point.fromHex(Q + numTo32bStr(T)),
                        es = Point.BASE.multiplyAndAddUnsafe(X, z, J);
                    if (!es) throw Error("Cannot recover signature: point at infinify");
                    return es.assertValidity(), es
                }
                toRawBytes(l = !1) {
                    return hexToBytes(this.toHex(l))
                }
                toHex(l = !1) {
                    let c = numTo32bStr(this.x);
                    if (!l) return `04${c}${numTo32bStr(this.y)}`; {
                        let l = this.hasEvenY() ? "02" : "03";
                        return `${l}${c}`
                    }
                }
                toHexX() {
                    return this.toHex(!0).slice(2)
                }
                toRawX() {
                    return this.toRawBytes(!0).slice(1)
                }
                assertValidity() {
                    let l = "Point is not on elliptic curve",
                        {
                            x: c,
                            y: p
                        } = this;
                    if (!isValidFieldElement(c) || !isValidFieldElement(p)) throw Error(l);
                    let v = mod(p * p),
                        _ = weierstrass(c);
                    if (mod(v - _) !== tb) throw Error(l)
                }
                equals(l) {
                    return this.x === l.x && this.y === l.y
                }
                negate() {
                    return new Point(this.x, mod(-this.y))
                }
                double() {
                    return JacobianPoint.fromAffine(this).double().toAffine()
                }
                add(l) {
                    return JacobianPoint.fromAffine(this).add(JacobianPoint.fromAffine(l)).toAffine()
                }
                subtract(l) {
                    return this.add(l.negate())
                }
                multiply(l) {
                    return JacobianPoint.fromAffine(this).multiply(l, this).toAffine()
                }
                multiplyAndAddUnsafe(l, c, p) {
                    let v = JacobianPoint.fromAffine(this),
                        _ = c === tb || c === tw || this !== Point.BASE ? v.multiplyUnsafe(c) : v.multiply(c),
                        C = JacobianPoint.fromAffine(l).multiplyUnsafe(p),
                        P = _.add(C);
                    return P.equals(JacobianPoint.ZERO) ? void 0 : P.toAffine()
                }
            };

            function sliceDER(l) {
                return Number.parseInt(l[0], 16) >= 8 ? "00" + l : l
            }

            function parseDERInt(l) {
                if (l.length < 2 || 2 !== l[0]) throw Error(`Invalid signature integer tag: ${bytesToHex(l)}`);
                let c = l[1],
                    p = l.subarray(2, c + 2);
                if (!c || p.length !== c) throw Error("Invalid signature integer: wrong length");
                if (0 === p[0] && p[1] <= 127) throw Error("Invalid signature integer: trailing length");
                return {
                    data: bytesToNumber(p),
                    left: l.subarray(c + 2)
                }
            }
            Point.BASE = new Point(tA.Gx, tA.Gy), Point.ZERO = new Point(tb, tb);
            let esm_Signature = class esm_Signature {
                constructor(l, c) {
                    this.r = l, this.s = c, this.assertValidity()
                }
                static fromCompact(l) {
                    let c = l instanceof Uint8Array,
                        p = "Signature.fromCompact";
                    if ("string" != typeof l && !c) throw TypeError(`${p}: Expected string or Uint8Array`);
                    let v = c ? bytesToHex(l) : l;
                    if (128 !== v.length) throw Error(`${p}: Expected 64-byte hex`);
                    return new esm_Signature(hexToNumber(v.slice(0, 64)), hexToNumber(v.slice(64, 128)))
                }
                static fromDER(l) {
                    let c = l instanceof Uint8Array;
                    if ("string" != typeof l && !c) throw TypeError("Signature.fromDER: Expected string or Uint8Array");
                    let {
                        r: p,
                        s: v
                    } = function(l) {
                        if (l.length < 2 || 48 != l[0]) throw Error(`Invalid signature tag: ${bytesToHex(l)}`);
                        if (l[1] !== l.length - 2) throw Error("Invalid signature: incorrect length");
                        let {
                            data: c,
                            left: p
                        } = parseDERInt(l.subarray(2)), {
                            data: v,
                            left: _
                        } = parseDERInt(p);
                        if (_.length) throw Error(`Invalid signature: left bytes after parsing: ${bytesToHex(_)}`);
                        return {
                            r: c,
                            s: v
                        }
                    }(c ? l : hexToBytes(l));
                    return new esm_Signature(p, v)
                }
                static fromHex(l) {
                    return this.fromDER(l)
                }
                assertValidity() {
                    let {
                        r: l,
                        s: c
                    } = this;
                    if (!isWithinCurveOrder(l)) throw Error("Invalid Signature: r must be 0 < r < n");
                    if (!isWithinCurveOrder(c)) throw Error("Invalid Signature: s must be 0 < s < n")
                }
                hasHighS() {
                    let l = tA.n >> tw;
                    return this.s > l
                }
                normalizeS() {
                    return this.hasHighS() ? new esm_Signature(this.r, mod(-this.s, tA.n)) : this
                }
                toDERRawBytes() {
                    return hexToBytes(this.toDERHex())
                }
                toDERHex() {
                    let l = sliceDER(numberToHexUnpadded(this.s)),
                        c = sliceDER(numberToHexUnpadded(this.r)),
                        p = l.length / 2,
                        v = c.length / 2,
                        _ = numberToHexUnpadded(p),
                        C = numberToHexUnpadded(v),
                        P = numberToHexUnpadded(v + p + 4);
                    return `30${P}02${C}${c}02${_}${l}`
                }
                toRawBytes() {
                    return this.toDERRawBytes()
                }
                toHex() {
                    return this.toDERHex()
                }
                toCompactRawBytes() {
                    return hexToBytes(this.toCompactHex())
                }
                toCompactHex() {
                    return numTo32bStr(this.r) + numTo32bStr(this.s)
                }
            };

            function concatBytes(...l) {
                if (!l.every(l => l instanceof Uint8Array)) throw Error("Uint8Array list expected");
                if (1 === l.length) return l[0];
                let c = l.reduce((l, c) => l + c.length, 0),
                    p = new Uint8Array(c);
                for (let c = 0, v = 0; c < l.length; c++) {
                    let _ = l[c];
                    p.set(_, v), v += _.length
                }
                return p
            }
            let tP = Array.from({
                length: 256
            }, (l, c) => c.toString(16).padStart(2, "0"));

            function bytesToHex(l) {
                if (!(l instanceof Uint8Array)) throw Error("Expected Uint8Array");
                let c = "";
                for (let p = 0; p < l.length; p++) c += tP[l[p]];
                return c
            }
            let tD = BigInt("0x10000000000000000000000000000000000000000000000000000000000000000");

            function numTo32bStr(l) {
                if ("bigint" != typeof l) throw Error("Expected bigint");
                if (!(tb <= l && l < tD)) throw Error("Expected number 0 <= n < 2^256");
                return l.toString(16).padStart(64, "0")
            }

            function numTo32b(l) {
                let c = hexToBytes(numTo32bStr(l));
                if (32 !== c.length) throw Error("Error: expected 32 bytes");
                return c
            }

            function numberToHexUnpadded(l) {
                let c = l.toString(16);
                return 1 & c.length ? `0${c}` : c
            }

            function hexToNumber(l) {
                if ("string" != typeof l) throw TypeError("hexToNumber: expected string, got " + typeof l);
                return BigInt(`0x${l}`)
            }

            function hexToBytes(l) {
                if ("string" != typeof l) throw TypeError("hexToBytes: expected string, got " + typeof l);
                if (l.length % 2) throw Error("hexToBytes: received invalid unpadded hex" + l.length);
                let c = new Uint8Array(l.length / 2);
                for (let p = 0; p < c.length; p++) {
                    let v = 2 * p,
                        _ = l.slice(v, v + 2),
                        C = Number.parseInt(_, 16);
                    if (Number.isNaN(C) || C < 0) throw Error("Invalid byte sequence");
                    c[p] = C
                }
                return c
            }

            function bytesToNumber(l) {
                return hexToNumber(bytesToHex(l))
            }

            function ensureBytes(l) {
                return l instanceof Uint8Array ? Uint8Array.from(l) : hexToBytes(l)
            }

            function normalizeScalar(l) {
                if ("number" == typeof l && Number.isSafeInteger(l) && l > 0) return BigInt(l);
                if ("bigint" == typeof l && isWithinCurveOrder(l)) return l;
                throw TypeError("Expected valid private scalar: 0 < scalar < curve.n")
            }

            function mod(l, c = tA.P) {
                let p = l % c;
                return p >= tb ? p : c + p
            }

            function pow2(l, c) {
                let {
                    P: p
                } = tA, v = l;
                for (; c-- > tb;) v *= v, v %= p;
                return v
            }

            function invert(l, c = tA.P) {
                if (l === tb || c <= tb) throw Error(`invert: expected positive integers, got n=${l} mod=${c}`);
                let p = mod(l, c),
                    v = c,
                    _ = tb,
                    C = tw,
                    P = tw,
                    T = tb;
                for (; p !== tb;) {
                    let l = v / p,
                        c = v % p,
                        M = _ - P * l,
                        z = C - T * l;
                    v = p, p = c, _ = P, C = T, P = M, T = z
                }
                let M = v;
                if (M !== tw) throw Error("invert: does not exist");
                return mod(_, c)
            }

            function truncateHash(l, c = !1) {
                let p = function(l) {
                    let c = 8 * l.length - 256,
                        p = bytesToNumber(l);
                    return c > 0 ? p >> BigInt(c) : p
                }(l);
                if (c) return p;
                let {
                    n: v
                } = tA;
                return p >= v ? p - v : p
            }
            let HmacDrbg = class HmacDrbg {
                constructor(l, c) {
                    if (this.hashLen = l, this.qByteLen = c, "number" != typeof l || l < 2) throw Error("hashLen must be a number");
                    if ("number" != typeof c || c < 2) throw Error("qByteLen must be a number");
                    this.v = new Uint8Array(l).fill(1), this.k = new Uint8Array(l).fill(0), this.counter = 0
                }
                hmac(...l) {
                    return tO.hmacSha256(this.k, ...l)
                }
                hmacSync(...l) {
                    return _(this.k, ...l)
                }
                checkSync() {
                    if ("function" != typeof _) throw new ShaError("hmacSha256Sync needs to be set")
                }
                incr() {
                    if (this.counter >= 1e3) throw Error("Tried 1,000 k values for sign(), all were invalid");
                    this.counter += 1
                }
                async reseed(l = new Uint8Array) {
                    this.k = await this.hmac(this.v, Uint8Array.from([0]), l), this.v = await this.hmac(this.v), 0 !== l.length && (this.k = await this.hmac(this.v, Uint8Array.from([1]), l), this.v = await this.hmac(this.v))
                }
                reseedSync(l = new Uint8Array) {
                    this.checkSync(), this.k = this.hmacSync(this.v, Uint8Array.from([0]), l), this.v = this.hmacSync(this.v), 0 !== l.length && (this.k = this.hmacSync(this.v, Uint8Array.from([1]), l), this.v = this.hmacSync(this.v))
                }
                async generate() {
                    this.incr();
                    let l = 0,
                        c = [];
                    for (; l < this.qByteLen;) {
                        this.v = await this.hmac(this.v);
                        let p = this.v.slice();
                        c.push(p), l += this.v.length
                    }
                    return concatBytes(...c)
                }
                generateSync() {
                    this.checkSync(), this.incr();
                    let l = 0,
                        c = [];
                    for (; l < this.qByteLen;) {
                        this.v = this.hmacSync(this.v);
                        let p = this.v.slice();
                        c.push(p), l += this.v.length
                    }
                    return concatBytes(...c)
                }
            };

            function isWithinCurveOrder(l) {
                return tb < l && l < tA.n
            }

            function isValidFieldElement(l) {
                return tb < l && l < tA.P
            }

            function normalizePrivateKey(l) {
                let c;
                if ("bigint" == typeof l) c = l;
                else if ("number" == typeof l && Number.isSafeInteger(l) && l > 0) c = BigInt(l);
                else if ("string" == typeof l) {
                    if (64 !== l.length) throw Error("Expected 32 bytes of private key");
                    c = hexToNumber(l)
                } else if (l instanceof Uint8Array) {
                    if (32 !== l.length) throw Error("Expected 32 bytes of private key");
                    c = bytesToNumber(l)
                } else throw TypeError("Expected valid private key");
                if (!isWithinCurveOrder(c)) throw Error("Expected private key: 0 < key < n");
                return c
            }

            function isProbPub(l) {
                let c = l instanceof Uint8Array,
                    p = "string" == typeof l,
                    v = (c || p) && l.length;
                return c ? 33 === v || 65 === v : p ? 66 === v || 130 === v : l instanceof Point
            }

            function bits2int(l) {
                let c = l.length > 32 ? l.slice(0, 32) : l;
                return bytesToNumber(c)
            }
            Point.BASE._setWindowSize(8);
            let tk = {
                    node: ty,
                    web: "object" == typeof self && "crypto" in self ? self.crypto : void 0
                },
                tI = {},
                tO = {
                    bytesToHex,
                    hexToBytes,
                    concatBytes,
                    mod,
                    invert,
                    isValidPrivateKey(l) {
                        try {
                            return normalizePrivateKey(l), !0
                        } catch (l) {
                            return !1
                        }
                    },
                    _bigintTo32Bytes: numTo32b,
                    _normalizePrivateKey: normalizePrivateKey,
                    hashToPrivateKey: l => {
                        if ((l = ensureBytes(l)).length < 40 || l.length > 1024) throw Error("Expected valid bytes of private key as per FIPS 186");
                        let c = mod(bytesToNumber(l), tA.n - tw) + tw;
                        return numTo32b(c)
                    },
                    randomBytes: (l = 32) => {
                        if (tk.web) return tk.web.getRandomValues(new Uint8Array(l));
                        if (tk.node) {
                            let {
                                randomBytes: c
                            } = tk.node;
                            return Uint8Array.from(c(l))
                        }
                        throw Error("The environment doesn't have randomBytes function")
                    },
                    randomPrivateKey: () => tO.hashToPrivateKey(tO.randomBytes(40)),
                    precompute(l = 8, c = Point.BASE) {
                        let p = c === Point.BASE ? c : new Point(c.x, c.y);
                        return p._setWindowSize(l), p.multiply(t_), p
                    },
                    sha256: async (...l) => {
                        if (tk.web) {
                            let c = await tk.web.subtle.digest("SHA-256", concatBytes(...l));
                            return new Uint8Array(c)
                        }
                        if (tk.node) {
                            let {
                                createHash: c
                            } = tk.node, p = c("sha256");
                            return l.forEach(l => p.update(l)), Uint8Array.from(p.digest())
                        }
                        throw Error("The environment doesn't have sha256 function")
                    },
                    hmacSha256: async (l, ...c) => {
                        if (tk.web) {
                            let p = await tk.web.subtle.importKey("raw", l, {
                                    name: "HMAC",
                                    hash: {
                                        name: "SHA-256"
                                    }
                                }, !1, ["sign"]),
                                v = concatBytes(...c),
                                _ = await tk.web.subtle.sign("HMAC", p, v);
                            return new Uint8Array(_)
                        }
                        if (tk.node) {
                            let {
                                createHmac: p
                            } = tk.node, v = p("sha256", l);
                            return c.forEach(l => v.update(l)), Uint8Array.from(v.digest())
                        }
                        throw Error("The environment doesn't have hmac-sha256 function")
                    },
                    sha256Sync: void 0,
                    hmacSha256Sync: void 0,
                    taggedHash: async (l, ...c) => {
                        let p = tI[l];
                        if (void 0 === p) {
                            let c = await tO.sha256(Uint8Array.from(l, l => l.charCodeAt(0)));
                            p = concatBytes(c, c), tI[l] = p
                        }
                        return tO.sha256(p, ...c)
                    },
                    taggedHashSync: (l, ...c) => {
                        if ("function" != typeof v) throw new ShaError("sha256Sync is undefined, you need to set it");
                        let p = tI[l];
                        if (void 0 === p) {
                            let c = v(Uint8Array.from(l, l => l.charCodeAt(0)));
                            p = concatBytes(c, c), tI[l] = p
                        }
                        return v(p, ...c)
                    },
                    _JacobianPoint: JacobianPoint
                };
            Object.defineProperties(tO, {
                sha256Sync: {
                    configurable: !1,
                    get: () => v,
                    set(l) {
                        v || (v = l)
                    }
                },
                hmacSha256Sync: {
                    configurable: !1,
                    get: () => _,
                    set(l) {
                        _ || (_ = l)
                    }
                }
            });
            var tj = p(8105),
                tT = p(6769);
            let HMAC = class HMAC extends tT.kb {
                constructor(l, c) {
                    super(), this.finished = !1, this.destroyed = !1, tj.ZP.hash(l);
                    let p = (0, tT.O0)(c);
                    if (this.iHash = l.create(), !(this.iHash instanceof tT.kb)) throw TypeError("Expected instance of class which extends utils.Hash");
                    let v = this.blockLen = this.iHash.blockLen;
                    this.outputLen = this.iHash.outputLen;
                    let _ = new Uint8Array(v);
                    _.set(p.length > this.iHash.blockLen ? l.create().update(p).digest() : p);
                    for (let l = 0; l < _.length; l++) _[l] ^= 54;
                    this.iHash.update(_), this.oHash = l.create();
                    for (let l = 0; l < _.length; l++) _[l] ^= 106;
                    this.oHash.update(_), _.fill(0)
                }
                update(l) {
                    return tj.ZP.exists(this), this.iHash.update(l), this
                }
                digestInto(l) {
                    tj.ZP.exists(this), tj.ZP.bytes(l, this.outputLen), this.finished = !0, this.iHash.digestInto(l), this.oHash.update(l), this.oHash.digestInto(l), this.destroy()
                }
                digest() {
                    let l = new Uint8Array(this.oHash.outputLen);
                    return this.digestInto(l), l
                }
                _cloneInto(l) {
                    l || (l = Object.create(Object.getPrototypeOf(this), {}));
                    let {
                        oHash: c,
                        iHash: p,
                        finished: v,
                        destroyed: _,
                        blockLen: C,
                        outputLen: P
                    } = this;
                    return l.finished = v, l.destroyed = _, l.blockLen = C, l.outputLen = P, l.oHash = c._cloneInto(l.oHash), l.iHash = p._cloneInto(l.iHash), l
                }
                destroy() {
                    this.destroyed = !0, this.oHash.destroy(), this.iHash.destroy()
                }
            };
            let hmac_hmac = (l, c, p) => new HMAC(l, c).update(p).digest();
            hmac_hmac.create = (l, c) => new HMAC(l, c);
            let SHA2 = class SHA2 extends tT.kb {
                constructor(l, c, p, v) {
                    super(), this.blockLen = l, this.outputLen = c, this.padOffset = p, this.isLE = v, this.finished = !1, this.length = 0, this.pos = 0, this.destroyed = !1, this.buffer = new Uint8Array(l), this.view = (0, tT.GL)(this.buffer)
                }
                update(l) {
                    tj.ZP.exists(this);
                    let {
                        view: c,
                        buffer: p,
                        blockLen: v
                    } = this;
                    l = (0, tT.O0)(l);
                    let _ = l.length;
                    for (let C = 0; C < _;) {
                        let P = Math.min(v - this.pos, _ - C);
                        if (P === v) {
                            let c = (0, tT.GL)(l);
                            for (; v <= _ - C; C += v) this.process(c, C);
                            continue
                        }
                        p.set(l.subarray(C, C + P), this.pos), this.pos += P, C += P, this.pos === v && (this.process(c, 0), this.pos = 0)
                    }
                    return this.length += l.length, this.roundClean(), this
                }
                digestInto(l) {
                    tj.ZP.exists(this), tj.ZP.output(l, this), this.finished = !0;
                    let {
                        buffer: c,
                        view: p,
                        blockLen: v,
                        isLE: _
                    } = this, {
                        pos: C
                    } = this;
                    c[C++] = 128, this.buffer.subarray(C).fill(0), this.padOffset > v - C && (this.process(p, 0), C = 0);
                    for (let l = C; l < v; l++) c[l] = 0;
                    ! function(l, c, p, v) {
                        if ("function" == typeof l.setBigUint64) return l.setBigUint64(c, p, v);
                        let _ = BigInt(32),
                            C = BigInt(4294967295),
                            P = Number(p >> _ & C),
                            T = Number(p & C),
                            M = v ? 4 : 0,
                            z = v ? 0 : 4;
                        l.setUint32(c + M, P, v), l.setUint32(c + z, T, v)
                    }(p, v - 8, BigInt(8 * this.length), _), this.process(p, 0);
                    let P = (0, tT.GL)(l);
                    this.get().forEach((l, c) => P.setUint32(4 * c, l, _))
                }
                digest() {
                    let {
                        buffer: l,
                        outputLen: c
                    } = this;
                    this.digestInto(l);
                    let p = l.slice(0, c);
                    return this.destroy(), p
                }
                _cloneInto(l) {
                    l || (l = new this.constructor), l.set(...this.get());
                    let {
                        blockLen: c,
                        buffer: p,
                        length: v,
                        finished: _,
                        destroyed: C,
                        pos: P
                    } = this;
                    return l.length = v, l.pos = P, l.finished = _, l.destroyed = C, v % c && l.buffer.set(p), l
                }
            };
            let Chi = (l, c, p) => l & c ^ ~l & p,
                Maj = (l, c, p) => l & c ^ l & p ^ c & p,
                tR = new Uint32Array([1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298]),
                tL = new Uint32Array([1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225]),
                tM = new Uint32Array(64);
            let SHA256 = class SHA256 extends SHA2 {
                constructor() {
                    super(64, 32, 8, !1), this.A = 0 | tL[0], this.B = 0 | tL[1], this.C = 0 | tL[2], this.D = 0 | tL[3], this.E = 0 | tL[4], this.F = 0 | tL[5], this.G = 0 | tL[6], this.H = 0 | tL[7]
                }
                get() {
                    let {
                        A: l,
                        B: c,
                        C: p,
                        D: v,
                        E: _,
                        F: C,
                        G: P,
                        H: T
                    } = this;
                    return [l, c, p, v, _, C, P, T]
                }
                set(l, c, p, v, _, C, P, T) {
                    this.A = 0 | l, this.B = 0 | c, this.C = 0 | p, this.D = 0 | v, this.E = 0 | _, this.F = 0 | C, this.G = 0 | P, this.H = 0 | T
                }
                process(l, c) {
                    for (let p = 0; p < 16; p++, c += 4) tM[p] = l.getUint32(c, !1);
                    for (let l = 16; l < 64; l++) {
                        let c = tM[l - 15],
                            p = tM[l - 2],
                            v = (0, tT.np)(c, 7) ^ (0, tT.np)(c, 18) ^ c >>> 3,
                            _ = (0, tT.np)(p, 17) ^ (0, tT.np)(p, 19) ^ p >>> 10;
                        tM[l] = _ + tM[l - 7] + v + tM[l - 16] | 0
                    }
                    let {
                        A: p,
                        B: v,
                        C: _,
                        D: C,
                        E: P,
                        F: T,
                        G: M,
                        H: z
                    } = this;
                    for (let l = 0; l < 64; l++) {
                        let c = (0, tT.np)(P, 6) ^ (0, tT.np)(P, 11) ^ (0, tT.np)(P, 25),
                            J = z + c + Chi(P, T, M) + tR[l] + tM[l] | 0,
                            Q = (0, tT.np)(p, 2) ^ (0, tT.np)(p, 13) ^ (0, tT.np)(p, 22),
                            X = Q + Maj(p, v, _) | 0;
                        z = M, M = T, T = P, P = C + J | 0, C = _, _ = v, v = p, p = J + X | 0
                    }
                    p = p + this.A | 0, v = v + this.B | 0, _ = _ + this.C | 0, C = C + this.D | 0, P = P + this.E | 0, T = T + this.F | 0, M = M + this.G | 0, z = z + this.H | 0, this.set(p, v, _, C, P, T, M, z)
                }
                roundClean() {
                    tM.fill(0)
                }
                destroy() {
                    this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0)
                }
            };
            let tU = (0, tT.hE)(() => new SHA256);
            var tB = p(3913);
            let [tF, tH] = tB.ZP.split(["0x428a2f98d728ae22", "0x7137449123ef65cd", "0xb5c0fbcfec4d3b2f", "0xe9b5dba58189dbbc", "0x3956c25bf348b538", "0x59f111f1b605d019", "0x923f82a4af194f9b", "0xab1c5ed5da6d8118", "0xd807aa98a3030242", "0x12835b0145706fbe", "0x243185be4ee4b28c", "0x550c7dc3d5ffb4e2", "0x72be5d74f27b896f", "0x80deb1fe3b1696b1", "0x9bdc06a725c71235", "0xc19bf174cf692694", "0xe49b69c19ef14ad2", "0xefbe4786384f25e3", "0x0fc19dc68b8cd5b5", "0x240ca1cc77ac9c65", "0x2de92c6f592b0275", "0x4a7484aa6ea6e483", "0x5cb0a9dcbd41fbd4", "0x76f988da831153b5", "0x983e5152ee66dfab", "0xa831c66d2db43210", "0xb00327c898fb213f", "0xbf597fc7beef0ee4", "0xc6e00bf33da88fc2", "0xd5a79147930aa725", "0x06ca6351e003826f", "0x142929670a0e6e70", "0x27b70a8546d22ffc", "0x2e1b21385c26c926", "0x4d2c6dfc5ac42aed", "0x53380d139d95b3df", "0x650a73548baf63de", "0x766a0abb3c77b2a8", "0x81c2c92e47edaee6", "0x92722c851482353b", "0xa2bfe8a14cf10364", "0xa81a664bbc423001", "0xc24b8b70d0f89791", "0xc76c51a30654be30", "0xd192e819d6ef5218", "0xd69906245565a910", "0xf40e35855771202a", "0x106aa07032bbd1b8", "0x19a4c116b8d2d0c8", "0x1e376c085141ab53", "0x2748774cdf8eeb99", "0x34b0bcb5e19b48a8", "0x391c0cb3c5c95a63", "0x4ed8aa4ae3418acb", "0x5b9cca4f7763e373", "0x682e6ff3d6b2b8a3", "0x748f82ee5defb2fc", "0x78a5636f43172f60", "0x84c87814a1f0ab72", "0x8cc702081a6439ec", "0x90befffa23631e28", "0xa4506cebde82bde9", "0xbef9a3f7b2c67915", "0xc67178f2e372532b", "0xca273eceea26619c", "0xd186b8c721c0c207", "0xeada7dd6cde0eb1e", "0xf57d4f7fee6ed178", "0x06f067aa72176fba", "0x0a637dc5a2c898a6", "0x113f9804bef90dae", "0x1b710b35131c471b", "0x28db77f523047d84", "0x32caab7b40c72493", "0x3c9ebe0a15c9bebc", "0x431d67c49c100d4c", "0x4cc5d4becb3e42b6", "0x597f299cfc657e2a", "0x5fcb6fab3ad6faec", "0x6c44198c4a475817"].map(l => BigInt(l))), tV = new Uint32Array(80), tz = new Uint32Array(80);
            let SHA512 = class SHA512 extends SHA2 {
                constructor() {
                    super(128, 64, 16, !1), this.Ah = 1779033703, this.Al = -205731576, this.Bh = -1150833019, this.Bl = -2067093701, this.Ch = 1013904242, this.Cl = -23791573, this.Dh = -1521486534, this.Dl = 1595750129, this.Eh = 1359893119, this.El = -1377402159, this.Fh = -1694144372, this.Fl = 725511199, this.Gh = 528734635, this.Gl = -79577749, this.Hh = 1541459225, this.Hl = 327033209
                }
                get() {
                    let {
                        Ah: l,
                        Al: c,
                        Bh: p,
                        Bl: v,
                        Ch: _,
                        Cl: C,
                        Dh: P,
                        Dl: T,
                        Eh: M,
                        El: z,
                        Fh: J,
                        Fl: Q,
                        Gh: X,
                        Gl: es,
                        Hh: eo,
                        Hl: el
                    } = this;
                    return [l, c, p, v, _, C, P, T, M, z, J, Q, X, es, eo, el]
                }
                set(l, c, p, v, _, C, P, T, M, z, J, Q, X, es, eo, el) {
                    this.Ah = 0 | l, this.Al = 0 | c, this.Bh = 0 | p, this.Bl = 0 | v, this.Ch = 0 | _, this.Cl = 0 | C, this.Dh = 0 | P, this.Dl = 0 | T, this.Eh = 0 | M, this.El = 0 | z, this.Fh = 0 | J, this.Fl = 0 | Q, this.Gh = 0 | X, this.Gl = 0 | es, this.Hh = 0 | eo, this.Hl = 0 | el
                }
                process(l, c) {
                    for (let p = 0; p < 16; p++, c += 4) tV[p] = l.getUint32(c), tz[p] = l.getUint32(c += 4);
                    for (let l = 16; l < 80; l++) {
                        let c = 0 | tV[l - 15],
                            p = 0 | tz[l - 15],
                            v = tB.ZP.rotrSH(c, p, 1) ^ tB.ZP.rotrSH(c, p, 8) ^ tB.ZP.shrSH(c, p, 7),
                            _ = tB.ZP.rotrSL(c, p, 1) ^ tB.ZP.rotrSL(c, p, 8) ^ tB.ZP.shrSL(c, p, 7),
                            C = 0 | tV[l - 2],
                            P = 0 | tz[l - 2],
                            T = tB.ZP.rotrSH(C, P, 19) ^ tB.ZP.rotrBH(C, P, 61) ^ tB.ZP.shrSH(C, P, 6),
                            M = tB.ZP.rotrSL(C, P, 19) ^ tB.ZP.rotrBL(C, P, 61) ^ tB.ZP.shrSL(C, P, 6),
                            z = tB.ZP.add4L(_, M, tz[l - 7], tz[l - 16]),
                            J = tB.ZP.add4H(z, v, T, tV[l - 7], tV[l - 16]);
                        tV[l] = 0 | J, tz[l] = 0 | z
                    }
                    let {
                        Ah: p,
                        Al: v,
                        Bh: _,
                        Bl: C,
                        Ch: P,
                        Cl: T,
                        Dh: M,
                        Dl: z,
                        Eh: J,
                        El: Q,
                        Fh: X,
                        Fl: es,
                        Gh: eo,
                        Gl: el,
                        Hh: ec,
                        Hl: eh
                    } = this;
                    for (let l = 0; l < 80; l++) {
                        let c = tB.ZP.rotrSH(J, Q, 14) ^ tB.ZP.rotrSH(J, Q, 18) ^ tB.ZP.rotrBH(J, Q, 41),
                            ed = tB.ZP.rotrSL(J, Q, 14) ^ tB.ZP.rotrSL(J, Q, 18) ^ tB.ZP.rotrBL(J, Q, 41),
                            ef = J & X ^ ~J & eo,
                            ep = Q & es ^ ~Q & el,
                            eg = tB.ZP.add5L(eh, ed, ep, tH[l], tz[l]),
                            em = tB.ZP.add5H(eg, ec, c, ef, tF[l], tV[l]),
                            ey = 0 | eg,
                            eb = tB.ZP.rotrSH(p, v, 28) ^ tB.ZP.rotrBH(p, v, 34) ^ tB.ZP.rotrBH(p, v, 39),
                            ew = tB.ZP.rotrSL(p, v, 28) ^ tB.ZP.rotrBL(p, v, 34) ^ tB.ZP.rotrBL(p, v, 39),
                            ex = p & _ ^ p & P ^ _ & P,
                            e_ = v & C ^ v & T ^ C & T;
                        ec = 0 | eo, eh = 0 | el, eo = 0 | X, el = 0 | es, X = 0 | J, es = 0 | Q, ({
                            h: J,
                            l: Q
                        } = tB.ZP.add(0 | M, 0 | z, 0 | em, 0 | ey)), M = 0 | P, z = 0 | T, P = 0 | _, T = 0 | C, _ = 0 | p, C = 0 | v;
                        let eE = tB.ZP.add3L(ey, ew, e_);
                        p = tB.ZP.add3H(eE, em, eb, ex), v = 0 | eE
                    }({
                        h: p,
                        l: v
                    } = tB.ZP.add(0 | this.Ah, 0 | this.Al, 0 | p, 0 | v)), ({
                        h: _,
                        l: C
                    } = tB.ZP.add(0 | this.Bh, 0 | this.Bl, 0 | _, 0 | C)), ({
                        h: P,
                        l: T
                    } = tB.ZP.add(0 | this.Ch, 0 | this.Cl, 0 | P, 0 | T)), ({
                        h: M,
                        l: z
                    } = tB.ZP.add(0 | this.Dh, 0 | this.Dl, 0 | M, 0 | z)), ({
                        h: J,
                        l: Q
                    } = tB.ZP.add(0 | this.Eh, 0 | this.El, 0 | J, 0 | Q)), ({
                        h: X,
                        l: es
                    } = tB.ZP.add(0 | this.Fh, 0 | this.Fl, 0 | X, 0 | es)), ({
                        h: eo,
                        l: el
                    } = tB.ZP.add(0 | this.Gh, 0 | this.Gl, 0 | eo, 0 | el)), ({
                        h: ec,
                        l: eh
                    } = tB.ZP.add(0 | this.Hh, 0 | this.Hl, 0 | ec, 0 | eh)), this.set(p, v, _, C, P, T, M, z, J, Q, X, es, eo, el, ec, eh)
                }
                roundClean() {
                    tV.fill(0), tz.fill(0)
                }
                destroy() {
                    this.buffer.fill(0), this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)
                }
            };
            let SHA512_256 = class SHA512_256 extends SHA512 {
                constructor() {
                    super(), this.Ah = 573645204, this.Al = -64227540, this.Bh = -1621794909, this.Bl = -934517566, this.Ch = 596883563, this.Cl = 1867755857, this.Dh = -1774684391, this.Dl = 1497426621, this.Eh = -1775747358, this.El = -1467023389, this.Fh = -1101128155, this.Fl = 1401305490, this.Gh = 721525244, this.Gl = 746961066, this.Hh = 246885852, this.Hl = -2117784414, this.outputLen = 32
                }
            };
            let SHA384 = class SHA384 extends SHA512 {
                constructor() {
                    super(), this.Ah = -876896931, this.Al = -1056596264, this.Bh = 1654270250, this.Bl = 914150663, this.Ch = -1856437926, this.Cl = 812702999, this.Dh = 355462360, this.Dl = -150054599, this.Eh = 1731405415, this.El = -4191439, this.Fh = -1900787065, this.Fl = 1750603025, this.Gh = -619958771, this.Gl = 1694076839, this.Hh = 1203062813, this.Hl = -1090891868, this.outputLen = 48
                }
            };
            let tq = (0, tT.hE)(() => new SHA512);
            (0, tT.hE)(() => new SHA512_256), (0, tT.hE)(() => new SHA384);
            let tW = function() {
                if ("undefined" != typeof self) return self;
                if ("undefined" != typeof window) return window;
                if ("undefined" != typeof global) return global;
                throw Error("unable to locate global object")
            }();
            tW.crypto || tW.msCrypto;
            let tG = !1,
                _computeHmac = function(l, c, p) {
                    return (function(l, c) {
                        let p = {
                            sha256: tU,
                            sha512: tq
                        }[l];
                        return (0, C.en)(null != p, "invalid hmac algorithm", "algorithm", l), hmac_hmac.create(p, c)
                    })(l, c).update(p).digest()
                },
                tK = _computeHmac;

            function computeHmac(l, c, p) {
                let v = (0, T.Pw)(c, "key"),
                    _ = (0, T.Pw)(p, "data");
                return (0, T.Dv)(tK(l, v, _))
            }
            computeHmac._ = _computeHmac, computeHmac.lock = function() {
                tG = !0
            }, computeHmac.register = function(l) {
                if (tG) throw Error("computeHmac is locked");
                tK = l
            }, Object.freeze(computeHmac), tO.hmacSha256Sync = function(l, ...c) {
                return (0, T.Pw)(computeHmac("sha256", l, (0, T.zo)(c)))
            };
            let SigningKey = class SigningKey {#
                T;
                constructor(l) {
                    (0, C.en)(32 === (0, T.M5)(l), "invalid private key", "privateKey", "[REDACTED]"), this.#T = (0, T.Dv)(l)
                }
                get privateKey() {
                    return this.#T
                }
                get publicKey() {
                    return SigningKey.computePublicKey(this.#T)
                }
                get compressedPublicKey() {
                    return SigningKey.computePublicKey(this.#T, !0)
                }
                sign(l) {
                    (0, C.en)(32 === (0, T.M5)(l), "invalid digest length", "digest", l);
                    let [c, p] = function(l, c, p = {}) {
                        let v;
                        let {
                            seed: _,
                            m: C,
                            d: P
                        } = function(l, c, p) {
                            if (null == l) throw Error(`sign: expected valid message hash, not "${l}"`);
                            let v = ensureBytes(l),
                                _ = normalizePrivateKey(c),
                                C = [numTo32b(_), function(l) {
                                    var c;
                                    let p = bits2int(l),
                                        v = mod(p, tA.n);
                                    return numTo32b(v < tb ? p : v)
                                }(v)];
                            if (null != p) {
                                !0 === p && (p = tO.randomBytes(32));
                                let l = ensureBytes(p);
                                if (32 !== l.length) throw Error("sign: Expected 32 bytes of extra data");
                                C.push(l)
                            }
                            let P = concatBytes(...C),
                                T = bits2int(v);
                            return {
                                seed: P,
                                m: T,
                                d: _
                            }
                        }(l, c, p.extraEntropy), T = new HmacDrbg(32, 32);
                        for (T.reseedSync(_); !(v = function(l, c, p, v = !0) {
                                let {
                                    n: _
                                } = tA, C = truncateHash(l, !0);
                                if (!isWithinCurveOrder(C)) return;
                                let P = invert(C, _),
                                    T = Point.BASE.multiply(C),
                                    M = mod(T.x, _);
                                if (M === tb) return;
                                let z = mod(P * mod(c + p * M, _), _);
                                if (z === tb) return;
                                let J = new esm_Signature(M, z),
                                    Q = (T.x === J.r ? 0 : 2) | Number(T.y & tw);
                                return v && J.hasHighS() && (J = J.normalizeS(), Q ^= 1), {
                                    sig: J,
                                    recovery: Q
                                }
                            }(T.generateSync(), C, P, p.canonical));) T.reseedSync();
                        return function(l, c) {
                            let {
                                sig: p,
                                recovery: v
                            } = l, {
                                der: _,
                                recovered: C
                            } = Object.assign({
                                canonical: !0,
                                der: !0
                            }, c), P = _ ? p.toDERRawBytes() : p.toCompactRawBytes();
                            return C ? [P, v] : P
                        }(v, p)
                    }((0, T.h_)(l), (0, T.h_)(this.#T), {
                        recovered: !0,
                        canonical: !0
                    }), v = esm_Signature.fromHex(c);
                    return Signature.from({
                        r: (0, P.m9)("0x" + v.r.toString(16), 32),
                        s: (0, P.m9)("0x" + v.s.toString(16), 32),
                        v: p ? 28 : 27
                    })
                }
                computeSharedSecret(l) {
                    let c = SigningKey.computePublicKey(l);
                    return (0, T.Dv)(function(l, c, p = !1) {
                        if (isProbPub(l)) throw TypeError("getSharedSecret: first arg must be private key");
                        if (!isProbPub(c)) throw TypeError("getSharedSecret: second arg must be public key");
                        let v = c instanceof Point ? (c.assertValidity(), c) : Point.fromHex(c);
                        return v.assertValidity(), v.multiply(normalizePrivateKey(l)).toRawBytes(p)
                    }((0, T.h_)(this.#T), (0, T.Pw)(c)))
                }
                static computePublicKey(l, c) {
                    let p = (0, T.Pw)(l, "key");
                    if (32 === p.length) {
                        let l = function(l, c = !1) {
                            return Point.fromPrivateKey(l).toRawBytes(c)
                        }(p, !!c);
                        return (0, T.Dv)(l)
                    }
                    if (64 === p.length) {
                        let l = new Uint8Array(65);
                        l[0] = 4, l.set(p, 1), p = l
                    }
                    let v = Point.fromHex(p);
                    return (0, T.Dv)(v.toRawBytes(c))
                }
                static recoverPublicKey(l, c) {
                    (0, C.en)(32 === (0, T.M5)(l), "invalid digest length", "digest", l);
                    let p = Signature.from(c),
                        v = esm_Signature.fromCompact((0, T.h_)((0, T.zo)([p.r, p.s]))).toDERRawBytes(),
                        _ = function(l, c, p, v = !1) {
                            return Point.fromSignature(l, c, p).toRawBytes(v)
                        }((0, T.h_)(l), v, p.yParity);
                    return (0, C.en)(null != _, "invalid signature for digest", "signature", c), (0, T.Dv)(_)
                }
                static addPoints(l, c, p) {
                    let v = Point.fromHex(SigningKey.computePublicKey(l).substring(2)),
                        _ = Point.fromHex(SigningKey.computePublicKey(c).substring(2));
                    return "0x" + v.add(_).toHex(!!p)
                }
            };

            function unarrayifyInteger(l, c, p) {
                let v = 0;
                for (let _ = 0; _ < p; _++) v = 256 * v + l[c + _];
                return v
            }

            function _decodeChildren(l, c, p, v) {
                let _ = [];
                for (; p < c + 1 + v;) {
                    let P = _decode(l, p);
                    _.push(P.result), p += P.consumed, (0, C.hu)(p <= c + 1 + v, "child data too short", "BUFFER_OVERRUN", {
                        buffer: l,
                        length: v,
                        offset: c
                    })
                }
                return {
                    consumed: 1 + v,
                    result: _
                }
            }

            function _decode(l, c) {
                (0, C.hu)(0 !== l.length, "data too short", "BUFFER_OVERRUN", {
                    buffer: l,
                    length: 0,
                    offset: 1
                });
                let checkOffset = c => {
                    (0, C.hu)(c <= l.length, "data short segment too short", "BUFFER_OVERRUN", {
                        buffer: l,
                        length: l.length,
                        offset: c
                    })
                };
                if (l[c] >= 248) {
                    let p = l[c] - 247;
                    checkOffset(c + 1 + p);
                    let v = unarrayifyInteger(l, c + 1, p);
                    return checkOffset(c + 1 + p + v), _decodeChildren(l, c, c + 1 + p, p + v)
                }
                if (l[c] >= 192) {
                    let p = l[c] - 192;
                    return checkOffset(c + 1 + p), _decodeChildren(l, c, c + 1, p)
                }
                if (l[c] >= 184) {
                    let p = l[c] - 183;
                    checkOffset(c + 1 + p);
                    let v = unarrayifyInteger(l, c + 1, p);
                    checkOffset(c + 1 + p + v);
                    let _ = (0, T.Dv)(l.slice(c + 1 + p, c + 1 + p + v));
                    return {
                        consumed: 1 + p + v,
                        result: _
                    }
                }
                if (l[c] >= 128) {
                    let p = l[c] - 128;
                    checkOffset(c + 1 + p);
                    let v = (0, T.Dv)(l.slice(c + 1, c + 1 + p));
                    return {
                        consumed: 1 + p,
                        result: v
                    }
                }
                return {
                    consumed: 1,
                    result: function(l) {
                        let c = l.toString(16);
                        for (; c.length < 2;) c = "0" + c;
                        return "0x" + c
                    }(l[c])
                }
            }

            function decodeRlp(l) {
                let c = (0, T.Pw)(l, "data"),
                    p = _decode(c, 0);
                return (0, C.en)(p.consumed === c.length, "unexpected junk after rlp payload", "data", l), p.result
            }

            function arrayifyInteger(l) {
                let c = [];
                for (; l;) c.unshift(255 & l), l >>= 8;
                return c
            }
            let tZ = "0123456789abcdef";

            function encodeRlp(l) {
                let c = "0x";
                for (let p of function _encode(l) {
                        if (Array.isArray(l)) {
                            let c = [];
                            if (l.forEach(function(l) {
                                    c = c.concat(_encode(l))
                                }), c.length <= 55) return c.unshift(192 + c.length), c;
                            let p = arrayifyInteger(c.length);
                            return p.unshift(247 + p.length), p.concat(c)
                        }
                        let c = Array.prototype.slice.call((0, T.Pw)(l, "object"));
                        if (1 === c.length && c[0] <= 127) return c;
                        if (c.length <= 55) return c.unshift(128 + c.length), c;
                        let p = arrayifyInteger(c.length);
                        return p.unshift(183 + p.length), p.concat(c)
                    }(l)) c += tZ[p >> 4] + tZ[15 & p];
                return c
            }
            let tJ = BigInt(0),
                tQ = BigInt(2),
                t$ = BigInt(27),
                tY = BigInt(28),
                tX = BigInt(35),
                t0 = BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");

            function handleAddress(l) {
                return "0x" === l ? null : (0, X.K)(l)
            }

            function handleAccessList(l, c) {
                try {
                    return (0, e2.z)(l)
                } catch (p) {
                    (0, C.en)(!1, p.message, c, l)
                }
            }

            function handleNumber(l, c) {
                return "0x" === l ? 0 : (0, P.Dx)(l, c)
            }

            function handleUint(l, c) {
                if ("0x" === l) return tJ;
                let p = (0, P.yT)(l, c);
                return (0, C.en)(p <= t0, "value exceeds uint size", c, p), p
            }

            function formatNumber(l, c) {
                let p = (0, P.yT)(l, "value"),
                    v = (0, P.ot)(p);
                return (0, C.en)(v.length <= 32, "value too large", `tx.${c}`, p), v
            }

            function formatAccessList(l) {
                return (0, e2.z)(l).map(l => [l.address, l.storageKeys])
            }

            function _serializeLegacy(l, c) {
                let p = [formatNumber(l.nonce || 0, "nonce"), formatNumber(l.gasPrice || 0, "gasPrice"), formatNumber(l.gasLimit || 0, "gasLimit"), null != l.to ? (0, X.K)(l.to) : "0x", formatNumber(l.value || 0, "value"), l.data || "0x"],
                    v = tJ;
                if (l.chainId != tJ) v = (0, P.yT)(l.chainId, "tx.chainId"), (0, C.en)(!c || null == c.networkV || c.legacyChainId === v, "tx.chainId/sig.v mismatch", "sig", c);
                else if (l.signature) {
                    let c = l.signature.legacyChainId;
                    null != c && (v = c)
                }
                if (!c) return v !== tJ && (p.push((0, P.ot)(v)), p.push("0x"), p.push("0x")), encodeRlp(p);
                let _ = BigInt(27 + c.yParity);
                return v !== tJ ? _ = Signature.getChainIdV(v, c.v) : BigInt(c.v) !== _ && (0, C.en)(!1, "tx.chainId/sig.v mismatch", "sig", c), p.push((0, P.ot)(_)), p.push((0, P.ot)(c.r)), p.push((0, P.ot)(c.s)), encodeRlp(p)
            }

            function _parseEipSignature(l, c) {
                let p;
                try {
                    if (p = handleNumber(c[0], "yParity"), 0 !== p && 1 !== p) throw Error("bad yParity")
                } catch (l) {
                    (0, C.en)(!1, "invalid yParity", "yParity", c[0])
                }
                let v = (0, T.U3)(c[1], 32),
                    _ = (0, T.U3)(c[2], 32),
                    P = Signature.from({
                        r: v,
                        s: _,
                        yParity: p
                    });
                l.signature = P
            }

            function _serializeEip1559(l, c) {
                let p = [formatNumber(l.chainId || 0, "chainId"), formatNumber(l.nonce || 0, "nonce"), formatNumber(l.maxPriorityFeePerGas || 0, "maxPriorityFeePerGas"), formatNumber(l.maxFeePerGas || 0, "maxFeePerGas"), formatNumber(l.gasLimit || 0, "gasLimit"), null != l.to ? (0, X.K)(l.to) : "0x", formatNumber(l.value || 0, "value"), l.data || "0x", formatAccessList(l.accessList || [])];
                return c && (p.push(formatNumber(c.yParity, "yParity")), p.push((0, P.ot)(c.r)), p.push((0, P.ot)(c.s))), (0, T.zo)(["0x02", encodeRlp(p)])
            }

            function _serializeEip2930(l, c) {
                let p = [formatNumber(l.chainId || 0, "chainId"), formatNumber(l.nonce || 0, "nonce"), formatNumber(l.gasPrice || 0, "gasPrice"), formatNumber(l.gasLimit || 0, "gasLimit"), null != l.to ? (0, X.K)(l.to) : "0x", formatNumber(l.value || 0, "value"), l.data || "0x", formatAccessList(l.accessList || [])];
                return c && (p.push(formatNumber(c.yParity, "recoveryParam")), p.push((0, P.ot)(c.r)), p.push((0, P.ot)(c.s))), (0, T.zo)(["0x01", encodeRlp(p)])
            }
            let Transaction = class Transaction {#
                R;#
                L;#
                o;#
                M;#
                U;#
                B;#
                F;#
                H;#
                V;#
                i;#
                z;#
                q;
                get type() {
                    return this.#R
                }
                set type(l) {
                    switch (l) {
                        case null:
                            this.#R = null;
                            break;
                        case 0:
                        case "legacy":
                            this.#R = 0;
                            break;
                        case 1:
                        case "berlin":
                        case "eip-2930":
                            this.#R = 1;
                            break;
                        case 2:
                        case "london":
                        case "eip-1559":
                            this.#R = 2;
                            break;
                        default:
                            (0, C.en)(!1, "unsupported transaction type", "type", l)
                    }
                }
                get typeName() {
                    switch (this.type) {
                        case 0:
                            return "legacy";
                        case 1:
                            return "eip-2930";
                        case 2:
                            return "eip-1559"
                    }
                    return null
                }
                get to() {
                    return this.#L
                }
                set to(l) {
                    this.#L = null == l ? null : (0, X.K)(l)
                }
                get nonce() {
                    return this.#M
                }
                set nonce(l) {
                    this.#M = (0, P.Dx)(l, "value")
                }
                get gasLimit() {
                    return this.#U
                }
                set gasLimit(l) {
                    this.#U = (0, P.yT)(l)
                }
                get gasPrice() {
                    let l = this.#B;
                    return null == l && (0 === this.type || 1 === this.type) ? tJ : l
                }
                set gasPrice(l) {
                    this.#B = null == l ? null : (0, P.yT)(l, "gasPrice")
                }
                get maxPriorityFeePerGas() {
                    let l = this.#F;
                    return null == l ? 2 === this.type ? tJ : null : l
                }
                set maxPriorityFeePerGas(l) {
                    this.#F = null == l ? null : (0, P.yT)(l, "maxPriorityFeePerGas")
                }
                get maxFeePerGas() {
                    let l = this.#H;
                    return null == l ? 2 === this.type ? tJ : null : l
                }
                set maxFeePerGas(l) {
                    this.#H = null == l ? null : (0, P.yT)(l, "maxFeePerGas")
                }
                get data() {
                    return this.#o
                }
                set data(l) {
                    this.#o = (0, T.Dv)(l)
                }
                get value() {
                    return this.#V
                }
                set value(l) {
                    this.#V = (0, P.yT)(l, "value")
                }
                get chainId() {
                    return this.#i
                }
                set chainId(l) {
                    this.#i = (0, P.yT)(l)
                }
                get signature() {
                    return this.#z || null
                }
                set signature(l) {
                    this.#z = null == l ? null : Signature.from(l)
                }
                get accessList() {
                    let l = this.#q || null;
                    return null == l ? 1 === this.type || 2 === this.type ? [] : null : l
                }
                set accessList(l) {
                    this.#q = null == l ? null : (0, e2.z)(l)
                }
                constructor() {
                    this.#R = null, this.#L = null, this.#M = 0, this.#U = BigInt(0), this.#B = null, this.#F = null, this.#H = null, this.#o = "0x", this.#V = BigInt(0), this.#i = BigInt(0), this.#z = null, this.#q = null
                }
                get hash() {
                    return null == this.signature ? null : (0, ep.w)(this.serialized)
                }
                get unsignedHash() {
                    return (0, ep.w)(this.unsignedSerialized)
                }
                get from() {
                    var l, c, p;
                    let v;
                    return null == this.signature ? null : (l = this.unsignedHash, c = this.signature, v = "string" == typeof(p = SigningKey.recoverPublicKey(l, c)) ? SigningKey.computePublicKey(p, !1) : p.publicKey, (0, X.K)((0, ep.w)("0x" + v.substring(4)).substring(26)))
                }
                get fromPublicKey() {
                    return null == this.signature ? null : SigningKey.recoverPublicKey(this.unsignedHash, this.signature)
                }
                isSigned() {
                    return null != this.signature
                }
                get serialized() {
                    switch ((0, C.hu)(null != this.signature, "cannot serialize unsigned transaction; maybe you meant .unsignedSerialized", "UNSUPPORTED_OPERATION", {
                        operation: ".serialized"
                    }), this.inferType()) {
                        case 0:
                            return _serializeLegacy(this, this.signature);
                        case 1:
                            return _serializeEip2930(this, this.signature);
                        case 2:
                            return _serializeEip1559(this, this.signature)
                    }(0, C.hu)(!1, "unsupported transaction type", "UNSUPPORTED_OPERATION", {
                        operation: ".serialized"
                    })
                }
                get unsignedSerialized() {
                    switch (this.inferType()) {
                        case 0:
                            return _serializeLegacy(this);
                        case 1:
                            return _serializeEip2930(this);
                        case 2:
                            return _serializeEip1559(this)
                    }(0, C.hu)(!1, "unsupported transaction type", "UNSUPPORTED_OPERATION", {
                        operation: ".unsignedSerialized"
                    })
                }
                inferType() {
                    return this.inferTypes().pop()
                }
                inferTypes() {
                    let l = null != this.gasPrice,
                        c = null != this.maxFeePerGas || null != this.maxPriorityFeePerGas,
                        p = null != this.accessList;
                    null != this.maxFeePerGas && null != this.maxPriorityFeePerGas && (0, C.hu)(this.maxFeePerGas >= this.maxPriorityFeePerGas, "priorityFee cannot be more than maxFee", "BAD_DATA", {
                        value: this
                    }), (0, C.hu)(!c || 0 !== this.type && 1 !== this.type, "transaction type cannot have maxFeePerGas or maxPriorityFeePerGas", "BAD_DATA", {
                        value: this
                    }), (0, C.hu)(0 !== this.type || !p, "legacy transaction cannot have accessList", "BAD_DATA", {
                        value: this
                    });
                    let v = [];
                    return null != this.type ? v.push(this.type) : c ? v.push(2) : l ? (v.push(1), p || v.push(0)) : (p || v.push(0), v.push(1), v.push(2)), v.sort(), v
                }
                isLegacy() {
                    return 0 === this.type
                }
                isBerlin() {
                    return 1 === this.type
                }
                isLondon() {
                    return 2 === this.type
                }
                clone() {
                    return Transaction.from(this)
                }
                toJSON() {
                    let s = l => null == l ? null : l.toString();
                    return {
                        type: this.type,
                        to: this.to,
                        data: this.data,
                        nonce: this.nonce,
                        gasLimit: s(this.gasLimit),
                        gasPrice: s(this.gasPrice),
                        maxPriorityFeePerGas: s(this.maxPriorityFeePerGas),
                        maxFeePerGas: s(this.maxFeePerGas),
                        value: s(this.value),
                        chainId: s(this.chainId),
                        sig: this.signature ? this.signature.toJSON() : null,
                        accessList: this.accessList
                    }
                }
                static from(l) {
                    if (null == l) return new Transaction;
                    if ("string" == typeof l) {
                        let c = (0, T.Pw)(l);
                        if (c[0] >= 127) return Transaction.from(function(l) {
                            let c = decodeRlp(l);
                            (0, C.en)(Array.isArray(c) && (9 === c.length || 6 === c.length), "invalid field count for legacy transaction", "data", l);
                            let p = {
                                type: 0,
                                nonce: handleNumber(c[0], "nonce"),
                                gasPrice: handleUint(c[1], "gasPrice"),
                                gasLimit: handleUint(c[2], "gasLimit"),
                                to: handleAddress(c[3]),
                                value: handleUint(c[4], "value"),
                                data: (0, T.Dv)(c[5]),
                                chainId: tJ
                            };
                            if (6 === c.length) return p;
                            let v = handleUint(c[6], "v"),
                                _ = handleUint(c[7], "r"),
                                P = handleUint(c[8], "s");
                            if (_ === tJ && P === tJ) p.chainId = v;
                            else {
                                let _ = (v - tX) / tQ;
                                _ < tJ && (_ = tJ), p.chainId = _, (0, C.en)(_ !== tJ || v === t$ || v === tY, "non-canonical legacy v", "v", c[6]), p.signature = Signature.from({
                                    r: (0, T.U3)(c[7], 32),
                                    s: (0, T.U3)(c[8], 32),
                                    v
                                }), p.hash = (0, ep.w)(l)
                            }
                            return p
                        }(c));
                        switch (c[0]) {
                            case 1:
                                return Transaction.from(function(l) {
                                    let c = decodeRlp((0, T.Pw)(l).slice(1));
                                    (0, C.en)(Array.isArray(c) && (8 === c.length || 11 === c.length), "invalid field count for transaction type: 1", "data", (0, T.Dv)(l));
                                    let p = {
                                        type: 1,
                                        chainId: handleUint(c[0], "chainId"),
                                        nonce: handleNumber(c[1], "nonce"),
                                        gasPrice: handleUint(c[2], "gasPrice"),
                                        gasLimit: handleUint(c[3], "gasLimit"),
                                        to: handleAddress(c[4]),
                                        value: handleUint(c[5], "value"),
                                        data: (0, T.Dv)(c[6]),
                                        accessList: handleAccessList(c[7], "accessList")
                                    };
                                    return 8 === c.length || (p.hash = (0, ep.w)(l), _parseEipSignature(p, c.slice(8))), p
                                }(c));
                            case 2:
                                return Transaction.from(function(l) {
                                    let c = decodeRlp((0, T.Pw)(l).slice(1));
                                    (0, C.en)(Array.isArray(c) && (9 === c.length || 12 === c.length), "invalid field count for transaction type: 2", "data", (0, T.Dv)(l));
                                    let p = handleUint(c[2], "maxPriorityFeePerGas"),
                                        v = handleUint(c[3], "maxFeePerGas"),
                                        _ = {
                                            type: 2,
                                            chainId: handleUint(c[0], "chainId"),
                                            nonce: handleNumber(c[1], "nonce"),
                                            maxPriorityFeePerGas: p,
                                            maxFeePerGas: v,
                                            gasPrice: null,
                                            gasLimit: handleUint(c[4], "gasLimit"),
                                            to: handleAddress(c[5]),
                                            value: handleUint(c[6], "value"),
                                            data: (0, T.Dv)(c[7]),
                                            accessList: handleAccessList(c[8], "accessList")
                                        };
                                    return 9 === c.length || (_.hash = (0, ep.w)(l), _parseEipSignature(_, c.slice(9))), _
                                }(c))
                        }(0, C.hu)(!1, "unsupported transaction type", "UNSUPPORTED_OPERATION", {
                            operation: "from"
                        })
                    }
                    let c = new Transaction;
                    return null != l.type && (c.type = l.type), null != l.to && (c.to = l.to), null != l.nonce && (c.nonce = l.nonce), null != l.gasLimit && (c.gasLimit = l.gasLimit), null != l.gasPrice && (c.gasPrice = l.gasPrice), null != l.maxPriorityFeePerGas && (c.maxPriorityFeePerGas = l.maxPriorityFeePerGas), null != l.maxFeePerGas && (c.maxFeePerGas = l.maxFeePerGas), null != l.data && (c.data = l.data), null != l.value && (c.value = l.value), null != l.chainId && (c.chainId = l.chainId), null != l.signature && (c.signature = Signature.from(l.signature)), null != l.accessList && (c.accessList = l.accessList), null != l.hash && ((0, C.en)(c.isSigned(), "unsigned transaction cannot define hash", "tx", l), (0, C.en)(c.hash === l.hash, "hash mismatch", "tx", l)), null != l.from && ((0, C.en)(c.isSigned(), "unsigned transaction cannot define from", "tx", l), (0, C.en)(c.from.toLowerCase() === (l.from || "").toLowerCase(), "from mismatch", "tx", l)), c
                }
            };
            let getUrlFunc = async function(l, c) {
                    let p;
                    let v = l.url.split(":")[0].toLowerCase();
                    if ((0, C.hu)("http" === v || "https" === v, `unsupported protocol ${v}`, "UNSUPPORTED_OPERATION", {
                            info: {
                                protocol: v
                            },
                            operation: "request"
                        }), (0, C.hu)("https" === v || !l.credentials || l.allowInsecureAuthentication, "insecure authorized connections unsupported", "UNSUPPORTED_OPERATION", {
                            operation: "request"
                        }), c) {
                        let l = new AbortController;
                        p = l.signal, c.addListener(() => {
                            l.abort()
                        })
                    }
                    let _ = {
                            method: l.method,
                            headers: new Headers(Array.from(l)),
                            body: l.body || void 0,
                            signal: p
                        },
                        P = await fetch(l.url, _),
                        T = {};
                    P.headers.forEach((l, c) => {
                        T[c.toLowerCase()] = l
                    });
                    let M = await P.arrayBuffer(),
                        z = null == M ? null : new Uint8Array(M);
                    return {
                        statusCode: P.status,
                        statusMessage: P.statusText,
                        headers: T,
                        body: z
                    }
                },
                t1 = RegExp("^data:([^;:]*)?(;base64)?,(.*)$", "i"),
                t2 = RegExp("^ipfs://(ipfs/)?(.*)$", "i"),
                t5 = !1;
            async function dataGatewayFunc(l, c) {
                try {
                    var p;
                    let c = l.match(t1);
                    if (!c) throw Error("invalid data");
                    return new FetchResponse(200, "OK", {
                        "content-type": c[1] || "text/plain"
                    }, c[2] ? function(l) {
                        l = atob(l);
                        let c = new Uint8Array(l.length);
                        for (let p = 0; p < l.length; p++) c[p] = l.charCodeAt(p);
                        return (0, T.Pw)(c)
                    }(c[3]) : (p = c[3], (0, ef.Y0)(p.replace(/%([0-9a-f][0-9a-f])/gi, (l, c) => String.fromCharCode(parseInt(c, 16))))))
                } catch (c) {
                    return new FetchResponse(599, "BAD REQUEST (invalid data: URI)", {}, null, new fetch_FetchRequest(l))
                }
            }

            function getIpfsGatewayFunc(l) {
                return async function(c, p) {
                    try {
                        let p = c.match(t2);
                        if (!p) throw Error("invalid link");
                        return new fetch_FetchRequest(`${l}${p[2]}`)
                    } catch (l) {
                        return new FetchResponse(599, "BAD REQUEST (invalid IPFS URI)", {}, null, new fetch_FetchRequest(c))
                    }
                }
            }
            let t3 = {
                    data: dataGatewayFunc,
                    ipfs: getIpfsGatewayFunc("https://gateway.ipfs.io/ipfs/")
                },
                t6 = new WeakMap;
            let FetchCancelSignal = class FetchCancelSignal {#
                W;#
                G;
                constructor(l) {
                    this.#W = [], this.#G = !1, t6.set(l, () => {
                        if (!this.#G) {
                            for (let l of (this.#G = !0, this.#W)) setTimeout(() => {
                                l()
                            }, 0);
                            this.#W = []
                        }
                    })
                }
                addListener(l) {
                    (0, C.hu)(!this.#G, "singal already cancelled", "UNSUPPORTED_OPERATION", {
                        operation: "fetchCancelSignal.addCancelListener"
                    }), this.#W.push(l)
                }
                get cancelled() {
                    return this.#G
                }
                checkSignal() {
                    (0, C.hu)(!this.cancelled, "cancelled", "CANCELLED", {})
                }
            };

            function checkSignal(l) {
                if (null == l) throw Error("missing signal; should not happen");
                return l.checkSignal(), l
            }
            let fetch_FetchRequest = class fetch_FetchRequest {#
                K;#
                Z;#
                J;#
                Q;#
                $;#
                t;#
                Y;#
                X;#
                ee;#
                et;#
                er;#
                en;#
                ei;#
                es;
                get url() {
                    return this.#t
                }
                set url(l) {
                    this.#t = String(l)
                }
                get body() {
                    return null == this.#Y ? null : new Uint8Array(this.#Y)
                }
                set body(l) {
                    if (null == l) this.#Y = void 0, this.#X = void 0;
                    else if ("string" == typeof l) this.#Y = (0, ef.Y0)(l), this.#X = "text/plain";
                    else if (l instanceof Uint8Array) this.#Y = l, this.#X = "application/octet-stream";
                    else if ("object" == typeof l) this.#Y = (0, ef.Y0)(JSON.stringify(l)), this.#X = "application/json";
                    else throw Error("invalid body")
                }
                hasBody() {
                    return null != this.#Y
                }
                get method() {
                    return this.#Q ? this.#Q : this.hasBody() ? "POST" : "GET"
                }
                set method(l) {
                    null == l && (l = ""), this.#Q = String(l).toUpperCase()
                }
                get headers() {
                    let l = Object.assign({}, this.#J);
                    return this.#ee && (l.authorization = `Basic ${function(l){let c=(0,T.Pw)(l),p="";for(let l=0;l<c.length;l++)p+=String.fromCharCode(c[l]);return btoa(p)}((0,ef.Y0)(this.#ee))}`), this.allowGzip && (l["accept-encoding"] = "gzip"), null == l["content-type"] && this.#X && (l["content-type"] = this.#X), this.body && (l["content-length"] = String(this.body.length)), l
                }
                getHeader(l) {
                    return this.headers[l.toLowerCase()]
                }
                setHeader(l, c) {
                    this.#J[String(l).toLowerCase()] = String(c)
                }
                clearHeaders() {
                    this.#J = {}
                }[Symbol.iterator]() {
                    let l = this.headers,
                        c = Object.keys(l),
                        p = 0;
                    return {
                        next: () => {
                            if (p < c.length) {
                                let v = c[p++];
                                return {
                                    value: [v, l[v]],
                                    done: !1
                                }
                            }
                            return {
                                value: void 0,
                                done: !0
                            }
                        }
                    }
                }
                get credentials() {
                    return this.#ee || null
                }
                setCredentials(l, c) {
                    (0, C.en)(!l.match(/:/), "invalid basic authentication username", "username", "[REDACTED]"), this.#ee = `${l}:${c}`
                }
                get allowGzip() {
                    return this.#Z
                }
                set allowGzip(l) {
                    this.#Z = !!l
                }
                get allowInsecureAuthentication() {
                    return !!this.#K
                }
                set allowInsecureAuthentication(l) {
                    this.#K = !!l
                }
                get timeout() {
                    return this.#$
                }
                set timeout(l) {
                    (0, C.en)(l >= 0, "timeout must be non-zero", "timeout", l), this.#$ = l
                }
                get preflightFunc() {
                    return this.#et || null
                }
                set preflightFunc(l) {
                    this.#et = l
                }
                get processFunc() {
                    return this.#er || null
                }
                set processFunc(l) {
                    this.#er = l
                }
                get retryFunc() {
                    return this.#en || null
                }
                set retryFunc(l) {
                    this.#en = l
                }
                constructor(l) {
                    this.#t = String(l), this.#K = !1, this.#Z = !0, this.#J = {}, this.#Q = "", this.#$ = 3e5, this.#es = {
                        slotInterval: 250,
                        maxAttempts: 12
                    }
                }
                toString() {
                    return `<FetchRequest method=${JSON.stringify(this.method)} url=${JSON.stringify(this.url)} headers=${JSON.stringify(this.headers)} body=${this.#Y?(0,T.Dv)(this.#Y):"null"}>`
                }
                setThrottleParams(l) {
                    null != l.slotInterval && (this.#es.slotInterval = l.slotInterval), null != l.maxAttempts && (this.#es.maxAttempts = l.maxAttempts)
                }
                async# ea(l, c, p, v, _) {
                    if (l >= this.#es.maxAttempts) return _.makeServerError("exceeded maximum retry limit");
                    (0, C.hu)(getTime() <= c, "timeout", "TIMEOUT", {
                        operation: "request.send",
                        reason: "timeout",
                        request: v
                    }), p > 0 && await new Promise(l => setTimeout(l, p));
                    let P = this.clone(),
                        T = (P.url.split(":")[0] || "").toLowerCase();
                    if (T in t3) {
                        let l = await t3[T](P.url, checkSignal(v.#ei));
                        if (l instanceof FetchResponse) {
                            let c = l;
                            if (this.processFunc) {
                                checkSignal(v.#ei);
                                try {
                                    c = await this.processFunc(P, c)
                                } catch (l) {
                                    (null == l.throttle || "number" != typeof l.stall) && c.makeServerError("error in post-processing function", l).assertOk()
                                }
                            }
                            return c
                        }
                        P = l
                    }
                    this.preflightFunc && (P = await this.preflightFunc(P));
                    let M = await getUrlFunc(P, checkSignal(v.#ei)),
                        z = new FetchResponse(M.statusCode, M.statusMessage, M.headers, M.body, v);
                    if (301 === z.statusCode || 302 === z.statusCode) {
                        try {
                            let p = z.headers.location || "";
                            return P.redirect(p).#ea(l + 1, c, 0, v, z)
                        } catch (l) {}
                        return z
                    }
                    if (429 === z.statusCode && (null == this.retryFunc || await this.retryFunc(P, z, l))) {
                        let p = z.headers["retry-after"],
                            _ = this.#es.slotInterval * Math.trunc(Math.random() * Math.pow(2, l));
                        return "string" == typeof p && p.match(/^[1-9][0-9]*$/) && (_ = parseInt(p)), P.clone().#ea(l + 1, c, _, v, z)
                    }
                    if (this.processFunc) {
                        checkSignal(v.#ei);
                        try {
                            z = await this.processFunc(P, z)
                        } catch (_) {
                            (null == _.throttle || "number" != typeof _.stall) && z.makeServerError("error in post-processing function", _).assertOk();
                            let p = this.#es.slotInterval * Math.trunc(Math.random() * Math.pow(2, l));
                            return _.stall >= 0 && (p = _.stall), P.clone().#ea(l + 1, c, p, v, z)
                        }
                    }
                    return z
                }
                send() {
                    return (0, C.hu)(null == this.#ei, "request already sent", "UNSUPPORTED_OPERATION", {
                        operation: "fetchRequest.send"
                    }), this.#ei = new FetchCancelSignal(this), this.#ea(0, getTime() + this.timeout, 0, this, new FetchResponse(0, "", {}, null, this))
                }
                cancel() {
                    (0, C.hu)(null != this.#ei, "request has not been sent", "UNSUPPORTED_OPERATION", {
                        operation: "fetchRequest.cancel"
                    });
                    let l = t6.get(this);
                    if (!l) throw Error("missing signal; should not happen");
                    l()
                }
                redirect(l) {
                    let c = this.url.split(":")[0].toLowerCase(),
                        p = l.split(":")[0].toLowerCase();
                    (0, C.hu)("GET" === this.method && ("https" !== c || "http" !== p) && l.match(/^https?:/), "unsupported redirect", "UNSUPPORTED_OPERATION", {
                        operation: `redirect(${this.method} ${JSON.stringify(this.url)} => ${JSON.stringify(l)})`
                    });
                    let v = new fetch_FetchRequest(l);
                    return v.method = "GET", v.allowGzip = this.allowGzip, v.timeout = this.timeout, v.#J = Object.assign({}, this.#J), this.#Y && (v.#Y = new Uint8Array(this.#Y)), v.#X = this.#X, v
                }
                clone() {
                    let l = new fetch_FetchRequest(this.url);
                    return l.#Q = this.#Q, this.#Y && (l.#Y = this.#Y), l.#X = this.#X, l.#J = Object.assign({}, this.#J), l.#ee = this.#ee, this.allowGzip && (l.allowGzip = !0), l.timeout = this.timeout, this.allowInsecureAuthentication && (l.allowInsecureAuthentication = !0), l.#et = this.#et, l.#er = this.#er, l.#en = this.#en, l
                }
                static lockConfig() {
                    t5 = !0
                }
                static getGateway(l) {
                    return t3[l.toLowerCase()] || null
                }
                static registerGateway(l, c) {
                    if ("http" === (l = l.toLowerCase()) || "https" === l) throw Error(`cannot intercept ${l}; use registerGetUrl`);
                    if (t5) throw Error("gateways locked");
                    t3[l] = c
                }
                static registerGetUrl(l) {
                    if (t5) throw Error("gateways locked");
                    getUrlFunc = l
                }
                static createDataGateway() {
                    return dataGatewayFunc
                }
                static createIpfsGatewayFunc(l) {
                    return getIpfsGatewayFunc(l)
                }
            };
            let FetchResponse = class FetchResponse {#
                eo;#
                el;#
                J;#
                Y;#
                e;#
                ec;
                toString() {
                    return `<FetchResponse status=${this.statusCode} body=${this.#Y?(0,T.Dv)(this.#Y):"null"}>`
                }
                get statusCode() {
                    return this.#eo
                }
                get statusMessage() {
                    return this.#el
                }
                get headers() {
                    return Object.assign({}, this.#J)
                }
                get body() {
                    return null == this.#Y ? null : new Uint8Array(this.#Y)
                }
                get bodyText() {
                    try {
                        return null == this.#Y ? "" : (0, ef.ZN)(this.#Y)
                    } catch (l) {
                        (0, C.hu)(!1, "response body is not valid UTF-8 data", "UNSUPPORTED_OPERATION", {
                            operation: "bodyText",
                            info: {
                                response: this
                            }
                        })
                    }
                }
                get bodyJson() {
                    try {
                        return JSON.parse(this.bodyText)
                    } catch (l) {
                        (0, C.hu)(!1, "response body is not valid JSON", "UNSUPPORTED_OPERATION", {
                            operation: "bodyJson",
                            info: {
                                response: this
                            }
                        })
                    }
                }[Symbol.iterator]() {
                    let l = this.headers,
                        c = Object.keys(l),
                        p = 0;
                    return {
                        next: () => {
                            if (p < c.length) {
                                let v = c[p++];
                                return {
                                    value: [v, l[v]],
                                    done: !1
                                }
                            }
                            return {
                                value: void 0,
                                done: !0
                            }
                        }
                    }
                }
                constructor(l, c, p, v, _) {
                    this.#eo = l, this.#el = c, this.#J = Object.keys(p).reduce((l, c) => (l[c.toLowerCase()] = String(p[c]), l), {}), this.#Y = null == v ? null : new Uint8Array(v), this.#e = _ || null, this.#ec = {
                        message: ""
                    }
                }
                makeServerError(l, c) {
                    let p;
                    l ? p = `CLIENT ESCALATED SERVER ERROR (${this.statusCode} ${this.statusMessage}; ${l})` : (l = `${this.statusCode} ${this.statusMessage}`, p = `CLIENT ESCALATED SERVER ERROR (${l})`);
                    let v = new FetchResponse(599, p, this.headers, this.body, this.#e || void 0);
                    return v.#ec = {
                        message: l,
                        error: c
                    }, v
                }
                throwThrottleError(l, c) {
                    null == c ? c = -1 : (0, C.en)(Number.isInteger(c) && c >= 0, "invalid stall timeout", "stall", c);
                    let p = Error(l || "throttling requests");
                    throw (0, M.h)(p, {
                        stall: c,
                        throttle: !0
                    }), p
                }
                getHeader(l) {
                    return this.headers[l.toLowerCase()]
                }
                hasBody() {
                    return null != this.#Y
                }
                get request() {
                    return this.#e
                }
                ok() {
                    return "" === this.#ec.message && this.statusCode >= 200 && this.statusCode < 300
                }
                assertOk() {
                    if (this.ok()) return;
                    let {
                        message: l,
                        error: c
                    } = this.#ec;
                    "" === l && (l = `server response ${this.statusCode} ${this.statusMessage}`), (0, C.hu)(!1, l, "SERVER_ERROR", {
                        request: this.request || "unknown request",
                        response: this,
                        error: c
                    })
                }
            };

            function getTime() {
                return new Date().getTime()
            }
            BigInt(0);
            let t4 = BigInt(58);

            function getIpfsLink(l) {
                return l.match(/^ipfs:\/\/ipfs\//i) ? l = l.substring(12) : l.match(/^ipfs:\/\//i) ? l = l.substring(7) : (0, C.en)(!1, "unsupported IPFS format", "link", l), `https://gateway.ipfs.io/ipfs/${l}`
            }
            let MulticoinProviderPlugin = class MulticoinProviderPlugin {
                name;
                constructor(l) {
                    (0, M.h)(this, {
                        name: l
                    })
                }
                connect(l) {
                    return this
                }
                supportsCoinType(l) {
                    return !1
                }
                async encodeAddress(l, c) {
                    throw Error("unsupported coin")
                }
                async decodeAddress(l, c) {
                    throw Error("unsupported coin")
                }
            };
            let t8 = RegExp("^(ipfs)://(.*)$", "i"),
                t9 = [RegExp("^(https)://(.*)$", "i"), RegExp("^(data):(.*)$", "i"), t8, RegExp("^eip155:[0-9]+/(erc[0-9]+):(.*)$", "i")];
            let EnsResolver = class EnsResolver {
                provider;
                address;
                name;#
                eu;#
                eh;
                constructor(l, c, p) {
                    (0, M.h)(this, {
                        provider: l,
                        address: c,
                        name: p
                    }), this.#eu = null, this.#eh = new Contract(c, ["function supportsInterface(bytes4) view returns (bool)", "function resolve(bytes, bytes) view returns (bytes)", "function addr(bytes32) view returns (address)", "function addr(bytes32, uint) view returns (bytes)", "function text(bytes32, string) view returns (string)", "function contenthash(bytes32) view returns (bytes)"], l)
                }
                async supportsWildcard() {
                    return null == this.#eu && (this.#eu = (async () => {
                        try {
                            return await this.#eh.supportsInterface("0x9061b923")
                        } catch (l) {
                            if ((0, C.VZ)(l, "CALL_EXCEPTION")) return !1;
                            throw this.#eu = null, l
                        }
                    })()), await this.#eu
                }
                async# ed(l, c) {
                    c = (c || []).slice();
                    let p = this.#eh.interface;
                    c.unshift((0, ta.VM)(this.name));
                    let v = null;
                    await this.supportsWildcard() && (v = p.getFunction(l), (0, C.hu)(v, "missing fragment", "UNKNOWN_ERROR", {
                        info: {
                            funcName: l
                        }
                    }), c = [(0, ta.Kn)(this.name), p.encodeFunctionData(v, c)], l = "resolve(bytes,bytes)"), c.push({
                        enableCcipRead: !0
                    });
                    try {
                        let _ = await this.#eh[l](...c);
                        if (v) return p.decodeFunctionResult(v, _)[0];
                        return _
                    } catch (l) {
                        if (!(0, C.VZ)(l, "CALL_EXCEPTION")) throw l
                    }
                    return null
                }
                async getAddress(l) {
                    if (null == l && (l = 60), 60 === l) try {
                        let l = await this.#ed("addr(bytes32)");
                        if (null == l || l === e5) return null;
                        return l
                    } catch (l) {
                        if ((0, C.VZ)(l, "CALL_EXCEPTION")) return null;
                        throw l
                    }
                    if (l >= 0 && l < 2147483648) {
                        let c = l + 2147483648,
                            p = await this.#ed("addr(bytes32,uint)", [c]);
                        if ((0, T.A7)(p, 20)) return (0, X.K)(p)
                    }
                    let c = null;
                    for (let p of this.provider.plugins)
                        if (p instanceof MulticoinProviderPlugin && p.supportsCoinType(l)) {
                            c = p;
                            break
                        }
                    if (null == c) return null;
                    let p = await this.#ed("addr(bytes32,uint)", [l]);
                    if (null == p || "0x" === p) return null;
                    let v = await c.decodeAddress(l, p);
                    if (null != v) return v;
                    (0, C.hu)(!1, "invalid coin data", "UNSUPPORTED_OPERATION", {
                        operation: `getAddress(${l})`,
                        info: {
                            coinType: l,
                            data: p
                        }
                    })
                }
                async getText(l) {
                    let c = await this.#ed("text(bytes32,string)", [l]);
                    return null == c || "0x" === c ? null : c
                }
                async getContentHash() {
                    let l = await this.#ed("contenthash(bytes32)");
                    if (null == l || "0x" === l) return null;
                    let c = l.match(/^0x(e3010170|e5010172)(([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f]*))$/);
                    if (c) {
                        let l = "e3010170" === c[1] ? "ipfs" : "ipns",
                            p = parseInt(c[4], 16);
                        if (c[5].length === 2 * p) return `${l}://${function(l){let c=(0,P.Gh)((0,T.Pw)(l)),p="";for(;c;)p="123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"[Number(c%t4)]+p,c/=t4;return p}("0x"+c[2])}`
                    }
                    let p = l.match(/^0xe40101fa011b20([0-9a-f]*)$/);
                    if (p && 64 === p[1].length) return `bzz://${p[1]}`;
                    (0, C.hu)(!1, "invalid or unsupported content hash data", "UNSUPPORTED_OPERATION", {
                        operation: "getContentHash()",
                        info: {
                            data: l
                        }
                    })
                }
                async getAvatar() {
                    let l = await this._getAvatar();
                    return l.url
                }
                async _getAvatar() {
                    let l = [{
                        type: "name",
                        value: this.name
                    }];
                    try {
                        let c = await this.getText("avatar");
                        if (null == c) return l.push({
                            type: "!avatar",
                            value: ""
                        }), {
                            url: null,
                            linkage: l
                        };
                        l.push({
                            type: "avatar",
                            value: c
                        });
                        for (let p = 0; p < t9.length; p++) {
                            let v = c.match(t9[p]);
                            if (null == v) continue;
                            let _ = v[1].toLowerCase();
                            switch (_) {
                                case "https":
                                case "data":
                                    return l.push({
                                        type: "url",
                                        value: c
                                    }), {
                                        linkage: l,
                                        url: c
                                    };
                                case "ipfs":
                                    {
                                        let p = getIpfsLink(c);
                                        return l.push({
                                            type: "ipfs",
                                            value: c
                                        }),
                                        l.push({
                                            type: "url",
                                            value: p
                                        }),
                                        {
                                            linkage: l,
                                            url: p
                                        }
                                    }
                                case "erc721":
                                case "erc1155":
                                    {
                                        let p = "erc721" === _ ? "tokenURI(uint256)" : "uri(uint256)";l.push({
                                            type: _,
                                            value: c
                                        });
                                        let C = await this.getAddress();
                                        if (null == C) return l.push({
                                            type: "!owner",
                                            value: ""
                                        }), {
                                            url: null,
                                            linkage: l
                                        };
                                        let M = (v[2] || "").split("/");
                                        if (2 !== M.length) return l.push({
                                            type: `!${_}caip`,
                                            value: v[2] || ""
                                        }), {
                                            url: null,
                                            linkage: l
                                        };
                                        let z = M[1],
                                            J = new Contract(M[0], ["function tokenURI(uint) view returns (string)", "function ownerOf(uint) view returns (address)", "function uri(uint) view returns (string)", "function balanceOf(address, uint256) view returns (uint)"], this.provider);
                                        if ("erc721" === _) {
                                            let c = await J.ownerOf(z);
                                            if (C !== c) return l.push({
                                                type: "!owner",
                                                value: c
                                            }), {
                                                url: null,
                                                linkage: l
                                            };
                                            l.push({
                                                type: "owner",
                                                value: c
                                            })
                                        } else if ("erc1155" === _) {
                                            let c = await J.balanceOf(C, z);
                                            if (!c) return l.push({
                                                type: "!balance",
                                                value: "0"
                                            }), {
                                                url: null,
                                                linkage: l
                                            };
                                            l.push({
                                                type: "balance",
                                                value: c.toString()
                                            })
                                        }
                                        let Q = await J[p](z);
                                        if (null == Q || "0x" === Q) return l.push({
                                            type: "!metadata-url",
                                            value: ""
                                        }), {
                                            url: null,
                                            linkage: l
                                        };l.push({
                                            type: "metadata-url-base",
                                            value: Q
                                        }),
                                        "erc1155" === _ && (Q = Q.replace("{id}", (0, P.m9)(z, 32).substring(2)), l.push({
                                            type: "metadata-url-expanded",
                                            value: Q
                                        })),
                                        Q.match(/^ipfs:/i) && (Q = getIpfsLink(Q)),
                                        l.push({
                                            type: "metadata-url",
                                            value: Q
                                        });
                                        let X = {},
                                            es = await new fetch_FetchRequest(Q).send();es.assertOk();
                                        try {
                                            X = es.bodyJson
                                        } catch (c) {
                                            try {
                                                l.push({
                                                    type: "!metadata",
                                                    value: es.bodyText
                                                })
                                            } catch (p) {
                                                let c = es.body;
                                                c && l.push({
                                                    type: "!metadata",
                                                    value: (0, T.Dv)(c)
                                                })
                                            }
                                            return {
                                                url: null,
                                                linkage: l
                                            }
                                        }
                                        if (!X) return l.push({
                                            type: "!metadata",
                                            value: ""
                                        }), {
                                            url: null,
                                            linkage: l
                                        };l.push({
                                            type: "metadata",
                                            value: JSON.stringify(X)
                                        });
                                        let eo = X.image;
                                        if ("string" != typeof eo) return l.push({
                                            type: "!imageUrl",
                                            value: ""
                                        }), {
                                            url: null,
                                            linkage: l
                                        };
                                        if (eo.match(/^(https:\/\/|data:)/i));
                                        else {
                                            let c = eo.match(t8);
                                            if (null == c) return l.push({
                                                type: "!imageUrl-ipfs",
                                                value: eo
                                            }), {
                                                url: null,
                                                linkage: l
                                            };
                                            l.push({
                                                type: "imageUrl-ipfs",
                                                value: eo
                                            }), eo = getIpfsLink(eo)
                                        }
                                        return l.push({
                                            type: "url",
                                            value: eo
                                        }),
                                        {
                                            linkage: l,
                                            url: eo
                                        }
                                    }
                            }
                        }
                    } catch (l) {}
                    return {
                        linkage: l,
                        url: null
                    }
                }
                static async getEnsAddress(l) {
                    let c = await l.getNetwork(),
                        p = c.getPlugin("org.ethers.plugins.network.Ens");
                    return (0, C.hu)(p, "network does not support ENS", "UNSUPPORTED_OPERATION", {
                        operation: "getEnsAddress",
                        info: {
                            network: c
                        }
                    }), p.address
                }
                static async# ef(l, c) {
                    let p = await EnsResolver.getEnsAddress(l);
                    try {
                        let v = new Contract(p, ["function resolver(bytes32) view returns (address)"], l),
                            _ = await v.resolver((0, ta.VM)(c), {
                                enableCcipRead: !0
                            });
                        if (_ === e5) return null;
                        return _
                    } catch (l) {
                        throw l
                    }
                    return null
                }
                static async fromName(l, c) {
                    let p = c;
                    for (;;) {
                        if ("" === p || "." === p || "eth" !== c && "eth" === p) return null;
                        let v = await EnsResolver.#ef(l, p);
                        if (null != v) {
                            let _ = new EnsResolver(l, v, c);
                            if (p !== c && !await _.supportsWildcard()) return null;
                            return _
                        }
                        p = p.split(".").slice(1).join(".")
                    }
                }
            };
            let t7 = BigInt(0);

            function allowNull(l, c) {
                return function(p) {
                    return null == p ? c : l(p)
                }
            }

            function arrayOf(l) {
                return c => {
                    if (!Array.isArray(c)) throw Error("not an array");
                    return c.map(c => l(c))
                }
            }

            function object(l, c) {
                return p => {
                    let v = {};
                    for (let _ in l) {
                        let P = _;
                        if (c && _ in c && !(P in p)) {
                            for (let l of c[_])
                                if (l in p) {
                                    P = l;
                                    break
                                }
                        }
                        try {
                            let c = l[_](p[P]);
                            void 0 !== c && (v[_] = c)
                        } catch (c) {
                            let l = c instanceof Error ? c.message : "not-an-error";
                            (0, C.hu)(!1, `invalid value for value.${_} (${l})`, "BAD_DATA", {
                                value: p
                            })
                        }
                    }
                    return v
                }
            }

            function formatData(l) {
                return (0, C.en)((0, T.A7)(l, !0), "invalid data", "value", l), l
            }

            function formatHash(l) {
                return (0, C.en)((0, T.A7)(l, 32), "invalid hash", "value", l), l
            }
            let rt = object({
                    address: X.K,
                    blockHash: formatHash,
                    blockNumber: P.Dx,
                    data: formatData,
                    index: P.Dx,
                    removed: allowNull(function(l) {
                        switch (l) {
                            case !0:
                            case "true":
                                return !0;
                            case !1:
                            case "false":
                                return !1
                        }(0, C.en)(!1, `invalid boolean; ${JSON.stringify(l)}`, "value", l)
                    }, !1),
                    topics: arrayOf(formatHash),
                    transactionHash: formatHash,
                    transactionIndex: P.Dx
                }, {
                    index: ["logIndex"]
                }),
                rs = object({
                    hash: allowNull(formatHash),
                    parentHash: formatHash,
                    number: P.Dx,
                    timestamp: P.Dx,
                    nonce: allowNull(formatData),
                    difficulty: P.yT,
                    gasLimit: P.yT,
                    gasUsed: P.yT,
                    miner: allowNull(X.K),
                    extraData: formatData,
                    baseFeePerGas: allowNull(P.yT)
                }),
                ra = object({
                    transactionIndex: P.Dx,
                    blockNumber: P.Dx,
                    transactionHash: formatHash,
                    address: X.K,
                    topics: arrayOf(formatHash),
                    data: formatData,
                    index: P.Dx,
                    blockHash: formatHash
                }, {
                    index: ["logIndex"]
                }),
                ro = object({
                    to: allowNull(X.K, null),
                    from: allowNull(X.K, null),
                    contractAddress: allowNull(X.K, null),
                    index: P.Dx,
                    root: allowNull(T.Dv),
                    gasUsed: P.yT,
                    logsBloom: allowNull(formatData),
                    blockHash: formatHash,
                    hash: formatHash,
                    logs: arrayOf(function(l) {
                        return ra(l)
                    }),
                    blockNumber: P.Dx,
                    cumulativeGasUsed: P.yT,
                    effectiveGasPrice: allowNull(P.yT),
                    status: allowNull(P.Dx),
                    type: allowNull(P.Dx, 0)
                }, {
                    effectiveGasPrice: ["gasPrice"],
                    hash: ["transactionHash"],
                    index: ["transactionIndex"]
                });

            function formatTransactionResponse(l) {
                l.to && (0, P.yT)(l.to) === t7 && (l.to = "0x0000000000000000000000000000000000000000");
                let c = object({
                    hash: formatHash,
                    type: l => "0x" === l || null == l ? 0 : (0, P.Dx)(l),
                    accessList: allowNull(e2.z, null),
                    blockHash: allowNull(formatHash, null),
                    blockNumber: allowNull(P.Dx, null),
                    transactionIndex: allowNull(P.Dx, null),
                    from: X.K,
                    gasPrice: allowNull(P.yT),
                    maxPriorityFeePerGas: allowNull(P.yT),
                    maxFeePerGas: allowNull(P.yT),
                    gasLimit: P.yT,
                    to: allowNull(X.K, null),
                    value: P.yT,
                    nonce: P.Dx,
                    data: formatData,
                    creates: allowNull(X.K, null),
                    chainId: allowNull(P.yT, null)
                }, {
                    data: ["input"],
                    gasLimit: ["gas"]
                })(l);
                if (null == c.to && null == c.creates && (c.creates = function(l) {
                        let c = (0, X.K)(l.from),
                            p = (0, P.yT)(l.nonce, "tx.nonce"),
                            v = p.toString(16);
                        return v = "0" === v ? "0x" : v.length % 2 ? "0x0" + v : "0x" + v, (0, X.K)((0, T.QB)((0, ep.w)(encodeRlp([c, v])), 12))
                    }(c)), (1 === l.type || 2 === l.type) && null == l.accessList && (c.accessList = []), l.signature ? c.signature = Signature.from(l.signature) : c.signature = Signature.from(l), null == c.chainId) {
                    let l = c.signature.legacyChainId;
                    null != l && (c.chainId = l)
                }
                return c.blockHash && (0, P.yT)(c.blockHash) === t7 && (c.blockHash = null), c
            }
            var rl = p(8004);

            function copy(l) {
                return JSON.parse(JSON.stringify(l))
            }
            let PollingBlockSubscriber = class PollingBlockSubscriber {#
                ep;#
                eg;#
                em;#
                ey;
                constructor(l) {
                    this.#ep = l, this.#eg = null, this.#em = 4e3, this.#ey = -2
                }
                get pollingInterval() {
                    return this.#em
                }
                set pollingInterval(l) {
                    this.#em = l
                }
                async# ev() {
                    try {
                        let l = await this.#ep.getBlockNumber();
                        if (-2 === this.#ey) {
                            this.#ey = l;
                            return
                        }
                        if (l !== this.#ey) {
                            for (let c = this.#ey + 1; c <= l; c++) {
                                if (null == this.#eg) return;
                                await this.#ep.emit("block", c)
                            }
                            this.#ey = l
                        }
                    } catch (l) {}
                    null != this.#eg && (this.#eg = this.#ep._setTimeout(this.#ev.bind(this), this.#em))
                }
                start() {
                    this.#eg || (this.#eg = this.#ep._setTimeout(this.#ev.bind(this), this.#em), this.#ev())
                }
                stop() {
                    this.#eg && (this.#ep._clearTimeout(this.#eg), this.#eg = null)
                }
                pause(l) {
                    this.stop(), l && (this.#ey = -2)
                }
                resume() {
                    this.start()
                }
            };
            let OnBlockSubscriber = class OnBlockSubscriber {#
                ep;#
                ev;#
                eb;
                constructor(l) {
                    this.#ep = l, this.#eb = !1, this.#ev = l => {
                        this._poll(l, this.#ep)
                    }
                }
                async _poll(l, c) {
                    throw Error("sub-classes must override this")
                }
                start() {
                    this.#eb || (this.#eb = !0, this.#ev(-2), this.#ep.on("block", this.#ev))
                }
                stop() {
                    this.#eb && (this.#eb = !1, this.#ep.off("block", this.#ev))
                }
                pause(l) {
                    this.stop()
                }
                resume() {
                    this.start()
                }
            };
            let PollingOrphanSubscriber = class PollingOrphanSubscriber extends OnBlockSubscriber {#
                D;
                constructor(l, c) {
                    super(l), this.#D = copy(c)
                }
                async _poll(l, c) {
                    throw Error("@TODO")
                }
            };
            let PollingTransactionSubscriber = class PollingTransactionSubscriber extends OnBlockSubscriber {#
                ew;
                constructor(l, c) {
                    super(l), this.#ew = c
                }
                async _poll(l, c) {
                    let p = await c.getTransactionReceipt(this.#ew);
                    p && c.emit(this.#ew, p)
                }
            };
            let PollingEventSubscriber = class PollingEventSubscriber {#
                ep;#
                D;#
                eg;#
                eb;#
                ey;
                constructor(l, c) {
                    this.#ep = l, this.#D = copy(c), this.#eg = this.#ev.bind(this), this.#eb = !1, this.#ey = -2
                }
                async# ev(l) {
                    if (-2 === this.#ey) return;
                    let c = copy(this.#D);
                    c.fromBlock = this.#ey + 1, c.toBlock = l;
                    let p = await this.#ep.getLogs(c);
                    if (0 === p.length) {
                        this.#ey < l - 60 && (this.#ey = l - 60);
                        return
                    }
                    for (let l of p) this.#ep.emit(this.#D, l), this.#ey = l.blockNumber
                }
                start() {
                    this.#eb || (this.#eb = !0, -2 === this.#ey && this.#ep.getBlockNumber().then(l => {
                        this.#ey = l
                    }), this.#ep.on("block", this.#eg))
                }
                stop() {
                    this.#eb && (this.#eb = !1, this.#ep.off("block", this.#eg))
                }
                pause(l) {
                    this.stop(), l && (this.#ey = -2)
                }
                resume() {
                    this.start()
                }
            };
            let rc = BigInt(2);

            function isPromise(l) {
                return l && "function" == typeof l.then
            }

            function getTag(l, c) {
                return l + ":" + JSON.stringify(c, (l, c) => {
                    if (null == c) return "null";
                    if ("bigint" == typeof c) return `bigint:${c.toString()}`;
                    if ("string" == typeof c) return c.toLowerCase();
                    if ("object" == typeof c && !Array.isArray(c)) {
                        let l = Object.keys(c);
                        return l.sort(), l.reduce((l, p) => (l[p] = c[p], l), {})
                    }
                    return c
                })
            }
            let UnmanagedSubscriber = class UnmanagedSubscriber {
                name;
                constructor(l) {
                    (0, M.h)(this, {
                        name: l
                    })
                }
                start() {}
                stop() {}
                pause(l) {}
                resume() {}
            };

            function concisify(l) {
                return (l = Array.from(new Set(l).values())).sort(), l
            }
            async function getSubscription(l, c) {
                if (null == l) throw Error("invalid event");
                if (Array.isArray(l) && (l = {
                        topics: l
                    }), "string" == typeof l) switch (l) {
                    case "block":
                    case "pending":
                    case "debug":
                    case "error":
                    case "network":
                        return {
                            type: l,
                            tag: l
                        }
                }
                if ((0, T.A7)(l, 32)) {
                    let c = l.toLowerCase();
                    return {
                        type: "transaction",
                        tag: getTag("tx", {
                            hash: c
                        }),
                        hash: c
                    }
                }
                if (l.orphan) {
                    let c = l;
                    return {
                        type: "orphan",
                        tag: getTag("orphan", c),
                        filter: JSON.parse(JSON.stringify(c))
                    }
                }
                if (l.address || l.topics) {
                    let p = l,
                        v = {
                            topics: (p.topics || []).map(l => null == l ? null : Array.isArray(l) ? concisify(l.map(l => l.toLowerCase())) : l.toLowerCase())
                        };
                    if (p.address) {
                        let l = [],
                            _ = [],
                            addAddress = p => {
                                (0, T.A7)(p) ? l.push(p): _.push((async () => {
                                    l.push(await resolveAddress(p, c))
                                })())
                            };
                        Array.isArray(p.address) ? p.address.forEach(addAddress) : addAddress(p.address), _.length && await Promise.all(_), v.address = concisify(l.map(l => l.toLowerCase()))
                    }
                    return {
                        filter: v,
                        tag: getTag("event", v),
                        type: "event"
                    }
                }(0, C.en)(!1, "unknown ProviderEvent", "event", l)
            }

            function abstract_provider_getTime() {
                return new Date().getTime()
            }
            let rh = {
                cacheTimeout: 250,
                pollingInterval: 4e3
            };
            let AbstractProvider = class AbstractProvider {#
                ex;#
                s;#
                e_;#
                eE;#
                eA;#
                eC;#
                eS;#
                eN;#
                eP;#
                eD;#
                ek;#
                d;
                constructor(l, c) {
                    if (this.#d = Object.assign({}, rh, c || {}), "any" === l) this.#eC = !0, this.#eA = null;
                    else if (l) {
                        let c = rl.Z.from(l);
                        this.#eC = !1, this.#eA = Promise.resolve(c), setTimeout(() => {
                            this.emit("network", c, null)
                        }, 0)
                    } else this.#eC = !1, this.#eA = null;
                    this.#eN = -1, this.#eS = new Map, this.#ex = new Map, this.#s = new Map, this.#e_ = null, this.#eE = !1, this.#eP = 1, this.#eD = new Map, this.#ek = !1
                }
                get pollingInterval() {
                    return this.#d.pollingInterval
                }
                get provider() {
                    return this
                }
                get plugins() {
                    return Array.from(this.#s.values())
                }
                attachPlugin(l) {
                    if (this.#s.get(l.name)) throw Error(`cannot replace existing plugin: ${l.name} `);
                    return this.#s.set(l.name, l.connect(this)), this
                }
                getPlugin(l) {
                    return this.#s.get(l) || null
                }
                get disableCcipRead() {
                    return this.#ek
                }
                set disableCcipRead(l) {
                    this.#ek = !!l
                }
                async# eI(l) {
                    let c = this.#d.cacheTimeout;
                    if (c < 0) return await this._perform(l);
                    let p = getTag(l.method, l),
                        v = this.#eS.get(p);
                    return v || (v = this._perform(l), this.#eS.set(p, v), setTimeout(() => {
                        this.#eS.get(p) === v && this.#eS.delete(p)
                    }, c)), await v
                }
                async ccipReadFetch(l, c, p) {
                    if (this.disableCcipRead || 0 === p.length || null == l.to) return null;
                    let v = l.to.toLowerCase(),
                        _ = c.toLowerCase(),
                        P = [];
                    for (let c = 0; c < p.length; c++) {
                        let T = p[c],
                            M = T.replace("{sender}", v).replace("{data}", _),
                            z = new fetch_FetchRequest(M); - 1 === T.indexOf("{data}") && (z.body = {
                            data: _,
                            sender: v
                        }), this.emit("debug", {
                            action: "sendCcipReadFetchRequest",
                            request: z,
                            index: c,
                            urls: p
                        });
                        let J = "unknown error",
                            Q = await z.send();
                        try {
                            let l = Q.bodyJson;
                            if (l.data) return this.emit("debug", {
                                action: "receiveCcipReadFetchResult",
                                request: z,
                                result: l
                            }), l.data;
                            l.message && (J = l.message), this.emit("debug", {
                                action: "receiveCcipReadFetchError",
                                request: z,
                                result: l
                            })
                        } catch (l) {}(0, C.hu)(Q.statusCode < 400 || Q.statusCode >= 500, `response not found during CCIP fetch: ${J}`, "OFFCHAIN_FAULT", {
                            reason: "404_MISSING_RESOURCE",
                            transaction: l,
                            info: {
                                url: T,
                                errorMessage: J
                            }
                        }), P.push(J)
                    }(0, C.hu)(!1, `error encountered during CCIP fetch: ${P.map(l=>JSON.stringify(l)).join(", ")}`, "OFFCHAIN_FAULT", {
                        reason: "500_SERVER_ERROR",
                        transaction: l,
                        info: {
                            urls: p,
                            errorMessages: P
                        }
                    })
                }
                _wrapBlock(l, c) {
                    return new e4.gO(function(l) {
                        let c = rs(l);
                        return c.transactions = l.transactions.map(l => "string" == typeof l ? l : formatTransactionResponse(l)), c
                    }(l), this)
                }
                _wrapLog(l, c) {
                    return new e4.Zb(rt(l), this)
                }
                _wrapTransactionReceipt(l, c) {
                    return new e4.IX(ro(l), this)
                }
                _wrapTransactionResponse(l, c) {
                    return new e4.Mw(formatTransactionResponse(l), this)
                }
                _detectNetwork() {
                    (0, C.hu)(!1, "sub-classes must implement this", "UNSUPPORTED_OPERATION", {
                        operation: "_detectNetwork"
                    })
                }
                async _perform(l) {
                    (0, C.hu)(!1, `unsupported method: ${l.method}`, "UNSUPPORTED_OPERATION", {
                        operation: l.method,
                        info: l
                    })
                }
                async getBlockNumber() {
                    let l = (0, P.Dx)(await this.#eI({
                        method: "getBlockNumber"
                    }), "%response");
                    return this.#eN >= 0 && (this.#eN = l), l
                }
                _getAddress(l) {
                    return resolveAddress(l, this)
                }
                _getBlockTag(l) {
                    if (null == l) return "latest";
                    switch (l) {
                        case "earliest":
                            return "0x0";
                        case "latest":
                        case "pending":
                        case "safe":
                        case "finalized":
                            return l
                    }
                    return (0, T.A7)(l) ? (0, T.A7)(l, 32) ? l : (0, P.B4)(l) : ("bigint" == typeof l && (l = (0, P.Dx)(l, "blockTag")), "number" == typeof l) ? l >= 0 ? (0, P.B4)(l) : this.#eN >= 0 ? (0, P.B4)(this.#eN + l) : this.getBlockNumber().then(c => (0, P.B4)(c + l)) : void(0, C.en)(!1, "invalid blockTag", "blockTag", l)
                }
                _getFilter(l) {
                    let c, p;
                    let v = (l.topics || []).map(l => null == l ? null : Array.isArray(l) ? concisify(l.map(l => l.toLowerCase())) : l.toLowerCase()),
                        _ = "blockHash" in l ? l.blockHash : void 0,
                        resolve = (l, c, p) => {
                            let C;
                            switch (l.length) {
                                case 0:
                                    break;
                                case 1:
                                    C = l[0];
                                    break;
                                default:
                                    l.sort(), C = l
                            }
                            if (_ && (null != c || null != p)) throw Error("invalid filter");
                            let P = {};
                            return C && (P.address = C), v.length && (P.topics = v), c && (P.fromBlock = c), p && (P.toBlock = p), _ && (P.blockHash = _), P
                        },
                        C = [];
                    if (l.address) {
                        if (Array.isArray(l.address))
                            for (let c of l.address) C.push(this._getAddress(c));
                        else C.push(this._getAddress(l.address))
                    }
                    return "fromBlock" in l && (c = this._getBlockTag(l.fromBlock)), ("toBlock" in l && (p = this._getBlockTag(l.toBlock)), C.filter(l => "string" != typeof l).length || null != c && "string" != typeof c || null != p && "string" != typeof p) ? Promise.all([Promise.all(C), c, p]).then(l => resolve(l[0], l[1], l[2])) : resolve(C, c, p)
                }
                _getTransactionRequest(l) {
                    let c = (0, e4.kK)(l),
                        p = [];
                    if (["to", "from"].forEach(l => {
                            if (null == c[l]) return;
                            let v = resolveAddress(c[l]);
                            isPromise(v) ? p.push(async function() {
                                c[l] = await v
                            }()) : c[l] = v
                        }), null != c.blockTag) {
                        let l = this._getBlockTag(c.blockTag);
                        isPromise(l) ? p.push(async function() {
                            c.blockTag = await l
                        }()) : c.blockTag = l
                    }
                    return p.length ? async function() {
                        return await Promise.all(p), c
                    }() : c
                }
                async getNetwork() {
                    if (null == this.#eA) {
                        let l = this._detectNetwork().then(l => (this.emit("network", l, null), l), c => {
                            throw this.#eA === l && (this.#eA = null), c
                        });
                        return this.#eA = l, (await l).clone()
                    }
                    let l = this.#eA,
                        [c, p] = await Promise.all([l, this._detectNetwork()]);
                    return c.chainId !== p.chainId && (this.#eC ? (this.emit("network", p, c), this.#eA === l && (this.#eA = Promise.resolve(p))) : (0, C.hu)(!1, `network changed: ${c.chainId} => ${p.chainId} `, "NETWORK_ERROR", {
                        event: "changed"
                    })), c.clone()
                }
                async getFeeData() {
                    let l = await this.getNetwork(),
                        getFeeDataFunc = async () => {
                            let {
                                _block: c,
                                gasPrice: p
                            } = await (0, M.m)({
                                _block: this.#eO("latest", !1),
                                gasPrice: (async () => {
                                    try {
                                        let l = await this.#eI({
                                            method: "getGasPrice"
                                        });
                                        return (0, P.yT)(l, "%response")
                                    } catch (l) {}
                                    return null
                                })()
                            }), v = null, _ = null, C = this._wrapBlock(c, l);
                            return C && C.baseFeePerGas && (_ = BigInt("1000000000"), v = C.baseFeePerGas * rc + _), new e4.jW(p, v, _)
                        },
                        c = l.getPlugin("org.ethers.plugins.network.FetchUrlFeeDataPlugin");
                    if (c) {
                        let l = new fetch_FetchRequest(c.url),
                            p = await c.processFunc(getFeeDataFunc, this, l);
                        return new e4.jW(p.gasPrice, p.maxFeePerGas, p.maxPriorityFeePerGas)
                    }
                    return await getFeeDataFunc()
                }
                async estimateGas(l) {
                    let c = this._getTransactionRequest(l);
                    return isPromise(c) && (c = await c), (0, P.yT)(await this.#eI({
                        method: "estimateGas",
                        transaction: c
                    }), "%response")
                }
                async# ej(l, c, p) {
                    (0, C.hu)(p < 10, "CCIP read exceeded maximum redirections", "OFFCHAIN_FAULT", {
                        reason: "TOO_MANY_REDIRECTS",
                        transaction: Object.assign({}, l, {
                            blockTag: c,
                            enableCcipRead: !0
                        })
                    });
                    let v = (0, e4.kK)(l);
                    try {
                        return (0, T.Dv)(await this._perform({
                            method: "call",
                            transaction: v,
                            blockTag: c
                        }))
                    } catch (l) {
                        if (!this.disableCcipRead && (0, C.Hl)(l) && l.data && p >= 0 && "latest" === c && null != v.to && "0x556f1830" === (0, T.QB)(l.data, 0, 4)) {
                            let _;
                            let M = l.data,
                                z = await resolveAddress(v.to, this);
                            try {
                                _ = function(l) {
                                    let c = {
                                        sender: "",
                                        urls: [],
                                        calldata: "",
                                        selector: "",
                                        extraData: "",
                                        errorArgs: []
                                    };
                                    (0, C.hu)((0, T.M5)(l) >= 160, "insufficient OffchainLookup data", "OFFCHAIN_FAULT", {
                                        reason: "insufficient OffchainLookup data"
                                    });
                                    let p = (0, T.QB)(l, 0, 32);
                                    (0, C.hu)((0, T.QB)(p, 0, 12) === (0, T.QB)(rp, 0, 12), "corrupt OffchainLookup sender", "OFFCHAIN_FAULT", {
                                        reason: "corrupt OffchainLookup sender"
                                    }), c.sender = (0, T.QB)(p, 12);
                                    try {
                                        let p = [],
                                            v = (0, P.Dx)((0, T.QB)(l, 32, 64)),
                                            _ = (0, P.Dx)((0, T.QB)(l, v, v + 32)),
                                            C = (0, T.QB)(l, v + 32);
                                        for (let l = 0; l < _; l++) {
                                            let c = function(l, c) {
                                                try {
                                                    let p = _parseBytes(l, c);
                                                    if (p) return (0, ef.ZN)(p)
                                                } catch (l) {}
                                                return null
                                            }(C, 32 * l);
                                            if (null == c) throw Error("abort");
                                            p.push(c)
                                        }
                                        c.urls = p
                                    } catch (l) {
                                        (0, C.hu)(!1, "corrupt OffchainLookup urls", "OFFCHAIN_FAULT", {
                                            reason: "corrupt OffchainLookup urls"
                                        })
                                    }
                                    try {
                                        let p = _parseBytes(l, 64);
                                        if (null == p) throw Error("abort");
                                        c.calldata = p
                                    } catch (l) {
                                        (0, C.hu)(!1, "corrupt OffchainLookup calldata", "OFFCHAIN_FAULT", {
                                            reason: "corrupt OffchainLookup calldata"
                                        })
                                    }(0, C.hu)((0, T.QB)(l, 100, 128) === (0, T.QB)(rp, 0, 28), "corrupt OffchainLookup callbaackSelector", "OFFCHAIN_FAULT", {
                                        reason: "corrupt OffchainLookup callbaackSelector"
                                    }), c.selector = (0, T.QB)(l, 96, 100);
                                    try {
                                        let p = _parseBytes(l, 128);
                                        if (null == p) throw Error("abort");
                                        c.extraData = p
                                    } catch (l) {
                                        (0, C.hu)(!1, "corrupt OffchainLookup extraData", "OFFCHAIN_FAULT", {
                                            reason: "corrupt OffchainLookup extraData"
                                        })
                                    }
                                    return c.errorArgs = "sender,urls,calldata,selector,extraData".split(/,/).map(l => c[l]), c
                                }((0, T.QB)(l.data, 4))
                            } catch (l) {
                                (0, C.hu)(!1, l.message, "OFFCHAIN_FAULT", {
                                    reason: "BAD_DATA",
                                    transaction: v,
                                    info: {
                                        data: M
                                    }
                                })
                            }(0, C.hu)(_.sender.toLowerCase() === z.toLowerCase(), "CCIP Read sender mismatch", "CALL_EXCEPTION", {
                                action: "call",
                                data: M,
                                reason: "OffchainLookup",
                                transaction: v,
                                invocation: null,
                                revert: {
                                    signature: "OffchainLookup(address,string[],bytes,bytes4,bytes)",
                                    name: "OffchainLookup",
                                    args: _.errorArgs
                                }
                            });
                            let J = await this.ccipReadFetch(v, _.calldata, _.urls);
                            (0, C.hu)(null != J, "CCIP Read failed to fetch data", "OFFCHAIN_FAULT", {
                                reason: "FETCH_FAILED",
                                transaction: v,
                                info: {
                                    data: l.data,
                                    errorArgs: _.errorArgs
                                }
                            });
                            let Q = {
                                to: z,
                                data: (0, T.zo)([_.selector, function(l) {
                                    let c = [],
                                        p = 0;
                                    for (let v = 0; v < l.length; v++) c.push(rd), p += 32;
                                    for (let v = 0; v < l.length; v++) {
                                        let _ = (0, T.Pw)(l[v]);
                                        c[v] = numPad(p), c.push(numPad(_.length)), c.push(function(l) {
                                            if (l.length % 32 == 0) return l;
                                            let c = new Uint8Array(32 * Math.ceil(l.length / 32));
                                            return c.set(l), c
                                        }(_)), p += 32 + 32 * Math.ceil(_.length / 32)
                                    }
                                    return (0, T.zo)(c)
                                }([J, _.extraData])])
                            };
                            this.emit("debug", {
                                action: "sendCcipReadCall",
                                transaction: Q
                            });
                            try {
                                let l = await this.#ej(Q, c, p + 1);
                                return this.emit("debug", {
                                    action: "receiveCcipReadCallResult",
                                    transaction: Object.assign({}, Q),
                                    result: l
                                }), l
                            } catch (l) {
                                throw this.emit("debug", {
                                    action: "receiveCcipReadCallError",
                                    transaction: Object.assign({}, Q),
                                    error: l
                                }), l
                            }
                        }
                        throw l
                    }
                }
                async# eT(l) {
                    let {
                        value: c
                    } = await (0, M.m)({
                        network: this.getNetwork(),
                        value: l
                    });
                    return c
                }
                async call(l) {
                    let {
                        tx: c,
                        blockTag: p
                    } = await (0, M.m)({
                        tx: this._getTransactionRequest(l),
                        blockTag: this._getBlockTag(l.blockTag)
                    });
                    return await this.#eT(this.#ej(c, p, l.enableCcipRead ? 0 : -1))
                }
                async# eR(l, c, p) {
                    let v = this._getAddress(c),
                        _ = this._getBlockTag(p);
                    return ("string" != typeof v || "string" != typeof _) && ([v, _] = await Promise.all([v, _])), await this.#eT(this.#eI(Object.assign(l, {
                        address: v,
                        blockTag: _
                    })))
                }
                async getBalance(l, c) {
                    return (0, P.yT)(await this.#eR({
                        method: "getBalance"
                    }, l, c), "%response")
                }
                async getTransactionCount(l, c) {
                    return (0, P.Dx)(await this.#eR({
                        method: "getTransactionCount"
                    }, l, c), "%response")
                }
                async getCode(l, c) {
                    return (0, T.Dv)(await this.#eR({
                        method: "getCode"
                    }, l, c))
                }
                async getStorage(l, c, p) {
                    let v = (0, P.yT)(c, "position");
                    return (0, T.Dv)(await this.#eR({
                        method: "getStorage",
                        position: v
                    }, l, p))
                }
                async broadcastTransaction(l) {
                    let {
                        blockNumber: c,
                        hash: p,
                        network: v
                    } = await (0, M.m)({
                        blockNumber: this.getBlockNumber(),
                        hash: this._perform({
                            method: "broadcastTransaction",
                            signedTransaction: l
                        }),
                        network: this.getNetwork()
                    }), _ = Transaction.from(l);
                    if (_.hash !== p) throw Error("@TODO: the returned hash did not match");
                    return this._wrapTransactionResponse(_, v).replaceableTransaction(c)
                }
                async# eO(l, c) {
                    if ((0, T.A7)(l, 32)) return await this.#eI({
                        method: "getBlock",
                        blockHash: l,
                        includeTransactions: c
                    });
                    let p = this._getBlockTag(l);
                    return "string" != typeof p && (p = await p), await this.#eI({
                        method: "getBlock",
                        blockTag: p,
                        includeTransactions: c
                    })
                }
                async getBlock(l, c) {
                    let {
                        network: p,
                        params: v
                    } = await (0, M.m)({
                        network: this.getNetwork(),
                        params: this.#eO(l, !!c)
                    });
                    return null == v ? null : this._wrapBlock(v, p)
                }
                async getTransaction(l) {
                    let {
                        network: c,
                        params: p
                    } = await (0, M.m)({
                        network: this.getNetwork(),
                        params: this.#eI({
                            method: "getTransaction",
                            hash: l
                        })
                    });
                    return null == p ? null : this._wrapTransactionResponse(p, c)
                }
                async getTransactionReceipt(l) {
                    let {
                        network: c,
                        params: p
                    } = await (0, M.m)({
                        network: this.getNetwork(),
                        params: this.#eI({
                            method: "getTransactionReceipt",
                            hash: l
                        })
                    });
                    if (null == p) return null;
                    if (null == p.gasPrice && null == p.effectiveGasPrice) {
                        let c = await this.#eI({
                            method: "getTransaction",
                            hash: l
                        });
                        if (null == c) throw Error("report this; could not find tx or effectiveGasPrice");
                        p.effectiveGasPrice = c.gasPrice
                    }
                    return this._wrapTransactionReceipt(p, c)
                }
                async getTransactionResult(l) {
                    let {
                        result: c
                    } = await (0, M.m)({
                        network: this.getNetwork(),
                        result: this.#eI({
                            method: "getTransactionResult",
                            hash: l
                        })
                    });
                    return null == c ? null : (0, T.Dv)(c)
                }
                async getLogs(l) {
                    let c = this._getFilter(l);
                    isPromise(c) && (c = await c);
                    let {
                        network: p,
                        params: v
                    } = await (0, M.m)({
                        network: this.getNetwork(),
                        params: this.#eI({
                            method: "getLogs",
                            filter: c
                        })
                    });
                    return v.map(l => this._wrapLog(l, p))
                }
                _getProvider(l) {
                    (0, C.hu)(!1, "provider cannot connect to target network", "UNSUPPORTED_OPERATION", {
                        operation: "_getProvider()"
                    })
                }
                async getResolver(l) {
                    return await EnsResolver.fromName(this, l)
                }
                async getAvatar(l) {
                    let c = await this.getResolver(l);
                    return c ? await c.getAvatar() : null
                }
                async resolveName(l) {
                    let c = await this.getResolver(l);
                    return c ? await c.getAddress() : null
                }
                async lookupAddress(l) {
                    l = (0, X.K)(l);
                    let c = (0, ta.VM)(l.substring(2).toLowerCase() + ".addr.reverse");
                    try {
                        let p = await EnsResolver.getEnsAddress(this),
                            v = new Contract(p, ["function resolver(bytes32) view returns (address)"], this),
                            _ = await v.resolver(c);
                        if (null == _ || _ === e5) return null;
                        let C = new Contract(_, ["function name(bytes32) view returns (string)"], this),
                            P = await C.name(c),
                            T = await this.resolveName(P);
                        if (T !== l) return null;
                        return P
                    } catch (l) {
                        if ((0, C.VZ)(l, "BAD_DATA") && "0x" === l.value || (0, C.VZ)(l, "CALL_EXCEPTION")) return null;
                        throw l
                    }
                    return null
                }
                async waitForTransaction(l, c, p) {
                    let v = null != c ? c : 1;
                    return 0 === v ? this.getTransactionReceipt(l) : new Promise(async (c, _) => {
                        let P = null,
                            listener = async p => {
                                try {
                                    let _ = await this.getTransactionReceipt(l);
                                    if (null != _ && p - _.blockNumber + 1 >= v) {
                                        c(_), P && (clearTimeout(P), P = null);
                                        return
                                    }
                                } catch (l) {
                                    console.log("EEE", l)
                                }
                                this.once("block", listener)
                            };
                        null != p && (P = setTimeout(() => {
                            null != P && (P = null, this.off("block", listener), _((0, C.wf)("timeout", "TIMEOUT", {
                                reason: "timeout"
                            })))
                        }, p)), listener(await this.getBlockNumber())
                    })
                }
                async waitForBlock(l) {
                    (0, C.hu)(!1, "not implemented yet", "NOT_IMPLEMENTED", {
                        operation: "waitForBlock"
                    })
                }
                _clearTimeout(l) {
                    let c = this.#eD.get(l);
                    c && (c.timer && clearTimeout(c.timer), this.#eD.delete(l))
                }
                _setTimeout(l, c) {
                    null == c && (c = 0);
                    let p = this.#eP++,
                        func = () => {
                            this.#eD.delete(p), l()
                        };
                    if (this.paused) this.#eD.set(p, {
                        timer: null,
                        func,
                        time: c
                    });
                    else {
                        let l = setTimeout(func, c);
                        this.#eD.set(p, {
                            timer: l,
                            func,
                            time: abstract_provider_getTime()
                        })
                    }
                    return p
                }
                _forEachSubscriber(l) {
                    for (let c of this.#ex.values()) l(c.subscriber)
                }
                _getSubscriber(l) {
                    switch (l.type) {
                        case "debug":
                        case "error":
                        case "network":
                            return new UnmanagedSubscriber(l.type);
                        case "block":
                            {
                                let l = new PollingBlockSubscriber(this);
                                return l.pollingInterval = this.pollingInterval,
                                l
                            }
                        case "event":
                            return new PollingEventSubscriber(this, l.filter);
                        case "transaction":
                            return new PollingTransactionSubscriber(this, l.hash);
                        case "orphan":
                            return new PollingOrphanSubscriber(this, l.filter)
                    }
                    throw Error(`unsupported event: ${l.type}`)
                }
                _recoverSubscriber(l, c) {
                    for (let p of this.#ex.values())
                        if (p.subscriber === l) {
                            p.started && p.subscriber.stop(), p.subscriber = c, p.started && c.start(), null != this.#e_ && c.pause(this.#e_);
                            break
                        }
                }
                async# eL(l, c) {
                    let p = await getSubscription(l, this);
                    return "event" === p.type && c && c.length > 0 && !0 === c[0].removed && (p = await getSubscription({
                        orphan: "drop-log",
                        log: c[0]
                    }, this)), this.#ex.get(p.tag) || null
                }
                async# eM(l) {
                    let c = await getSubscription(l, this),
                        p = c.tag,
                        v = this.#ex.get(p);
                    if (!v) {
                        let l = this._getSubscriber(c),
                            _ = new WeakMap,
                            C = new Map;
                        v = {
                            subscriber: l,
                            tag: p,
                            addressableMap: _,
                            nameMap: C,
                            started: !1,
                            listeners: []
                        }, this.#ex.set(p, v)
                    }
                    return v
                }
                async on(l, c) {
                    let p = await this.#eM(l);
                    return p.listeners.push({
                        listener: c,
                        once: !1
                    }), p.started || (p.subscriber.start(), p.started = !0, null != this.#e_ && p.subscriber.pause(this.#e_)), this
                }
                async once(l, c) {
                    let p = await this.#eM(l);
                    return p.listeners.push({
                        listener: c,
                        once: !0
                    }), p.started || (p.subscriber.start(), p.started = !0, null != this.#e_ && p.subscriber.pause(this.#e_)), this
                }
                async emit(l, ...c) {
                    let p = await this.#eL(l, c);
                    if (!p || 0 === p.listeners.length) return !1;
                    let v = p.listeners.length;
                    return p.listeners = p.listeners.filter(({
                        listener: p,
                        once: v
                    }) => {
                        let _ = new EventPayload(this, v ? null : p, l);
                        try {
                            p.call(this, ...c, _)
                        } catch (l) {}
                        return !v
                    }), 0 === p.listeners.length && (p.started && p.subscriber.stop(), this.#ex.delete(p.tag)), v > 0
                }
                async listenerCount(l) {
                    if (l) {
                        let c = await this.#eL(l);
                        return c ? c.listeners.length : 0
                    }
                    let c = 0;
                    for (let {
                            listeners: l
                        } of this.#ex.values()) c += l.length;
                    return c
                }
                async listeners(l) {
                    if (l) {
                        let c = await this.#eL(l);
                        return c ? c.listeners.map(({
                            listener: l
                        }) => l) : []
                    }
                    let c = [];
                    for (let {
                            listeners: l
                        } of this.#ex.values()) c = c.concat(l.map(({
                        listener: l
                    }) => l));
                    return c
                }
                async off(l, c) {
                    let p = await this.#eL(l);
                    if (!p) return this;
                    if (c) {
                        let l = p.listeners.map(({
                            listener: l
                        }) => l).indexOf(c);
                        l >= 0 && p.listeners.splice(l, 1)
                    }
                    return c && 0 !== p.listeners.length || (p.started && p.subscriber.stop(), this.#ex.delete(p.tag)), this
                }
                async removeAllListeners(l) {
                    if (l) {
                        let {
                            tag: c,
                            started: p,
                            subscriber: v
                        } = await this.#eM(l);
                        p && v.stop(), this.#ex.delete(c)
                    } else
                        for (let [l, {
                                started: c,
                                subscriber: p
                            }] of this.#ex) c && p.stop(), this.#ex.delete(l);
                    return this
                }
                async addListener(l, c) {
                    return await this.on(l, c)
                }
                async removeListener(l, c) {
                    return this.off(l, c)
                }
                get destroyed() {
                    return this.#eE
                }
                destroy() {
                    for (let l of (this.removeAllListeners(), this.#eD.keys())) this._clearTimeout(l);
                    this.#eE = !0
                }
                get paused() {
                    return null != this.#e_
                }
                set paused(l) {
                    !!l !== this.paused && (this.paused ? this.resume() : this.pause(!1))
                }
                pause(l) {
                    if (this.#eN = -1, null != this.#e_) {
                        if (!!l == this.#e_) return;
                        (0, C.hu)(!1, "cannot change pause type; resume first", "UNSUPPORTED_OPERATION", {
                            operation: "pause"
                        })
                    }
                    for (let c of (this._forEachSubscriber(c => c.pause(l)), this.#e_ = !!l, this.#eD.values())) c.timer && clearTimeout(c.timer), c.time = abstract_provider_getTime() - c.time
                }
                resume() {
                    if (null != this.#e_)
                        for (let l of (this._forEachSubscriber(l => l.resume()), this.#e_ = null, this.#eD.values())) {
                            let c = l.time;
                            c < 0 && (c = 0), l.time = abstract_provider_getTime(), setTimeout(l.func, c)
                        }
                }
            };

            function _parseBytes(l, c) {
                if ("0x" === l) return null;
                try {
                    let p = (0, P.Dx)((0, T.QB)(l, c, c + 32)),
                        v = (0, P.Dx)((0, T.QB)(l, p, p + 32));
                    return (0, T.QB)(l, p + 32, p + 32 + v)
                } catch (l) {}
                return null
            }

            function numPad(l) {
                let c = (0, P.ot)(l);
                if (c.length > 32) throw Error("internal; should not happen");
                let p = new Uint8Array(32);
                return p.set(c, 32 - c.length), p
            }
            let rd = new Uint8Array([]),
                rp = "0x0000000000000000000000000000000000000000000000000000000000000000";

            function checkProvider(l, c) {
                if (l.provider) return l.provider;
                (0, C.hu)(!1, "missing provider", "UNSUPPORTED_OPERATION", {
                    operation: c
                })
            }
            async function populate(l, c) {
                let p = (0, e4.kK)(c);
                if (null != p.to && (p.to = resolveAddress(p.to, l)), null != p.from) {
                    let c = p.from;
                    p.from = Promise.all([l.getAddress(), resolveAddress(c, l)]).then(([l, c]) => ((0, C.en)(l.toLowerCase() === c.toLowerCase(), "transaction from mismatch", "tx.from", c), l))
                } else p.from = l.getAddress();
                return await (0, M.m)(p)
            }
            let AbstractSigner = class AbstractSigner {
                provider;
                constructor(l) {
                    (0, M.h)(this, {
                        provider: l || null
                    })
                }
                async getNonce(l) {
                    return checkProvider(this, "getTransactionCount").getTransactionCount(await this.getAddress(), l)
                }
                async populateCall(l) {
                    let c = await populate(this, l);
                    return c
                }
                async populateTransaction(l) {
                    let c = checkProvider(this, "populateTransaction"),
                        p = await populate(this, l);
                    null == p.nonce && (p.nonce = await this.getNonce("pending")), null == p.gasLimit && (p.gasLimit = await this.estimateGas(p));
                    let v = await this.provider.getNetwork();
                    if (null != p.chainId) {
                        let c = (0, P.yT)(p.chainId);
                        (0, C.en)(c === v.chainId, "transaction chainId mismatch", "tx.chainId", l.chainId)
                    } else p.chainId = v.chainId;
                    let _ = null != p.maxFeePerGas || null != p.maxPriorityFeePerGas;
                    if (null != p.gasPrice && (2 === p.type || _) ? (0, C.en)(!1, "eip-1559 transaction do not support gasPrice", "tx", l) : (0 === p.type || 1 === p.type) && _ && (0, C.en)(!1, "pre-eip-1559 transaction do not support maxFeePerGas/maxPriorityFeePerGas", "tx", l), (2 === p.type || null == p.type) && null != p.maxFeePerGas && null != p.maxPriorityFeePerGas) p.type = 2;
                    else if (0 === p.type || 1 === p.type) {
                        let l = await c.getFeeData();
                        (0, C.hu)(null != l.gasPrice, "network does not support gasPrice", "UNSUPPORTED_OPERATION", {
                            operation: "getGasPrice"
                        }), null == p.gasPrice && (p.gasPrice = l.gasPrice)
                    } else {
                        let l = await c.getFeeData();
                        if (null == p.type) {
                            if (null != l.maxFeePerGas && null != l.maxPriorityFeePerGas) {
                                if (p.type = 2, null != p.gasPrice) {
                                    let l = p.gasPrice;
                                    delete p.gasPrice, p.maxFeePerGas = l, p.maxPriorityFeePerGas = l
                                } else null == p.maxFeePerGas && (p.maxFeePerGas = l.maxFeePerGas), null == p.maxPriorityFeePerGas && (p.maxPriorityFeePerGas = l.maxPriorityFeePerGas)
                            } else null != l.gasPrice ? ((0, C.hu)(!_, "network does not support EIP-1559", "UNSUPPORTED_OPERATION", {
                                operation: "populateTransaction"
                            }), null == p.gasPrice && (p.gasPrice = l.gasPrice), p.type = 0) : (0, C.hu)(!1, "failed to get consistent fee data", "UNSUPPORTED_OPERATION", {
                                operation: "signer.getFeeData"
                            })
                        } else 2 === p.type && (null == p.maxFeePerGas && (p.maxFeePerGas = l.maxFeePerGas), null == p.maxPriorityFeePerGas && (p.maxPriorityFeePerGas = l.maxPriorityFeePerGas))
                    }
                    return await (0, M.m)(p)
                }
                async estimateGas(l) {
                    return checkProvider(this, "estimateGas").estimateGas(await this.populateCall(l))
                }
                async call(l) {
                    return checkProvider(this, "call").call(await this.populateCall(l))
                }
                async resolveName(l) {
                    let c = checkProvider(this, "resolveName");
                    return await c.resolveName(l)
                }
                async sendTransaction(l) {
                    let c = checkProvider(this, "sendTransaction"),
                        p = await this.populateTransaction(l);
                    delete p.from;
                    let v = Transaction.from(p);
                    return await c.broadcastTransaction(await this.signTransaction(v))
                }
            };
            let FilterIdSubscriber = class FilterIdSubscriber {#
                ep;#
                eU;#
                eg;#
                eb;#
                eB;#
                eF;
                constructor(l) {
                    this.#ep = l, this.#eU = null, this.#eg = this.#ev.bind(this), this.#eb = !1, this.#eB = null, this.#eF = !1
                }
                _subscribe(l) {
                    throw Error("subclasses must override this")
                }
                _emitResults(l, c) {
                    throw Error("subclasses must override this")
                }
                _recover(l) {
                    throw Error("subclasses must override this")
                }
                async# ev(l) {
                    try {
                        null == this.#eU && (this.#eU = this._subscribe(this.#ep));
                        let l = null;
                        try {
                            l = await this.#eU
                        } catch (l) {
                            if (!(0, C.VZ)(l, "UNSUPPORTED_OPERATION") || "eth_newFilter" !== l.operation) throw l
                        }
                        if (null == l) {
                            this.#eU = null, this.#ep._recoverSubscriber(this, this._recover(this.#ep));
                            return
                        }
                        let c = await this.#ep.getNetwork();
                        if (this.#eB || (this.#eB = c), this.#eB.chainId !== c.chainId) throw Error("chaid changed");
                        if (this.#eF) return;
                        let p = await this.#ep.send("eth_getFilterChanges", [l]);
                        await this._emitResults(this.#ep, p)
                    } catch (l) {
                        console.log("@TODO", l)
                    }
                    this.#ep.once("block", this.#eg)
                }#
                eH() {
                    let l = this.#eU;
                    l && (this.#eU = null, l.then(l => {
                        this.#ep.send("eth_uninstallFilter", [l])
                    }))
                }
                start() {
                    this.#eb || (this.#eb = !0, this.#ev(-2))
                }
                stop() {
                    this.#eb && (this.#eb = !1, this.#eF = !0, this.#eH(), this.#ep.off("block", this.#eg))
                }
                pause(l) {
                    l && this.#eH(), this.#ep.off("block", this.#eg)
                }
                resume() {
                    this.start()
                }
            };
            let FilterIdEventSubscriber = class FilterIdEventSubscriber extends FilterIdSubscriber {#
                eV;
                constructor(l, c) {
                    super(l), this.#eV = JSON.parse(JSON.stringify(c))
                }
                _recover(l) {
                    return new PollingEventSubscriber(l, this.#eV)
                }
                async _subscribe(l) {
                    let c = await l.send("eth_newFilter", [this.#eV]);
                    return c
                }
                async _emitResults(l, c) {
                    for (let p of c) l.emit(this.#eV, l._wrapLog(p, l._network))
                }
            };
            let FilterIdPendingSubscriber = class FilterIdPendingSubscriber extends FilterIdSubscriber {
                async _subscribe(l) {
                    return await l.send("eth_newPendingTransactionFilter", [])
                }
                async _emitResults(l, c) {
                    for (let p of c) l.emit("pending", p)
                }
            };
            let rg = "bigint,boolean,function,number,string,symbol".split(/,/g);

            function deepCopy(l) {
                if (null == l || rg.indexOf(typeof l) >= 0 || "function" == typeof l.getAddress) return l;
                if (Array.isArray(l)) return l.map(deepCopy);
                if ("object" == typeof l) return Object.keys(l).reduce((c, p) => (c[p] = l[p], c), {});
                throw Error(`should not happen: ${l} (${typeof l})`)
            }

            function getLowerCase(l) {
                return l ? l.toLowerCase() : l
            }

            function isPollable(l) {
                return l && "number" == typeof l.pollingInterval
            }
            let rm = {
                polling: !1,
                staticNetwork: null,
                batchStallTime: 10,
                batchMaxSize: 1048576,
                batchMaxCount: 100,
                cacheTimeout: 250,
                pollingInterval: 4e3
            };
            let JsonRpcSigner = class JsonRpcSigner extends AbstractSigner {
                address;
                constructor(l, c) {
                    super(l), c = (0, X.K)(c), (0, M.h)(this, {
                        address: c
                    })
                }
                connect(l) {
                    (0, C.hu)(!1, "cannot reconnect JsonRpcSigner", "UNSUPPORTED_OPERATION", {
                        operation: "signer.connect"
                    })
                }
                async getAddress() {
                    return this.address
                }
                async populateTransaction(l) {
                    return await this.populateCall(l)
                }
                async sendUncheckedTransaction(l) {
                    let c = deepCopy(l),
                        p = [];
                    if (c.from) {
                        let v = c.from;
                        p.push((async () => {
                            let p = await resolveAddress(v, this.provider);
                            (0, C.en)(null != p && p.toLowerCase() === this.address.toLowerCase(), "from address mismatch", "transaction", l), c.from = p
                        })())
                    } else c.from = this.address;
                    if (null == c.gasLimit && p.push((async () => {
                            c.gasLimit = await this.provider.estimateGas({ ...c,
                                from: this.address
                            })
                        })()), null != c.to) {
                        let l = c.to;
                        p.push((async () => {
                            c.to = await resolveAddress(l, this.provider)
                        })())
                    }
                    p.length && await Promise.all(p);
                    let v = this.provider.getRpcTransaction(c);
                    return this.provider.send("eth_sendTransaction", [v])
                }
                async sendTransaction(l) {
                    let c = await this.provider.getBlockNumber(),
                        p = await this.sendUncheckedTransaction(l);
                    return await new Promise((l, v) => {
                        let _ = [1e3, 100],
                            checkTx = async () => {
                                let v = await this.provider.getTransaction(p);
                                if (null != v) {
                                    l(v.replaceableTransaction(c));
                                    return
                                }
                                this.provider._setTimeout(() => {
                                    checkTx()
                                }, _.pop() || 4e3)
                            };
                        checkTx()
                    })
                }
                async signTransaction(l) {
                    let c = deepCopy(l);
                    if (c.from) {
                        let p = await resolveAddress(c.from, this.provider);
                        (0, C.en)(null != p && p.toLowerCase() === this.address.toLowerCase(), "from address mismatch", "transaction", l), c.from = p
                    } else c.from = this.address;
                    let p = this.provider.getRpcTransaction(c);
                    return await this.provider.send("eth_signTransaction", [p])
                }
                async signMessage(l) {
                    let c = "string" == typeof l ? (0, ef.Y0)(l) : l;
                    return await this.provider.send("personal_sign", [(0, T.Dv)(c), this.address.toLowerCase()])
                }
                async signTypedData(l, c, p) {
                    let v = deepCopy(p),
                        _ = await TypedDataEncoder.resolveNames(l, c, v, async l => {
                            let c = await resolveAddress(l);
                            return (0, C.en)(null != c, "TypedData does not support null address", "value", l), c
                        });
                    return await this.provider.send("eth_signTypedData_v4", [this.address.toLowerCase(), JSON.stringify(TypedDataEncoder.getPayload(_.domain, c, _.value))])
                }
                async unlock(l) {
                    return this.provider.send("personal_unlockAccount", [this.address.toLowerCase(), l, null])
                }
                async _legacySignMessage(l) {
                    let c = "string" == typeof l ? (0, ef.Y0)(l) : l;
                    return await this.provider.send("eth_sign", [this.address.toLowerCase(), (0, T.Dv)(c)])
                }
            };
            let JsonRpcApiProvider = class JsonRpcApiProvider extends AbstractProvider {#
                d;#
                ez;#
                eq;#
                eW;#
                eG;#
                eB;#
                eK() {
                    if (this.#eW) return;
                    let l = 1 === this._getOption("batchMaxCount") ? 0 : this._getOption("batchStallTime");
                    this.#eW = setTimeout(() => {
                        this.#eW = null;
                        let l = this.#eq;
                        for (this.#eq = []; l.length;) {
                            let c = [l.shift()];
                            for (; l.length && c.length !== this.#d.batchMaxCount;) {
                                c.push(l.shift());
                                let p = JSON.stringify(c.map(l => l.payload));
                                if (p.length > this.#d.batchMaxSize) {
                                    l.unshift(c.pop());
                                    break
                                }
                            }(async () => {
                                let l = 1 === c.length ? c[0].payload : c.map(l => l.payload);
                                this.emit("debug", {
                                    action: "sendRpcPayload",
                                    payload: l
                                });
                                try {
                                    let p = await this._send(l);
                                    for (let {
                                            resolve: l,
                                            reject: v,
                                            payload: _
                                        } of (this.emit("debug", {
                                            action: "receiveRpcResult",
                                            result: p
                                        }), c)) {
                                        if (this.destroyed) {
                                            v((0, C.wf)("provider destroyed; cancelled request", "UNSUPPORTED_OPERATION", {
                                                operation: _.method
                                            }));
                                            continue
                                        }
                                        let c = p.filter(l => l.id === _.id)[0];
                                        if (null == c) {
                                            let l = (0, C.wf)("missing response for request", "BAD_DATA", {
                                                value: p,
                                                info: {
                                                    payload: _
                                                }
                                            });
                                            this.emit("error", l), v(l);
                                            continue
                                        }
                                        if ("error" in c) {
                                            v(this.getRpcError(_, c));
                                            continue
                                        }
                                        l(c.result)
                                    }
                                } catch (l) {
                                    for (let {
                                            reject: p
                                        } of (this.emit("debug", {
                                            action: "receiveRpcError",
                                            error: l
                                        }), c)) p(l)
                                }
                            })()
                        }
                    }, l)
                }
                constructor(l, c) {
                    super(l, c), this.#ez = 1, this.#d = Object.assign({}, rm, c || {}), this.#eq = [], this.#eW = null, this.#eB = null; {
                        let l = null,
                            c = new Promise(c => {
                                l = c
                            });
                        this.#eG = {
                            promise: c,
                            resolve: l
                        }
                    }
                    let p = this._getOption("staticNetwork");
                    p && ((0, C.en)(null == l || p.matches(l), "staticNetwork MUST match network object", "options", c), this.#eB = p)
                }
                _getOption(l) {
                    return this.#d[l]
                }
                get _network() {
                    return (0, C.hu)(this.#eB, "network is not available yet", "NETWORK_ERROR"), this.#eB
                }
                async _perform(l) {
                    if ("call" === l.method || "estimateGas" === l.method) {
                        let c = l.transaction;
                        if (c && null != c.type && (0, P.yT)(c.type) && null == c.maxFeePerGas && null == c.maxPriorityFeePerGas) {
                            let p = await this.getFeeData();
                            null == p.maxFeePerGas && null == p.maxPriorityFeePerGas && (l = Object.assign({}, l, {
                                transaction: Object.assign({}, c, {
                                    type: void 0
                                })
                            }))
                        }
                    }
                    let c = this.getRpcRequest(l);
                    return null != c ? await this.send(c.method, c.args) : super._perform(l)
                }
                async _detectNetwork() {
                    let l;
                    let c = this._getOption("staticNetwork");
                    if (c) return c;
                    if (this.ready) return rl.Z.from((0, P.yT)(await this.send("eth_chainId", [])));
                    let p = {
                        id: this.#ez++,
                        method: "eth_chainId",
                        params: [],
                        jsonrpc: "2.0"
                    };
                    this.emit("debug", {
                        action: "sendRpcPayload",
                        payload: p
                    });
                    try {
                        l = (await this._send(p))[0]
                    } catch (l) {
                        throw this.emit("debug", {
                            action: "receiveRpcError",
                            error: l
                        }), l
                    }
                    if (this.emit("debug", {
                            action: "receiveRpcResult",
                            result: l
                        }), "result" in l) return rl.Z.from((0, P.yT)(l.result));
                    throw this.getRpcError(p, l)
                }
                _start() {
                    null != this.#eG && null != this.#eG.resolve && (this.#eG.resolve(), this.#eG = null, (async () => {
                        for (; null == this.#eB && !this.destroyed;) try {
                            this.#eB = await this._detectNetwork()
                        } catch (l) {
                            if (this.destroyed) break;
                            console.log("JsonRpcProvider failed to detect network and cannot start up; retry in 1s (perhaps the URL is wrong or the node is not started)"), this.emit("error", (0, C.wf)("failed to bootstrap network detection", "NETWORK_ERROR", {
                                event: "initial-network-discovery",
                                info: {
                                    error: l
                                }
                            })), await new Promise(l => {
                                setTimeout(l, 1e3)
                            })
                        }
                        this.#eK()
                    })())
                }
                async _waitUntilReady() {
                    if (null != this.#eG) return await this.#eG.promise
                }
                _getSubscriber(l) {
                    return "pending" === l.type ? new FilterIdPendingSubscriber(this) : "event" === l.type ? this._getOption("polling") ? new PollingEventSubscriber(this, l.filter) : new FilterIdEventSubscriber(this, l.filter) : "orphan" === l.type && "drop-log" === l.filter.orphan ? new UnmanagedSubscriber("orphan") : super._getSubscriber(l)
                }
                get ready() {
                    return null == this.#eG
                }
                getRpcTransaction(l) {
                    let c = {};
                    return ["chainId", "gasLimit", "gasPrice", "type", "maxFeePerGas", "maxPriorityFeePerGas", "nonce", "value"].forEach(p => {
                        if (null == l[p]) return;
                        let v = p;
                        "gasLimit" === p && (v = "gas"), c[v] = (0, P.B4)((0, P.yT)(l[p], `tx.${p}`))
                    }), ["from", "to", "data"].forEach(p => {
                        null != l[p] && (c[p] = (0, T.Dv)(l[p]))
                    }), l.accessList && (c.accessList = (0, e2.z)(l.accessList)), c
                }
                getRpcRequest(l) {
                    switch (l.method) {
                        case "chainId":
                            return {
                                method: "eth_chainId",
                                args: []
                            };
                        case "getBlockNumber":
                            return {
                                method: "eth_blockNumber",
                                args: []
                            };
                        case "getGasPrice":
                            return {
                                method: "eth_gasPrice",
                                args: []
                            };
                        case "getBalance":
                            return {
                                method: "eth_getBalance",
                                args: [getLowerCase(l.address), l.blockTag]
                            };
                        case "getTransactionCount":
                            return {
                                method: "eth_getTransactionCount",
                                args: [getLowerCase(l.address), l.blockTag]
                            };
                        case "getCode":
                            return {
                                method: "eth_getCode",
                                args: [getLowerCase(l.address), l.blockTag]
                            };
                        case "getStorage":
                            return {
                                method: "eth_getStorageAt",
                                args: [getLowerCase(l.address), "0x" + l.position.toString(16), l.blockTag]
                            };
                        case "broadcastTransaction":
                            return {
                                method: "eth_sendRawTransaction",
                                args: [l.signedTransaction]
                            };
                        case "getBlock":
                            if ("blockTag" in l) return {
                                method: "eth_getBlockByNumber",
                                args: [l.blockTag, !!l.includeTransactions]
                            };
                            if ("blockHash" in l) return {
                                method: "eth_getBlockByHash",
                                args: [l.blockHash, !!l.includeTransactions]
                            };
                            break;
                        case "getTransaction":
                            return {
                                method: "eth_getTransactionByHash",
                                args: [l.hash]
                            };
                        case "getTransactionReceipt":
                            return {
                                method: "eth_getTransactionReceipt",
                                args: [l.hash]
                            };
                        case "call":
                            return {
                                method: "eth_call",
                                args: [this.getRpcTransaction(l.transaction), l.blockTag]
                            };
                        case "estimateGas":
                            return {
                                method: "eth_estimateGas",
                                args: [this.getRpcTransaction(l.transaction)]
                            };
                        case "getLogs":
                            return l.filter && null != l.filter.address && (Array.isArray(l.filter.address) ? l.filter.address = l.filter.address.map(getLowerCase) : l.filter.address = getLowerCase(l.filter.address)), {
                                method: "eth_getLogs",
                                args: [l.filter]
                            }
                    }
                    return null
                }
                getRpcError(l, c) {
                    let {
                        method: p
                    } = l, {
                        error: v
                    } = c;
                    if ("eth_estimateGas" === p && v.message) {
                        let c = v.message;
                        if (!c.match(/revert/i) && c.match(/insufficient funds/i)) return (0, C.wf)("insufficient funds", "INSUFFICIENT_FUNDS", {
                            transaction: l.params[0],
                            info: {
                                payload: l,
                                error: v
                            }
                        })
                    }
                    if ("eth_call" === p || "eth_estimateGas" === p) {
                        let c = function spelunkData(l) {
                                if (null == l) return null;
                                if ("string" == typeof l.message && l.message.match(/revert/i) && (0, T.A7)(l.data)) return {
                                    message: l.message,
                                    data: l.data
                                };
                                if ("object" == typeof l) {
                                    for (let c in l) {
                                        let p = spelunkData(l[c]);
                                        if (p) return p
                                    }
                                    return null
                                }
                                if ("string" == typeof l) try {
                                    return spelunkData(JSON.parse(l))
                                } catch (l) {}
                                return null
                            }(v),
                            _ = AbiCoder.getBuiltinCallException("eth_call" === p ? "call" : "estimateGas", l.params[0], c ? c.data : null);
                        return _.info = {
                            error: v,
                            payload: l
                        }, _
                    }
                    let _ = JSON.stringify(function(l) {
                        let c = [];
                        return ! function _spelunkMessage(l, c) {
                            if (null != l) {
                                if ("string" == typeof l.message && c.push(l.message), "object" == typeof l)
                                    for (let p in l) _spelunkMessage(l[p], c);
                                if ("string" == typeof l) try {
                                    return _spelunkMessage(JSON.parse(l), c)
                                } catch (l) {}
                            }
                        }(l, c), c
                    }(v));
                    if ("string" == typeof v.message && v.message.match(/user denied|ethers-user-denied/i)) return (0, C.wf)("user rejected action", "ACTION_REJECTED", {
                        action: {
                            eth_sign: "signMessage",
                            personal_sign: "signMessage",
                            eth_signTypedData_v4: "signTypedData",
                            eth_signTransaction: "signTransaction",
                            eth_sendTransaction: "sendTransaction",
                            eth_requestAccounts: "requestAccess",
                            wallet_requestAccounts: "requestAccess"
                        }[p] || "unknown",
                        reason: "rejected",
                        info: {
                            payload: l,
                            error: v
                        }
                    });
                    if ("eth_sendRawTransaction" === p || "eth_sendTransaction" === p) {
                        let c = l.params[0];
                        if (_.match(/insufficient funds|base fee exceeds gas limit/i)) return (0, C.wf)("insufficient funds for intrinsic transaction cost", "INSUFFICIENT_FUNDS", {
                            transaction: c,
                            info: {
                                error: v
                            }
                        });
                        if (_.match(/nonce/i) && _.match(/too low/i)) return (0, C.wf)("nonce has already been used", "NONCE_EXPIRED", {
                            transaction: c,
                            info: {
                                error: v
                            }
                        });
                        if (_.match(/replacement transaction/i) && _.match(/underpriced/i)) return (0, C.wf)("replacement fee too low", "REPLACEMENT_UNDERPRICED", {
                            transaction: c,
                            info: {
                                error: v
                            }
                        });
                        if (_.match(/only replay-protected/i)) return (0, C.wf)("legacy pre-eip-155 transactions not supported", "UNSUPPORTED_OPERATION", {
                            operation: p,
                            info: {
                                transaction: c,
                                info: {
                                    error: v
                                }
                            }
                        })
                    }
                    let P = !!_.match(/the method .* does not exist/i);
                    return (!P && v && v.details && v.details.startsWith("Unauthorized method:") && (P = !0), P) ? (0, C.wf)("unsupported operation", "UNSUPPORTED_OPERATION", {
                        operation: l.method,
                        info: {
                            error: v,
                            payload: l
                        }
                    }) : (0, C.wf)("could not coalesce error", "UNKNOWN_ERROR", {
                        error: v,
                        payload: l
                    })
                }
                send(l, c) {
                    if (this.destroyed) return Promise.reject((0, C.wf)("provider destroyed; cancelled request", "UNSUPPORTED_OPERATION", {
                        operation: l
                    }));
                    let p = this.#ez++,
                        v = new Promise((v, _) => {
                            this.#eq.push({
                                resolve: v,
                                reject: _,
                                payload: {
                                    method: l,
                                    params: c,
                                    id: p,
                                    jsonrpc: "2.0"
                                }
                            })
                        });
                    return this.#eK(), v
                }
                async getSigner(l) {
                    null == l && (l = 0);
                    let c = this.send("eth_accounts", []);
                    if ("number" == typeof l) {
                        let p = await c;
                        if (l >= p.length) throw Error("no such account");
                        return new JsonRpcSigner(this, p[l])
                    }
                    let {
                        accounts: p
                    } = await (0, M.m)({
                        network: this.getNetwork(),
                        accounts: c
                    });
                    for (let c of (l = (0, X.K)(l), p))
                        if ((0, X.K)(c) === l) return new JsonRpcSigner(this, l);
                    throw Error("invalid account")
                }
                async listAccounts() {
                    let l = await this.send("eth_accounts", []);
                    return l.map(l => new JsonRpcSigner(this, l))
                }
                destroy() {
                    for (let {
                            payload: l,
                            reject: c
                        } of (this.#eW && (clearTimeout(this.#eW), this.#eW = null), this.#eq)) c((0, C.wf)("provider destroyed; cancelled request", "UNSUPPORTED_OPERATION", {
                        operation: l.method
                    }));
                    this.#eq = [], super.destroy()
                }
            };
            let JsonRpcApiPollingProvider = class JsonRpcApiPollingProvider extends JsonRpcApiProvider {#
                eZ;
                constructor(l, c) {
                    super(l, c), this.#eZ = 4e3
                }
                _getSubscriber(l) {
                    let c = super._getSubscriber(l);
                    return isPollable(c) && (c.pollingInterval = this.#eZ), c
                }
                get pollingInterval() {
                    return this.#eZ
                }
                set pollingInterval(l) {
                    if (!Number.isInteger(l) || l < 0) throw Error("invalid interval");
                    this.#eZ = l, this._forEachSubscriber(l => {
                        isPollable(l) && (l.pollingInterval = this.#eZ)
                    })
                }
            }
        },
        795: function(l, c, p) {
            "use strict";
            p.d(c, {
                IX: function() {
                    return TransactionReceipt
                },
                Mw: function() {
                    return TransactionResponse
                },
                Zb: function() {
                    return Log
                },
                gO: function() {
                    return Block
                },
                jW: function() {
                    return FeeData
                },
                kK: function() {
                    return copyRequest
                }
            });
            var v = p(2671),
                _ = p(8582),
                C = p(8101),
                P = p(9644),
                T = p(2204);
            let M = BigInt(0);

            function getValue(l) {
                return null == l ? null : l
            }

            function toJson(l) {
                return null == l ? null : l.toString()
            }
            let FeeData = class FeeData {
                gasPrice;
                maxFeePerGas;
                maxPriorityFeePerGas;
                constructor(l, c, p) {
                    (0, v.h)(this, {
                        gasPrice: getValue(l),
                        maxFeePerGas: getValue(c),
                        maxPriorityFeePerGas: getValue(p)
                    })
                }
                toJSON() {
                    let {
                        gasPrice: l,
                        maxFeePerGas: c,
                        maxPriorityFeePerGas: p
                    } = this;
                    return {
                        _type: "FeeData",
                        gasPrice: toJson(l),
                        maxFeePerGas: toJson(c),
                        maxPriorityFeePerGas: toJson(p)
                    }
                }
            };

            function copyRequest(l) {
                let c = {};
                for (let p of (l.to && (c.to = l.to), l.from && (c.from = l.from), l.data && (c.data = (0, _.Dv)(l.data)), "chainId,gasLimit,gasPrice,maxFeePerGas,maxPriorityFeePerGas,value".split(/,/))) p in l && null != l[p] && (c[p] = (0, C.yT)(l[p], `request.${p}`));
                for (let p of "type,nonce".split(/,/)) p in l && null != l[p] && (c[p] = (0, C.Dx)(l[p], `request.${p}`));
                return l.accessList && (c.accessList = (0, T.z)(l.accessList)), "blockTag" in l && (c.blockTag = l.blockTag), "enableCcipRead" in l && (c.enableCcipRead = !!l.enableCcipRead), "customData" in l && (c.customData = l.customData), c
            }
            let Block = class Block {
                provider;
                number;
                hash;
                timestamp;
                parentHash;
                nonce;
                difficulty;
                gasLimit;
                gasUsed;
                miner;
                extraData;
                baseFeePerGas;#
                eJ;
                constructor(l, c) {
                    this.#eJ = l.transactions.map(l => "string" != typeof l ? new TransactionResponse(l, c) : l), (0, v.h)(this, {
                        provider: c,
                        hash: getValue(l.hash),
                        number: l.number,
                        timestamp: l.timestamp,
                        parentHash: l.parentHash,
                        nonce: l.nonce,
                        difficulty: l.difficulty,
                        gasLimit: l.gasLimit,
                        gasUsed: l.gasUsed,
                        miner: l.miner,
                        extraData: l.extraData,
                        baseFeePerGas: getValue(l.baseFeePerGas)
                    })
                }
                get transactions() {
                    return this.#eJ.map(l => "string" == typeof l ? l : l.hash)
                }
                get prefetchedTransactions() {
                    let l = this.#eJ.slice();
                    return 0 === l.length ? [] : ((0, P.hu)("object" == typeof l[0], "transactions were not prefetched with block request", "UNSUPPORTED_OPERATION", {
                        operation: "transactionResponses()"
                    }), l)
                }
                toJSON() {
                    let {
                        baseFeePerGas: l,
                        difficulty: c,
                        extraData: p,
                        gasLimit: v,
                        gasUsed: _,
                        hash: C,
                        miner: P,
                        nonce: T,
                        number: M,
                        parentHash: z,
                        timestamp: J,
                        transactions: Q
                    } = this;
                    return {
                        _type: "Block",
                        baseFeePerGas: toJson(l),
                        difficulty: toJson(c),
                        extraData: p,
                        gasLimit: toJson(v),
                        gasUsed: toJson(_),
                        hash: C,
                        miner: P,
                        nonce: T,
                        number: M,
                        parentHash: z,
                        timestamp: J,
                        transactions: Q
                    }
                }[Symbol.iterator]() {
                    let l = 0,
                        c = this.transactions;
                    return {
                        next: () => l < this.length ? {
                            value: c[l++],
                            done: !1
                        } : {
                            value: void 0,
                            done: !0
                        }
                    }
                }
                get length() {
                    return this.#eJ.length
                }
                get date() {
                    return null == this.timestamp ? null : new Date(1e3 * this.timestamp)
                }
                async getTransaction(l) {
                    let c;
                    if ("number" == typeof l) c = this.#eJ[l];
                    else {
                        let p = l.toLowerCase();
                        for (let l of this.#eJ) {
                            if ("string" == typeof l) {
                                if (l !== p) continue;
                                c = l;
                                break
                            }
                            if (l.hash !== p) {
                                c = l;
                                break
                            }
                        }
                    }
                    if (null == c) throw Error("no such tx");
                    return "string" == typeof c ? await this.provider.getTransaction(c) : c
                }
                getPrefetchedTransaction(l) {
                    let c = this.prefetchedTransactions;
                    if ("number" == typeof l) return c[l];
                    for (let p of (l = l.toLowerCase(), c))
                        if (p.hash === l) return p;
                    (0, P.en)(!1, "no matching transaction", "indexOrHash", l)
                }
                isMined() {
                    return !!this.hash
                }
                isLondon() {
                    return !!this.baseFeePerGas
                }
                orphanedEvent() {
                    if (!this.isMined()) throw Error("");
                    return {
                        orphan: "drop-block",
                        hash: this.hash,
                        number: this.number
                    }
                }
            };
            let Log = class Log {
                provider;
                transactionHash;
                blockHash;
                blockNumber;
                removed;
                address;
                data;
                topics;
                index;
                transactionIndex;
                constructor(l, c) {
                    this.provider = c;
                    let p = Object.freeze(l.topics.slice());
                    (0, v.h)(this, {
                        transactionHash: l.transactionHash,
                        blockHash: l.blockHash,
                        blockNumber: l.blockNumber,
                        removed: l.removed,
                        address: l.address,
                        data: l.data,
                        topics: p,
                        index: l.index,
                        transactionIndex: l.transactionIndex
                    })
                }
                toJSON() {
                    let {
                        address: l,
                        blockHash: c,
                        blockNumber: p,
                        data: v,
                        index: _,
                        removed: C,
                        topics: P,
                        transactionHash: T,
                        transactionIndex: M
                    } = this;
                    return {
                        _type: "log",
                        address: l,
                        blockHash: c,
                        blockNumber: p,
                        data: v,
                        index: _,
                        removed: C,
                        topics: P,
                        transactionHash: T,
                        transactionIndex: M
                    }
                }
                async getBlock() {
                    let l = await this.provider.getBlock(this.blockHash);
                    return (0, P.hu)(!!l, "failed to find transaction", "UNKNOWN_ERROR", {}), l
                }
                async getTransaction() {
                    let l = await this.provider.getTransaction(this.transactionHash);
                    return (0, P.hu)(!!l, "failed to find transaction", "UNKNOWN_ERROR", {}), l
                }
                async getTransactionReceipt() {
                    let l = await this.provider.getTransactionReceipt(this.transactionHash);
                    return (0, P.hu)(!!l, "failed to find transaction receipt", "UNKNOWN_ERROR", {}), l
                }
                removedEvent() {
                    return {
                        orphan: "drop-log",
                        log: {
                            transactionHash: this.transactionHash,
                            blockHash: this.blockHash,
                            blockNumber: this.blockNumber,
                            address: this.address,
                            data: this.data,
                            topics: Object.freeze(this.topics.slice()),
                            index: this.index
                        }
                    }
                }
            };
            let TransactionReceipt = class TransactionReceipt {
                provider;
                to;
                from;
                contractAddress;
                hash;
                index;
                blockHash;
                blockNumber;
                logsBloom;
                gasUsed;
                cumulativeGasUsed;
                gasPrice;
                type;
                status;
                root;#
                eQ;
                constructor(l, c) {
                    this.#eQ = Object.freeze(l.logs.map(l => new Log(l, c)));
                    let p = M;
                    null != l.effectiveGasPrice ? p = l.effectiveGasPrice : null != l.gasPrice && (p = l.gasPrice), (0, v.h)(this, {
                        provider: c,
                        to: l.to,
                        from: l.from,
                        contractAddress: l.contractAddress,
                        hash: l.hash,
                        index: l.index,
                        blockHash: l.blockHash,
                        blockNumber: l.blockNumber,
                        logsBloom: l.logsBloom,
                        gasUsed: l.gasUsed,
                        cumulativeGasUsed: l.cumulativeGasUsed,
                        gasPrice: p,
                        type: l.type,
                        status: l.status,
                        root: l.root
                    })
                }
                get logs() {
                    return this.#eQ
                }
                toJSON() {
                    let {
                        to: l,
                        from: c,
                        contractAddress: p,
                        hash: v,
                        index: _,
                        blockHash: C,
                        blockNumber: P,
                        logsBloom: T,
                        logs: M,
                        status: z,
                        root: J
                    } = this;
                    return {
                        _type: "TransactionReceipt",
                        blockHash: C,
                        blockNumber: P,
                        contractAddress: p,
                        cumulativeGasUsed: toJson(this.cumulativeGasUsed),
                        from: c,
                        gasPrice: toJson(this.gasPrice),
                        gasUsed: toJson(this.gasUsed),
                        hash: v,
                        index: _,
                        logs: M,
                        logsBloom: T,
                        root: J,
                        status: z,
                        to: l
                    }
                }
                get length() {
                    return this.logs.length
                }[Symbol.iterator]() {
                    let l = 0;
                    return {
                        next: () => l < this.length ? {
                            value: this.logs[l++],
                            done: !1
                        } : {
                            value: void 0,
                            done: !0
                        }
                    }
                }
                get fee() {
                    return this.gasUsed * this.gasPrice
                }
                async getBlock() {
                    let l = await this.provider.getBlock(this.blockHash);
                    if (null == l) throw Error("TODO");
                    return l
                }
                async getTransaction() {
                    let l = await this.provider.getTransaction(this.hash);
                    if (null == l) throw Error("TODO");
                    return l
                }
                async getResult() {
                    return await this.provider.getTransactionResult(this.hash)
                }
                async confirmations() {
                    return await this.provider.getBlockNumber() - this.blockNumber + 1
                }
                removedEvent() {
                    return createRemovedTransactionFilter(this)
                }
                reorderedEvent(l) {
                    return (0, P.hu)(!l || l.isMined(), "unmined 'other' transction cannot be orphaned", "UNSUPPORTED_OPERATION", {
                        operation: "reorderedEvent(other)"
                    }), createReorderedTransactionFilter(this, l)
                }
            };
            let TransactionResponse = class TransactionResponse {
                provider;
                blockNumber;
                blockHash;
                index;
                hash;
                type;
                to;
                from;
                nonce;
                gasLimit;
                gasPrice;
                maxPriorityFeePerGas;
                maxFeePerGas;
                data;
                value;
                chainId;
                signature;
                accessList;#
                e$;
                constructor(l, c) {
                    this.provider = c, this.blockNumber = null != l.blockNumber ? l.blockNumber : null, this.blockHash = null != l.blockHash ? l.blockHash : null, this.hash = l.hash, this.index = l.index, this.type = l.type, this.from = l.from, this.to = l.to || null, this.gasLimit = l.gasLimit, this.nonce = l.nonce, this.data = l.data, this.value = l.value, this.gasPrice = l.gasPrice, this.maxPriorityFeePerGas = null != l.maxPriorityFeePerGas ? l.maxPriorityFeePerGas : null, this.maxFeePerGas = null != l.maxFeePerGas ? l.maxFeePerGas : null, this.chainId = l.chainId, this.signature = l.signature, this.accessList = null != l.accessList ? l.accessList : null, this.#e$ = -1
                }
                toJSON() {
                    let {
                        blockNumber: l,
                        blockHash: c,
                        index: p,
                        hash: v,
                        type: _,
                        to: C,
                        from: P,
                        nonce: T,
                        data: M,
                        signature: z,
                        accessList: J
                    } = this;
                    return {
                        _type: "TransactionReceipt",
                        accessList: J,
                        blockNumber: l,
                        blockHash: c,
                        chainId: toJson(this.chainId),
                        data: M,
                        from: P,
                        gasLimit: toJson(this.gasLimit),
                        gasPrice: toJson(this.gasPrice),
                        hash: v,
                        maxFeePerGas: toJson(this.maxFeePerGas),
                        maxPriorityFeePerGas: toJson(this.maxPriorityFeePerGas),
                        nonce: T,
                        signature: z,
                        to: C,
                        index: p,
                        type: _,
                        value: toJson(this.value)
                    }
                }
                async getBlock() {
                    let l = this.blockNumber;
                    if (null == l) {
                        let c = await this.getTransaction();
                        c && (l = c.blockNumber)
                    }
                    if (null == l) return null;
                    let c = this.provider.getBlock(l);
                    if (null == c) throw Error("TODO");
                    return c
                }
                async getTransaction() {
                    return this.provider.getTransaction(this.hash)
                }
                async confirmations() {
                    if (null == this.blockNumber) {
                        let {
                            tx: l,
                            blockNumber: c
                        } = await (0, v.m)({
                            tx: this.getTransaction(),
                            blockNumber: this.provider.getBlockNumber()
                        });
                        return null == l || null == l.blockNumber ? 0 : c - l.blockNumber + 1
                    }
                    let l = await this.provider.getBlockNumber();
                    return l - this.blockNumber + 1
                }
                async wait(l, c) {
                    let p = null == l ? 1 : l,
                        _ = null == c ? 0 : c,
                        C = this.#e$,
                        T = -1,
                        z = -1 === C,
                        checkReplacement = async () => {
                            if (z) return null;
                            let {
                                blockNumber: l,
                                nonce: c
                            } = await (0, v.m)({
                                blockNumber: this.provider.getBlockNumber(),
                                nonce: this.provider.getTransactionCount(this.from)
                            });
                            if (c < this.nonce) {
                                C = l;
                                return
                            }
                            if (z) return null;
                            let _ = await this.getTransaction();
                            if (!_ || null == _.blockNumber)
                                for (-1 === T && (T = C - 3) < this.#e$ && (T = this.#e$); T <= l;) {
                                    if (z) return null;
                                    let c = await this.provider.getBlock(T, !0);
                                    if (null == c) break;
                                    for (let l of c)
                                        if (l === this.hash) return;
                                    for (let v = 0; v < c.length; v++) {
                                        let _ = await c.getTransaction(v);
                                        if (_.from === this.from && _.nonce === this.nonce) {
                                            if (z) return null;
                                            let c = await this.provider.getTransactionReceipt(_.hash);
                                            if (null == c || l - c.blockNumber + 1 < p) return;
                                            let v = "replaced";
                                            _.data === this.data && _.to === this.to && _.value === this.value ? v = "repriced" : "0x" === _.data && _.from === _.to && _.value === M && (v = "cancelled"), (0, P.hu)(!1, "transaction was replaced", "TRANSACTION_REPLACED", {
                                                cancelled: "replaced" === v || "cancelled" === v,
                                                reason: v,
                                                replacement: _.replaceableTransaction(C),
                                                hash: _.hash,
                                                receipt: c
                                            })
                                        }
                                    }
                                    T++
                                }
                        },
                        checkReceipt = l => {
                            if (null == l || 0 !== l.status) return l;
                            (0, P.hu)(!1, "transaction execution reverted", "CALL_EXCEPTION", {
                                action: "sendTransaction",
                                data: null,
                                reason: null,
                                invocation: null,
                                revert: null,
                                transaction: {
                                    to: l.to,
                                    from: l.from,
                                    data: ""
                                },
                                receipt: l
                            })
                        },
                        J = await this.provider.getTransactionReceipt(this.hash);
                    if (0 === p) return checkReceipt(J);
                    if (J) {
                        if (await J.confirmations() >= p) return checkReceipt(J)
                    } else if (await checkReplacement(), 0 === p) return null;
                    let Q = new Promise((l, c) => {
                        let v = [],
                            cancel = () => {
                                v.forEach(l => l())
                            };
                        if (v.push(() => {
                                z = !0
                            }), _ > 0) {
                            let l = setTimeout(() => {
                                cancel(), c((0, P.wf)("wait for transaction timeout", "TIMEOUT"))
                            }, _);
                            v.push(() => {
                                clearTimeout(l)
                            })
                        }
                        let txListener = async v => {
                            if (await v.confirmations() >= p) {
                                cancel();
                                try {
                                    l(checkReceipt(v))
                                } catch (l) {
                                    c(l)
                                }
                            }
                        };
                        if (v.push(() => {
                                this.provider.off(this.hash, txListener)
                            }), this.provider.on(this.hash, txListener), C >= 0) {
                            let replaceListener = async () => {
                                try {
                                    await checkReplacement()
                                } catch (l) {
                                    if ((0, P.VZ)(l, "TRANSACTION_REPLACED")) {
                                        cancel(), c(l);
                                        return
                                    }
                                }
                                z || this.provider.once("block", replaceListener)
                            };
                            v.push(() => {
                                this.provider.off("block", replaceListener)
                            }), this.provider.once("block", replaceListener)
                        }
                    });
                    return await Q
                }
                isMined() {
                    return null != this.blockHash
                }
                isLegacy() {
                    return 0 === this.type
                }
                isBerlin() {
                    return 1 === this.type
                }
                isLondon() {
                    return 2 === this.type
                }
                removedEvent() {
                    return (0, P.hu)(this.isMined(), "unmined transaction canot be orphaned", "UNSUPPORTED_OPERATION", {
                        operation: "removeEvent()"
                    }), createRemovedTransactionFilter(this)
                }
                reorderedEvent(l) {
                    return (0, P.hu)(this.isMined(), "unmined transaction canot be orphaned", "UNSUPPORTED_OPERATION", {
                        operation: "removeEvent()"
                    }), (0, P.hu)(!l || l.isMined(), "unmined 'other' transaction canot be orphaned", "UNSUPPORTED_OPERATION", {
                        operation: "removeEvent()"
                    }), createReorderedTransactionFilter(this, l)
                }
                replaceableTransaction(l) {
                    (0, P.en)(Number.isInteger(l) && l >= 0, "invalid startBlock", "startBlock", l);
                    let c = new TransactionResponse(this, this.provider);
                    return c.#e$ = l, c
                }
            };

            function createReorderedTransactionFilter(l, c) {
                return {
                    orphan: "reorder-transaction",
                    tx: l,
                    other: c
                }
            }

            function createRemovedTransactionFilter(l) {
                return {
                    orphan: "drop-transaction",
                    tx: l
                }
            }
        },
        2204: function(l, c, p) {
            "use strict";
            p.d(c, {
                z: function() {
                    return accessListify
                }
            });
            var v = p(4072),
                _ = p(9644),
                C = p(8582);

            function accessSetify(l, c) {
                return {
                    address: (0, v.K)(l),
                    storageKeys: c.map((l, c) => ((0, _.en)((0, C.A7)(l, 32), "invalid slot", `storageKeys[${c}]`, l), l.toLowerCase()))
                }
            }

            function accessListify(l) {
                if (Array.isArray(l)) return l.map((c, p) => Array.isArray(c) ? ((0, _.en)(2 === c.length, "invalid slot set", `value[${p}]`, c), accessSetify(c[0], c[1])) : ((0, _.en)(null != c && "object" == typeof c, "invalid address-slot set", "value", l), accessSetify(c.address, c.storageKeys)));
                (0, _.en)(null != l && "object" == typeof l, "invalid access list", "value", l);
                let c = Object.keys(l).map(c => {
                    let p = l[c].reduce((l, c) => (l[c] = !0, l), {});
                    return accessSetify(c, Object.keys(p).sort())
                });
                return c.sort((l, c) => l.address.localeCompare(c.address)), c
            }
        },
        8582: function(l, c, p) {
            "use strict";
            p.d(c, {
                A7: function() {
                    return isHexString
                },
                Dv: function() {
                    return hexlify
                },
                M5: function() {
                    return dataLength
                },
                Pw: function() {
                    return getBytes
                },
                QB: function() {
                    return dataSlice
                },
                SK: function() {
                    return zeroPadBytes
                },
                U3: function() {
                    return zeroPadValue
                },
                Zq: function() {
                    return isBytesLike
                },
                h_: function() {
                    return getBytesCopy
                },
                zo: function() {
                    return concat
                }
            });
            var v = p(9644);

            function _getBytes(l, c, p) {
                if (l instanceof Uint8Array) return p ? new Uint8Array(l) : l;
                if ("string" == typeof l && l.match(/^0x([0-9a-f][0-9a-f])*$/i)) {
                    let c = new Uint8Array((l.length - 2) / 2),
                        p = 2;
                    for (let v = 0; v < c.length; v++) c[v] = parseInt(l.substring(p, p + 2), 16), p += 2;
                    return c
                }(0, v.en)(!1, "invalid BytesLike value", c || "value", l)
            }

            function getBytes(l, c) {
                return _getBytes(l, c, !1)
            }

            function getBytesCopy(l, c) {
                return _getBytes(l, c, !0)
            }

            function isHexString(l, c) {
                return !!("string" == typeof l && l.match(/^0x[0-9A-Fa-f]*$/)) && ("number" != typeof c || l.length === 2 + 2 * c) && (!0 !== c || l.length % 2 == 0)
            }

            function isBytesLike(l) {
                return isHexString(l, !0) || l instanceof Uint8Array
            }
            let _ = "0123456789abcdef";

            function hexlify(l) {
                let c = getBytes(l),
                    p = "0x";
                for (let l = 0; l < c.length; l++) {
                    let v = c[l];
                    p += _[(240 & v) >> 4] + _[15 & v]
                }
                return p
            }

            function concat(l) {
                return "0x" + l.map(l => hexlify(l).substring(2)).join("")
            }

            function dataLength(l) {
                return isHexString(l, !0) ? (l.length - 2) / 2 : getBytes(l).length
            }

            function dataSlice(l, c, p) {
                let _ = getBytes(l);
                return null != p && p > _.length && (0, v.hu)(!1, "cannot slice beyond data bounds", "BUFFER_OVERRUN", {
                    buffer: _,
                    length: _.length,
                    offset: p
                }), hexlify(_.slice(null == c ? 0 : c, null == p ? _.length : p))
            }

            function zeroPad(l, c, p) {
                let _ = getBytes(l);
                (0, v.hu)(c >= _.length, "padding exceeds data length", "BUFFER_OVERRUN", {
                    buffer: new Uint8Array(_),
                    length: c,
                    offset: c + 1
                });
                let C = new Uint8Array(c);
                return C.fill(0), p ? C.set(_, c - _.length) : C.set(_, 0), hexlify(C)
            }

            function zeroPadValue(l, c) {
                return zeroPad(l, c, !0)
            }

            function zeroPadBytes(l, c) {
                return zeroPad(l, c, !1)
            }
        },
        9644: function(l, c, p) {
            "use strict";
            p.d(c, {
                hu: function() {
                    return assert
                },
                en: function() {
                    return assertArgument
                },
                fG: function() {
                    return assertArgumentCount
                },
                fA: function() {
                    return assertNormalize
                },
                NK: function() {
                    return assertPrivate
                },
                Hl: function() {
                    return isCallException
                },
                VZ: function() {
                    return isError
                },
                wf: function() {
                    return makeError
                }
            });
            var v = p(2671);

            function stringify(l) {
                if (null == l) return "null";
                if (Array.isArray(l)) return "[ " + l.map(stringify).join(", ") + " ]";
                if (l instanceof Uint8Array) {
                    let c = "0123456789abcdef",
                        p = "0x";
                    for (let v = 0; v < l.length; v++) p += c[l[v] >> 4] + c[15 & l[v]];
                    return p
                }
                if ("object" == typeof l && "function" == typeof l.toJSON) return stringify(l.toJSON());
                switch (typeof l) {
                    case "boolean":
                    case "symbol":
                    case "number":
                        return l.toString();
                    case "bigint":
                        return BigInt(l).toString();
                    case "string":
                        return JSON.stringify(l);
                    case "object":
                        {
                            let c = Object.keys(l);
                            return c.sort(),
                            "{ " + c.map(c => `${stringify(c)}: ${stringify(l[c])}`).join(", ") + " }"
                        }
                }
                return "[ COULD NOT SERIALIZE ]"
            }

            function isError(l, c) {
                return l && l.code === c
            }

            function isCallException(l) {
                return isError(l, "CALL_EXCEPTION")
            }

            function makeError(l, c, p) {
                let _; {
                    let v = [];
                    if (p) {
                        if ("message" in p || "code" in p || "name" in p) throw Error(`value will overwrite populated values: ${stringify(p)}`);
                        for (let l in p) {
                            let c = p[l];
                            v.push(l + "=" + stringify(c))
                        }
                    }
                    v.push(`code=${c}`), v.push("version=6.7.1"), v.length && (l += " (" + v.join(", ") + ")")
                }
                switch (c) {
                    case "INVALID_ARGUMENT":
                        _ = TypeError(l);
                        break;
                    case "NUMERIC_FAULT":
                    case "BUFFER_OVERRUN":
                        _ = RangeError(l);
                        break;
                    default:
                        _ = Error(l)
                }
                return (0, v.h)(_, {
                    code: c
                }), p && Object.assign(_, p), _
            }

            function assert(l, c, p, v) {
                if (!l) throw makeError(c, p, v)
            }

            function assertArgument(l, c, p, v) {
                assert(l, c, "INVALID_ARGUMENT", {
                    argument: p,
                    value: v
                })
            }

            function assertArgumentCount(l, c, p) {
                null == p && (p = ""), p && (p = ": " + p), assert(l >= c, "missing arguemnt" + p, "MISSING_ARGUMENT", {
                    count: l,
                    expectedCount: c
                }), assert(l <= c, "too many arguemnts" + p, "UNEXPECTED_ARGUMENT", {
                    count: l,
                    expectedCount: c
                })
            }
            let _ = ["NFD", "NFC", "NFKD", "NFKC"].reduce((l, c) => {
                try {
                    if ("test" !== "test".normalize(c)) throw Error("bad");
                    if ("NFD" === c) {
                        let l = String.fromCharCode(233).normalize("NFD"),
                            c = String.fromCharCode(101, 769);
                        if (l !== c) throw Error("broken")
                    }
                    l.push(c)
                } catch (l) {}
                return l
            }, []);

            function assertNormalize(l) {
                assert(_.indexOf(l) >= 0, "platform missing String.prototype.normalize", "UNSUPPORTED_OPERATION", {
                    operation: "String.prototype.normalize",
                    info: {
                        form: l
                    }
                })
            }

            function assertPrivate(l, c, p) {
                if (null == p && (p = ""), l !== c) {
                    let l = p,
                        c = "new";
                    p && (l += ".", c += " " + p), assert(!1, `private constructor; use ${l}from* methods`, "UNSUPPORTED_OPERATION", {
                        operation: c
                    })
                }
            }
        },
        8101: function(l, c, p) {
            "use strict";
            p.d(c, {
                $j: function() {
                    return toTwos
                },
                B4: function() {
                    return toQuantity
                },
                Dx: function() {
                    return getNumber
                },
                Gh: function() {
                    return toBigInt
                },
                He: function() {
                    return toNumber
                },
                _Y: function() {
                    return fromTwos
                },
                m9: function() {
                    return toBeHex
                },
                ot: function() {
                    return toBeArray
                },
                sS: function() {
                    return mask
                },
                yT: function() {
                    return getBigInt
                }
            });
            var v = p(8582),
                _ = p(9644);
            let C = BigInt(0),
                P = BigInt(1);

            function fromTwos(l, c) {
                let p = getUint(l, "value"),
                    v = BigInt(getNumber(c, "width"));
                if ((0, _.hu)(p >> v === C, "overflow", "NUMERIC_FAULT", {
                        operation: "fromTwos",
                        fault: "overflow",
                        value: l
                    }), p >> v - P) {
                    let l = (P << v) - P;
                    return -((~p & l) + P)
                }
                return p
            }

            function toTwos(l, c) {
                let p = getBigInt(l, "value"),
                    v = BigInt(getNumber(c, "width")),
                    T = P << v - P;
                return p < C ? (p = -p, (0, _.hu)(p <= T, "too low", "NUMERIC_FAULT", {
                    operation: "toTwos",
                    fault: "overflow",
                    value: l
                }), (~p & (P << v) - P) + P) : ((0, _.hu)(p < T, "too high", "NUMERIC_FAULT", {
                    operation: "toTwos",
                    fault: "overflow",
                    value: l
                }), p)
            }

            function mask(l, c) {
                let p = getUint(l, "value"),
                    v = BigInt(getNumber(c, "bits"));
                return p & (P << v) - P
            }

            function getBigInt(l, c) {
                switch (typeof l) {
                    case "bigint":
                        return l;
                    case "number":
                        return (0, _.en)(Number.isInteger(l), "underflow", c || "value", l), (0, _.en)(l >= -9007199254740991 && l <= 9007199254740991, "overflow", c || "value", l), BigInt(l);
                    case "string":
                        try {
                            if ("" === l) throw Error("empty string");
                            if ("-" === l[0] && "-" !== l[1]) return -BigInt(l.substring(1));
                            return BigInt(l)
                        } catch (p) {
                            (0, _.en)(!1, `invalid BigNumberish string: ${p.message}`, c || "value", l)
                        }
                }(0, _.en)(!1, "invalid BigNumberish value", c || "value", l)
            }

            function getUint(l, c) {
                let p = getBigInt(l, c);
                return (0, _.hu)(p >= C, "unsigned value cannot be negative", "NUMERIC_FAULT", {
                    fault: "overflow",
                    operation: "getUint",
                    value: l
                }), p
            }
            let T = "0123456789abcdef";

            function toBigInt(l) {
                if (l instanceof Uint8Array) {
                    let c = "0x0";
                    for (let p of l) c += T[p >> 4] + T[15 & p];
                    return BigInt(c)
                }
                return getBigInt(l)
            }

            function getNumber(l, c) {
                switch (typeof l) {
                    case "bigint":
                        return (0, _.en)(l >= -9007199254740991 && l <= 9007199254740991, "overflow", c || "value", l), Number(l);
                    case "number":
                        return (0, _.en)(Number.isInteger(l), "underflow", c || "value", l), (0, _.en)(l >= -9007199254740991 && l <= 9007199254740991, "overflow", c || "value", l), l;
                    case "string":
                        try {
                            if ("" === l) throw Error("empty string");
                            return getNumber(BigInt(l), c)
                        } catch (p) {
                            (0, _.en)(!1, `invalid numeric string: ${p.message}`, c || "value", l)
                        }
                }(0, _.en)(!1, "invalid numeric value", c || "value", l)
            }

            function toNumber(l) {
                return getNumber(toBigInt(l))
            }

            function toBeHex(l, c) {
                let p = getUint(l, "value"),
                    v = p.toString(16);
                if (null == c) v.length % 2 && (v = "0" + v);
                else {
                    let p = getNumber(c, "width");
                    for ((0, _.hu)(2 * p >= v.length, `value exceeds width (${p} bits)`, "NUMERIC_FAULT", {
                            operation: "toBeHex",
                            fault: "overflow",
                            value: l
                        }); v.length < 2 * p;) v = "0" + v
                }
                return "0x" + v
            }

            function toBeArray(l) {
                let c = getUint(l, "value");
                if (c === C) return new Uint8Array([]);
                let p = c.toString(16);
                p.length % 2 && (p = "0" + p);
                let v = new Uint8Array(p.length / 2);
                for (let l = 0; l < v.length; l++) {
                    let c = 2 * l;
                    v[l] = parseInt(p.substring(c, c + 2), 16)
                }
                return v
            }

            function toQuantity(l) {
                let c = (0, v.Dv)((0, v.Zq)(l) ? l : toBeArray(l)).substring(2);
                for (; c.startsWith("0");) c = c.substring(1);
                return "" === c && (c = "0"), "0x" + c
            }
        },
        2671: function(l, c, p) {
            "use strict";
            async function resolveProperties(l) {
                let c = Object.keys(l),
                    p = await Promise.all(c.map(c => Promise.resolve(l[c])));
                return p.reduce((l, p, v) => (l[c[v]] = p, l), {})
            }

            function defineProperties(l, c, p) {
                for (let v in c) {
                    let _ = c[v],
                        C = p ? p[v] : null;
                    C && function(l, c, p) {
                        let v = c.split("|").map(l => l.trim());
                        for (let p = 0; p < v.length; p++) switch (c) {
                            case "any":
                                return;
                            case "bigint":
                            case "boolean":
                            case "number":
                            case "string":
                                if (typeof l === c) return
                        }
                        let _ = Error(`invalid value for type ${c}`);
                        throw _.code = "INVALID_ARGUMENT", _.argument = `value.${p}`, _.value = l, _
                    }(_, C, v), Object.defineProperty(l, v, {
                        enumerable: !0,
                        value: _,
                        writable: !1
                    })
                }
            }
            p.d(c, {
                h: function() {
                    return defineProperties
                },
                m: function() {
                    return resolveProperties
                }
            })
        },
        3100: function(l, c, p) {
            "use strict";
            p.d(c, {
                Y0: function() {
                    return toUtf8Bytes
                },
                ZN: function() {
                    return toUtf8String
                }
            });
            var v = p(8582),
                _ = p(9644);

            function ignoreFunc(l, c, p, v, _) {
                if ("BAD_PREFIX" === l || "UNEXPECTED_CONTINUE" === l) {
                    let l = 0;
                    for (let v = c + 1; v < p.length && p[v] >> 6 == 2; v++) l++;
                    return l
                }
                return "OVERRUN" === l ? p.length - c - 1 : 0
            }
            let C = Object.freeze({
                error: function(l, c, p, v, C) {
                    (0, _.en)(!1, `invalid codepoint at offset ${c}; ${l}`, "bytes", p)
                },
                ignore: ignoreFunc,
                replace: function(l, c, p, v, C) {
                    return "OVERLONG" === l ? ((0, _.en)("number" == typeof C, "invalid bad code point for replacement", "badCodepoint", C), v.push(C), 0) : (v.push(65533), ignoreFunc(l, c, p, v, C))
                }
            });

            function toUtf8Bytes(l, c) {
                null != c && ((0, _.fA)(c), l = l.normalize(c));
                let p = [];
                for (let c = 0; c < l.length; c++) {
                    let v = l.charCodeAt(c);
                    if (v < 128) p.push(v);
                    else if (v < 2048) p.push(v >> 6 | 192), p.push(63 & v | 128);
                    else if ((64512 & v) == 55296) {
                        c++;
                        let C = l.charCodeAt(c);
                        (0, _.en)(c < l.length && (64512 & C) == 56320, "invalid surrogate pair", "str", l);
                        let P = 65536 + ((1023 & v) << 10) + (1023 & C);
                        p.push(P >> 18 | 240), p.push(P >> 12 & 63 | 128), p.push(P >> 6 & 63 | 128), p.push(63 & P | 128)
                    } else p.push(v >> 12 | 224), p.push(v >> 6 & 63 | 128), p.push(63 & v | 128)
                }
                return new Uint8Array(p)
            }

            function toUtf8String(l, c) {
                return (function(l, c) {
                    null == c && (c = C.error);
                    let p = (0, v.Pw)(l, "bytes"),
                        _ = [],
                        P = 0;
                    for (; P < p.length;) {
                        let l = p[P++];
                        if (l >> 7 == 0) {
                            _.push(l);
                            continue
                        }
                        let v = null,
                            C = null;
                        if ((224 & l) == 192) v = 1, C = 127;
                        else if ((240 & l) == 224) v = 2, C = 2047;
                        else if ((248 & l) == 240) v = 3, C = 65535;
                        else {
                            (192 & l) == 128 ? P += c("UNEXPECTED_CONTINUE", P - 1, p, _) : P += c("BAD_PREFIX", P - 1, p, _);
                            continue
                        }
                        if (P - 1 + v >= p.length) {
                            P += c("OVERRUN", P - 1, p, _);
                            continue
                        }
                        let T = l & (1 << 8 - v - 1) - 1;
                        for (let l = 0; l < v; l++) {
                            let l = p[P];
                            if ((192 & l) != 128) {
                                P += c("MISSING_CONTINUE", P, p, _), T = null;
                                break
                            }
                            T = T << 6 | 63 & l, P++
                        }
                        if (null !== T) {
                            if (T > 1114111) {
                                P += c("OUT_OF_RANGE", P - 1 - v, p, _, T);
                                continue
                            }
                            if (T >= 55296 && T <= 57343) {
                                P += c("UTF16_SURROGATE", P - 1 - v, p, _, T);
                                continue
                            }
                            if (T <= C) {
                                P += c("OVERLONG", P - 1 - v, p, _, T);
                                continue
                            }
                            _.push(T)
                        }
                    }
                    return _
                })(l, c).map(l => l <= 65535 ? String.fromCharCode(l) : String.fromCharCode(((l -= 65536) >> 10 & 1023) + 55296, (1023 & l) + 56320)).join("")
            }
        },
        2843: function(l, c, p) {
            "use strict";
            p.d(c, {
                $l: function() {
                    return C
                },
                BN: function() {
                    return internalMutate
                },
                DY: function() {
                    return M
                },
                J$: function() {
                    return SWRConfig
                },
                JN: function() {
                    return createCacheHelper
                },
                LI: function() {
                    return ep
                },
                PM: function() {
                    return mergeObjects
                },
                W6: function() {
                    return ef
                },
                i_: function() {
                    return _
                },
                kY: function() {
                    return useSWRConfig
                },
                ko: function() {
                    return subscribeCallback
                },
                kw: function() {
                    return rAF
                },
                mf: function() {
                    return isFunction
                },
                o8: function() {
                    return isUndefined
                },
                qC: function() {
                    return serialize
                },
                s6: function() {
                    return withArgs
                },
                sj: function() {
                    return eb
                },
                u3: function() {
                    return getTimestamp
                },
                u_: function() {
                    return e_
                },
                w6: function() {
                    return ed
                },
                xD: function() {
                    return withMiddleware
                }
            });
            var v = p(1248);
            let noop = () => {},
                _ = noop(),
                C = Object,
                isUndefined = l => l === _,
                isFunction = l => "function" == typeof l,
                mergeObjects = (l, c) => ({ ...l,
                    ...c
                }),
                isPromiseLike = l => isFunction(l.then),
                P = new WeakMap,
                T = 0,
                stableHash = l => {
                    let c, p;
                    let v = typeof l,
                        _ = l && l.constructor,
                        M = _ == Date;
                    if (C(l) !== l || M || _ == RegExp) c = M ? l.toJSON() : "symbol" == v ? l.toString() : "string" == v ? JSON.stringify(l) : "" + l;
                    else {
                        if (c = P.get(l)) return c;
                        if (c = ++T + "~", P.set(l, c), _ == Array) {
                            for (p = 0, c = "@"; p < l.length; p++) c += stableHash(l[p]) + ",";
                            P.set(l, c)
                        }
                        if (_ == C) {
                            c = "#";
                            let v = C.keys(l).sort();
                            for (; !isUndefined(p = v.pop());) isUndefined(l[p]) || (c += p + ":" + stableHash(l[p]) + ",");
                            P.set(l, c)
                        }
                    }
                    return c
                },
                M = new WeakMap,
                z = {},
                J = {},
                Q = "undefined",
                X = typeof window != Q,
                es = typeof document != Q,
                hasRequestAnimationFrame = () => X && typeof window.requestAnimationFrame != Q,
                createCacheHelper = (l, c) => {
                    let p = M.get(l);
                    return [() => !isUndefined(c) && l.get(c) || z, v => {
                        if (!isUndefined(c)) {
                            let _ = l.get(c);
                            c in J || (J[c] = _), p[5](c, mergeObjects(_, v), _ || z)
                        }
                    }, p[6], () => !isUndefined(c) && c in J ? J[c] : !isUndefined(c) && l.get(c) || z]
                },
                eo = !0,
                [el, ec] = X && window.addEventListener ? [window.addEventListener.bind(window), window.removeEventListener.bind(window)] : [noop, noop],
                eh = {
                    initFocus: l => (es && document.addEventListener("visibilitychange", l), el("focus", l), () => {
                        es && document.removeEventListener("visibilitychange", l), ec("focus", l)
                    }),
                    initReconnect: l => {
                        let onOnline = () => {
                                eo = !0, l()
                            },
                            onOffline = () => {
                                eo = !1
                            };
                        return el("online", onOnline), el("offline", onOffline), () => {
                            ec("online", onOnline), ec("offline", onOffline)
                        }
                    }
                },
                ed = !v.useId,
                ef = !X || "Deno" in window,
                rAF = l => hasRequestAnimationFrame() ? window.requestAnimationFrame(l) : setTimeout(l, 1),
                ep = ef ? v.useEffect : v.useLayoutEffect,
                eg = "undefined" != typeof navigator && navigator.connection,
                em = !ef && eg && (["slow-2g", "2g"].includes(eg.effectiveType) || eg.saveData),
                serialize = l => {
                    if (isFunction(l)) try {
                        l = l()
                    } catch (c) {
                        l = ""
                    }
                    let c = l;
                    return [l = "string" == typeof l ? l : (Array.isArray(l) ? l.length : l) ? stableHash(l) : "", c]
                },
                ey = 0,
                getTimestamp = () => ++ey;
            var eb = {
                __proto__: null,
                ERROR_REVALIDATE_EVENT: 3,
                FOCUS_EVENT: 0,
                MUTATE_EVENT: 2,
                RECONNECT_EVENT: 1
            };
            async function internalMutate(...l) {
                let [c, p, v, C] = l, P = mergeObjects({
                    populateCache: !0,
                    throwOnError: !0
                }, "boolean" == typeof C ? {
                    revalidate: C
                } : C || {}), T = P.populateCache, z = P.rollbackOnError, J = P.optimisticData, Q = !1 !== P.revalidate, rollbackOnError = l => "function" == typeof z ? z(l) : !1 !== z, X = P.throwOnError;
                if (isFunction(p)) {
                    let l = [],
                        v = c.keys();
                    for (let _ of v) !/^\$(inf|sub)\$/.test(_) && p(c.get(_)._k) && l.push(_);
                    return Promise.all(l.map(mutateByKey))
                }
                return mutateByKey(p);
                async function mutateByKey(p) {
                    let C;
                    let [P] = serialize(p);
                    if (!P) return;
                    let [z, es] = createCacheHelper(c, P), [eo, el, ec, eh] = M.get(c), startRevalidate = () => {
                        let l = eo[P];
                        return Q && (delete ec[P], delete eh[P], l && l[0]) ? l[0](2).then(() => z().data) : z().data
                    };
                    if (l.length < 3) return startRevalidate();
                    let ed = v,
                        ef = getTimestamp();
                    el[P] = [ef, 0];
                    let ep = !isUndefined(J),
                        eg = z(),
                        em = eg.data,
                        ey = eg._c,
                        eb = isUndefined(ey) ? em : ey;
                    if (ep && es({
                            data: J = isFunction(J) ? J(eb, em) : J,
                            _c: eb
                        }), isFunction(ed)) try {
                        ed = ed(eb)
                    } catch (l) {
                        C = l
                    }
                    if (ed && isPromiseLike(ed)) {
                        if (ed = await ed.catch(l => {
                                C = l
                            }), ef !== el[P][0]) {
                            if (C) throw C;
                            return ed
                        }
                        C && ep && rollbackOnError(C) && (T = !0, es({
                            data: eb,
                            _c: _
                        }))
                    }
                    if (T && !C) {
                        if (isFunction(T)) {
                            let l = T(ed, eb);
                            es({
                                data: l,
                                error: _,
                                _c: _
                            })
                        } else es({
                            data: ed,
                            error: _,
                            _c: _
                        })
                    }
                    if (el[P][1] = getTimestamp(), Promise.resolve(startRevalidate()).then(() => {
                            es({
                                _c: _
                            })
                        }), C) {
                        if (X) throw C;
                        return
                    }
                    return ed
                }
            }
            let revalidateAllKeys = (l, c) => {
                    for (let p in l) l[p][0] && l[p][0](c)
                },
                initCache = (l, c) => {
                    if (!M.has(l)) {
                        let p = mergeObjects(eh, c),
                            v = {},
                            C = internalMutate.bind(_, l),
                            P = noop,
                            T = {},
                            subscribe = (l, c) => {
                                let p = T[l] || [];
                                return T[l] = p, p.push(c), () => p.splice(p.indexOf(c), 1)
                            },
                            setter = (c, p, v) => {
                                l.set(c, p);
                                let _ = T[c];
                                if (_)
                                    for (let l of _) l(p, v)
                            },
                            initProvider = () => {
                                if (!M.has(l) && (M.set(l, [v, {}, {}, {}, C, setter, subscribe]), !ef)) {
                                    let c = p.initFocus(setTimeout.bind(_, revalidateAllKeys.bind(_, v, 0))),
                                        C = p.initReconnect(setTimeout.bind(_, revalidateAllKeys.bind(_, v, 1)));
                                    P = () => {
                                        c && c(), C && C(), M.delete(l)
                                    }
                                }
                            };
                        return initProvider(), [l, C, initProvider, P]
                    }
                    return [l, M.get(l)[4]]
                },
                [ew, ex] = initCache(new Map),
                e_ = mergeObjects({
                    onLoadingSlow: noop,
                    onSuccess: noop,
                    onError: noop,
                    onErrorRetry: (l, c, p, v, _) => {
                        let C = p.errorRetryCount,
                            P = _.retryCount,
                            T = ~~((Math.random() + .5) * (1 << (P < 8 ? P : 8))) * p.errorRetryInterval;
                        (isUndefined(C) || !(P > C)) && setTimeout(v, T, _)
                    },
                    onDiscarded: noop,
                    revalidateOnFocus: !0,
                    revalidateOnReconnect: !0,
                    revalidateIfStale: !0,
                    shouldRetryOnError: !0,
                    errorRetryInterval: em ? 1e4 : 5e3,
                    focusThrottleInterval: 5e3,
                    dedupingInterval: 2e3,
                    loadingTimeout: em ? 5e3 : 3e3,
                    compare: (l, c) => stableHash(l) == stableHash(c),
                    isPaused: () => !1,
                    cache: ew,
                    mutate: ex,
                    fallback: {}
                }, {
                    isOnline: () => eo,
                    isVisible: () => {
                        let l = es && document.visibilityState;
                        return isUndefined(l) || "hidden" !== l
                    }
                }),
                mergeConfigs = (l, c) => {
                    let p = mergeObjects(l, c);
                    if (c) {
                        let {
                            use: v,
                            fallback: _
                        } = l, {
                            use: C,
                            fallback: P
                        } = c;
                        v && C && (p.use = v.concat(C)), _ && P && (p.fallback = mergeObjects(_, P))
                    }
                    return p
                },
                eE = (0, v.createContext)({}),
                SWRConfig = l => {
                    let {
                        value: c
                    } = l, p = (0, v.useContext)(eE), C = isFunction(c), P = (0, v.useMemo)(() => C ? c(p) : c, [C, p, c]), T = (0, v.useMemo)(() => C ? P : mergeConfigs(p, P), [C, p, P]), M = P && P.provider, z = (0, v.useRef)(_);
                    M && !z.current && (z.current = initCache(M(T.cache || ew), P));
                    let J = z.current;
                    return J && (T.cache = J[0], T.mutate = J[1]), ep(() => {
                        if (J) return J[2] && J[2](), J[3]
                    }, []), (0, v.createElement)(eE.Provider, mergeObjects(l, {
                        value: T
                    }))
                },
                eA = X && window.__SWR_DEVTOOLS_USE__,
                eC = eA ? window.__SWR_DEVTOOLS_USE__ : [],
                normalize = l => isFunction(l[1]) ? [l[0], l[1], l[2] || {}] : [l[0], null, (null === l[1] ? l[2] : l[1]) || {}],
                useSWRConfig = () => mergeObjects(e_, (0, v.useContext)(eE)),
                eS = eC.concat(l => (c, p, v) => {
                    let _ = p && ((...l) => {
                        let [v] = serialize(c), [, , , _] = M.get(ew);
                        if (v.startsWith("$inf$")) return p(...l);
                        let C = _[v];
                        return isUndefined(C) ? p(...l) : (delete _[v], C)
                    });
                    return l(c, _, v)
                }),
                withArgs = l => function(...c) {
                    let p = useSWRConfig(),
                        [v, _, C] = normalize(c),
                        P = mergeConfigs(p, C),
                        T = l,
                        {
                            use: M
                        } = P,
                        z = (M || []).concat(eS);
                    for (let l = z.length; l--;) T = z[l](T);
                    return T(v, _ || P.fetcher || null, P)
                },
                subscribeCallback = (l, c, p) => {
                    let v = c[l] || (c[l] = []);
                    return v.push(p), () => {
                        let l = v.indexOf(p);
                        l >= 0 && (v[l] = v[v.length - 1], v.pop())
                    }
                },
                withMiddleware = (l, c) => (...p) => {
                    let [v, _, C] = normalize(p), P = (C.use || []).concat(c);
                    return l(v, _, { ...C,
                        use: P
                    })
                };
            eA && (window.__SWR_DEVTOOLS_REACT__ = v)
        },
        1389: function(l, c, p) {
            "use strict";
            p.d(c, {
                m: function() {
                    return Q
                }
            });
            var v = /^\[(.+)\]$/;

            function getPart(l, c) {
                var p = l;
                return c.split("-").forEach(function(l) {
                    p.nextPart.has(l) || p.nextPart.set(l, {
                        nextPart: new Map,
                        validators: []
                    }), p = p.nextPart.get(l)
                }), p
            }
            var _ = /\s+/;

            function twJoin() {
                for (var l, c, p = 0, v = ""; p < arguments.length;)(l = arguments[p++]) && (c = function toValue(l) {
                    if ("string" == typeof l) return l;
                    for (var c, p = "", v = 0; v < l.length; v++) l[v] && (c = toValue(l[v])) && (p && (p += " "), p += c);
                    return p
                }(l)) && (v && (v += " "), v += c);
                return v
            }

            function fromTheme(l) {
                var themeGetter = function(c) {
                    return c[l] || []
                };
                return themeGetter.isThemeGetter = !0, themeGetter
            }
            var C = /^\[(?:([a-z-]+):)?(.+)\]$/i,
                P = /^\d+\/\d+$/,
                T = new Set(["px", "full", "screen"]),
                M = /^(\d+(\.\d+)?)?(xs|sm|md|lg|xl)$/,
                z = /\d+(%|px|r?em|[sdl]?v([hwib]|min|max)|pt|pc|in|cm|mm|cap|ch|ex|r?lh|cq(w|h|i|b|min|max))|\b(calc|min|max|clamp)\(.+\)|^0$/,
                J = /^-?((\d+)?\.?(\d+)[a-z]+|0)_-?((\d+)?\.?(\d+)[a-z]+|0)/;

            function isLength(l) {
                return isNumber(l) || T.has(l) || P.test(l) || isArbitraryLength(l)
            }

            function isArbitraryLength(l) {
                return getIsArbitraryValue(l, "length", isLengthOnly)
            }

            function isArbitrarySize(l) {
                return getIsArbitraryValue(l, "size", isNever)
            }

            function isArbitraryPosition(l) {
                return getIsArbitraryValue(l, "position", isNever)
            }

            function isArbitraryUrl(l) {
                return getIsArbitraryValue(l, "url", isUrl)
            }

            function isArbitraryNumber(l) {
                return getIsArbitraryValue(l, "number", isNumber)
            }

            function isNumber(l) {
                return !Number.isNaN(Number(l))
            }

            function isPercent(l) {
                return l.endsWith("%") && isNumber(l.slice(0, -1))
            }

            function isInteger(l) {
                return isIntegerOnly(l) || getIsArbitraryValue(l, "number", isIntegerOnly)
            }

            function isArbitraryValue(l) {
                return C.test(l)
            }

            function isAny() {
                return !0
            }

            function isTshirtSize(l) {
                return M.test(l)
            }

            function isArbitraryShadow(l) {
                return getIsArbitraryValue(l, "", isShadow)
            }

            function getIsArbitraryValue(l, c, p) {
                var v = C.exec(l);
                return !!v && (v[1] ? v[1] === c : p(v[2]))
            }

            function isLengthOnly(l) {
                return z.test(l)
            }

            function isNever() {
                return !1
            }

            function isUrl(l) {
                return l.startsWith("url(")
            }

            function isIntegerOnly(l) {
                return Number.isInteger(Number(l))
            }

            function isShadow(l) {
                return J.test(l)
            }
            var Q = function() {
                for (var l, c, p, C = arguments.length, P = Array(C), T = 0; T < C; T++) P[T] = arguments[T];
                var functionToCall = function(_) {
                    var C = P[0];
                    return c = (l = function(l) {
                        var c, p, _, C, P, T, M, z, J, Q, X;
                        return {
                            cache: function(l) {
                                if (l < 1) return {
                                    get: function() {},
                                    set: function() {}
                                };
                                var c = 0,
                                    p = new Map,
                                    v = new Map;

                                function update(_, C) {
                                    p.set(_, C), ++c > l && (c = 0, v = p, p = new Map)
                                }
                                return {
                                    get: function(l) {
                                        var c = p.get(l);
                                        return void 0 !== c ? c : void 0 !== (c = v.get(l)) ? (update(l, c), c) : void 0
                                    },
                                    set: function(l, c) {
                                        p.has(l) ? p.set(l, c) : update(l, c)
                                    }
                                }
                            }(l.cacheSize),
                            splitModifiers: (p = 1 === (c = l.separator || ":").length, _ = c[0], C = c.length, function(l) {
                                for (var v, P = [], T = 0, M = 0, z = 0; z < l.length; z++) {
                                    var J = l[z];
                                    if (0 === T) {
                                        if (J === _ && (p || l.slice(z, z + C) === c)) {
                                            P.push(l.slice(M, z)), M = z + C;
                                            continue
                                        }
                                        if ("/" === J) {
                                            v = z;
                                            continue
                                        }
                                    }
                                    "[" === J ? T++ : "]" === J && T--
                                }
                                var Q = 0 === P.length ? l : l.substring(M),
                                    X = Q.startsWith("!"),
                                    es = X ? Q.substring(1) : Q;
                                return {
                                    modifiers: P,
                                    hasImportantModifier: X,
                                    baseClassName: es,
                                    maybePostfixModifierPosition: v && v > M ? v - M : void 0
                                }
                            }),
                            ...(z = l.theme, J = l.prefix, Q = {
                                nextPart: new Map,
                                validators: []
                            }, (X = Object.entries(l.classGroups), J ? X.map(function(l) {
                                return [l[0], l[1].map(function(l) {
                                    return "string" == typeof l ? J + l : "object" == typeof l ? Object.fromEntries(Object.entries(l).map(function(l) {
                                        return [J + l[0], l[1]]
                                    })) : l
                                })]
                            }) : X).forEach(function(l) {
                                var c = l[0];
                                (function processClassesRecursively(l, c, p, v) {
                                    l.forEach(function(l) {
                                        if ("string" == typeof l) {
                                            ("" === l ? c : getPart(c, l)).classGroupId = p;
                                            return
                                        }
                                        if ("function" == typeof l) {
                                            if (l.isThemeGetter) {
                                                processClassesRecursively(l(v), c, p, v);
                                                return
                                            }
                                            c.validators.push({
                                                validator: l,
                                                classGroupId: p
                                            });
                                            return
                                        }
                                        Object.entries(l).forEach(function(l) {
                                            var _ = l[0];
                                            processClassesRecursively(l[1], getPart(c, _), p, v)
                                        })
                                    })
                                })(l[1], Q, c, z)
                            }), P = l.conflictingClassGroups, M = void 0 === (T = l.conflictingClassGroupModifiers) ? {} : T, {
                                getClassGroupId: function(l) {
                                    var c = l.split("-");
                                    return "" === c[0] && 1 !== c.length && c.shift(),
                                        function getGroupRecursive(l, c) {
                                            if (0 === l.length) return c.classGroupId;
                                            var p = l[0],
                                                v = c.nextPart.get(p),
                                                _ = v ? getGroupRecursive(l.slice(1), v) : void 0;
                                            if (_) return _;
                                            if (0 !== c.validators.length) {
                                                var C = l.join("-");
                                                return c.validators.find(function(l) {
                                                    return (0, l.validator)(C)
                                                }) ? .classGroupId
                                            }
                                        }(c, Q) || function(l) {
                                            if (v.test(l)) {
                                                var c = v.exec(l)[1],
                                                    p = c ? .substring(0, c.indexOf(":"));
                                                if (p) return "arbitrary.." + p
                                            }
                                        }(l)
                                },
                                getConflictingClassGroupIds: function(l, c) {
                                    var p = P[l] || [];
                                    return c && M[l] ? [].concat(p, M[l]) : p
                                }
                            })
                        }
                    }(P.slice(1).reduce(function(l, c) {
                        return c(l)
                    }, C()))).cache.get, p = l.cache.set, functionToCall = tailwindMerge, tailwindMerge(_)
                };

                function tailwindMerge(v) {
                    var C, P, T, M, z, J = c(v);
                    if (J) return J;
                    var Q = (P = (C = l).splitModifiers, T = C.getClassGroupId, M = C.getConflictingClassGroupIds, z = new Set, v.trim().split(_).map(function(l) {
                        var c = P(l),
                            p = c.modifiers,
                            v = c.hasImportantModifier,
                            _ = c.baseClassName,
                            C = c.maybePostfixModifierPosition,
                            M = T(C ? _.substring(0, C) : _),
                            z = !!C;
                        if (!M) {
                            if (!C || !(M = T(_))) return {
                                isTailwindClass: !1,
                                originalClassName: l
                            };
                            z = !1
                        }
                        var J = (function(l) {
                            if (l.length <= 1) return l;
                            var c = [],
                                p = [];
                            return l.forEach(function(l) {
                                "[" === l[0] ? (c.push.apply(c, p.sort().concat([l])), p = []) : p.push(l)
                            }), c.push.apply(c, p.sort()), c
                        })(p).join(":");
                        return {
                            isTailwindClass: !0,
                            modifierId: v ? J + "!" : J,
                            classGroupId: M,
                            originalClassName: l,
                            hasPostfixModifier: z
                        }
                    }).reverse().filter(function(l) {
                        if (!l.isTailwindClass) return !0;
                        var c = l.modifierId,
                            p = l.classGroupId,
                            v = l.hasPostfixModifier,
                            _ = c + p;
                        return !z.has(_) && (z.add(_), M(p, v).forEach(function(l) {
                            return z.add(c + l)
                        }), !0)
                    }).reverse().map(function(l) {
                        return l.originalClassName
                    }).join(" "));
                    return p(v, Q), Q
                }
                return function() {
                    return functionToCall(twJoin.apply(null, arguments))
                }
            }(function() {
                var l = fromTheme("colors"),
                    c = fromTheme("spacing"),
                    p = fromTheme("blur"),
                    v = fromTheme("brightness"),
                    _ = fromTheme("borderColor"),
                    C = fromTheme("borderRadius"),
                    P = fromTheme("borderSpacing"),
                    T = fromTheme("borderWidth"),
                    M = fromTheme("contrast"),
                    z = fromTheme("grayscale"),
                    J = fromTheme("hueRotate"),
                    Q = fromTheme("invert"),
                    X = fromTheme("gap"),
                    es = fromTheme("gradientColorStops"),
                    eo = fromTheme("gradientColorStopPositions"),
                    el = fromTheme("inset"),
                    ec = fromTheme("margin"),
                    eh = fromTheme("opacity"),
                    ed = fromTheme("padding"),
                    ef = fromTheme("saturate"),
                    ep = fromTheme("scale"),
                    eg = fromTheme("sepia"),
                    em = fromTheme("skew"),
                    ey = fromTheme("space"),
                    eb = fromTheme("translate"),
                    getOverscroll = function() {
                        return ["auto", "contain", "none"]
                    },
                    getOverflow = function() {
                        return ["auto", "hidden", "clip", "visible", "scroll"]
                    },
                    getSpacingWithAutoAndArbitrary = function() {
                        return ["auto", isArbitraryValue, c]
                    },
                    getSpacingWithArbitrary = function() {
                        return [isArbitraryValue, c]
                    },
                    getLengthWithEmpty = function() {
                        return ["", isLength]
                    },
                    getNumberWithAutoAndArbitrary = function() {
                        return ["auto", isNumber, isArbitraryValue]
                    },
                    getPositions = function() {
                        return ["bottom", "center", "left", "left-bottom", "left-top", "right", "right-bottom", "right-top", "top"]
                    },
                    getLineStyles = function() {
                        return ["solid", "dashed", "dotted", "double", "none"]
                    },
                    getBlendModes = function() {
                        return ["normal", "multiply", "screen", "overlay", "darken", "lighten", "color-dodge", "color-burn", "hard-light", "soft-light", "difference", "exclusion", "hue", "saturation", "color", "luminosity", "plus-lighter"]
                    },
                    getAlign = function() {
                        return ["start", "end", "center", "between", "around", "evenly", "stretch"]
                    },
                    getZeroAndEmpty = function() {
                        return ["", "0", isArbitraryValue]
                    },
                    getBreaks = function() {
                        return ["auto", "avoid", "all", "avoid-page", "page", "left", "right", "column"]
                    },
                    getNumber = function() {
                        return [isNumber, isArbitraryNumber]
                    },
                    getNumberAndArbitrary = function() {
                        return [isNumber, isArbitraryValue]
                    };
                return {
                    cacheSize: 500,
                    theme: {
                        colors: [isAny],
                        spacing: [isLength],
                        blur: ["none", "", isTshirtSize, isArbitraryValue],
                        brightness: getNumber(),
                        borderColor: [l],
                        borderRadius: ["none", "", "full", isTshirtSize, isArbitraryValue],
                        borderSpacing: getSpacingWithArbitrary(),
                        borderWidth: getLengthWithEmpty(),
                        contrast: getNumber(),
                        grayscale: getZeroAndEmpty(),
                        hueRotate: getNumberAndArbitrary(),
                        invert: getZeroAndEmpty(),
                        gap: getSpacingWithArbitrary(),
                        gradientColorStops: [l],
                        gradientColorStopPositions: [isPercent, isArbitraryLength],
                        inset: getSpacingWithAutoAndArbitrary(),
                        margin: getSpacingWithAutoAndArbitrary(),
                        opacity: getNumber(),
                        padding: getSpacingWithArbitrary(),
                        saturate: getNumber(),
                        scale: getNumber(),
                        sepia: getZeroAndEmpty(),
                        skew: getNumberAndArbitrary(),
                        space: getSpacingWithArbitrary(),
                        translate: getSpacingWithArbitrary()
                    },
                    classGroups: {
                        aspect: [{
                            aspect: ["auto", "square", "video", isArbitraryValue]
                        }],
                        container: ["container"],
                        columns: [{
                            columns: [isTshirtSize]
                        }],
                        "break-after": [{
                            "break-after": getBreaks()
                        }],
                        "break-before": [{
                            "break-before": getBreaks()
                        }],
                        "break-inside": [{
                            "break-inside": ["auto", "avoid", "avoid-page", "avoid-column"]
                        }],
                        "box-decoration": [{
                            "box-decoration": ["slice", "clone"]
                        }],
                        box: [{
                            box: ["border", "content"]
                        }],
                        display: ["block", "inline-block", "inline", "flex", "inline-flex", "table", "inline-table", "table-caption", "table-cell", "table-column", "table-column-group", "table-footer-group", "table-header-group", "table-row-group", "table-row", "flow-root", "grid", "inline-grid", "contents", "list-item", "hidden"],
                        float: [{
                            float: ["right", "left", "none"]
                        }],
                        clear: [{
                            clear: ["left", "right", "both", "none"]
                        }],
                        isolation: ["isolate", "isolation-auto"],
                        "object-fit": [{
                            object: ["contain", "cover", "fill", "none", "scale-down"]
                        }],
                        "object-position": [{
                            object: [].concat(getPositions(), [isArbitraryValue])
                        }],
                        overflow: [{
                            overflow: getOverflow()
                        }],
                        "overflow-x": [{
                            "overflow-x": getOverflow()
                        }],
                        "overflow-y": [{
                            "overflow-y": getOverflow()
                        }],
                        overscroll: [{
                            overscroll: getOverscroll()
                        }],
                        "overscroll-x": [{
                            "overscroll-x": getOverscroll()
                        }],
                        "overscroll-y": [{
                            "overscroll-y": getOverscroll()
                        }],
                        position: ["static", "fixed", "absolute", "relative", "sticky"],
                        inset: [{
                            inset: [el]
                        }],
                        "inset-x": [{
                            "inset-x": [el]
                        }],
                        "inset-y": [{
                            "inset-y": [el]
                        }],
                        start: [{
                            start: [el]
                        }],
                        end: [{
                            end: [el]
                        }],
                        top: [{
                            top: [el]
                        }],
                        right: [{
                            right: [el]
                        }],
                        bottom: [{
                            bottom: [el]
                        }],
                        left: [{
                            left: [el]
                        }],
                        visibility: ["visible", "invisible", "collapse"],
                        z: [{
                            z: ["auto", isInteger]
                        }],
                        basis: [{
                            basis: getSpacingWithAutoAndArbitrary()
                        }],
                        "flex-direction": [{
                            flex: ["row", "row-reverse", "col", "col-reverse"]
                        }],
                        "flex-wrap": [{
                            flex: ["wrap", "wrap-reverse", "nowrap"]
                        }],
                        flex: [{
                            flex: ["1", "auto", "initial", "none", isArbitraryValue]
                        }],
                        grow: [{
                            grow: getZeroAndEmpty()
                        }],
                        shrink: [{
                            shrink: getZeroAndEmpty()
                        }],
                        order: [{
                            order: ["first", "last", "none", isInteger]
                        }],
                        "grid-cols": [{
                            "grid-cols": [isAny]
                        }],
                        "col-start-end": [{
                            col: ["auto", {
                                span: ["full", isInteger]
                            }, isArbitraryValue]
                        }],
                        "col-start": [{
                            "col-start": getNumberWithAutoAndArbitrary()
                        }],
                        "col-end": [{
                            "col-end": getNumberWithAutoAndArbitrary()
                        }],
                        "grid-rows": [{
                            "grid-rows": [isAny]
                        }],
                        "row-start-end": [{
                            row: ["auto", {
                                span: [isInteger]
                            }, isArbitraryValue]
                        }],
                        "row-start": [{
                            "row-start": getNumberWithAutoAndArbitrary()
                        }],
                        "row-end": [{
                            "row-end": getNumberWithAutoAndArbitrary()
                        }],
                        "grid-flow": [{
                            "grid-flow": ["row", "col", "dense", "row-dense", "col-dense"]
                        }],
                        "auto-cols": [{
                            "auto-cols": ["auto", "min", "max", "fr", isArbitraryValue]
                        }],
                        "auto-rows": [{
                            "auto-rows": ["auto", "min", "max", "fr", isArbitraryValue]
                        }],
                        gap: [{
                            gap: [X]
                        }],
                        "gap-x": [{
                            "gap-x": [X]
                        }],
                        "gap-y": [{
                            "gap-y": [X]
                        }],
                        "justify-content": [{
                            justify: ["normal"].concat(getAlign())
                        }],
                        "justify-items": [{
                            "justify-items": ["start", "end", "center", "stretch"]
                        }],
                        "justify-self": [{
                            "justify-self": ["auto", "start", "end", "center", "stretch"]
                        }],
                        "align-content": [{
                            content: ["normal"].concat(getAlign(), ["baseline"])
                        }],
                        "align-items": [{
                            items: ["start", "end", "center", "baseline", "stretch"]
                        }],
                        "align-self": [{
                            self: ["auto", "start", "end", "center", "stretch", "baseline"]
                        }],
                        "place-content": [{
                            "place-content": [].concat(getAlign(), ["baseline"])
                        }],
                        "place-items": [{
                            "place-items": ["start", "end", "center", "baseline", "stretch"]
                        }],
                        "place-self": [{
                            "place-self": ["auto", "start", "end", "center", "stretch"]
                        }],
                        p: [{
                            p: [ed]
                        }],
                        px: [{
                            px: [ed]
                        }],
                        py: [{
                            py: [ed]
                        }],
                        ps: [{
                            ps: [ed]
                        }],
                        pe: [{
                            pe: [ed]
                        }],
                        pt: [{
                            pt: [ed]
                        }],
                        pr: [{
                            pr: [ed]
                        }],
                        pb: [{
                            pb: [ed]
                        }],
                        pl: [{
                            pl: [ed]
                        }],
                        m: [{
                            m: [ec]
                        }],
                        mx: [{
                            mx: [ec]
                        }],
                        my: [{
                            my: [ec]
                        }],
                        ms: [{
                            ms: [ec]
                        }],
                        me: [{
                            me: [ec]
                        }],
                        mt: [{
                            mt: [ec]
                        }],
                        mr: [{
                            mr: [ec]
                        }],
                        mb: [{
                            mb: [ec]
                        }],
                        ml: [{
                            ml: [ec]
                        }],
                        "space-x": [{
                            "space-x": [ey]
                        }],
                        "space-x-reverse": ["space-x-reverse"],
                        "space-y": [{
                            "space-y": [ey]
                        }],
                        "space-y-reverse": ["space-y-reverse"],
                        w: [{
                            w: ["auto", "min", "max", "fit", isArbitraryValue, c]
                        }],
                        "min-w": [{
                            "min-w": ["min", "max", "fit", isArbitraryValue, isLength]
                        }],
                        "max-w": [{
                            "max-w": ["0", "none", "full", "min", "max", "fit", "prose", {
                                screen: [isTshirtSize]
                            }, isTshirtSize, isArbitraryValue]
                        }],
                        h: [{
                            h: [isArbitraryValue, c, "auto", "min", "max", "fit"]
                        }],
                        "min-h": [{
                            "min-h": ["min", "max", "fit", isArbitraryValue, isLength]
                        }],
                        "max-h": [{
                            "max-h": [isArbitraryValue, c, "min", "max", "fit"]
                        }],
                        "font-size": [{
                            text: ["base", isTshirtSize, isArbitraryLength]
                        }],
                        "font-smoothing": ["antialiased", "subpixel-antialiased"],
                        "font-style": ["italic", "not-italic"],
                        "font-weight": [{
                            font: ["thin", "extralight", "light", "normal", "medium", "semibold", "bold", "extrabold", "black", isArbitraryNumber]
                        }],
                        "font-family": [{
                            font: [isAny]
                        }],
                        "fvn-normal": ["normal-nums"],
                        "fvn-ordinal": ["ordinal"],
                        "fvn-slashed-zero": ["slashed-zero"],
                        "fvn-figure": ["lining-nums", "oldstyle-nums"],
                        "fvn-spacing": ["proportional-nums", "tabular-nums"],
                        "fvn-fraction": ["diagonal-fractions", "stacked-fractons"],
                        tracking: [{
                            tracking: ["tighter", "tight", "normal", "wide", "wider", "widest", isArbitraryValue]
                        }],
                        "line-clamp": [{
                            "line-clamp": ["none", isNumber, isArbitraryNumber]
                        }],
                        leading: [{
                            leading: ["none", "tight", "snug", "normal", "relaxed", "loose", isArbitraryValue, isLength]
                        }],
                        "list-image": [{
                            "list-image": ["none", isArbitraryValue]
                        }],
                        "list-style-type": [{
                            list: ["none", "disc", "decimal", isArbitraryValue]
                        }],
                        "list-style-position": [{
                            list: ["inside", "outside"]
                        }],
                        "placeholder-color": [{
                            placeholder: [l]
                        }],
                        "placeholder-opacity": [{
                            "placeholder-opacity": [eh]
                        }],
                        "text-alignment": [{
                            text: ["left", "center", "right", "justify", "start", "end"]
                        }],
                        "text-color": [{
                            text: [l]
                        }],
                        "text-opacity": [{
                            "text-opacity": [eh]
                        }],
                        "text-decoration": ["underline", "overline", "line-through", "no-underline"],
                        "text-decoration-style": [{
                            decoration: [].concat(getLineStyles(), ["wavy"])
                        }],
                        "text-decoration-thickness": [{
                            decoration: ["auto", "from-font", isLength]
                        }],
                        "underline-offset": [{
                            "underline-offset": ["auto", isArbitraryValue, isLength]
                        }],
                        "text-decoration-color": [{
                            decoration: [l]
                        }],
                        "text-transform": ["uppercase", "lowercase", "capitalize", "normal-case"],
                        "text-overflow": ["truncate", "text-ellipsis", "text-clip"],
                        indent: [{
                            indent: getSpacingWithArbitrary()
                        }],
                        "vertical-align": [{
                            align: ["baseline", "top", "middle", "bottom", "text-top", "text-bottom", "sub", "super", isArbitraryValue]
                        }],
                        whitespace: [{
                            whitespace: ["normal", "nowrap", "pre", "pre-line", "pre-wrap", "break-spaces"]
                        }],
                        break: [{
                            break: ["normal", "words", "all", "keep"]
                        }],
                        hyphens: [{
                            hyphens: ["none", "manual", "auto"]
                        }],
                        content: [{
                            content: ["none", isArbitraryValue]
                        }],
                        "bg-attachment": [{
                            bg: ["fixed", "local", "scroll"]
                        }],
                        "bg-clip": [{
                            "bg-clip": ["border", "padding", "content", "text"]
                        }],
                        "bg-opacity": [{
                            "bg-opacity": [eh]
                        }],
                        "bg-origin": [{
                            "bg-origin": ["border", "padding", "content"]
                        }],
                        "bg-position": [{
                            bg: [].concat(getPositions(), [isArbitraryPosition])
                        }],
                        "bg-repeat": [{
                            bg: ["no-repeat", {
                                repeat: ["", "x", "y", "round", "space"]
                            }]
                        }],
                        "bg-size": [{
                            bg: ["auto", "cover", "contain", isArbitrarySize]
                        }],
                        "bg-image": [{
                            bg: ["none", {
                                "gradient-to": ["t", "tr", "r", "br", "b", "bl", "l", "tl"]
                            }, isArbitraryUrl]
                        }],
                        "bg-color": [{
                            bg: [l]
                        }],
                        "gradient-from-pos": [{
                            from: [eo]
                        }],
                        "gradient-via-pos": [{
                            via: [eo]
                        }],
                        "gradient-to-pos": [{
                            to: [eo]
                        }],
                        "gradient-from": [{
                            from: [es]
                        }],
                        "gradient-via": [{
                            via: [es]
                        }],
                        "gradient-to": [{
                            to: [es]
                        }],
                        rounded: [{
                            rounded: [C]
                        }],
                        "rounded-s": [{
                            "rounded-s": [C]
                        }],
                        "rounded-e": [{
                            "rounded-e": [C]
                        }],
                        "rounded-t": [{
                            "rounded-t": [C]
                        }],
                        "rounded-r": [{
                            "rounded-r": [C]
                        }],
                        "rounded-b": [{
                            "rounded-b": [C]
                        }],
                        "rounded-l": [{
                            "rounded-l": [C]
                        }],
                        "rounded-ss": [{
                            "rounded-ss": [C]
                        }],
                        "rounded-se": [{
                            "rounded-se": [C]
                        }],
                        "rounded-ee": [{
                            "rounded-ee": [C]
                        }],
                        "rounded-es": [{
                            "rounded-es": [C]
                        }],
                        "rounded-tl": [{
                            "rounded-tl": [C]
                        }],
                        "rounded-tr": [{
                            "rounded-tr": [C]
                        }],
                        "rounded-br": [{
                            "rounded-br": [C]
                        }],
                        "rounded-bl": [{
                            "rounded-bl": [C]
                        }],
                        "border-w": [{
                            border: [T]
                        }],
                        "border-w-x": [{
                            "border-x": [T]
                        }],
                        "border-w-y": [{
                            "border-y": [T]
                        }],
                        "border-w-s": [{
                            "border-s": [T]
                        }],
                        "border-w-e": [{
                            "border-e": [T]
                        }],
                        "border-w-t": [{
                            "border-t": [T]
                        }],
                        "border-w-r": [{
                            "border-r": [T]
                        }],
                        "border-w-b": [{
                            "border-b": [T]
                        }],
                        "border-w-l": [{
                            "border-l": [T]
                        }],
                        "border-opacity": [{
                            "border-opacity": [eh]
                        }],
                        "border-style": [{
                            border: [].concat(getLineStyles(), ["hidden"])
                        }],
                        "divide-x": [{
                            "divide-x": [T]
                        }],
                        "divide-x-reverse": ["divide-x-reverse"],
                        "divide-y": [{
                            "divide-y": [T]
                        }],
                        "divide-y-reverse": ["divide-y-reverse"],
                        "divide-opacity": [{
                            "divide-opacity": [eh]
                        }],
                        "divide-style": [{
                            divide: getLineStyles()
                        }],
                        "border-color": [{
                            border: [_]
                        }],
                        "border-color-x": [{
                            "border-x": [_]
                        }],
                        "border-color-y": [{
                            "border-y": [_]
                        }],
                        "border-color-t": [{
                            "border-t": [_]
                        }],
                        "border-color-r": [{
                            "border-r": [_]
                        }],
                        "border-color-b": [{
                            "border-b": [_]
                        }],
                        "border-color-l": [{
                            "border-l": [_]
                        }],
                        "divide-color": [{
                            divide: [_]
                        }],
                        "outline-style": [{
                            outline: [""].concat(getLineStyles())
                        }],
                        "outline-offset": [{
                            "outline-offset": [isArbitraryValue, isLength]
                        }],
                        "outline-w": [{
                            outline: [isLength]
                        }],
                        "outline-color": [{
                            outline: [l]
                        }],
                        "ring-w": [{
                            ring: getLengthWithEmpty()
                        }],
                        "ring-w-inset": ["ring-inset"],
                        "ring-color": [{
                            ring: [l]
                        }],
                        "ring-opacity": [{
                            "ring-opacity": [eh]
                        }],
                        "ring-offset-w": [{
                            "ring-offset": [isLength]
                        }],
                        "ring-offset-color": [{
                            "ring-offset": [l]
                        }],
                        shadow: [{
                            shadow: ["", "inner", "none", isTshirtSize, isArbitraryShadow]
                        }],
                        "shadow-color": [{
                            shadow: [isAny]
                        }],
                        opacity: [{
                            opacity: [eh]
                        }],
                        "mix-blend": [{
                            "mix-blend": getBlendModes()
                        }],
                        "bg-blend": [{
                            "bg-blend": getBlendModes()
                        }],
                        filter: [{
                            filter: ["", "none"]
                        }],
                        blur: [{
                            blur: [p]
                        }],
                        brightness: [{
                            brightness: [v]
                        }],
                        contrast: [{
                            contrast: [M]
                        }],
                        "drop-shadow": [{
                            "drop-shadow": ["", "none", isTshirtSize, isArbitraryValue]
                        }],
                        grayscale: [{
                            grayscale: [z]
                        }],
                        "hue-rotate": [{
                            "hue-rotate": [J]
                        }],
                        invert: [{
                            invert: [Q]
                        }],
                        saturate: [{
                            saturate: [ef]
                        }],
                        sepia: [{
                            sepia: [eg]
                        }],
                        "backdrop-filter": [{
                            "backdrop-filter": ["", "none"]
                        }],
                        "backdrop-blur": [{
                            "backdrop-blur": [p]
                        }],
                        "backdrop-brightness": [{
                            "backdrop-brightness": [v]
                        }],
                        "backdrop-contrast": [{
                            "backdrop-contrast": [M]
                        }],
                        "backdrop-grayscale": [{
                            "backdrop-grayscale": [z]
                        }],
                        "backdrop-hue-rotate": [{
                            "backdrop-hue-rotate": [J]
                        }],
                        "backdrop-invert": [{
                            "backdrop-invert": [Q]
                        }],
                        "backdrop-opacity": [{
                            "backdrop-opacity": [eh]
                        }],
                        "backdrop-saturate": [{
                            "backdrop-saturate": [ef]
                        }],
                        "backdrop-sepia": [{
                            "backdrop-sepia": [eg]
                        }],
                        "border-collapse": [{
                            border: ["collapse", "separate"]
                        }],
                        "border-spacing": [{
                            "border-spacing": [P]
                        }],
                        "border-spacing-x": [{
                            "border-spacing-x": [P]
                        }],
                        "border-spacing-y": [{
                            "border-spacing-y": [P]
                        }],
                        "table-layout": [{
                            table: ["auto", "fixed"]
                        }],
                        caption: [{
                            caption: ["top", "bottom"]
                        }],
                        transition: [{
                            transition: ["none", "all", "", "colors", "opacity", "shadow", "transform", isArbitraryValue]
                        }],
                        duration: [{
                            duration: getNumberAndArbitrary()
                        }],
                        ease: [{
                            ease: ["linear", "in", "out", "in-out", isArbitraryValue]
                        }],
                        delay: [{
                            delay: getNumberAndArbitrary()
                        }],
                        animate: [{
                            animate: ["none", "spin", "ping", "pulse", "bounce", isArbitraryValue]
                        }],
                        transform: [{
                            transform: ["", "gpu", "none"]
                        }],
                        scale: [{
                            scale: [ep]
                        }],
                        "scale-x": [{
                            "scale-x": [ep]
                        }],
                        "scale-y": [{
                            "scale-y": [ep]
                        }],
                        rotate: [{
                            rotate: [isInteger, isArbitraryValue]
                        }],
                        "translate-x": [{
                            "translate-x": [eb]
                        }],
                        "translate-y": [{
                            "translate-y": [eb]
                        }],
                        "skew-x": [{
                            "skew-x": [em]
                        }],
                        "skew-y": [{
                            "skew-y": [em]
                        }],
                        "transform-origin": [{
                            origin: ["center", "top", "top-right", "right", "bottom-right", "bottom", "bottom-left", "left", "top-left", isArbitraryValue]
                        }],
                        accent: [{
                            accent: ["auto", l]
                        }],
                        appearance: ["appearance-none"],
                        cursor: [{
                            cursor: ["auto", "default", "pointer", "wait", "text", "move", "help", "not-allowed", "none", "context-menu", "progress", "cell", "crosshair", "vertical-text", "alias", "copy", "no-drop", "grab", "grabbing", "all-scroll", "col-resize", "row-resize", "n-resize", "e-resize", "s-resize", "w-resize", "ne-resize", "nw-resize", "se-resize", "sw-resize", "ew-resize", "ns-resize", "nesw-resize", "nwse-resize", "zoom-in", "zoom-out", isArbitraryValue]
                        }],
                        "caret-color": [{
                            caret: [l]
                        }],
                        "pointer-events": [{
                            "pointer-events": ["none", "auto"]
                        }],
                        resize: [{
                            resize: ["none", "y", "x", ""]
                        }],
                        "scroll-behavior": [{
                            scroll: ["auto", "smooth"]
                        }],
                        "scroll-m": [{
                            "scroll-m": getSpacingWithArbitrary()
                        }],
                        "scroll-mx": [{
                            "scroll-mx": getSpacingWithArbitrary()
                        }],
                        "scroll-my": [{
                            "scroll-my": getSpacingWithArbitrary()
                        }],
                        "scroll-ms": [{
                            "scroll-ms": getSpacingWithArbitrary()
                        }],
                        "scroll-me": [{
                            "scroll-me": getSpacingWithArbitrary()
                        }],
                        "scroll-mt": [{
                            "scroll-mt": getSpacingWithArbitrary()
                        }],
                        "scroll-mr": [{
                            "scroll-mr": getSpacingWithArbitrary()
                        }],
                        "scroll-mb": [{
                            "scroll-mb": getSpacingWithArbitrary()
                        }],
                        "scroll-ml": [{
                            "scroll-ml": getSpacingWithArbitrary()
                        }],
                        "scroll-p": [{
                            "scroll-p": getSpacingWithArbitrary()
                        }],
                        "scroll-px": [{
                            "scroll-px": getSpacingWithArbitrary()
                        }],
                        "scroll-py": [{
                            "scroll-py": getSpacingWithArbitrary()
                        }],
                        "scroll-ps": [{
                            "scroll-ps": getSpacingWithArbitrary()
                        }],
                        "scroll-pe": [{
                            "scroll-pe": getSpacingWithArbitrary()
                        }],
                        "scroll-pt": [{
                            "scroll-pt": getSpacingWithArbitrary()
                        }],
                        "scroll-pr": [{
                            "scroll-pr": getSpacingWithArbitrary()
                        }],
                        "scroll-pb": [{
                            "scroll-pb": getSpacingWithArbitrary()
                        }],
                        "scroll-pl": [{
                            "scroll-pl": getSpacingWithArbitrary()
                        }],
                        "snap-align": [{
                            snap: ["start", "end", "center", "align-none"]
                        }],
                        "snap-stop": [{
                            snap: ["normal", "always"]
                        }],
                        "snap-type": [{
                            snap: ["none", "x", "y", "both"]
                        }],
                        "snap-strictness": [{
                            snap: ["mandatory", "proximity"]
                        }],
                        touch: [{
                            touch: ["auto", "none", "pinch-zoom", "manipulation", {
                                pan: ["x", "left", "right", "y", "up", "down"]
                            }]
                        }],
                        select: [{
                            select: ["none", "text", "all", "auto"]
                        }],
                        "will-change": [{
                            "will-change": ["auto", "scroll", "contents", "transform", isArbitraryValue]
                        }],
                        fill: [{
                            fill: [l, "none"]
                        }],
                        "stroke-w": [{
                            stroke: [isLength, isArbitraryNumber]
                        }],
                        stroke: [{
                            stroke: [l, "none"]
                        }],
                        sr: ["sr-only", "not-sr-only"]
                    },
                    conflictingClassGroups: {
                        overflow: ["overflow-x", "overflow-y"],
                        overscroll: ["overscroll-x", "overscroll-y"],
                        inset: ["inset-x", "inset-y", "start", "end", "top", "right", "bottom", "left"],
                        "inset-x": ["right", "left"],
                        "inset-y": ["top", "bottom"],
                        flex: ["basis", "grow", "shrink"],
                        gap: ["gap-x", "gap-y"],
                        p: ["px", "py", "ps", "pe", "pt", "pr", "pb", "pl"],
                        px: ["pr", "pl"],
                        py: ["pt", "pb"],
                        m: ["mx", "my", "ms", "me", "mt", "mr", "mb", "ml"],
                        mx: ["mr", "ml"],
                        my: ["mt", "mb"],
                        "font-size": ["leading"],
                        "fvn-normal": ["fvn-ordinal", "fvn-slashed-zero", "fvn-figure", "fvn-spacing", "fvn-fraction"],
                        "fvn-ordinal": ["fvn-normal"],
                        "fvn-slashed-zero": ["fvn-normal"],
                        "fvn-figure": ["fvn-normal"],
                        "fvn-spacing": ["fvn-normal"],
                        "fvn-fraction": ["fvn-normal"],
                        rounded: ["rounded-s", "rounded-e", "rounded-t", "rounded-r", "rounded-b", "rounded-l", "rounded-ss", "rounded-se", "rounded-ee", "rounded-es", "rounded-tl", "rounded-tr", "rounded-br", "rounded-bl"],
                        "rounded-s": ["rounded-ss", "rounded-es"],
                        "rounded-e": ["rounded-se", "rounded-ee"],
                        "rounded-t": ["rounded-tl", "rounded-tr"],
                        "rounded-r": ["rounded-tr", "rounded-br"],
                        "rounded-b": ["rounded-br", "rounded-bl"],
                        "rounded-l": ["rounded-tl", "rounded-bl"],
                        "border-spacing": ["border-spacing-x", "border-spacing-y"],
                        "border-w": ["border-w-s", "border-w-e", "border-w-t", "border-w-r", "border-w-b", "border-w-l"],
                        "border-w-x": ["border-w-r", "border-w-l"],
                        "border-w-y": ["border-w-t", "border-w-b"],
                        "border-color": ["border-color-t", "border-color-r", "border-color-b", "border-color-l"],
                        "border-color-x": ["border-color-r", "border-color-l"],
                        "border-color-y": ["border-color-t", "border-color-b"],
                        "scroll-m": ["scroll-mx", "scroll-my", "scroll-ms", "scroll-me", "scroll-mt", "scroll-mr", "scroll-mb", "scroll-ml"],
                        "scroll-mx": ["scroll-mr", "scroll-ml"],
                        "scroll-my": ["scroll-mt", "scroll-mb"],
                        "scroll-p": ["scroll-px", "scroll-py", "scroll-ps", "scroll-pe", "scroll-pt", "scroll-pr", "scroll-pb", "scroll-pl"],
                        "scroll-px": ["scroll-pr", "scroll-pl"],
                        "scroll-py": ["scroll-pt", "scroll-pb"]
                    },
                    conflictingClassGroupModifiers: {
                        "font-size": ["leading"]
                    }
                }
            })
        }
    },
    function(l) {
        var __webpack_exec__ = function(c) {
            return l(l.s = c)
        };
        l.O(0, [9774, 179], function() {
            return __webpack_exec__(6840), __webpack_exec__(7013)
        }), _N_E = l.O()
    }
]);